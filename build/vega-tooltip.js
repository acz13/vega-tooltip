(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.vegaTooltip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// https://d3js.org/d3-collection/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) return rollup != null
        ? rollup(array) : (sortValues != null
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],2:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.2.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
var formatDecimal = function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
};

var exponent = function(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
};

var formatGroup = function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
};

var formatNumerals = function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
};

var formatDefault = function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
};

var prefixExponent;

var formatPrefixAuto = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

var formatRounded = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

var formatTypes = {
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

var identity = function(x) {
  return x;
};

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

var formatLocale = function(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
};

var locale;



defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

var precisionFixed = function(step) {
  return Math.max(0, -exponent(Math.abs(step)));
};

var precisionPrefix = function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
};

var precisionRound = function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
};

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.0.6. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

var namespace = function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
};

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

var creator = function(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
};

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

var selection_on = function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
};

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

var sourceEvent = function() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
};

var point = function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
};

var mouse = function(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
};

function none() {}

var selector = function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
};

var selection_select = function(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

function empty() {
  return [];
}

var selectorAll = function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
};

var selection_selectAll = function(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
};

var selection_filter = function(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

var sparse = function(update) {
  return new Array(update.length);
};

var selection_enter = function() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
};

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

var constant = function(x) {
  return function() {
    return x;
  };
};

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

var selection_data = function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
};

var selection_exit = function() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
};

var selection_merge = function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
};

var selection_order = function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
};

var selection_sort = function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
};

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

var selection_call = function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
};

var selection_nodes = function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
};

var selection_node = function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
};

var selection_size = function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
};

var selection_empty = function() {
  return !this.node();
};

var selection_each = function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
};

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

var selection_attr = function(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
};

var defaultView = function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
};

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

var selection_style = function(name, value, priority) {
  var node;
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : defaultView(node = this.node())
          .getComputedStyle(node, null)
          .getPropertyValue(name);
};

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

var selection_property = function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
};

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

var selection_classed = function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
};

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

var selection_text = function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
};

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

var selection_html = function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
};

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

var selection_raise = function() {
  return this.each(raise);
};

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

var selection_lower = function() {
  return this.each(lower);
};

var selection_append = function(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
};

function constantNull() {
  return null;
}

var selection_insert = function(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
};

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

var selection_remove = function() {
  return this.each(remove);
};

var selection_datum = function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
};

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

var selection_dispatch = function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
};

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

var select = function(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
};

var selectAll = function(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
};

var touch = function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
};

var touches = function(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
};

exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],4:[function(require,module,exports){
// https://d3js.org/d3-time-format/ Version 2.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "S": formatSeconds,
    "U": formatWeekNumberSunday,
    "w": formatWeekdayNumber,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "S": formatUTCSeconds,
    "U": formatUTCWeekNumberSunday,
    "w": formatUTCWeekdayNumber,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "S": parseSeconds,
    "U": parseWeekNumberSunday,
    "w": parseWeekdayNumber,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0);
      if (i != string.length) return null;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
        var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekdayNumber(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekdayNumber(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

var locale$1;





defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale$1 = formatLocale(definition);
  exports.timeFormat = locale$1.format;
  exports.timeParse = locale$1.parse;
  exports.utcFormat = locale$1.utcFormat;
  exports.utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":5}],5:[function(require,module,exports){
// https://d3js.org/d3-time/ Version 1.0.6. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date;
var t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],6:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":7}],7:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":8,"./lib/stringify":9}],8:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],9:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],10:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],11:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.vega = global.vega || {})));
}(this, (function (exports) { 'use strict';

/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */
var eventSelector = function(selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
};

var VIEW    = 'view';
var LBRACK  = '[';
var RBRACK  = ']';
var LBRACE  = '{';
var RBRACE  = '}';
var COLON   = ':';
var COMMA   = ',';
var NAME    = '@';
var GT      = '>';
var ILLEGAL = /[\[\]\{\}]/;
var DEFAULT_SOURCE;
var MARKS;
var DEFAULT_MARKS = {
      '*': 1,
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };

function isMarkType(type) {
  return MARKS.hasOwnProperty(type);
}

function find(s, i, endChar, pushChar, popChar) {
  var count = 0,
      n = s.length,
      c;
  for (; i<n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;
    else if (popChar && popChar.indexOf(c) >= 0) --count;
    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }
  return i;
}

function parseMerge(s) {
  var output = [],
      start = 0,
      n = s.length,
      i = 0;

  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }

  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }
  return output;
}

function parseSelector(s) {
  return s[0] === '['
    ? parseBetween(s)
    : parseStream(s);
}

function parseBetween(s) {
  var n = s.length,
      i = 1,
      b, stream;

  i = find(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw 'Empty between selector: ' + s;
  }

  b = parseMerge(s.substring(1, i));
  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }

  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }

  b = b.map(parseSelector);

  stream = parseSelector(s.slice(1).trim());
  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }

  return stream;
}

function parseStream(s) {
  var stream = {source: DEFAULT_SOURCE},
      source = [],
      throttle = [0, 0],
      markname = 0,
      start = 0,
      n = s.length,
      i = 0, j,
      filter;

  // extract throttle from end
  if (s[n-1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i+1, n-1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;
    i = 0;
  }

  if (!n) throw s;

  // set name flag based on first char
  if (s[0] === NAME) markname = ++i;

  // extract first part of multi-part stream selector
  j = find(s, i, COLON);
  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  }

  // extract remaining part of stream selector
  i = find(s, i, LBRACK);
  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  }

  // extract filters
  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n-1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  }

  // marshall event stream specification
  if (!(n = source.length) || ILLEGAL.test(source[n-1])) {
    throw 'Invalid event selector: ' + s;
  }

  if (n > 1) {
    stream.type = source[1];
    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }
  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }
  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];

  return stream;
}

function parseThrottle(s) {
  var a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(function(_) {
    var x = +_;
    if (x !== x) throw s;
    return x;
  });
}

exports.selector = eventSelector;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],12:[function(require,module,exports){
module.exports={
  "name": "vega-lite",
  "author": "Jeffrey Heer, Dominik Moritz, Kanit \"Ham\" Wongsuphasawat",
  "version": "2.0.0-beta.2",
  "collaborators": [
    "Kanit Wongsuphasawat <kanitw@gmail.com> (http://kanitw.yellowpigz.com)",
    "Dominik Moritz <domoritz@cs.washington.edu> (https://www.domoritz.de)",
    "Jeffrey Heer <jheer@uw.edu> (http://jheer.org)"
  ],
  "homepage": "https://vega.github.io/vega-lite/",
  "description": "Vega-lite provides a higher-level grammar for visual analysis, comparable to ggplot or Tableau, that generates complete Vega specifications.",
  "main": "build/src/vl.js",
  "types": "build/src/vl.d.ts",
  "bin": {
    "vl2png": "./bin/vl2png",
    "vl2svg": "./bin/vl2svg",
    "vl2vg": "./bin/vl2vg"
  },
  "directories": {
    "test": "test"
  },
  "scripts": {
    "tsc": "rm -rf build/*/** && tsc",
    "prebuild": "mkdir -p build/site build/examples/images build/test-gallery",
    "build": "npm run tsc && cp package.json build && browserify src/vl.ts -p tsify -d -s vl | exorcist build/vega-lite.js.map > build/vega-lite.js",
    "postbuild": "uglifyjs build/vega-lite.js -cm --in-source-map build/vega-lite.js.map --source-map build/vega-lite.min.js.map > build/vega-lite.min.js && npm run schema",
    "build:examples": "./scripts/build-examples.sh && rm -rf examples/specs/normalized/* && scripts/build-normalized-examples",
    "build:images": "npm run data && scripts/generate-images.sh",
    "build:toc": "bundle exec jekyll build -q && scripts/generate-toc",
    "build:site": "npm run link && browserify site/static/main.ts -p [tsify -p site] -d | exorcist build/site/main.js.map > build/site/main.js",
    "build:versions": "scripts/update-version.sh",
    "build:test-gallery": "browserify test-gallery/main.ts -p [tsify -p test-gallery] -d > build/test-gallery/main.js",
    "check:examples": "scripts/check-examples.sh",
    "check:schema": "scripts/check-schema.sh",
    "clean": "rm -rf build && rm -f vega-lite.* & find -E src test site examples -regex '.*\\.(js|js.map|d.ts|vg.json)' -delete & rm -rf data",
    "data": "rsync -r node_modules/vega-datasets/data/* data",
    "link": "npm link && npm link vega-lite",

    "deploy": "scripts/deploy.sh",
    "deploy:gh": "scripts/deploy-gh.sh",
    "deploy:schema": "scripts/deploy-schema.sh",

    "prestart": "npm run data && npm run build && scripts/index-examples",
    "start": "nodemon -x 'npm run build:test-gallery' & browser-sync start --server --files 'build/test-gallery/main.js' --index 'test-gallery/index.html'",
    "poststart": "rm examples/all-examples.json",

    "preschema": "npm run prebuild",
    "schema": "typescript-json-schema --required true --noExtraProps true src/spec.ts TopLevelExtendedSpec > build/vega-lite-schema.json && rm -f _data/vega-lite-schema.json && npm run replaceschema && cp build/vega-lite-schema.json _data/",
    "replaceschema": "sed -i -e 's/GenericLayerSpec<.*..\\./LayerSpec/g' build/vega-lite-schema.json && sed -i -e 's/GenericRepeatSpec<.*..\\./RepeatSpec/g' build/vega-lite-schema.json && sed -i -e 's/GenericUnitSpec<Encoding<.*..\\./UnitSpec/g' build/vega-lite-schema.json && sed -i -e 's/GenericUnitSpec<EncodingWithFacet<.*..\\./FacetedUnitSpec/g' build/vega-lite-schema.json && sed -i -e 's/<Field>//g' build/vega-lite-schema.json",
    "presite": "npm run build && npm run data && npm run build:site && npm run build:toc && npm run build:versions",
    "site": "bundle exec jekyll serve",

    "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
    "test": "npm run tsc && npm run schema && npm run test:only && npm run lint",
    "posttest": "npm run data && npm run mocha:examples",
    "test:nocompile": "npm run test:only && npm run lint && npm run mocha:examples",
    "test:only": "nyc --reporter=html --reporter=text-summary npm run mocha:test",
    "test:debug": "npm run tsc && npm run schema && mocha --recursive --debug-brk --inspect build/test build/examples",
    "mocha:test": "mocha --require source-map-support/register --reporter dot --recursive build/test",
    "mocha:examples": "mocha --require source-map-support/register --reporter dot --recursive build/examples",

    "codecov": "nyc report --reporter=json && codecov -f coverage/*.json",
    "watch:build": "watchify src/vl.ts -p tsify -v -d -s vl -o 'exorcist build/vega-lite.js.map > build/vega-lite.js'",
    "watch:test": "nodemon -x 'npm test'",
    "watch": "nodemon -x 'npm run build && npm run test:nocompile' # already ran schema in build"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/vega/vega-lite.git"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/vega/vega-lite/issues"
  },
  "devDependencies": {
    "@types/chai": "^3.5.2",
    "@types/d3": "^4.8.0",
    "@types/highlight.js": "^9.1.9",
    "@types/json-stable-stringify": "^1.0.31",
    "@types/mocha": "^2.2.41",
    "@types/node": "^7.0.14",
    "ajv": "5.0.1",
    "browser-sync": "^2.18.8",
    "browserify": "^14.3.0",
    "browserify-shim": "^3.8.14",
    "chai": "^3.5.0",
    "cheerio": "^0.22.0",
    "codecov": "^2.1.0",
    "d3": "^4.8.0",
    "exorcist": "^0.4.0",
    "highlight.js": "^9.11.0",
    "mocha": "^3.3.0",
    "nodemon": "^1.11.0",
    "nyc": "^10.3.0",
    "source-map-support": "^0.4.15",
    "tsify": "^3.0.1",
    "tslint": "^5.1.0",
    "tslint-eslint-rules": "^4.0.0",
    "typescript": "^2.3.2",
    "typescript-json-schema": "^0.11.0",
    "uglify-js": "^2.8.22",
    "vega": "3.0.0-beta.30",
    "vega-datasets": "vega/vega-datasets#gh-pages",
    "vega-embed": "3.0.0-beta.14",
    "watchify": "^3.9.0",
    "yaml-front-matter": "^3.4.0"
  },
  "dependencies": {
    "json-stable-stringify": "^1.0.1",
    "tslib": "^1.6.1",
    "vega-event-selector": "^2.0.0-beta",
    "vega-util": "^1.2.0",
    "yargs": "^7.1.0"
  }
}

},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
exports.AGGREGATE_OPS = [
    'values',
    'count',
    'valid',
    'missing',
    'distinct',
    'sum',
    'mean',
    'average',
    'variance',
    'variancep',
    'stdev',
    'stdevp',
    'median',
    'q1',
    'q3',
    'ci0',
    'ci1',
    'modeskew',
    'min',
    'max',
    'argmin',
    'argmax',
];
exports.AGGREGATE_OP_INDEX = util_1.toSet(exports.AGGREGATE_OPS);
/** Additive-based aggregation operations.  These can be applied to stack. */
exports.SUM_OPS = [
    'count',
    'sum',
    'distinct',
    'valid',
    'missing'
];
/**
 * Aggregation operators that always produce values within the range [domainMin, domainMax].
 */
exports.SHARED_DOMAIN_OPS = [
    'mean',
    'average',
    'median',
    'q1',
    'q3',
    'min',
    'max',
];
exports.SHARED_DOMAIN_OP_INDEX = util_1.toSet(exports.SHARED_DOMAIN_OPS);

},{"./util":102}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AXIS_PROPERTIES = [
    'domain', 'format', 'grid', 'labelPadding', 'labels', 'maxExtent', 'minExtent', 'offset', 'orient', 'position', 'tickCount', 'ticks', 'tickSize', 'title', 'titlePadding', 'values', 'zindex'
];

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("./channel");
var util_1 = require("./util");
function binToString(bin) {
    if (util_1.isBoolean(bin)) {
        return 'bin';
    }
    return 'bin' + Object.keys(bin).map(function (p) { return "_" + p + "_" + bin[p]; }).join('');
}
exports.binToString = binToString;
function autoMaxBins(channel) {
    switch (channel) {
        case channel_1.ROW:
        case channel_1.COLUMN:
        case channel_1.SIZE:
        case channel_1.COLOR:
        case channel_1.OPACITY:
        // Facets and Size shouldn't have too many bins
        // We choose 6 like shape to simplify the rule
        case channel_1.SHAPE:
            return 6; // Vega's "shape" has 6 distinct values
        default:
            return 10;
    }
}
exports.autoMaxBins = autoMaxBins;

},{"./channel":16,"./util":102}],16:[function(require,module,exports){
"use strict";
/*
 * Constants and utilities for encoding channels (Visual variables)
 * such as 'x', 'y', 'color'.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var scale_1 = require("./scale");
var util_1 = require("./util");
var Channel;
(function (Channel) {
    // Facet
    Channel.ROW = 'row';
    Channel.COLUMN = 'column';
    // Position
    Channel.X = 'x';
    Channel.Y = 'y';
    Channel.X2 = 'x2';
    Channel.Y2 = 'y2';
    // Mark property with scale
    Channel.COLOR = 'color';
    Channel.SHAPE = 'shape';
    Channel.SIZE = 'size';
    Channel.OPACITY = 'opacity';
    // Non-scale channel
    Channel.TEXT = 'text';
    Channel.ORDER = 'order';
    Channel.DETAIL = 'detail';
    Channel.TOOLTIP = 'tooltip';
})(Channel = exports.Channel || (exports.Channel = {}));
exports.X = Channel.X;
exports.Y = Channel.Y;
exports.X2 = Channel.X2;
exports.Y2 = Channel.Y2;
exports.ROW = Channel.ROW;
exports.COLUMN = Channel.COLUMN;
exports.SHAPE = Channel.SHAPE;
exports.SIZE = Channel.SIZE;
exports.COLOR = Channel.COLOR;
exports.TEXT = Channel.TEXT;
exports.DETAIL = Channel.DETAIL;
exports.ORDER = Channel.ORDER;
exports.OPACITY = Channel.OPACITY;
exports.TOOLTIP = Channel.TOOLTIP;
exports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.TOOLTIP];
var CHANNEL_INDEX = util_1.toSet(exports.CHANNELS);
function isChannel(str) {
    return !!CHANNEL_INDEX[str];
}
exports.isChannel = isChannel;
// CHANNELS without COLUMN, ROW
exports.UNIT_CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.TOOLTIP];
// UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT, TOOLTIP
exports.UNIT_SCALE_CHANNELS = [exports.X, exports.Y, exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY];
// UNIT_SCALE_CHANNELS with ROW, COLUMN
exports.SCALE_CHANNELS = [exports.X, exports.Y, exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY, exports.ROW, exports.COLUMN];
// UNIT_CHANNELS without X, Y, X2, Y2;
exports.NONSPATIAL_CHANNELS = [exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.TOOLTIP];
// X and Y;
exports.SPATIAL_SCALE_CHANNELS = [exports.X, exports.Y];
// UNIT_SCALE_CHANNELS without X, Y;
exports.NONSPATIAL_SCALE_CHANNELS = [exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY];
exports.LEVEL_OF_DETAIL_CHANNELS = util_1.without(exports.NONSPATIAL_CHANNELS, ['order']);
/** Channels that can serve as groupings for stacked charts. */
exports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];
/**
 * Return whether a channel supports a particular mark type.
 * @param channel  channel name
 * @param mark the mark type
 * @return whether the mark supports the channel
 */
function supportMark(channel, mark) {
    return mark in getSupportedMark(channel);
}
exports.supportMark = supportMark;
/**
 * Return a dictionary showing whether a channel supports mark type.
 * @param channel
 * @return A dictionary mapping mark types to boolean values.
 */
function getSupportedMark(channel) {
    switch (channel) {
        case exports.X:
        case exports.Y:
        case exports.COLOR:
        case exports.DETAIL:
        case exports.TOOLTIP:
        case exports.ORDER: // TODO: revise (order might not support rect, which is not stackable?)
        case exports.OPACITY:
        case exports.ROW:
        case exports.COLUMN:
            return {
                point: true, tick: true, rule: true, circle: true, square: true,
                bar: true, rect: true, line: true, area: true, text: true
            };
        case exports.X2:
        case exports.Y2:
            return {
                rule: true, bar: true, rect: true, area: true
            };
        case exports.SIZE:
            return {
                point: true, tick: true, rule: true, circle: true, square: true,
                bar: true, text: true, line: true
            };
        case exports.SHAPE:
            return { point: true };
        case exports.TEXT:
            return { text: true };
    }
}
exports.getSupportedMark = getSupportedMark;
function hasScale(channel) {
    return !util_1.contains([exports.DETAIL, exports.TEXT, exports.ORDER, exports.TOOLTIP], channel);
}
exports.hasScale = hasScale;
// Position does not work with ordinal (lookup) scale and sequential (which is only for color)
var POSITION_SCALE_TYPE_INDEX = util_1.toSet(util_1.without(scale_1.SCALE_TYPES, ['ordinal', 'sequential']));
function supportScaleType(channel, scaleType) {
    switch (channel) {
        case exports.ROW:
        case exports.COLUMN:
            return scaleType === 'band'; // row / column currently supports band only
        case exports.X:
        case exports.Y:
        case exports.SIZE: // TODO: size and opacity can support ordinal with more modification
        case exports.OPACITY:
            // Although it generally doesn't make sense to use band with size and opacity,
            // it can also work since we use band: 0.5 to get midpoint.
            return scaleType in POSITION_SCALE_TYPE_INDEX;
        case exports.COLOR:
            return scaleType !== 'band'; // band does not make sense with color
        case exports.SHAPE:
            return scaleType === 'ordinal'; // shape = lookup only
    }
    /* istanbul ignore next: it should never reach here */
    return false;
}
exports.supportScaleType = supportScaleType;
function rangeType(channel) {
    switch (channel) {
        case exports.X:
        case exports.Y:
        case exports.SIZE:
        case exports.OPACITY:
            return 'continuous';
        case exports.ROW:
        case exports.COLUMN:
        case exports.SHAPE:
            return 'discrete';
        // Color can be either continuous or discrete, depending on scale type.
        case exports.COLOR:
            return 'flexible';
        // No scale, no range type.
        case exports.X2:
        case exports.Y2:
        case exports.DETAIL:
        case exports.TEXT:
        case exports.ORDER:
        case exports.TOOLTIP:
            return undefined;
    }
    /* istanbul ignore next: should never reach here. */
    throw new Error('getSupportedRole not implemented for ' + channel);
}
exports.rangeType = rangeType;

},{"./scale":93,"./util":102}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var type_1 = require("../../type");
var util_1 = require("../../util");
var common_1 = require("../common");
function labels(model, channel, labelsSpec, def) {
    var fieldDef = model.fieldDef(channel);
    var axis = model.axis(channel);
    var config = model.config;
    // Text
    if (fieldDef.type === type_1.TEMPORAL) {
        labelsSpec = util_1.extend({
            text: {
                signal: common_1.timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, config.axis.shortTimeLabels, config.timeFormat)
            }
        }, labelsSpec);
    }
    // Label Angle
    if (axis.labelAngle !== undefined) {
        labelsSpec.angle = { value: axis.labelAngle };
    }
    else {
        // auto rotate for X
        if (channel === channel_1.X && (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === type_1.TEMPORAL)) {
            labelsSpec.angle = { value: 270 };
        }
    }
    // Auto set align if rotated
    // TODO: consider other value besides 270, 90
    if (labelsSpec.angle) {
        if (labelsSpec.angle.value === 270) {
            labelsSpec.align = {
                value: def.orient === 'top' ? 'left' :
                    (channel === channel_1.X) ? 'right' :
                        'center'
            };
        }
        else if (labelsSpec.angle.value === 90) {
            labelsSpec.align = { value: 'center' };
        }
    }
    if (labelsSpec.angle) {
        // Auto set baseline if rotated
        // TODO: consider other value besides 270, 90
        if (labelsSpec.angle.value === 270) {
            labelsSpec.baseline = { value: (channel === channel_1.X) ? 'middle' : 'bottom' };
        }
        else if (labelsSpec.angle.value === 90) {
            labelsSpec.baseline = { value: 'bottom' };
        }
    }
    return util_1.keys(labelsSpec).length === 0 ? undefined : labelsSpec;
}
exports.labels = labels;

},{"../../channel":16,"../../type":101,"../../util":102,"../common":20}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var axis_1 = require("../../axis");
var encode = require("./encode");
var rules = require("./rules");
var util_1 = require("../../util");
var AXIS_PARTS = ['domain', 'grid', 'labels', 'ticks', 'title'];
function parseAxisComponent(model, axisChannels) {
    return axisChannels.reduce(function (axis, channel) {
        var axisComponent = { axes: [], gridAxes: [] };
        if (model.axis(channel)) {
            // TODO: support multiple axis
            var main = parseMainAxis(channel, model);
            if (main && isVisibleAxis(main)) {
                axisComponent.axes.push(main);
            }
            var grid = parseGridAxis(channel, model);
            if (grid && isVisibleAxis(grid)) {
                axisComponent.gridAxes.push(grid);
            }
            axis[channel] = axisComponent;
        }
        return axis;
    }, {});
}
exports.parseAxisComponent = parseAxisComponent;
function isFalseOrNull(v) {
    return v === false || v === null;
}
/**
 * Return if an axis is visible (shows at least one part of the axis).
 */
function isVisibleAxis(axis) {
    return util_1.some(AXIS_PARTS, function (part) { return hasAxisPart(axis, part); });
}
function hasAxisPart(axis, part) {
    // FIXME this method can be wrong if users use a Vega theme.
    // (Not sure how to correctly handle that yet.).
    if (part === 'grid' || part === 'title') {
        return !!axis[part];
    }
    // Other parts are enabled by default, so they should not be false or null.
    return !isFalseOrNull(axis[part]);
}
/**
 * Make an inner axis for showing grid for shared axis.
 */
function parseGridAxis(channel, model) {
    // FIXME: support adding ticks for grid axis that are inner axes of faceted plots.
    return parseAxis(channel, model, true);
}
exports.parseGridAxis = parseGridAxis;
function parseMainAxis(channel, model) {
    return parseAxis(channel, model, false);
}
exports.parseMainAxis = parseMainAxis;
function parseAxis(channel, model, isGridAxis) {
    var axis = model.axis(channel);
    var vgAxis = {
        scale: model.scaleName(channel)
    };
    // 1.2. Add properties
    axis_1.AXIS_PROPERTIES.forEach(function (property) {
        var value = getSpecifiedOrDefaultValue(property, axis, channel, model, isGridAxis);
        if (value !== undefined) {
            vgAxis[property] = value;
        }
    });
    // Special case for gridScale since gridScale is not a Vega-Lite Axis property.
    var gridScale = getSpecifiedOrDefaultValue('gridScale', axis, channel, model, isGridAxis);
    if (gridScale !== undefined) {
        vgAxis.gridScale = gridScale;
    }
    // 2) Add guide encode definition groups
    var encodeSpec = axis.encode || {};
    AXIS_PARTS.forEach(function (part) {
        if (!hasAxisPart(vgAxis, part)) {
            // No need to create encode for a disabled part.
            return;
        }
        // TODO(@yuhanlu): instead of calling encode[part], break this line based on part type
        // as different require different parameters.
        var value;
        if (part === 'labels') {
            value = encode.labels(model, channel, encodeSpec.labels || {}, vgAxis);
        }
        else {
            value = encodeSpec[part] || {};
        }
        if (value !== undefined && util_1.keys(value).length > 0) {
            vgAxis.encode = vgAxis.encode || {};
            vgAxis.encode[part] = { update: value };
        }
    });
    return vgAxis;
}
function getSpecifiedOrDefaultValue(property, specifiedAxis, channel, model, isGridAxis) {
    var fieldDef = model.fieldDef(channel);
    switch (property) {
        case 'labels':
            return isGridAxis ? false : specifiedAxis[property];
        case 'domain':
            return rules.domain(property, specifiedAxis, isGridAxis, channel);
        case 'ticks':
            return rules.ticks(property, specifiedAxis, isGridAxis, channel);
        case 'format':
            return rules.format(specifiedAxis, channel, fieldDef, model.config);
        case 'grid':
            return rules.grid(model, channel, isGridAxis); // FIXME: refactor this
        case 'gridScale':
            return rules.gridScale(model, channel, isGridAxis);
        case 'orient':
            return rules.orient(specifiedAxis, channel);
        case 'tickCount':
            return rules.tickCount(specifiedAxis, channel, fieldDef); // TODO: scaleType
        case 'title':
            return rules.title(specifiedAxis, fieldDef, model.config, isGridAxis);
        case 'values':
            return rules.values(specifiedAxis);
        case 'zindex':
            return rules.zindex(specifiedAxis, isGridAxis);
    }
    // Otherwise, return specified property.
    return specifiedAxis[property];
}

},{"../../axis":14,"../../util":102,"./encode":17,"./rules":19}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var channel_1 = require("../../channel");
var datetime_1 = require("../../datetime");
var fielddef_1 = require("../../fielddef");
var util_1 = require("../../util");
var common_1 = require("../common");
function format(specifiedAxis, channel, fieldDef, config) {
    return common_1.numberFormat(fieldDef, specifiedAxis.format, config, channel);
}
exports.format = format;
// TODO: we need to refactor this method after we take care of config refactoring
/**
 * Default rules for whether to show a grid should be shown for a channel.
 * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned
 */
function gridShow(model, channel) {
    var grid = model.axis(channel).grid;
    if (grid !== undefined) {
        return grid;
    }
    return !model.hasDiscreteDomain(channel) && !model.fieldDef(channel).bin;
}
exports.gridShow = gridShow;
function grid(model, channel, isGridAxis) {
    if (channel === channel_1.ROW || channel === channel_1.COLUMN) {
        // never apply grid for ROW and COLUMN since we manually create rule-group for them
        return false;
    }
    if (!isGridAxis) {
        return undefined;
    }
    return gridShow(model, channel);
}
exports.grid = grid;
function gridScale(model, channel, isGridAxis) {
    if (isGridAxis) {
        var gridChannel = channel === 'x' ? 'y' : 'x';
        if (model.scale(gridChannel)) {
            return model.scaleName(gridChannel);
        }
    }
    return undefined;
}
exports.gridScale = gridScale;
function orient(specifiedAxis, channel) {
    var orient = specifiedAxis.orient;
    if (orient) {
        return orient;
    }
    switch (channel) {
        case channel_1.COLUMN:
            // FIXME test and decide
            return 'top';
        case channel_1.X:
            return 'bottom';
        case channel_1.ROW:
        case channel_1.Y:
            return 'left';
    }
    /* istanbul ignore next: This should never happen. */
    throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);
}
exports.orient = orient;
function tickCount(specifiedAxis, channel, fieldDef) {
    var count = specifiedAxis.tickCount;
    if (count !== undefined) {
        return count;
    }
    // FIXME depends on scale type too
    if (channel === channel_1.X && !fieldDef.bin) {
        // Vega's default tickCount often lead to a lot of label occlusion on X without 90 degree rotation
        return 5;
    }
    return undefined;
}
exports.tickCount = tickCount;
function title(specifiedAxis, fieldDef, config, isGridAxis) {
    if (isGridAxis) {
        return undefined;
    }
    if (specifiedAxis.title === '') {
        return undefined;
    }
    if (specifiedAxis.title !== undefined) {
        return specifiedAxis.title;
    }
    // if not defined, automatically determine axis title from field def
    var fieldTitle = fielddef_1.title(fieldDef, config);
    var maxLength = specifiedAxis.titleMaxLength;
    return maxLength ? util_1.truncate(fieldTitle, maxLength) : fieldTitle;
}
exports.title = title;
function values(specifiedAxis) {
    var vals = specifiedAxis.values;
    if (specifiedAxis.values && datetime_1.isDateTime(vals[0])) {
        return vals.map(function (dt) {
            // normalize = true as end user won't put 0 = January
            return datetime_1.timestamp(dt, true);
        });
    }
    return vals;
}
exports.values = values;
function zindex(specifiedAxis, isGridAxis) {
    var z = specifiedAxis.zindex;
    if (z !== undefined) {
        return z;
    }
    if (isGridAxis) {
        // if grid is true, need to put layer on the back so that grid is behind marks
        return 0;
    }
    return 1; // otherwise return undefined and use Vega's default.
}
exports.zindex = zindex;
function domainAndTicks(property, specifiedAxis, isGridAxis, channel) {
    if (isGridAxis || channel === channel_1.ROW || channel === channel_1.COLUMN) {
        return false;
    }
    return specifiedAxis[property];
}
exports.domainAndTicks = domainAndTicks;
exports.domain = domainAndTicks;
exports.ticks = domainAndTicks;

},{"../../channel":16,"../../datetime":84,"../../fielddef":87,"../../log":90,"../../util":102,"../common":20}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../log");
var channel_1 = require("../channel");
var fielddef_1 = require("../fielddef");
var spec_1 = require("../spec");
var timeunit_1 = require("../timeunit");
var type_1 = require("../type");
var util_1 = require("../util");
var concat_1 = require("./concat");
var facet_1 = require("./facet");
var layer_1 = require("./layer");
var repeat_1 = require("./repeat");
var unit_1 = require("./unit");
function buildModel(spec, parent, parentGivenName, unitSize, repeater, config) {
    if (spec_1.isFacetSpec(spec)) {
        return new facet_1.FacetModel(spec, parent, parentGivenName, repeater, config);
    }
    if (spec_1.isLayerSpec(spec)) {
        return new layer_1.LayerModel(spec, parent, parentGivenName, unitSize, repeater, config);
    }
    if (spec_1.isUnitSpec(spec)) {
        return new unit_1.UnitModel(spec, parent, parentGivenName, unitSize, repeater, config);
    }
    if (spec_1.isRepeatSpec(spec)) {
        return new repeat_1.RepeatModel(spec, parent, parentGivenName, repeater, config);
    }
    if (spec_1.isConcatSpec(spec)) {
        return new concat_1.ConcatModel(spec, parent, parentGivenName, repeater, config);
    }
    throw new Error(log.message.INVALID_SPEC);
}
exports.buildModel = buildModel;
function applyConfig(e, config, // TODO(#1842): consolidate MarkConfig | TextConfig?
    propsList) {
    for (var _i = 0, propsList_1 = propsList; _i < propsList_1.length; _i++) {
        var property = propsList_1[_i];
        var value = config[property];
        if (value !== undefined) {
            e[property] = { value: value };
        }
    }
    return e;
}
exports.applyConfig = applyConfig;
function applyMarkConfig(e, model, propsList) {
    for (var _i = 0, propsList_2 = propsList; _i < propsList_2.length; _i++) {
        var property = propsList_2[_i];
        var value = getMarkConfig(property, model.mark(), model.config);
        if (value !== undefined) {
            e[property] = { value: value };
        }
    }
    return e;
}
exports.applyMarkConfig = applyMarkConfig;
/**
 * Return value mark specific config property if exists.
 * Otherwise, return general mark specific config.
 */
function getMarkConfig(prop, mark, config) {
    var markSpecificConfig = config[mark];
    if (markSpecificConfig[prop] !== undefined) {
        return markSpecificConfig[prop];
    }
    return config.mark[prop];
}
exports.getMarkConfig = getMarkConfig;
function formatSignalRef(fieldDef, specifiedFormat, expr, config, useBinRange) {
    if (fieldDef.type === 'quantitative') {
        var format = numberFormat(fieldDef, specifiedFormat, config, 'text');
        if (fieldDef.bin) {
            if (useBinRange) {
                // For bin range, no need to apply format as the formula that creates range already include format
                return { signal: fielddef_1.field(fieldDef, { expr: expr, binSuffix: 'range' }) };
            }
            else {
                return {
                    signal: "format(" + fielddef_1.field(fieldDef, { expr: expr, binSuffix: 'start' }) + ", '" + format + "')" + "+'-'+" +
                        ("format(" + fielddef_1.field(fieldDef, { expr: expr, binSuffix: 'end' }) + ", '" + format + "')")
                };
            }
        }
        else {
            return {
                signal: "format(" + fielddef_1.field(fieldDef, { expr: expr }) + ", '" + format + "')"
            };
        }
    }
    else if (fieldDef.type === 'temporal') {
        return {
            signal: timeFormatExpression(fielddef_1.field(fieldDef, { expr: expr }), fieldDef.timeUnit, specifiedFormat, config.text.shortTimeLabels, config.timeFormat)
        };
    }
    else {
        return { signal: fielddef_1.field(fieldDef, { expr: expr }) };
    }
}
exports.formatSignalRef = formatSignalRef;
/**
 * Returns number format for a fieldDef
 *
 * @param format explicitly specified format
 */
function numberFormat(fieldDef, specifiedFormat, config, channel) {
    // Specified format in axis/legend has higher precedence than fieldDef.format
    var format = specifiedFormat;
    if (fieldDef.type === type_1.QUANTITATIVE) {
        // add number format for quantitative type only
        if (format) {
            return format;
        }
        else if (fieldDef.aggregate === 'count' && channel === channel_1.TEXT) {
            // FIXME: need a more holistic way to deal with this.
            return 'd';
        }
        // TODO: need to make this work correctly for numeric ordinal / nominal type
        return config.numberFormat;
    }
    return undefined;
}
exports.numberFormat = numberFormat;
/**
 * Returns the time expression used for axis/legend labels or text mark for a temporal field
 */
function timeFormatExpression(field, timeUnit, format, shortTimeLabels, timeFormatConfig) {
    if (!timeUnit || format) {
        // If there is not time unit, or if user explicitly specify format for axis/legend/text.
        var _format = format || timeFormatConfig; // only use config.timeFormat if there is no timeUnit.
        return "timeFormat(" + field + ", '" + _format + "')";
    }
    else {
        return timeunit_1.formatExpression(timeUnit, field, shortTimeLabels);
    }
}
exports.timeFormatExpression = timeFormatExpression;
/**
 * Return Vega sort parameters (tuple of field and order).
 */
function sortParams(orderDef) {
    return (util_1.isArray(orderDef) ? orderDef : [orderDef]).reduce(function (s, orderChannelDef) {
        s.field.push(fielddef_1.field(orderChannelDef, { binSuffix: 'start' }));
        s.order.push(orderChannelDef.sort || 'ascending');
        return s;
    }, { field: [], order: [] });
}
exports.sortParams = sortParams;

},{"../channel":16,"../fielddef":87,"../log":90,"../spec":96,"../timeunit":98,"../type":101,"../util":102,"./concat":22,"./facet":38,"./layer":39,"./repeat":58,"./unit":78}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Module for compiling Vega-lite spec into Vega spec.
 */
var config_1 = require("../config");
var log = require("../log");
var spec_1 = require("../spec");
var toplevelprops_1 = require("../toplevelprops");
var common_1 = require("./common");
function compile(inputSpec, logger) {
    if (logger) {
        // set the singleton logger to the provided logger
        log.set(logger);
    }
    try {
        // 1. initialize config
        var config = config_1.initConfig(inputSpec.config);
        // 2. Convert input spec into a normal form
        // (Decompose all extended unit specs into composition of unit spec.)
        var spec = spec_1.normalize(inputSpec, config);
        // 3. Instantiate the model with default config
        var model = common_1.buildModel(spec, null, '', undefined, undefined, config);
        // 4. Parse each part of the model to produce components that will be assembled later
        // We traverse the whole tree to parse once for each type of components
        // (e.g., data, layout, mark, scale).
        // Please see inside model.parse() for order for compilation.
        model.parse();
        // 5. Assemble a Vega Spec from the parsed components in 3.
        return assemble(model, getTopLevelProperties(inputSpec, config));
    }
    finally {
        // Reset the singleton logger if a logger is provided
        if (logger) {
            log.reset();
        }
    }
}
exports.compile = compile;
function getTopLevelProperties(topLevelSpec, config) {
    return tslib_1.__assign({}, toplevelprops_1.extractTopLevelProperties(config), toplevelprops_1.extractTopLevelProperties(topLevelSpec));
}
function assemble(model, topLevelProperties) {
    // TODO: change type to become VgSpec
    var output = tslib_1.__assign({ $schema: 'http://vega.github.io/schema/vega/v3.0.json' }, (model.description ? { description: model.description } : {}), { autosize: 'pad' }, topLevelProperties, { data: [].concat(model.assembleSelectionData([]), model.assembleData()), signals: ([].concat(
        // TODO(https://github.com/vega/vega-lite/issues/2198):
        // Merge the top-level's width/height signal with the top-level model
        // so we can remove this special casing based on model.name
        (model.name ? [
            // If model has name, its calculated width and height will not be named width and height, need to map it to the global width and height signals.
            { name: 'width', update: model.getName('width') },
            { name: 'height', update: model.getName('height') }
        ] : []), model.assembleLayoutSignals(), model.assembleSelectionTopLevelSignals([]))) }, assembleNestedMainGroup(model));
    return {
        spec: output
        // TODO: add warning / errors here
    };
}
function assembleNestedMainGroup(model) {
    var _a = model.assembleGroup([]), layout = _a.layout, signals = _a.signals, group = tslib_1.__rest(_a, ["layout", "signals"]);
    var marks = group.marks;
    var parentEncodeEntry = model.assembleParentGroupProperties();
    return tslib_1.__assign({}, group, { marks: [tslib_1.__assign({ name: model.getName('nested_main_group'), type: 'group', layout: layout,
                signals: signals }, (parentEncodeEntry ? {
                encode: {
                    update: parentEncodeEntry
                }
            } : {}), { marks: marks })] });
}
exports.assembleNestedMainGroup = assembleNestedMainGroup;

},{"../config":82,"../log":90,"../spec":96,"../toplevelprops":99,"./common":20,"tslib":10}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var spec_1 = require("../spec");
var util_1 = require("../util");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_1 = require("./data/parse");
var model_1 = require("./model");
var ConcatModel = (function (_super) {
    tslib_1.__extends(ConcatModel, _super);
    function ConcatModel(spec, parent, parentGivenName, repeater, config) {
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.isVConcat = spec_1.isVConcatSpec(spec);
        _this.children = (spec_1.isVConcatSpec(spec) ? spec.vconcat : spec.hconcat).map(function (child, i) {
            return common_1.buildModel(child, _this, _this.getName('concat_' + i), undefined, repeater, config);
        });
        return _this;
    }
    ConcatModel.prototype.parseData = function () {
        this.component.data = parse_1.parseData(this);
        this.children.forEach(function (child) {
            child.parseData();
        });
    };
    ConcatModel.prototype.parseSelection = function () {
        var _this = this;
        // Merge selections up the hierarchy so that they may be referenced
        // across unit specs. Persist their definitions within each child
        // to assemble signals which remain within output Vega unit groups.
        this.component.selection = {};
        var _loop_1 = function (child) {
            child.parseSelection();
            util_1.keys(child.component.selection).forEach(function (key) {
                _this.component.selection[key] = child.component.selection[key];
            });
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_1(child);
        }
    };
    ConcatModel.prototype.parseScale = function () {
        var model = this;
        var scaleComponent = this.component.scales = {};
        this.children.forEach(function (child) {
            child.parseScale();
        });
    };
    ConcatModel.prototype.parseMark = function () {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseMark();
        }
    };
    ConcatModel.prototype.parseAxisAndHeader = function () {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseAxisAndHeader();
        }
    };
    ConcatModel.prototype.parseAxisGroup = function () {
        return null;
    };
    ConcatModel.prototype.parseLegend = function () {
        var legendComponent = this.component.legends = {};
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseLegend();
        }
    };
    ConcatModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    ConcatModel.prototype.assembleParentGroupProperties = function () {
        return null;
    };
    ConcatModel.prototype.assembleSelectionTopLevelSignals = function (signals) {
        return this.children.reduce(function (sg, child) { return child.assembleSelectionTopLevelSignals(sg); }, signals);
    };
    ConcatModel.prototype.assembleSelectionSignals = function () {
        this.children.forEach(function (child) { return child.assembleSelectionSignals(); });
        return [];
    };
    ConcatModel.prototype.assembleLayoutSignals = function () {
        return this.children.reduce(function (signals, child) {
            return signals.concat(child.assembleLayoutSignals());
        }, []);
    };
    ConcatModel.prototype.assembleSelectionData = function (data) {
        return this.children.reduce(function (db, child) { return child.assembleSelectionData(db); }, []);
    };
    ConcatModel.prototype.assembleScales = function () {
        // combine with scales from children
        return this.children.reduce(function (scales, c) {
            return scales.concat(c.assembleScales());
        }, _super.prototype.assembleScales.call(this));
    };
    ConcatModel.prototype.assembleLayout = function () {
        // TODO: allow customization
        return tslib_1.__assign({ padding: { row: 10, column: 10 }, offset: 10 }, (this.isVConcat ? { columns: 1 } : {}), { bounds: 'full', align: 'all' });
    };
    ConcatModel.prototype.assembleMarks = function () {
        // only children have marks
        return this.children.map(function (child) {
            var encodeEntry = child.assembleParentGroupProperties();
            return tslib_1.__assign({ type: 'group', name: child.getName('group') }, (encodeEntry ? {
                encode: {
                    update: encodeEntry
                }
            } : {}), child.assembleGroup());
        });
    };
    return ConcatModel;
}(model_1.Model));
exports.ConcatModel = ConcatModel;

},{"../spec":96,"../util":102,"./common":20,"./data/assemble":24,"./data/parse":32,"./model":57,"tslib":10}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var type_1 = require("../../type");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
function addDimension(dims, fieldDef) {
    if (fieldDef.bin) {
        dims[fielddef_1.field(fieldDef, { binSuffix: 'start' })] = true;
        dims[fielddef_1.field(fieldDef, { binSuffix: 'end' })] = true;
        // We need the range only when the user explicitly forces a binned field to be ordinal (range used in axis and legend labels).
        // We could check whether the axis or legend exists but that seems overkill. In axes and legends, we check hasDiscreteDomain(scaleType).
        if (fieldDef.type === type_1.ORDINAL) {
            dims[fielddef_1.field(fieldDef, { binSuffix: 'range' })] = true;
        }
    }
    else {
        dims[fielddef_1.field(fieldDef)] = true;
    }
    return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
    for (var field_1 in childMeasures) {
        if (childMeasures.hasOwnProperty(field_1)) {
            // when we merge a measure, we either have to add an aggregation operator or even a new field
            var ops = childMeasures[field_1];
            for (var op in ops) {
                if (ops.hasOwnProperty(op)) {
                    if (field_1 in parentMeasures) {
                        // add operator to existing measure field
                        parentMeasures[field_1][op] = true;
                    }
                    else {
                        parentMeasures[field_1] = { op: true };
                    }
                }
            }
        }
    }
}
var AggregateNode = (function (_super) {
    tslib_1.__extends(AggregateNode, _super);
    /**
     * @param dimensions string set for dimensions
     * @param measures dictionary mapping field name => dict set of aggregation functions
     */
    function AggregateNode(dimensions, measures) {
        var _this = _super.call(this) || this;
        _this.dimensions = dimensions;
        _this.measures = measures;
        return _this;
    }
    AggregateNode.prototype.clone = function () {
        return new AggregateNode(util_1.extend({}, this.dimensions), util_1.duplicate(this.measures));
    };
    AggregateNode.make = function (model) {
        var isAggregate = false;
        model.forEachFieldDef(function (fd) {
            if (fd.aggregate) {
                isAggregate = true;
            }
        });
        var meas = {};
        var dims = {};
        if (!isAggregate) {
            // no need to create this node if the model has no aggregation
            return null;
        }
        model.forEachFieldDef(function (fieldDef, channel) {
            if (fieldDef.aggregate) {
                if (fieldDef.aggregate === 'count') {
                    meas['*'] = meas['*'] || {};
                    /* tslint:disable:no-string-literal */
                    meas['*']['count'] = true;
                    /* tslint:enable:no-string-literal */
                }
                else {
                    meas[fieldDef.field] = meas[fieldDef.field] || {};
                    meas[fieldDef.field][fieldDef.aggregate] = true;
                    // add min/max so we can use their union as unaggregated domain
                    var scale = model.scale(channel);
                    if (scale && scale.domain === 'unaggregated') {
                        meas[fieldDef.field]['min'] = true;
                        meas[fieldDef.field]['max'] = true;
                    }
                }
            }
            else {
                addDimension(dims, fieldDef);
            }
        });
        if ((Object.keys(dims).length + Object.keys(meas).length) === 0) {
            return null;
        }
        return new AggregateNode(dims, meas);
    };
    AggregateNode.prototype.merge = function (other) {
        if (!util_1.differ(this.dimensions, other.dimensions)) {
            mergeMeasures(this.measures, other.measures);
            other.remove();
        }
        else {
            log.debug('different dimensions, cannot merge');
        }
    };
    AggregateNode.prototype.addDimensions = function (fields) {
        var _this = this;
        fields.forEach(function (f) { return _this.dimensions[f] = true; });
    };
    AggregateNode.prototype.dependentFields = function () {
        var out = {};
        util_1.keys(this.dimensions).forEach(function (f) { return out[f] = true; });
        util_1.keys(this.measures).forEach(function (m) { return out[m] = true; });
        return out;
    };
    AggregateNode.prototype.producedFields = function () {
        var _this = this;
        var out = {};
        util_1.keys(this.measures).forEach(function (field) {
            util_1.keys(_this.measures[field]).forEach(function (op) {
                out[op + "_" + field] = true;
            });
        });
        return out;
    };
    AggregateNode.prototype.assemble = function () {
        var _this = this;
        var ops = [];
        var fields = [];
        util_1.keys(this.measures).forEach(function (field) {
            util_1.keys(_this.measures[field]).forEach(function (op) {
                ops.push(op);
                fields.push(field);
            });
        });
        return {
            type: 'aggregate',
            groupby: util_1.keys(this.dimensions),
            ops: ops,
            fields: fields
        };
    };
    return AggregateNode;
}(dataflow_1.DataFlowNode));
exports.AggregateNode = AggregateNode;

},{"../../fielddef":87,"../../log":90,"../../type":101,"../../util":102,"./dataflow":26,"tslib":10}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var data_1 = require("../../data");
var util_1 = require("../../util");
var aggregate_1 = require("./aggregate");
var bin_1 = require("./bin");
var dataflow_1 = require("./dataflow");
var facet_1 = require("./facet");
var formatparse_1 = require("./formatparse");
var nonpositivefilter_1 = require("./nonpositivefilter");
var nullfilter_1 = require("./nullfilter");
var optimizers_1 = require("./optimizers");
var optimizers = require("./optimizers");
var pathorder_1 = require("./pathorder");
var source_1 = require("./source");
var stack_1 = require("./stack");
var timeunit_1 = require("./timeunit");
var transforms_1 = require("./transforms");
exports.FACET_SCALE_PREFIX = 'scale_';
/**
 * Start optimization path from the root. Useful for removing nodes.
 */
function removeUnnecessaryNodes(node) {
    // remove empty non positive filter
    if (node instanceof nonpositivefilter_1.NonPositiveFilterNode && util_1.every(util_1.vals(node.filter), function (b) { return b === false; })) {
        node.remove();
    }
    // remove empty null filter nodes
    if (node instanceof nullfilter_1.NullFilterNode && util_1.every(util_1.vals(node.filteredFields), function (f) { return f === null; })) {
        node.remove();
    }
    // remove output nodes that are not required
    if (node instanceof dataflow_1.OutputNode && !node.required) {
        node.remove();
    }
    node.children.forEach(removeUnnecessaryNodes);
}
/**
 * Clones the subtree and ignores output nodes except for the leafs, which are renamed.
 */
function cloneSubtree(facet) {
    function clone(node) {
        if (!(node instanceof pathorder_1.OrderNode)) {
            var copy_1 = node.clone();
            if (copy_1 instanceof dataflow_1.OutputNode) {
                var newName = exports.FACET_SCALE_PREFIX + facet.model.getName(copy_1.source);
                copy_1.source = newName;
                facet.model.component.data.outputNodes[newName] = copy_1;
                util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });
            }
            else if (copy_1 instanceof aggregate_1.AggregateNode || copy_1 instanceof stack_1.StackNode) {
                copy_1.addDimensions(facet.fields);
                util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });
            }
            else {
                util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });
            }
            return [copy_1];
        }
        return util_1.flatten(node.children.map(clone));
    }
    return clone;
}
/**
 * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.
 * After moving down the facet node, make a copy of the subtree and make it a child of the main output.
 */
function moveFacetDown(node) {
    if (node instanceof facet_1.FacetNode) {
        if (node.numChildren() === 1 && !(node.children[0] instanceof dataflow_1.OutputNode)) {
            // move down until we hit a fork or output node
            var child = node.children[0];
            if (child instanceof aggregate_1.AggregateNode || child instanceof stack_1.StackNode) {
                child.addDimensions(node.fields);
            }
            child.swapWithParent();
            moveFacetDown(node);
        }
        else {
            // move main to facet
            moveMainDownToFacet(node.model.component.data.main);
            // replicate the subtree and place it before the facet's main node
            var copy = util_1.flatten(node.children.map(cloneSubtree(node)));
            copy.forEach(function (c) { return c.parent = node.model.component.data.main; });
        }
    }
    else {
        node.children.forEach(moveFacetDown);
    }
}
function moveMainDownToFacet(node) {
    if (node instanceof dataflow_1.OutputNode && node.type === data_1.MAIN) {
        if (node.numChildren() === 1) {
            var child = node.children[0];
            if (!(child instanceof facet_1.FacetNode)) {
                child.swapWithParent();
                moveMainDownToFacet(node);
            }
        }
    }
}
/**
 * Return all leaf nodes.
 */
function getLeaves(roots) {
    var leaves = [];
    function append(node) {
        if (node.numChildren() === 0) {
            leaves.push(node);
        }
        else {
            node.children.forEach(append);
        }
    }
    roots.forEach(append);
    return leaves;
}
/**
 * Print debug information for dataflow tree.
 */
function debug(node) {
    console.log("" + node.constructor.name + (node.debugName ? " (" + node.debugName + ")" : '') + " -> " + (node.children.map(function (c) {
        return "" + c.constructor.name + (c.debugName ? " (" + c.debugName + ")" : '');
    })));
    console.log(node);
    node.children.forEach(debug);
}
function makeWalkTree(data) {
    // to name datasources
    var datasetIndex = 0;
    /**
     * Recursively walk down the tree.
     */
    function walkTree(node, dataSource) {
        if (node instanceof formatparse_1.ParseNode) {
            if (node.parent instanceof source_1.SourceNode && !dataSource.source) {
                // If node's parent is a root source and the data source does not refer to another data source, use normal format parse
                dataSource.format = tslib_1.__assign({}, dataSource.format || {}, { parse: node.assembleFormatParse() });
            }
            else {
                // Otherwise use Vega expression to parse
                dataSource.transform = dataSource.transform.concat(node.assembleTransforms());
            }
        }
        if (node instanceof facet_1.FacetNode) {
            if (!dataSource.name) {
                dataSource.name = "data_" + datasetIndex++;
            }
            if (!dataSource.source || dataSource.transform.length > 0) {
                data.push(dataSource);
                node.data = dataSource.name;
            }
            else {
                node.data = dataSource.source;
            }
            node.assemble().forEach(function (d) { return data.push(d); });
            // break here because the rest of the tree has to be taken care of by the facet.
            return;
        }
        if (node instanceof transforms_1.FilterNode ||
            node instanceof nullfilter_1.NullFilterNode ||
            node instanceof transforms_1.CalculateNode ||
            node instanceof aggregate_1.AggregateNode ||
            node instanceof pathorder_1.OrderNode) {
            dataSource.transform.push(node.assemble());
        }
        if (node instanceof nonpositivefilter_1.NonPositiveFilterNode ||
            node instanceof bin_1.BinNode ||
            node instanceof timeunit_1.TimeUnitNode ||
            node instanceof stack_1.StackNode) {
            dataSource.transform = dataSource.transform.concat(node.assemble());
        }
        if (node instanceof dataflow_1.OutputNode) {
            if (dataSource.source && dataSource.transform.length === 0) {
                node.source = dataSource.source;
            }
            else if (node.parent instanceof dataflow_1.OutputNode) {
                // Note that an output node may be required but we still do not assemble a
                // separate data source for it.
                node.source = dataSource.name;
            }
            else {
                if (!dataSource.name) {
                    dataSource.name = "data_" + datasetIndex++;
                }
                // Here we set the name of the datasource we generated. From now on
                // other assemblers can use it.
                node.source = dataSource.name;
                // if this node has more than one child, we will add a datasource automatically
                if (node.numChildren() === 1 && dataSource.transform.length > 0) {
                    data.push(dataSource);
                    var newData = {
                        name: null,
                        source: dataSource.name,
                        transform: []
                    };
                    dataSource = newData;
                }
            }
        }
        switch (node.numChildren()) {
            case 0:
                // done
                if (node instanceof dataflow_1.OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
                    // do not push empty datasources that are simply references
                    data.push(dataSource);
                }
                break;
            case 1:
                walkTree(node.children[0], dataSource);
                break;
            default:
                var source_2 = dataSource.name;
                if (!dataSource.source || dataSource.transform.length > 0) {
                    data.push(dataSource);
                }
                else {
                    source_2 = dataSource.source;
                }
                node.children.forEach(function (child) {
                    var newData = {
                        name: null,
                        source: source_2,
                        transform: []
                    };
                    walkTree(child, newData);
                });
                break;
        }
    }
    return walkTree;
}
/**
 * Assemble data sources that are derived from faceted data.
 */
function assembleFacetData(root) {
    var data = [];
    var walkTree = makeWalkTree(data);
    root.children.forEach(function (child) { return walkTree(child, {
        source: root.name,
        name: null,
        transform: []
    }); });
    return data;
}
exports.assembleFacetData = assembleFacetData;
/**
 * Create Vega Data array from a given compiled model and append all of them to the given array
 *
 * @param  model
 * @param  data array
 * @return modified data array
 */
function assembleData(roots) {
    var data = [];
    roots.forEach(removeUnnecessaryNodes);
    // remove source nodes that don't have any children because they also don't have output nodes
    roots = roots.filter(function (r) { return r.numChildren() > 0; });
    getLeaves(roots).forEach(optimizers_1.iterateFromLeaves(optimizers.removeUnusedSubtrees));
    roots = roots.filter(function (r) { return r.numChildren() > 0; });
    getLeaves(roots).forEach(optimizers_1.iterateFromLeaves(optimizers.moveParseUp));
    roots.forEach(moveFacetDown);
    // roots.forEach(debug);
    var walkTree = makeWalkTree(data);
    var sourceIndex = 0;
    roots.forEach(function (root) {
        // assign a name if the source does not have a name yet
        if (!root.hasName()) {
            root.dataName = "source_" + sourceIndex++;
        }
        var newData = root.assemble();
        walkTree(root, newData);
    });
    // remove empty transform arrays for cleaner output
    data.forEach(function (d) {
        if (d.transform.length === 0) {
            delete d.transform;
        }
    });
    return data;
}
exports.assembleData = assembleData;

},{"../../data":83,"../../util":102,"./aggregate":23,"./bin":25,"./dataflow":26,"./facet":27,"./formatparse":28,"./nonpositivefilter":29,"./nullfilter":30,"./optimizers":31,"./pathorder":33,"./source":34,"./stack":35,"./timeunit":36,"./transforms":37,"tslib":10}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var bin_1 = require("../../bin");
var fielddef_1 = require("../../fielddef");
var util_1 = require("../../util");
var common_1 = require("../common");
var unit_1 = require("../unit");
var dataflow_1 = require("./dataflow");
function numberFormatExpr(expr, format) {
    return "format(" + expr + ", '" + format + "')";
}
function rangeFormula(model, fieldDef, channel, config) {
    var discreteDomain = model.hasDiscreteDomain(channel);
    if (discreteDomain) {
        // read format from axis or legend, if there is no format then use config.numberFormat
        var guide = (model instanceof unit_1.UnitModel) ? (model.axis(channel) || model.legend(channel) || {}) : {};
        var format = common_1.numberFormat(fieldDef, guide.format, config, channel);
        var startField = fielddef_1.field(fieldDef, { expr: 'datum', binSuffix: 'start' });
        var endField = fielddef_1.field(fieldDef, { expr: 'datum', binSuffix: 'end' });
        return {
            formulaAs: fielddef_1.field(fieldDef, { binSuffix: 'range' }),
            formula: numberFormatExpr(startField, format) + " + ' - ' + " + numberFormatExpr(endField, format)
        };
    }
    return {};
}
var BinNode = (function (_super) {
    tslib_1.__extends(BinNode, _super);
    function BinNode(bins) {
        var _this = _super.call(this) || this;
        _this.bins = bins;
        return _this;
    }
    BinNode.prototype.clone = function () {
        return new BinNode(util_1.duplicate(this.bins));
    };
    BinNode.make = function (model) {
        var bins = model.reduceFieldDef(function (binComponent, fieldDef, channel) {
            var fieldDefBin = model.fieldDef(channel).bin;
            if (fieldDefBin) {
                var bin = util_1.isBoolean(fieldDefBin) ? {} : fieldDefBin;
                var key = bin_1.binToString(fieldDef.bin) + "_" + fieldDef.field;
                if (!(key in binComponent)) {
                    binComponent[key] = {
                        bin: bin,
                        field: fieldDef.field,
                        as: [fielddef_1.field(fieldDef, { binSuffix: 'start' }), fielddef_1.field(fieldDef, { binSuffix: 'end' })],
                        signal: model.getName(key + "_bins"),
                        extentSignal: model.getName(key + '_extent')
                    };
                }
                binComponent[key] = tslib_1.__assign({}, binComponent[key], rangeFormula(model, fieldDef, channel, model.config));
            }
            return binComponent;
        }, {});
        if (Object.keys(bins).length === 0) {
            return null;
        }
        return new BinNode(bins);
    };
    BinNode.prototype.merge = function (other) {
        this.bins = util_1.extend(other.bins);
        other.remove();
    };
    BinNode.prototype.producedFields = function () {
        var out = {};
        util_1.vals(this.bins).forEach(function (c) {
            c.as.forEach(function (f) { return out[f] = true; });
        });
        return out;
    };
    BinNode.prototype.dependentFields = function () {
        var out = {};
        util_1.vals(this.bins).forEach(function (c) {
            out[c.field] = true;
        });
        return out;
    };
    BinNode.prototype.assemble = function () {
        return util_1.flatten(util_1.vals(this.bins).map(function (bin) {
            var transform = [];
            var binTrans = tslib_1.__assign({ type: 'bin', field: bin.field, as: bin.as, signal: bin.signal }, bin.bin);
            if (!bin.bin.extent) {
                transform.push({
                    type: 'extent',
                    field: bin.field,
                    signal: bin.extentSignal
                });
                binTrans.extent = { signal: bin.extentSignal };
            }
            transform.push(binTrans);
            if (bin.formula) {
                transform.push({
                    type: 'formula',
                    expr: bin.formula,
                    as: bin.formulaAs
                });
            }
            return transform;
        }));
    };
    return BinNode;
}(dataflow_1.DataFlowNode));
exports.BinNode = BinNode;

},{"../../bin":15,"../../fielddef":87,"../../util":102,"../common":20,"../unit":78,"./dataflow":26,"tslib":10}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * A node in the dataflow tree.
 */
var DataFlowNode = (function () {
    function DataFlowNode(debugName) {
        this.debugName = debugName;
        this._children = [];
        this._parent = null;
    }
    /**
     * Clone this node with a deep copy but don't clone links to children or parents.
     */
    DataFlowNode.prototype.clone = function () {
        throw new Error('Cannot clone node');
    };
    /**
     * Set of fields that are being created by this node.
     */
    DataFlowNode.prototype.producedFields = function () {
        return {};
    };
    DataFlowNode.prototype.dependentFields = function () {
        return {};
    };
    Object.defineProperty(DataFlowNode.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        /**
         * Set the parent of the node and also add this not to the parent's children.
         */
        set: function (parent) {
            this._parent = parent;
            parent.addChild(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataFlowNode.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    DataFlowNode.prototype.numChildren = function () {
        return this._children.length;
    };
    DataFlowNode.prototype.addChild = function (child) {
        this._children.push(child);
    };
    DataFlowNode.prototype.removeChild = function (oldChild) {
        this._children.splice(this._children.indexOf(oldChild), 1);
    };
    /**
     * Remove node from the dataflow.
     */
    DataFlowNode.prototype.remove = function () {
        var _this = this;
        this._children.forEach(function (child) { return child.parent = _this._parent; });
        this._parent.removeChild(this);
    };
    DataFlowNode.prototype.swapWithParent = function () {
        var parent = this._parent;
        var newParent = parent.parent;
        // reconnect the children
        this._children.forEach(function (c) { return c.parent = parent; });
        // remove old links
        this._children = []; // equivalent to removing every child link one by one
        parent.removeChild(this);
        parent.parent.removeChild(parent);
        // swap two nodes
        this.parent = newParent;
        parent.parent = this;
    };
    return DataFlowNode;
}());
exports.DataFlowNode = DataFlowNode;
var OutputNode = (function (_super) {
    tslib_1.__extends(OutputNode, _super);
    function OutputNode(source, type) {
        var _this = _super.call(this, source) || this;
        _this.type = type;
        _this._refcount = 0;
        _this._source = source;
        return _this;
    }
    OutputNode.prototype.clone = function () {
        var cloneObj = new this.constructor;
        cloneObj._source = this._source;
        cloneObj.debugName = 'clone_' + this.debugName;
        cloneObj._refcount = this._refcount;
        return cloneObj;
    };
    Object.defineProperty(OutputNode.prototype, "source", {
        /**
         * Request the datasource name.
         *
         * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
         * It is crucial to request the name from an output node to mark it as a required node.
         * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
         *
         * In the assemble phase, this will return the correct name.
         */
        get: function () {
            this._refcount++;
            return this._source;
        },
        set: function (source) {
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputNode.prototype, "required", {
        get: function () {
            return this._refcount > 0;
        },
        enumerable: true,
        configurable: true
    });
    return OutputNode;
}(DataFlowNode));
exports.OutputNode = OutputNode;

},{"tslib":10}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var dataflow_1 = require("./dataflow");
/**
 * A node that helps us track what fields we are faceting by.
 */
var FacetNode = (function (_super) {
    tslib_1.__extends(FacetNode, _super);
    /**
     * @param model The facet model.
     * @param name The name that this facet source will have.
     * @param data The source data for this facet data.
     */
    function FacetNode(model, name, data) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.name = name;
        _this.data = data;
        if (model.facet.column) {
            _this.columnField = model.field(channel_1.COLUMN);
            _this.columnName = model.getName('column');
        }
        if (model.facet.row) {
            _this.rowField = model.field(channel_1.ROW);
            _this.rowName = model.getName('row');
        }
        return _this;
    }
    Object.defineProperty(FacetNode.prototype, "fields", {
        get: function () {
            var fields = [];
            if (this.columnField) {
                fields.push(this.columnField);
            }
            if (this.rowField) {
                fields.push(this.rowField);
            }
            return fields;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FacetNode.prototype, "source", {
        /**
         * The name to reference this source is its name
         */
        get: function () {
            return this.name;
        },
        enumerable: true,
        configurable: true
    });
    FacetNode.prototype.assemble = function () {
        var data = [];
        if (this.columnName) {
            data.push({
                name: this.columnName,
                source: this.data,
                transform: [{
                        type: 'aggregate',
                        groupby: [this.columnField]
                    }]
            });
            // Column needs another data source to calculate cardinality as input to layout
            data.push({
                name: this.columnName + '_layout',
                source: this.columnName,
                transform: [{
                        type: 'aggregate',
                        ops: ['distinct'],
                        fields: [this.columnField]
                    }]
            });
        }
        if (this.rowName) {
            data.push({
                name: this.rowName,
                source: this.data,
                transform: [{
                        type: 'aggregate',
                        groupby: [this.rowField]
                    }]
            });
        }
        return data;
    };
    return FacetNode;
}(dataflow_1.DataFlowNode));
exports.FacetNode = FacetNode;

},{"../../channel":16,"./dataflow":26,"tslib":10}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var datetime_1 = require("../../datetime");
var fielddef_1 = require("../../fielddef");
var filter_1 = require("../../filter");
var log = require("../../log");
var transform_1 = require("../../transform");
var type_1 = require("../../type");
var util_1 = require("../../util");
var model_1 = require("../model");
var dataflow_1 = require("./dataflow");
function parseExpression(field, parse) {
    var f = "datum[" + util_1.stringValue(field) + "]";
    if (parse === 'number') {
        return "toNumber(" + f + ")";
    }
    else if (parse === 'boolean') {
        return "toBoolean(" + f + ")";
    }
    else if (parse === 'string') {
        return "toString(" + f + ")";
    }
    else if (parse === 'date') {
        return "toDate(" + f + ")";
    }
    else if (parse.indexOf('date:') === 0) {
        var specifier = parse.slice(6, parse.length - 1); // specifier is in "" or ''
        return "timeParse(" + f + ",\"" + specifier + "\")";
    }
    else {
        log.warn(log.message.unrecognizedParse(parse));
        return null;
    }
}
var ParseNode = (function (_super) {
    tslib_1.__extends(ParseNode, _super);
    function ParseNode(parse) {
        var _this = _super.call(this) || this;
        _this._parse = {};
        _this._parse = parse;
        return _this;
    }
    ParseNode.prototype.clone = function () {
        return new ParseNode(util_1.duplicate(this.parse));
    };
    ParseNode.make = function (model) {
        var parse = {};
        var calcFieldMap = model.transforms.filter(transform_1.isCalculate).reduce(function (fieldMap, formula) {
            fieldMap[formula.as] = true;
            return fieldMap;
        }, {});
        // Parse filter fields
        model.transforms.filter(transform_1.isFilter).forEach(function (transform) {
            var filter = transform.filter;
            var val = null;
            // For EqualFilter, just use the equal property.
            // For RangeFilter and OneOfFilter, all array members should have
            // the same type, so we only use the first one.
            if (filter_1.isEqualFilter(filter)) {
                val = filter.equal;
            }
            else if (filter_1.isRangeFilter(filter)) {
                val = filter.range[0];
            }
            else if (filter_1.isOneOfFilter(filter)) {
                val = (filter.oneOf || filter['in'])[0];
            } // else -- for filter expression, we can't infer anything
            if (val) {
                if (datetime_1.isDateTime(val)) {
                    parse[filter['field']] = 'date';
                }
                else if (util_1.isNumber(val)) {
                    parse[filter['field']] = 'number';
                }
                else if (util_1.isString(val)) {
                    parse[filter['field']] = 'string';
                }
            }
        });
        if (model instanceof model_1.ModelWithField) {
            // Parse encoded fields
            model.forEachFieldDef(function (fieldDef) {
                if (fieldDef.type === type_1.TEMPORAL) {
                    parse[fieldDef.field] = 'date';
                }
                else if (fieldDef.type === type_1.QUANTITATIVE) {
                    if (fielddef_1.isCount(fieldDef) || calcFieldMap[fieldDef.field]) {
                        return;
                    }
                    parse[fieldDef.field] = 'number';
                }
            });
        }
        // Custom parse should override inferred parse
        var data = model.data;
        if (data && data.format && data.format.parse) {
            var p_1 = data.format.parse;
            util_1.keys(p_1).forEach(function (field) {
                parse[field] = p_1[field];
            });
        }
        if (util_1.keys(parse).length === 0) {
            return null;
        }
        return new ParseNode(parse);
    };
    Object.defineProperty(ParseNode.prototype, "parse", {
        get: function () {
            return this._parse;
        },
        enumerable: true,
        configurable: true
    });
    ParseNode.prototype.merge = function (other) {
        this._parse = util_1.extend(this._parse, other.parse);
        other.remove();
    };
    ParseNode.prototype.assembleFormatParse = function () {
        return this._parse;
    };
    ParseNode.prototype.assembleTransforms = function () {
        var _this = this;
        return Object.keys(this._parse).map(function (field) {
            var expr = parseExpression(field, _this._parse[field]);
            if (!expr) {
                return null;
            }
            var formula = {
                type: 'formula',
                expr: expr,
                as: field
            };
            return formula;
        }).filter(function (t) { return t !== null; });
    };
    return ParseNode;
}(dataflow_1.DataFlowNode));
exports.ParseNode = ParseNode;

},{"../../datetime":84,"../../fielddef":87,"../../filter":88,"../../log":90,"../../transform":100,"../../type":101,"../../util":102,"../model":57,"./dataflow":26,"tslib":10}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var NonPositiveFilterNode = (function (_super) {
    tslib_1.__extends(NonPositiveFilterNode, _super);
    function NonPositiveFilterNode(filter) {
        var _this = _super.call(this) || this;
        _this._filter = filter;
        return _this;
    }
    NonPositiveFilterNode.prototype.clone = function () {
        return new NonPositiveFilterNode(util_1.extend({}, this._filter));
    };
    NonPositiveFilterNode.make = function (model) {
        var filter = model.channels().reduce(function (nonPositiveComponent, channel) {
            var scale = model.scale(channel);
            if (!scale || !model.field(channel)) {
                // don't set anything
                return nonPositiveComponent;
            }
            nonPositiveComponent[model.field(channel)] = scale.type === scale_1.ScaleType.LOG;
            return nonPositiveComponent;
        }, {});
        if (!Object.keys(filter).length) {
            return null;
        }
        return new NonPositiveFilterNode(filter);
    };
    Object.defineProperty(NonPositiveFilterNode.prototype, "filter", {
        get: function () {
            return this._filter;
        },
        enumerable: true,
        configurable: true
    });
    NonPositiveFilterNode.prototype.assemble = function () {
        var _this = this;
        return util_1.keys(this._filter).filter(function (field) {
            // Only filter fields (keys) with value = true
            return _this._filter[field];
        }).map(function (field) {
            return {
                type: 'filter',
                expr: 'datum["' + field + '"] > 0'
            };
        });
    };
    return NonPositiveFilterNode;
}(dataflow_1.DataFlowNode));
exports.NonPositiveFilterNode = NonPositiveFilterNode;

},{"../../scale":93,"../../util":102,"./dataflow":26,"tslib":10}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var type_1 = require("../../type");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var DEFAULT_NULL_FILTERS = {
    nominal: false,
    ordinal: false,
    quantitative: true,
    temporal: true
};
var NullFilterNode = (function (_super) {
    tslib_1.__extends(NullFilterNode, _super);
    function NullFilterNode(fields) {
        var _this = _super.call(this) || this;
        _this._filteredFields = fields;
        return _this;
    }
    NullFilterNode.prototype.clone = function () {
        return new NullFilterNode(util_1.duplicate(this._filteredFields));
    };
    NullFilterNode.make = function (model) {
        var fields = model.reduceFieldDef(function (aggregator, fieldDef) {
            if (fieldDef.aggregate !== 'count') {
                if (model.config.filterInvalid ||
                    (model.config.filterInvalid === undefined && (fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type]))) {
                    aggregator[fieldDef.field] = fieldDef;
                }
                else {
                    // define this so we know that we don't filter nulls for this field
                    // this makes it easier to merge into parents
                    aggregator[fieldDef.field] = null;
                }
            }
            return aggregator;
        }, {});
        if (Object.keys(fields).length === 0) {
            return null;
        }
        return new NullFilterNode(fields);
    };
    Object.defineProperty(NullFilterNode.prototype, "filteredFields", {
        get: function () {
            return this._filteredFields;
        },
        enumerable: true,
        configurable: true
    });
    NullFilterNode.prototype.merge = function (other) {
        var _this = this;
        var t = Object.keys(this._filteredFields).map(function (k) { return k + ' ' + util_1.hash(_this._filteredFields[k]); });
        var o = Object.keys(other.filteredFields).map(function (k) { return k + ' ' + util_1.hash(other.filteredFields[k]); });
        if (!util_1.differArray(t, o)) {
            this._filteredFields = util_1.extend(this._filteredFields, other._filteredFields);
            other.remove();
        }
    };
    NullFilterNode.prototype.assemble = function () {
        var _this = this;
        var filters = util_1.keys(this._filteredFields).reduce(function (_filters, field) {
            var fieldDef = _this._filteredFields[field];
            if (fieldDef !== null) {
                _filters.push("datum[" + util_1.stringValue(fieldDef.field) + "] !== null");
                if (util_1.contains([type_1.QUANTITATIVE, type_1.TEMPORAL], fieldDef.type)) {
                    // TODO(https://github.com/vega/vega-lite/issues/1436):
                    // We can be even smarter and add NaN filter for N,O that are numbers
                    // based on the `parse` property once we have it.
                    _filters.push("!isNaN(datum[" + util_1.stringValue(fieldDef.field) + "])");
                }
            }
            return _filters;
        }, []);
        return filters.length > 0 ?
            {
                type: 'filter',
                expr: filters.join(' && ')
            } : null;
    };
    return NullFilterNode;
}(dataflow_1.DataFlowNode));
exports.NullFilterNode = NullFilterNode;

},{"../../type":101,"../../util":102,"./dataflow":26,"tslib":10}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dataflow_1 = require("./dataflow");
var formatparse_1 = require("./formatparse");
var source_1 = require("./source");
/**
 * Start optimization path at the leaves. Useful for merging up or removing things.
 *
 * If the callback returns true, the recursion continues.
 */
function iterateFromLeaves(f) {
    function optimizeNextFromLeaves(node) {
        if (node instanceof source_1.SourceNode) {
            return;
        }
        var next = node.parent;
        if (f(node)) {
            optimizeNextFromLeaves(next);
        }
    }
    return optimizeNextFromLeaves;
}
exports.iterateFromLeaves = iterateFromLeaves;
/**
 * Move parse nodes up to forks.
 */
function moveParseUp(node) {
    var parent = node.parent;
    // move parse up by merging or swapping
    if (node instanceof formatparse_1.ParseNode) {
        if (parent instanceof source_1.SourceNode) {
            return false;
        }
        if (parent.numChildren() > 1) {
            return true;
        }
        if (parent instanceof formatparse_1.ParseNode) {
            parent.merge(node);
        }
        else {
            node.swapWithParent();
        }
    }
    return true;
}
exports.moveParseUp = moveParseUp;
/**
 * Repeatedly remove leaf nodes that are not output nodes.
 * The reason is that we don't need subtrees that don't have any output nodes.
 */
function removeUnusedSubtrees(node) {
    var parent = node.parent;
    if (node instanceof dataflow_1.OutputNode || node.numChildren() > 0) {
        // no need to continue with parent because it is output node or will have children (there was a fork)
        return false;
    }
    else {
        node.remove();
    }
    return true;
}
exports.removeUnusedSubtrees = removeUnusedSubtrees;

},{"./dataflow":26,"./formatparse":28,"./source":34}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("../../data");
var facet_1 = require("../facet");
var layer_1 = require("../layer");
var model_1 = require("../model");
var unit_1 = require("../unit");
var aggregate_1 = require("./aggregate");
var bin_1 = require("./bin");
var dataflow_1 = require("./dataflow");
var facet_2 = require("./facet");
var formatparse_1 = require("./formatparse");
var nonpositivefilter_1 = require("./nonpositivefilter");
var nullfilter_1 = require("./nullfilter");
var pathorder_1 = require("./pathorder");
var source_1 = require("./source");
var stack_1 = require("./stack");
var timeunit_1 = require("./timeunit");
var transforms_1 = require("./transforms");
function parseRoot(model, sources) {
    if (model.data || !model.parent) {
        // if the model defines a data source or is the root, create a source node
        var source = new source_1.SourceNode(model);
        var hash = source.hash();
        if (hash in sources) {
            // use a reference if we already have a source
            return sources[hash];
        }
        else {
            // otherwise add a new one
            sources[hash] = source;
            return source;
        }
    }
    else {
        // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.
        return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
    }
}
/*
Description of the dataflow (http://asciiflow.com/):

     +--------+
     | Source |
     +---+----+
         |
         v
       Parse
         |
         v
     Transforms
(Filter, Compute, ...)
         |
         v
     Null Filter
         |
         v
      Binning
         |
         v
     Timeunit
         |
         v
      +--+--+
      | Raw |
      +-----+
         |
         v
     Aggregate
         |
         v
       Stack
         |
         v
      >0 Filter
         |
         v
     Path Order
         |
         v
   +----------+
   |   Main   |
   +----------+
         |
         v
     +-------+
     | Facet |----> "column", "column-layout", and "row"
     +-------+
         |
         v
  ...Child data...

*/
function parseData(model) {
    var root = parseRoot(model, model.component.data.sources);
    var outputNodes = model.component.data.outputNodes;
    // the current head of the tree that we are appending to
    var head = root;
    var parse = formatparse_1.ParseNode.make(model);
    if (parse) {
        parse.parent = root;
        head = parse;
    }
    // HACK: This is equivalent for merging bin extent for union scale.
    // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale
    var parentIsLayer = model.parent && (model.parent instanceof layer_1.LayerModel);
    if (model instanceof model_1.ModelWithField) {
        if (parentIsLayer) {
            var bin = bin_1.BinNode.make(model);
            if (bin) {
                bin.parent = head;
                head = bin;
            }
        }
    }
    if (model.transforms.length > 0) {
        var _a = transforms_1.parseTransformArray(model), first = _a.first, last = _a.last;
        first.parent = head;
        head = last;
    }
    if (model instanceof model_1.ModelWithField) {
        var nullFilter = nullfilter_1.NullFilterNode.make(model);
        if (nullFilter) {
            nullFilter.parent = head;
            head = nullFilter;
        }
        if (!parentIsLayer) {
            var bin = bin_1.BinNode.make(model);
            if (bin) {
                bin.parent = head;
                head = bin;
            }
        }
        var tu = timeunit_1.TimeUnitNode.make(model);
        if (tu) {
            tu.parent = head;
            head = tu;
        }
    }
    // add an output node pre aggregation
    var rawName = model.getName(data_1.RAW);
    var raw = new dataflow_1.OutputNode(rawName, data_1.RAW);
    outputNodes[rawName] = raw;
    raw.parent = head;
    head = raw;
    if (model instanceof unit_1.UnitModel) {
        var agg = aggregate_1.AggregateNode.make(model);
        if (agg) {
            agg.parent = head;
            head = agg;
        }
        var stack = stack_1.StackNode.make(model);
        if (stack) {
            stack.parent = head;
            head = stack;
        }
        var nonPosFilter = nonpositivefilter_1.NonPositiveFilterNode.make(model);
        if (nonPosFilter) {
            nonPosFilter.parent = head;
            head = nonPosFilter;
        }
    }
    if (model instanceof unit_1.UnitModel) {
        var order = pathorder_1.OrderNode.make(model);
        if (order) {
            order.parent = head;
            head = order;
        }
    }
    // output node for marks
    var mainName = model.getName(data_1.MAIN);
    var main = new dataflow_1.OutputNode(mainName, data_1.MAIN);
    outputNodes[mainName] = main;
    main.parent = head;
    head = main;
    // add facet marker
    var facetRoot = null;
    if (model instanceof facet_1.FacetModel) {
        var facetName = model.getName('facet');
        facetRoot = new facet_2.FacetNode(model, facetName, main.source);
        outputNodes[facetName] = facetRoot;
        facetRoot.parent = head;
        head = facetRoot;
    }
    return {
        sources: model.component.data.sources,
        outputNodes: outputNodes,
        main: main,
        facetRoot: facetRoot
    };
}
exports.parseData = parseData;

},{"../../data":83,"../facet":38,"../layer":39,"../model":57,"../unit":78,"./aggregate":23,"./bin":25,"./dataflow":26,"./facet":27,"./formatparse":28,"./nonpositivefilter":29,"./nullfilter":30,"./pathorder":33,"./source":34,"./stack":35,"./timeunit":36,"./transforms":37}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var encoding_1 = require("../../encoding");
var fielddef_1 = require("../../fielddef");
var sort_1 = require("../../sort");
var util_1 = require("../../util");
var common_1 = require("../common");
var dataflow_1 = require("./dataflow");
var OrderNode = (function (_super) {
    tslib_1.__extends(OrderNode, _super);
    function OrderNode(sort) {
        var _this = _super.call(this) || this;
        _this.sort = sort;
        return _this;
    }
    OrderNode.prototype.clone = function () {
        return new OrderNode(util_1.duplicate(this.sort));
    };
    OrderNode.make = function (model) {
        var sort = null;
        if (util_1.contains(['line', 'area'], model.mark())) {
            if (model.mark() === 'line' && model.channelHasField('order')) {
                // For only line, sort by the order field if it is specified.
                sort = common_1.sortParams(model.encoding.order);
            }
            else {
                // For both line and area, we sort values based on dimension by default
                var dimensionChannel = model.markDef.orient === 'horizontal' ? 'y' : 'x';
                var s = model.sort(dimensionChannel);
                var sortField = sort_1.isSortField(s) ?
                    fielddef_1.field({
                        // FIXME: this op might not already exist?
                        // FIXME: what if dimensionChannel (x or y) contains custom domain?
                        aggregate: encoding_1.isAggregate(model.encoding) ? s.op : undefined,
                        field: s.field
                    }) :
                    model.field(dimensionChannel, { binSuffix: 'start' });
                sort = {
                    field: sortField,
                    order: 'descending'
                };
            }
        }
        else {
            return null;
        }
        return new OrderNode(sort);
    };
    OrderNode.prototype.assemble = function () {
        return {
            type: 'collect',
            sort: this.sort
        };
    };
    return OrderNode;
}(dataflow_1.DataFlowNode));
exports.OrderNode = OrderNode;

},{"../../encoding":85,"../../fielddef":87,"../../sort":95,"../../util":102,"../common":20,"./dataflow":26,"tslib":10}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var data_1 = require("../../data");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var SourceNode = (function (_super) {
    tslib_1.__extends(SourceNode, _super);
    function SourceNode(model) {
        var _this = _super.call(this) || this;
        var data = model.data || { name: 'source' };
        if (data_1.isInlineData(data)) {
            _this._data = {
                values: data.values,
                format: { type: 'json' }
            };
        }
        else if (data_1.isUrlData(data)) {
            // Extract extension from URL using snippet from
            // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript
            var defaultExtension = /(?:\.([^.]+))?$/.exec(data.url)[1];
            if (!util_1.contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {
                defaultExtension = 'json';
            }
            var dataFormat = data.format || {};
            // For backward compatibility for former `data.formatType` property
            var formatType = dataFormat.type || data['formatType'];
            var property = dataFormat.property, feature = dataFormat.feature, mesh = dataFormat.mesh;
            var format = tslib_1.__assign({ type: formatType ? formatType : defaultExtension }, (property ? { property: property } : {}), (feature ? { feature: feature } : {}), (mesh ? { mesh: mesh } : {}));
            _this._data = {
                url: data.url,
                format: format
            };
        }
        else if (data_1.isNamedData(data)) {
            _this._name = data.name;
            _this._data = {};
        }
        return _this;
    }
    Object.defineProperty(SourceNode.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    SourceNode.prototype.hasName = function () {
        return !!this._name;
    };
    Object.defineProperty(SourceNode.prototype, "dataName", {
        get: function () {
            return this._name;
        },
        set: function (name) {
            this._name = name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SourceNode.prototype, "parent", {
        set: function (parent) {
            throw new Error('Source nodes have to be roots.');
        },
        enumerable: true,
        configurable: true
    });
    SourceNode.prototype.remove = function () {
        throw new Error('Source nodes are roots and cannot be removed.');
    };
    /**
     * Return a unique identifir for this data source.
     */
    SourceNode.prototype.hash = function () {
        if (data_1.isInlineData(this._data)) {
            return util_1.hash(this._data);
        }
        else if (data_1.isUrlData(this._data)) {
            return this._data.url + " " + util_1.hash(this._data.format);
        }
        else {
            return this._name;
        }
    };
    SourceNode.prototype.assemble = function () {
        return tslib_1.__assign({ name: this._name }, this._data, { transform: [] });
    };
    return SourceNode;
}(dataflow_1.DataFlowNode));
exports.SourceNode = SourceNode;

},{"../../data":83,"../../util":102,"./dataflow":26,"tslib":10}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vega_util_1 = require("vega-util");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var common_1 = require("../common");
var dataflow_1 = require("./dataflow");
function getStackByFields(model) {
    return model.stack.stackBy.reduce(function (fields, by) {
        var channel = by.channel;
        var fieldDef = by.fieldDef;
        var scale = model.scale(channel);
        var _field = fielddef_1.field(fieldDef, {
            binSuffix: scale && scale_1.hasDiscreteDomain(scale.type) ? 'range' : 'start'
        });
        if (_field) {
            fields.push(_field);
        }
        return fields;
    }, []);
}
var StackNode = (function (_super) {
    tslib_1.__extends(StackNode, _super);
    function StackNode(stack) {
        var _this = _super.call(this) || this;
        _this._stack = stack;
        return _this;
    }
    StackNode.prototype.clone = function () {
        return new StackNode(util_1.duplicate(this._stack));
    };
    StackNode.make = function (model) {
        var stackProperties = model.stack;
        if (!stackProperties) {
            return null;
        }
        var groupby = [];
        if (stackProperties.groupbyChannel) {
            var groupbyFieldDef = model.fieldDef(stackProperties.groupbyChannel);
            if (groupbyFieldDef.bin) {
                // For Bin, we need to add both start and end to ensure that both get imputed
                // and included in the stack output (https://github.com/vega/vega-lite/issues/1805).
                groupby.push(model.field(stackProperties.groupbyChannel, { binSuffix: 'start' }));
                groupby.push(model.field(stackProperties.groupbyChannel, { binSuffix: 'end' }));
            }
            else {
                groupby.push(model.field(stackProperties.groupbyChannel));
            }
        }
        var stackby = getStackByFields(model);
        var orderDef = model.encoding.order;
        var sort;
        if (orderDef) {
            sort = common_1.sortParams(orderDef);
        }
        else {
            // default = descending by stackFields
            // FIXME is the default here correct for binned fields?
            sort = stackby.reduce(function (s, field) {
                s.field.push(field);
                s.order.push('descending');
                return s;
            }, { field: [], order: [] });
        }
        return new StackNode({
            groupby: groupby,
            field: model.field(stackProperties.fieldChannel),
            stackby: stackby,
            sort: sort,
            offset: stackProperties.offset,
            impute: util_1.contains(['area', 'line'], model.mark()),
        });
    };
    Object.defineProperty(StackNode.prototype, "stack", {
        get: function () {
            return this._stack;
        },
        enumerable: true,
        configurable: true
    });
    StackNode.prototype.addDimensions = function (fields) {
        this._stack.groupby = this._stack.groupby.concat(fields);
    };
    StackNode.prototype.dependentFields = function () {
        var out = {};
        out[this._stack.field] = true;
        this._stack.groupby.forEach(function (f) { return out[f] = true; });
        var field = this._stack.sort.field;
        vega_util_1.isArray(field) ? field.forEach(function (f) { return out[f] = true; }) : out[field] = true;
        return out;
    };
    StackNode.prototype.producedFields = function () {
        var out = {};
        out[this._stack.field + '_start'] = true;
        out[this._stack.field + '_end'] = true;
        return out;
    };
    StackNode.prototype.assemble = function () {
        var transform = [];
        var stack = this._stack;
        // Impute
        if (stack.impute) {
            transform.push({
                type: 'impute',
                field: stack.field,
                groupby: stack.stackby,
                orderby: stack.groupby,
                method: 'value',
                value: 0
            });
        }
        // Stack
        transform.push({
            type: 'stack',
            groupby: stack.groupby,
            field: stack.field,
            sort: stack.sort,
            as: [
                stack.field + '_start',
                stack.field + '_end'
            ],
            offset: stack.offset
        });
        return transform;
    };
    return StackNode;
}(dataflow_1.DataFlowNode));
exports.StackNode = StackNode;

},{"../../fielddef":87,"../../scale":93,"../../util":102,"../common":20,"./dataflow":26,"tslib":10,"vega-util":106}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fielddef_1 = require("../../fielddef");
var timeunit_1 = require("../../timeunit");
var type_1 = require("../../type");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var TimeUnitNode = (function (_super) {
    tslib_1.__extends(TimeUnitNode, _super);
    function TimeUnitNode(formula) {
        var _this = _super.call(this) || this;
        _this.formula = formula;
        return _this;
    }
    TimeUnitNode.prototype.clone = function () {
        return new TimeUnitNode(util_1.duplicate(this.formula));
    };
    TimeUnitNode.make = function (model) {
        var formula = model.reduceFieldDef(function (timeUnitComponent, fieldDef) {
            if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {
                var f = fielddef_1.field(fieldDef);
                timeUnitComponent[f] = {
                    as: f,
                    timeUnit: fieldDef.timeUnit,
                    field: fieldDef.field
                };
            }
            return timeUnitComponent;
        }, {});
        if (Object.keys(formula).length === 0) {
            return null;
        }
        return new TimeUnitNode(formula);
    };
    TimeUnitNode.prototype.merge = function (other) {
        this.formula = util_1.extend(this.formula, other.formula);
        other.remove();
    };
    TimeUnitNode.prototype.producedFields = function () {
        var out = {};
        util_1.vals(this.formula).forEach(function (f) {
            out[f.as] = true;
        });
        return out;
    };
    TimeUnitNode.prototype.dependentFields = function () {
        var out = {};
        util_1.vals(this.formula).forEach(function (f) {
            out[f.field] = true;
        });
        return out;
    };
    TimeUnitNode.prototype.assemble = function () {
        return util_1.vals(this.formula).map(function (c) {
            return {
                type: 'formula',
                as: c.as,
                expr: timeunit_1.fieldExpr(c.timeUnit, c.field)
            };
        });
    };
    return TimeUnitNode;
}(dataflow_1.DataFlowNode));
exports.TimeUnitNode = TimeUnitNode;

},{"../../fielddef":87,"../../timeunit":98,"../../type":101,"../../util":102,"./dataflow":26,"tslib":10}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var filter_1 = require("../../filter");
var log = require("../../log");
var transform_1 = require("../../transform");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var FilterNode = (function (_super) {
    tslib_1.__extends(FilterNode, _super);
    function FilterNode(model, filter) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.filter = filter;
        return _this;
    }
    FilterNode.prototype.clone = function () {
        return new FilterNode(this.model, util_1.duplicate(this.filter));
    };
    FilterNode.prototype.assemble = function () {
        return {
            type: 'filter',
            expr: filter_1.expression(this.model, this.filter)
        };
    };
    return FilterNode;
}(dataflow_1.DataFlowNode));
exports.FilterNode = FilterNode;
/**
 * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.
 */
var CalculateNode = (function (_super) {
    tslib_1.__extends(CalculateNode, _super);
    function CalculateNode(transform) {
        var _this = _super.call(this) || this;
        _this.transform = transform;
        return _this;
    }
    CalculateNode.prototype.clone = function () {
        return new CalculateNode(util_1.duplicate(this.transform));
    };
    CalculateNode.prototype.producedFields = function () {
        var out = {};
        out[this.transform.as] = true;
        return out;
    };
    CalculateNode.prototype.assemble = function () {
        return {
            type: 'formula',
            expr: this.transform.calculate,
            as: this.transform.as
        };
    };
    return CalculateNode;
}(dataflow_1.DataFlowNode));
exports.CalculateNode = CalculateNode;
/**
 * Parses a transforms array into a chain of connected dataflow nodes.
 */
function parseTransformArray(model) {
    var first;
    var last;
    var node;
    var previous;
    model.transforms.forEach(function (t, i) {
        if (transform_1.isCalculate(t)) {
            node = new CalculateNode(t);
        }
        else if (transform_1.isFilter(t)) {
            node = new FilterNode(model, t.filter);
        }
        else {
            log.warn(log.message.invalidTransformIgnored(t));
            return;
        }
        if (i === 0) {
            first = node;
        }
        else {
            node.parent = previous;
        }
        previous = node;
    });
    last = node;
    return { first: first, last: last };
}
exports.parseTransformArray = parseTransformArray;

},{"../../filter":88,"../../log":90,"../../transform":100,"../../util":102,"./dataflow":26,"tslib":10}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../channel");
var encoding_1 = require("../encoding");
var fielddef_1 = require("../fielddef");
var log = require("../log");
var mark_1 = require("../mark");
var util_1 = require("../util");
var vega_schema_1 = require("../vega.schema");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_1 = require("./data/parse");
var header_1 = require("./layout/header");
var model_1 = require("./model");
var repeat_1 = require("./repeat");
var FacetModel = (function (_super) {
    tslib_1.__extends(FacetModel, _super);
    function FacetModel(spec, parent, parentGivenName, repeater, config) {
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.child = common_1.buildModel(spec.spec, _this, _this.getName('child'), undefined, repeater, config);
        _this.children = [_this.child];
        var facet = repeat_1.replaceRepeaterInFacet(spec.facet, repeater);
        _this.facet = _this.initFacet(facet);
        return _this;
    }
    FacetModel.prototype.initFacet = function (facet) {
        // clone to prevent side effect to the original spec
        return encoding_1.reduce(facet, function (normalizedFacet, fieldDef, channel) {
            if (!util_1.contains([channel_1.ROW, channel_1.COLUMN], channel)) {
                // Drop unsupported channel
                log.warn(log.message.incompatibleChannel(channel, 'facet'));
                return normalizedFacet;
            }
            if (fieldDef.field === undefined) {
                log.warn(log.message.emptyFieldDef(fieldDef, channel));
                return normalizedFacet;
            }
            // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.
            normalizedFacet[channel] = fielddef_1.normalize(fieldDef, channel);
            return normalizedFacet;
        }, {});
    };
    FacetModel.prototype.channelHasField = function (channel) {
        return !!this.facet[channel];
    };
    FacetModel.prototype.hasDiscreteDomain = function (channel) {
        return true;
    };
    FacetModel.prototype.fieldDef = function (channel) {
        return this.facet[channel];
    };
    FacetModel.prototype.parseData = function () {
        this.component.data = parse_1.parseData(this);
        this.child.parseData();
    };
    FacetModel.prototype.parseSelection = function () {
        // As a facet has a single child, the selection components are the same.
        // The child maintains its selections to assemble signals, which remain
        // within its unit.
        this.child.parseSelection();
        this.component.selection = this.child.component.selection;
    };
    FacetModel.prototype.parseScale = function () {
        var _this = this;
        var child = this.child;
        var model = this;
        child.parseScale();
        var scaleComponent = this.component.scales = {};
        // Then, move shared/union from its child spec.
        util_1.keys(child.component.scales).forEach(function (channel) {
            // TODO: correctly implement independent scale
            if (true) {
                var scale = scaleComponent[channel] = child.component.scales[channel];
                var scaleNameWithoutPrefix = scale.name.substr(child.getName('').length);
                var newName = model.scaleName(scaleNameWithoutPrefix, true);
                child.renameScale(scale.name, newName);
                scale.name = newName;
                // Replace the scale domain with data output from a cloned subtree after the facet.
                var domain = scale.domain;
                if (vega_schema_1.isDataRefDomain(domain) || vega_schema_1.isFieldRefUnionDomain(domain)) {
                    domain.data = assemble_1.FACET_SCALE_PREFIX + _this.getName(domain.data);
                }
                else if (vega_schema_1.isDataRefUnionedDomain(domain)) {
                    domain.fields = domain.fields.map(function (f) {
                        return tslib_1.__assign({}, f, { data: assemble_1.FACET_SCALE_PREFIX + _this.getName(f.data) });
                    });
                }
                // Once put in parent, just remove the child's scale.
                delete child.component.scales[channel];
            }
        });
    };
    FacetModel.prototype.parseMark = function () {
        this.child.parseMark();
        this.component.mark = [{
                name: this.getName('cell'),
                type: 'group',
                from: {
                    facet: {
                        name: this.component.data.facetRoot.name,
                        data: this.component.data.facetRoot.data,
                        groupby: [].concat(this.channelHasField(channel_1.ROW) ? [this.field(channel_1.ROW)] : [], this.channelHasField(channel_1.COLUMN) ? [this.field(channel_1.COLUMN)] : [])
                    }
                },
                encode: {
                    update: getFacetGroupProperties(this)
                }
            }];
    };
    FacetModel.prototype.parseAxisAndHeader = function () {
        this.child.parseAxisAndHeader();
        this.parseHeader('column');
        this.parseHeader('row');
        this.mergeChildAxis('x');
        this.mergeChildAxis('y');
    };
    FacetModel.prototype.parseHeader = function (channel) {
        if (this.channelHasField(channel)) {
            var fieldDef = this.facet[channel];
            var header = fieldDef.header || {};
            var title = header.title !== undefined ? header.title : fielddef_1.title(fieldDef, this.config);
            if (this.child.component.layoutHeaders[channel].title) {
                // merge title with child to produce "Title / Subtitle / Sub-subtitle"
                title += ' / ' + this.child.component.layoutHeaders[channel].title;
                this.child.component.layoutHeaders[channel].title = null;
            }
            this.component.layoutHeaders[channel] = {
                title: title,
                fieldRef: common_1.formatSignalRef(fieldDef, header.format, 'parent', this.config, true),
                // TODO: support adding label to footer as well
                header: [this.makeHeaderComponent(channel, true)]
            };
        }
    };
    FacetModel.prototype.makeHeaderComponent = function (channel, labels) {
        var sizeChannel = channel === 'row' ? 'height' : 'width';
        return {
            labels: labels,
            sizeSignal: this.child.getSizeSignalRef(sizeChannel),
            axes: []
        };
    };
    FacetModel.prototype.mergeChildAxis = function (channel) {
        var child = this.child;
        if (child.component.axes[channel]) {
            // TODO: read these from the resolve syntax
            var scaleResolve = 'shared';
            var axisResolve = 'shared';
            if (scaleResolve === 'shared' && axisResolve === 'shared') {
                // For shared axis, move the axes to facet's header or footer
                var headerChannel = channel === 'x' ? 'column' : 'row';
                var layoutHeader = this.component.layoutHeaders[headerChannel];
                for (var _i = 0, _a = child.component.axes[channel].axes; _i < _a.length; _i++) {
                    var axis = _a[_i];
                    var headerType = header_1.getHeaderType(axis.orient);
                    layoutHeader[headerType] = layoutHeader[headerType] ||
                        [this.makeHeaderComponent(headerChannel, false)];
                    layoutHeader[headerType][0].axes.push(axis);
                }
                child.component.axes[channel].axes = [];
            }
            else {
                // Otherwise do nothing for independent axes
            }
        }
    };
    FacetModel.prototype.parseLegend = function () {
        this.child.parseLegend();
        // TODO: support legend for independent non-position scale across facets
        // TODO: support legend for field reference of parent data (e.g., for SPLOM)
        // For now, assuming that non-positional scales are always shared across facets
        // Thus, just move all legends from its child
        this.component.legends = this.child.component.legends;
        this.child.component.legends = {};
    };
    FacetModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    FacetModel.prototype.assembleParentGroupProperties = function () {
        return null;
    };
    FacetModel.prototype.assembleSelectionTopLevelSignals = function (signals) {
        return this.child.assembleSelectionTopLevelSignals(signals);
    };
    FacetModel.prototype.assembleSelectionSignals = function () {
        this.child.assembleSelectionSignals();
        return [];
    };
    FacetModel.prototype.assembleSelectionData = function (data) {
        return this.child.assembleSelectionData(data);
    };
    FacetModel.prototype.assembleLayout = function () {
        var columns = this.channelHasField('column') ? {
            signal: this.columnDistinctSignal()
        } : 1;
        // TODO: determine default align based on shared / independent scales
        return {
            padding: { row: 10, column: 10 },
            // TODO: support offset for rowHeader/rowFooter/rowTitle/columnHeader/columnFooter/columnTitle
            offset: 10,
            columns: columns,
            bounds: 'full'
        };
    };
    FacetModel.prototype.assembleLayoutSignals = function () {
        // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.
        return this.child.assembleLayoutSignals();
    };
    FacetModel.prototype.columnDistinctSignal = function () {
        // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.
        var facetLayoutDataName = this.getName('column') + '_layout';
        var columnDistinct = this.field('column', { prefix: 'distinct' });
        return "data('" + facetLayoutDataName + "')[0][" + util_1.stringValue(columnDistinct) + "]";
    };
    FacetModel.prototype.assembleMarks = function () {
        var facetRoot = this.component.data.facetRoot;
        var data = assemble_1.assembleFacetData(facetRoot);
        var mark = this.component.mark[0];
        // correct the name of the faceted data source
        mark.from.facet = tslib_1.__assign({}, mark.from.facet, { name: facetRoot.name, data: facetRoot.data });
        var marks = [tslib_1.__assign({}, (data.length > 0 ? { data: data } : {}), mark, this.child.assembleGroup())];
        return marks.map(this.correctDataNames);
    };
    FacetModel.prototype.channels = function () {
        return [channel_1.ROW, channel_1.COLUMN];
    };
    FacetModel.prototype.getMapping = function () {
        return this.facet;
    };
    return FacetModel;
}(model_1.ModelWithField));
exports.FacetModel = FacetModel;
// FIXME(https://github.com/vega/vega-lite/issues/2041): revise this.
function getFacetGroupProperties(model) {
    var encodeEntry = model.child.assembleParentGroupProperties();
    return tslib_1.__assign({}, (encodeEntry ? encodeEntry : {}), common_1.applyConfig({}, model.config.facet.cell, mark_1.FILL_STROKE_CONFIG.concat(['clip'])));
}

},{"../channel":16,"../encoding":85,"../fielddef":87,"../log":90,"../mark":91,"../util":102,"../vega.schema":104,"./common":20,"./data/assemble":24,"./data/parse":32,"./layout/header":40,"./model":57,"./repeat":58,"tslib":10}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mark_1 = require("../mark");
var resolve_1 = require("../resolve");
var util_1 = require("../util");
var vega_schema_1 = require("../vega.schema");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_1 = require("./data/parse");
var index_1 = require("./layout/index");
var model_1 = require("./model");
var domain_1 = require("./scale/domain");
var selection_1 = require("./selection/selection");
var LayerModel = (function (_super) {
    tslib_1.__extends(LayerModel, _super);
    function LayerModel(spec, parent, parentGivenName, parentUnitSize, repeater, config) {
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.resolve = resolve_1.initLayerResolve(spec.resolve || {});
        var unitSize = tslib_1.__assign({}, parentUnitSize, (spec.width ? { width: spec.width } : {}), (spec.height ? { height: spec.height } : {}));
        _this.children = spec.layer.map(function (layer, i) {
            // FIXME: this is not always the case
            // we know that the model has to be a unit model because we pass in a unit spec
            return common_1.buildModel(layer, _this, _this.getName('layer_' + i), unitSize, repeater, config);
        });
        return _this;
    }
    LayerModel.prototype.parseData = function () {
        this.component.data = parse_1.parseData(this);
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseData();
        }
    };
    LayerModel.prototype.parseSelection = function () {
        var _this = this;
        // Merge selections up the hierarchy so that they may be referenced
        // across unit specs. Persist their definitions within each child
        // to assemble signals which remain within output Vega unit groups.
        this.component.selection = {};
        var _loop_1 = function (child) {
            child.parseSelection();
            util_1.keys(child.component.selection).forEach(function (key) {
                _this.component.selection[key] = child.component.selection[key];
            });
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_1(child);
        }
    };
    LayerModel.prototype.parseScale = function () {
        var _this = this;
        var model = this;
        var scaleComponent = this.component.scales = {};
        var _loop_2 = function (child) {
            child.parseScale();
            // Check whether the scales are actually compatible, e.g. use the same sort or throw error
            util_1.keys(child.component.scales).forEach(function (channel) {
                if (_this.resolve[channel].scale === 'shared') {
                    var childScale = child.component.scales[channel];
                    var modelScale = scaleComponent[channel];
                    if (!childScale || vega_schema_1.isSignalRefDomain(childScale.domain) || (modelScale && vega_schema_1.isSignalRefDomain(modelScale.domain))) {
                        // TODO: merge signal ref domains
                        return;
                    }
                    if (modelScale) {
                        modelScale.domain = domain_1.unionDomains(modelScale.domain, childScale.domain);
                    }
                    else {
                        scaleComponent[channel] = childScale;
                    }
                    // rename child scale to parent scales
                    var scaleNameWithoutPrefix = childScale.name.substr(child.getName('').length);
                    var newName = model.scaleName(scaleNameWithoutPrefix, true);
                    child.renameScale(childScale.name, newName);
                    childScale.name = newName;
                    // remove merged scales from children
                    delete child.component.scales[channel];
                }
            });
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_2(child);
        }
    };
    LayerModel.prototype.parseMark = function () {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseMark();
        }
    };
    LayerModel.prototype.parseAxisAndHeader = function () {
        var _this = this;
        var axisComponent = this.component.axes = {};
        var _loop_3 = function (child) {
            child.parseAxisAndHeader();
            util_1.keys(child.component.axes).forEach(function (channel) {
                if (_this.resolve[channel].axis === 'shared') {
                    // If shared/union axis
                    // Just use the first axes definition for each channel
                    // TODO: what if the axes from different children are not compatible
                    if (!axisComponent[channel]) {
                        axisComponent[channel] = child.component.axes[channel];
                    }
                }
                else {
                    // If axes are independent
                    // TODO(#2251): correctly merge axis
                    if (!axisComponent[channel]) {
                        // copy the first axis
                        axisComponent[channel] = child.component.axes[channel];
                    }
                    else {
                        // put every odd numbered axis on the right/top
                        axisComponent[channel].axes.push(tslib_1.__assign({}, child.component.axes[channel].axes[0], (axisComponent[channel].axes.length % 2 === 1 ? { orient: channel === 'y' ? 'right' : 'top' } : {})));
                        if (child.component.axes[channel].gridAxes.length > 0) {
                            axisComponent[channel].gridAxes.push(tslib_1.__assign({}, child.component.axes[channel].gridAxes[0]));
                        }
                    }
                }
                // delete child.component.axes[channel];
            });
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_3(child);
        }
    };
    LayerModel.prototype.parseLegend = function () {
        var _this = this;
        var legendComponent = this.component.legends = {};
        var _loop_4 = function (child) {
            child.parseLegend();
            // TODO: correctly implement independent axes
            util_1.keys(child.component.legends).forEach(function (channel) {
                if (_this.resolve[channel].legend === 'shared') {
                    // just use the first legend definition for each channel
                    if (!legendComponent[channel]) {
                        legendComponent[channel] = child.component.legends[channel];
                    }
                }
                else {
                    // TODO: support independent legends
                }
            });
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_4(child);
        }
    };
    LayerModel.prototype.assembleParentGroupProperties = function () {
        return tslib_1.__assign({ width: this.getSizeSignalRef('width'), height: this.getSizeSignalRef('height') }, common_1.applyConfig({}, this.config.cell, mark_1.FILL_STROKE_CONFIG.concat(['clip'])));
    };
    LayerModel.prototype.assembleSelectionTopLevelSignals = function (signals) {
        return this.children.reduce(function (sg, child) { return child.assembleSelectionTopLevelSignals(sg); }, signals);
    };
    // TODO: Support same named selections across children.
    LayerModel.prototype.assembleSelectionSignals = function () {
        return this.children.reduce(function (signals, child) {
            return signals.concat(child.assembleSelectionSignals());
        }, []);
    };
    LayerModel.prototype.assembleLayoutSignals = function () {
        return this.children.reduce(function (signals, child) {
            return signals.concat(child.assembleLayoutSignals());
        }, index_1.assembleLayoutLayerSignals(this));
    };
    LayerModel.prototype.assembleSelectionData = function (data) {
        return this.children.reduce(function (db, child) { return child.assembleSelectionData(db); }, []);
    };
    LayerModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    LayerModel.prototype.assembleScales = function () {
        // combine with scales from children
        return this.children.reduce(function (scales, c) {
            return scales.concat(c.assembleScales());
        }, _super.prototype.assembleScales.call(this));
    };
    LayerModel.prototype.assembleLayout = function () {
        return null;
    };
    LayerModel.prototype.assembleMarks = function () {
        return selection_1.assembleLayerSelectionMarks(this, util_1.flatten(this.children.map(function (child) {
            return child.assembleMarks();
        })));
    };
    return LayerModel;
}(model_1.Model));
exports.LayerModel = LayerModel;

},{"../mark":91,"../resolve":92,"../util":102,"../vega.schema":104,"./common":20,"./data/assemble":24,"./data/parse":32,"./layout/index":41,"./model":57,"./scale/domain":60,"./selection/selection":68,"tslib":10}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
exports.HEADER_CHANNELS = ['row', 'column'];
exports.HEADER_TYPES = ['header', 'footer'];
function getHeaderType(orient) {
    if (orient === 'top' || orient === 'left') {
        return 'header';
    }
    return 'footer';
}
exports.getHeaderType = getHeaderType;
function getTitleGroup(model, channel) {
    var sizeChannel = channel === 'row' ? 'height' : 'width';
    var title = model.component.layoutHeaders[channel].title;
    var positionChannel = channel === 'row' ? 'y' : 'x';
    var align = channel === 'row' ? 'right' : 'center';
    var textOrient = channel === 'row' ? 'vertical' : undefined;
    return {
        name: model.getName(channel + "_title"),
        role: channel + "-title",
        type: 'group',
        marks: [{
                type: 'text',
                role: channel + "-title-text",
                encode: {
                    update: tslib_1.__assign((_a = {}, _a[positionChannel] = { signal: "0.5 * " + sizeChannel }, _a.align = { value: align }, _a.text = { value: title }, _a.fill = { value: 'black' }, _a.fontWeight = { value: 'bold' }, _a), (textOrient === 'vertical' ? { angle: { value: 270 } } : {}))
                }
            }]
    };
    var _a;
}
exports.getTitleGroup = getTitleGroup;
function getHeaderGroup(model, channel, headerType, layoutHeader, header) {
    if (header) {
        var title = null;
        if (layoutHeader.fieldRef && header.labels) {
            title = {
                text: layoutHeader.fieldRef,
                offset: 10,
                orient: channel === 'row' ? 'left' : 'top',
                encode: {
                    update: tslib_1.__assign({ fontWeight: { value: 'normal' }, angle: { value: 0 }, fontSize: { value: 10 } }, (channel === 'row' ? {
                        align: { value: 'right' },
                        baseline: { value: 'middle' }
                    } : {}))
                }
            };
        }
        var axes = header.axes;
        var hasAxes = axes && axes.length > 0;
        if (title || hasAxes) {
            var sizeChannel = channel === 'row' ? 'height' : 'width';
            return tslib_1.__assign({ name: model.getName(channel + "_" + headerType), type: 'group', role: channel + "-" + headerType }, (layoutHeader.fieldRef ? { from: { data: model.getName(channel) } } : {}), (title ? { title: title } : {}), { encode: {
                    update: (_a = {},
                        _a[sizeChannel] = header.sizeSignal,
                        _a)
                } }, (hasAxes ? { axes: axes } : {}));
        }
    }
    return null;
    var _a;
}
exports.getHeaderGroup = getHeaderGroup;

},{"tslib":10}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scale_1 = require("../../scale");
// TODO: rewrite this such that we merge redundant signals
function assembleLayoutLayerSignals(model) {
    return [
        { name: model.getName('width'), update: layerSizeExpr(model, 'width') },
        { name: model.getName('height'), update: layerSizeExpr(model, 'height') }
    ];
}
exports.assembleLayoutLayerSignals = assembleLayoutLayerSignals;
function layerSizeExpr(model, sizeType) {
    var childrenSizeSignals = model.children.map(function (child) { return child.getName(sizeType); }).join(', ');
    return "max(" + childrenSizeSignals + ")";
}
exports.layerSizeExpr = layerSizeExpr;
function assembleLayoutUnitSignals(model) {
    return [
        { name: model.getName('width'), update: unitSizeExpr(model, 'width') },
        { name: model.getName('height'), update: unitSizeExpr(model, 'height') }
    ];
}
exports.assembleLayoutUnitSignals = assembleLayoutUnitSignals;
function unitSizeExpr(model, sizeType) {
    var channel = sizeType === 'width' ? 'x' : 'y';
    var scale = model.scale(channel);
    if (scale) {
        if (scale_1.hasDiscreteDomain(scale.type) && scale.rangeStep) {
            var scaleName = model.scaleName(channel);
            var cardinality = "domain('" + scaleName + "').length";
            var paddingOuter = scale.paddingOuter !== undefined ? scale.paddingOuter : scale.padding;
            var paddingInner = scale.type === 'band' ?
                // only band has real paddingInner
                (scale.paddingInner !== undefined ? scale.paddingInner : scale.padding) :
                // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
                // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
                1;
            return "bandspace(" + cardinality + ", " + paddingInner + ", " + paddingOuter + ") * " + scale.rangeStep;
        }
    }
    return "" + model[sizeType];
}
exports.unitSizeExpr = unitSizeExpr;

},{"../../scale":93}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var mark_1 = require("../../mark");
var type_1 = require("../../type");
var util_1 = require("../../util");
var common_1 = require("../common");
var mixins = require("../mark/mixins");
function symbols(fieldDef, symbolsSpec, model, channel) {
    var symbols = {};
    var mark = model.mark();
    switch (mark) {
        case mark_1.BAR:
        case mark_1.TICK:
        case mark_1.TEXT:
            symbols.shape = { value: 'square' };
            break;
        case mark_1.CIRCLE:
        case mark_1.SQUARE:
            symbols.shape = { value: mark };
            break;
        case mark_1.POINT:
        case mark_1.LINE:
        case mark_1.AREA:
            // use default circle
            break;
    }
    var cfg = model.config;
    var filled = model.markDef.filled;
    var config = channel === channel_1.COLOR ?
        /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the legend's `fill` or `stroke` scale should have precedence */
        util_1.without(mark_1.FILL_STROKE_CONFIG, [filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :
        /* For other legend, no need to omit. */
        mark_1.FILL_STROKE_CONFIG;
    config = util_1.without(config, ['strokeDash', 'strokeDashOffset']);
    common_1.applyMarkConfig(symbols, model, config);
    if (channel !== channel_1.COLOR) {
        var colorMixins = mixins.color(model);
        // If there are field for fill or stroke, remove them as we already apply channels.
        if (colorMixins.fill && fielddef_1.isFieldDef(colorMixins.fill)) {
            delete colorMixins.fill;
        }
        if (colorMixins.stroke && fielddef_1.isFieldDef(colorMixins.stroke)) {
            delete colorMixins.stroke;
        }
        util_1.extend(symbols, colorMixins);
    }
    if (channel !== channel_1.SHAPE) {
        var shapeDef = model.encoding.shape;
        if (fielddef_1.isValueDef(shapeDef)) {
            symbols.shape = { value: shapeDef.value };
        }
    }
    symbols = util_1.extend(symbols, symbolsSpec || {});
    return util_1.keys(symbols).length > 0 ? symbols : undefined;
}
exports.symbols = symbols;
function labels(fieldDef, labelsSpec, model, channel) {
    var legend = model.legend(channel);
    var config = model.config;
    var labels = {};
    if (fieldDef.type === type_1.TEMPORAL) {
        labelsSpec = util_1.extend({
            text: {
                signal: common_1.timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat)
            }
        }, labelsSpec || {});
    }
    labels = util_1.extend(labels, labelsSpec || {});
    return util_1.keys(labels).length > 0 ? labels : undefined;
}
exports.labels = labels;

},{"../../channel":16,"../../fielddef":87,"../../mark":91,"../../type":101,"../../util":102,"../common":20,"../mark/mixins":50}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var legend_1 = require("../../legend");
var util_1 = require("../../util");
var common_1 = require("../common");
var encode = require("./encode");
var rules = require("./rules");
function parseLegendComponent(model) {
    return [channel_1.COLOR, channel_1.SIZE, channel_1.SHAPE, channel_1.OPACITY].reduce(function (legendComponent, channel) {
        if (model.legend(channel)) {
            legendComponent[channel] = parseLegend(model, channel);
        }
        return legendComponent;
    }, {});
}
exports.parseLegendComponent = parseLegendComponent;
function getLegendDefWithScale(model, channel) {
    // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels
    switch (channel) {
        case channel_1.COLOR:
            var scale = model.scaleName(channel_1.COLOR);
            return model.markDef.filled ? { fill: scale } : { stroke: scale };
        case channel_1.SIZE:
            return { size: model.scaleName(channel_1.SIZE) };
        case channel_1.SHAPE:
            return { shape: model.scaleName(channel_1.SHAPE) };
        case channel_1.OPACITY:
            return { opacity: model.scaleName(channel_1.OPACITY) };
    }
    return null;
}
function parseLegend(model, channel) {
    var fieldDef = model.fieldDef(channel);
    var legend = model.legend(channel);
    var def = getLegendDefWithScale(model, channel);
    legend_1.LEGEND_PROPERTIES.forEach(function (property) {
        var value = getSpecifiedOrDefaultValue(property, legend, channel, model);
        if (value !== undefined) {
            def[property] = value;
        }
    });
    // 2) Add mark property definition groups
    var encodeSpec = legend.encode || {};
    ['labels', 'legend', 'title', 'symbols'].forEach(function (part) {
        var value = encode[part] ?
            encode[part](fieldDef, encodeSpec[part], model, channel) :
            encodeSpec[part]; // no rule -- just default values
        if (value !== undefined && util_1.keys(value).length > 0) {
            def.encode = def.encode || {};
            def.encode[part] = { update: value };
        }
    });
    return def;
}
exports.parseLegend = parseLegend;
function getSpecifiedOrDefaultValue(property, specifiedLegend, channel, model) {
    var fieldDef = model.fieldDef(channel);
    switch (property) {
        case 'format':
            return common_1.numberFormat(fieldDef, specifiedLegend.format, model.config, channel);
        case 'title':
            return rules.title(specifiedLegend, fieldDef, model.config);
        case 'values':
            return rules.values(specifiedLegend);
        case 'type':
            return rules.type(specifiedLegend, fieldDef.type, channel, model.scale(channel).type);
    }
    // Otherwise, return specified property.
    return specifiedLegend[property];
}

},{"../../channel":16,"../../legend":89,"../../util":102,"../common":20,"./encode":42,"./rules":44}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var datetime_1 = require("../../datetime");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
function title(legend, fieldDef, config) {
    if (legend.title !== undefined) {
        return legend.title;
    }
    return fielddef_1.title(fieldDef, config);
}
exports.title = title;
function values(legend) {
    var vals = legend.values;
    if (vals && datetime_1.isDateTime(vals[0])) {
        return vals.map(function (dt) {
            // normalize = true as end user won't put 0 = January
            return datetime_1.timestamp(dt, true);
        });
    }
    return vals;
}
exports.values = values;
function type(legend, type, channel, scaleType) {
    if (legend.type) {
        return legend.type;
    }
    if (channel === channel_1.COLOR && ((type === 'quantitative' && !scale_1.isBinScale(scaleType)) || (type === 'temporal' && util_1.contains(['time', 'utc'], scaleType)))) {
        return 'gradient';
    }
    return undefined;
}
exports.type = type;

},{"../../channel":16,"../../datetime":84,"../../fielddef":87,"../../scale":93,"../../util":102}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
exports.area = {
    vgMark: 'area',
    defaultRole: undefined,
    encodeEntry: function (model) {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMin'), mixins.pointPosition('y', model, 'zeroOrMin'), mixins.pointPosition2(model, 'zeroOrMin'), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('opacity', model), mixins.markDefProperties(model.markDef, ['orient', 'interpolate', 'tension']));
    }
};

},{"./mixins":50,"tslib":10}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var scale_1 = require("../../scale");
var mixins = require("./mixins");
var ref = require("./valueref");
exports.bar = {
    vgMark: 'rect',
    defaultRole: 'bar',
    encodeEntry: function (model) {
        var stack = model.stack;
        return tslib_1.__assign({}, x(model, stack), y(model, stack), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('opacity', model));
    }
};
function x(model, stack) {
    var config = model.config, width = model.width;
    var orient = model.markDef.orient;
    var sizeDef = model.encoding.size;
    var xDef = model.encoding.x;
    var xScaleName = model.scaleName(channel_1.X);
    var xScale = model.scale(channel_1.X);
    // x, x2, and width -- we must specify two of these in all conditions
    if (orient === 'horizontal') {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMin'), mixins.pointPosition2(model, 'zeroOrMin'));
    }
    else {
        if (fielddef_1.isFieldDef(xDef)) {
            if (!sizeDef && scale_1.isBinScale(xScale.type)) {
                return mixins.binnedPosition('x', model, config.bar.binSpacing);
            }
            else if (xScale.type === scale_1.ScaleType.BAND) {
                return mixins.bandPosition('x', model);
            }
        }
        // sized bin, normal point-ordinal axis, quantitative x-axis, or no x
        return mixins.centeredBandPosition('x', model, tslib_1.__assign({}, ref.midX(width, config)), defaultSizeRef(xScaleName, model.scale(channel_1.X), config));
    }
}
function y(model, stack) {
    var config = model.config, encoding = model.encoding, height = model.height;
    var orient = model.markDef.orient;
    var sizeDef = encoding.size;
    var yDef = encoding.y;
    var yScaleName = model.scaleName(channel_1.Y);
    var yScale = model.scale(channel_1.Y);
    // y, y2 & height -- we must specify two of these in all conditions
    if (orient === 'vertical') {
        return tslib_1.__assign({}, mixins.pointPosition('y', model, 'zeroOrMin'), mixins.pointPosition2(model, 'zeroOrMin'));
    }
    else {
        if (fielddef_1.isFieldDef(yDef)) {
            if (yDef.bin && !sizeDef) {
                return mixins.binnedPosition('y', model, config.bar.binSpacing);
            }
            else if (yScale.type === scale_1.ScaleType.BAND) {
                return mixins.bandPosition('y', model);
            }
        }
        return mixins.centeredBandPosition('y', model, ref.midY(height, config), defaultSizeRef(yScaleName, model.scale(channel_1.Y), config));
    }
}
function defaultSizeRef(scaleName, scale, config) {
    if (config.bar.discreteBandSize) {
        return { value: config.bar.discreteBandSize };
    }
    if (scale) {
        if (scale.type === scale_1.ScaleType.POINT) {
            if (scale.rangeStep !== null) {
                return { value: scale.rangeStep - 1 };
            }
            log.warn(log.message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL);
        }
        else if (scale.type === scale_1.ScaleType.BAND) {
            return ref.band(scaleName);
        }
        else {
            return { value: config.bar.continuousBandSize };
        }
    }
    if (config.scale.rangeStep && config.scale.rangeStep !== null) {
        return { value: config.scale.rangeStep - 1 };
    }
    // TODO: this should depends on cell's width / height?
    return { value: 20 };
}

},{"../../channel":16,"../../fielddef":87,"../../log":90,"../../scale":93,"./mixins":50,"./valueref":56,"tslib":10}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var encoding_1 = require("../../encoding");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var mark_1 = require("../../mark");
var scale_1 = require("../../scale");
var type_1 = require("../../type");
var util_1 = require("../../util");
var common_1 = require("../common");
function initMarkDef(mark, encoding, scale, config) {
    var markDef = mark_1.isMarkDef(mark) ? tslib_1.__assign({}, mark) : { type: mark };
    var specifiedOrient = markDef.orient || common_1.getMarkConfig('orient', markDef.type, config);
    markDef.orient = orient(markDef.type, encoding, scale, specifiedOrient);
    if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {
        log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));
    }
    var specifiedFilled = markDef.filled;
    if (specifiedFilled === undefined) {
        markDef.filled = filled(markDef.type, config);
    }
    return markDef;
}
exports.initMarkDef = initMarkDef;
/**
 * Initialize encoding's value with some special default values
 */
function initEncoding(mark, encoding, stacked, config) {
    var opacityConfig = common_1.getMarkConfig('opacity', mark, config);
    if (!encoding.opacity && opacityConfig === undefined) {
        var opacity = defaultOpacity(mark, encoding, stacked);
        if (opacity !== undefined) {
            encoding.opacity = { value: opacity };
        }
    }
    return encoding;
}
exports.initEncoding = initEncoding;
function defaultOpacity(mark, encoding, stacked) {
    if (util_1.contains([mark_1.POINT, mark_1.TICK, mark_1.CIRCLE, mark_1.SQUARE], mark)) {
        // point-based marks
        if (!encoding_1.isAggregate(encoding)) {
            return 0.7;
        }
    }
    return undefined;
}
function filled(mark, config) {
    var filledConfig = common_1.getMarkConfig('filled', mark, config);
    return filledConfig !== undefined ? filledConfig : mark !== mark_1.POINT && mark !== mark_1.LINE && mark !== mark_1.RULE;
}
function orient(mark, encoding, scale, specifiedOrient) {
    switch (mark) {
        case mark_1.POINT:
        case mark_1.CIRCLE:
        case mark_1.SQUARE:
        case mark_1.TEXT:
        case mark_1.RECT:
            // orient is meaningless for these marks.
            return undefined;
    }
    var yIsRange = encoding.y && encoding.y2;
    var xIsRange = encoding.x && encoding.x2;
    switch (mark) {
        case mark_1.TICK:
            var xScaleType = scale['x'] ? scale['x'].type : null;
            var yScaleType = scale['y'] ? scale['y'].type : null;
            // Tick is opposite to bar, line, area and never have ranged mark.
            if (!scale_1.hasDiscreteDomain(xScaleType) && (!encoding.y ||
                scale_1.hasDiscreteDomain(yScaleType) ||
                (fielddef_1.isFieldDef(encoding.y) && encoding.y.bin))) {
                return 'vertical';
            }
            // y:Q or Ambiguous case, return horizontal
            return 'horizontal';
        case mark_1.RULE:
        case mark_1.BAR:
        case mark_1.AREA:
            // If there are range for both x and y, y (vertical) has higher precedence.
            if (yIsRange) {
                return 'vertical';
            }
            else if (xIsRange) {
                return 'horizontal';
            }
            else if (mark === mark_1.RULE) {
                if (encoding.x && !encoding.y) {
                    return 'vertical';
                }
                else if (encoding.y && !encoding.x) {
                    return 'horizontal';
                }
            }
        /* tslint:disable */
        case mark_1.LINE:
            /* tslint:enable */
            var xIsContinuous = fielddef_1.isFieldDef(encoding.x) && fielddef_1.isContinuous(encoding.x);
            var yIsContinuous = fielddef_1.isFieldDef(encoding.y) && fielddef_1.isContinuous(encoding.y);
            if (xIsContinuous && !yIsContinuous) {
                return 'horizontal';
            }
            else if (!xIsContinuous && yIsContinuous) {
                return 'vertical';
            }
            else if (xIsContinuous && yIsContinuous) {
                var xDef = encoding.x; // we can cast here since they are surely fieldDef
                var yDef = encoding.y;
                var xIsTemporal = xDef.type === type_1.TEMPORAL;
                var yIsTemporal = yDef.type === type_1.TEMPORAL;
                // temporal without timeUnit is considered continuous, but better serves as dimension
                if (xIsTemporal && !yIsTemporal) {
                    return 'vertical';
                }
                else if (!xIsTemporal && yIsTemporal) {
                    return 'horizontal';
                }
                if (!xDef.aggregate && yDef.aggregate) {
                    return 'vertical';
                }
                else if (xDef.aggregate && !yDef.aggregate) {
                    return 'horizontal';
                }
                if (specifiedOrient) {
                    // When ambiguous, use user specified one.
                    return specifiedOrient;
                }
                if (!(mark === mark_1.LINE && encoding.order)) {
                    // Except for connected scatterplot, we should log warning for unclear orientation of QxQ plots.
                    log.warn(log.message.unclearOrientContinuous(mark));
                }
                return 'vertical';
            }
            else {
                // For Discrete x Discrete case, return undefined.
                log.warn(log.message.unclearOrientDiscreteOrEmpty(mark));
                return undefined;
            }
    }
    return 'vertical';
}

},{"../../encoding":85,"../../fielddef":87,"../../log":90,"../../mark":91,"../../scale":93,"../../type":101,"../../util":102,"../common":20,"tslib":10}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
exports.line = {
    vgMark: 'line',
    defaultRole: undefined,
    encodeEntry: function (model) {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMin'), mixins.pointPosition('y', model, 'zeroOrMin'), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('opacity', model), mixins.nonPosition('size', model, {
            vgChannel: 'strokeWidth' // VL's line size is strokeWidth
        }), mixins.markDefProperties(model.markDef, ['interpolate', 'tension']));
    }
};

},{"./mixins":50,"tslib":10}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var mark_1 = require("../../mark");
var util_1 = require("../../util");
var area_1 = require("./area");
var bar_1 = require("./bar");
var line_1 = require("./line");
var point_1 = require("./point");
var rect_1 = require("./rect");
var rule_1 = require("./rule");
var text_1 = require("./text");
var tick_1 = require("./tick");
var data_1 = require("../../data");
var channel_2 = require("../../channel");
var scale_1 = require("../../scale");
var markCompiler = {
    area: area_1.area,
    bar: bar_1.bar,
    line: line_1.line,
    point: point_1.point,
    text: text_1.text,
    tick: tick_1.tick,
    rect: rect_1.rect,
    rule: rule_1.rule,
    circle: point_1.circle,
    square: point_1.square
};
function parseMark(model) {
    if (util_1.contains([mark_1.LINE, mark_1.AREA], model.mark())) {
        return parsePathMark(model);
    }
    else {
        return parseNonPathMark(model);
    }
}
exports.parseMark = parseMark;
var FACETED_PATH_PREFIX = 'faceted_path_';
function parsePathMark(model) {
    var mark = model.mark();
    // FIXME: replace this with more general case for composition
    var details = detailFields(model);
    var pathMarks = [
        tslib_1.__assign({ name: model.getName('marks'), type: markCompiler[mark].vgMark }, (clip(model)), { 
            // If has subfacet for line/area group, need to use faceted data from below.
            // FIXME: support sorting path order (in connected scatterplot)
            from: { data: (details.length > 0 ? FACETED_PATH_PREFIX : '') + model.requestDataName(data_1.MAIN) }, encode: { update: markCompiler[mark].encodeEntry(model) } })
    ];
    if (details.length > 0) {
        // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)
        return [{
                name: model.getName('pathgroup'),
                type: 'group',
                from: {
                    facet: {
                        name: FACETED_PATH_PREFIX + model.requestDataName(data_1.MAIN),
                        data: model.requestDataName(data_1.MAIN),
                        groupby: details,
                    }
                },
                encode: {
                    update: {
                        width: { field: { group: 'width' } },
                        height: { field: { group: 'height' } }
                    }
                },
                marks: pathMarks
            }];
    }
    else {
        return pathMarks;
    }
}
function parseNonPathMark(model) {
    var mark = model.mark();
    var role = model.markDef.role || markCompiler[mark].defaultRole;
    var marks = []; // TODO: vgMarks
    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)
    marks.push(tslib_1.__assign({ name: model.getName('marks'), type: markCompiler[mark].vgMark }, (clip(model)), (role ? { role: role } : {}), { from: { data: model.requestDataName(data_1.MAIN) }, encode: { update: markCompiler[mark].encodeEntry(model) } }));
    return marks;
}
/**
 * Returns list of detail (group-by) fields
 * that the model's spec contains.
 */
function detailFields(model) {
    return channel_1.LEVEL_OF_DETAIL_CHANNELS.reduce(function (details, channel) {
        if (model.channelHasField(channel) && !model.fieldDef(channel).aggregate) {
            details.push(model.field(channel));
        }
        return details;
    }, []);
}
function clip(model) {
    var xscale = model.scale(channel_2.X), yscale = model.scale(channel_2.Y);
    return (xscale && scale_1.isSelectionDomain(xscale.domain)) ||
        (yscale && scale_1.isSelectionDomain(yscale.domain)) ? { clip: true } : {};
}

},{"../../channel":16,"../../data":83,"../../mark":91,"../../scale":93,"../../util":102,"./area":45,"./bar":46,"./line":48,"./point":51,"./rect":52,"./rule":53,"./text":54,"./tick":55,"tslib":10}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util = require("../../util");
var common_1 = require("../common");
var ref = require("./valueref");
var selection_1 = require("../selection/selection");
function color(model) {
    var config = model.config;
    var filled = model.markDef.filled;
    var e = nonPosition('color', model, {
        vgChannel: filled ? 'fill' : 'stroke',
        defaultValue: common_1.getMarkConfig('color', model.mark(), config)
    });
    // If there is no fill, always fill symbols
    // with transparent fills https://github.com/vega/vega-lite/issues/1316
    if (!e.fill && util.contains(['bar', 'point', 'circle', 'square'], model.mark())) {
        e.fill = { value: 'transparent' };
    }
    return e;
}
exports.color = color;
function markDefProperties(mark, props) {
    return props.reduce(function (m, prop) {
        if (mark[prop]) {
            m[prop] = { value: mark[prop] };
        }
        return m;
    }, {});
}
exports.markDefProperties = markDefProperties;
function valueIfDefined(prop, value) {
    if (value !== undefined) {
        return _a = {}, _a[prop] = { value: value }, _a;
    }
    return undefined;
    var _a;
}
exports.valueIfDefined = valueIfDefined;
/**
 * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)
 */
function nonPosition(channel, model, opt) {
    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613
    if (opt === void 0) { opt = {}; }
    var defaultValue = opt.defaultValue, vgChannel = opt.vgChannel;
    var defaultRef = opt.defaultRef || (defaultValue !== undefined ? { value: defaultValue } : undefined);
    var channelDef = model.encoding[channel];
    var valueRef = ref.midPoint(channel, channelDef, model.scaleName(channel), model.scale(channel), defaultRef);
    return wrapCondition(model, channelDef && channelDef.condition, vgChannel || channel, valueRef);
}
exports.nonPosition = nonPosition;
/**
 * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.
 * or a simple mixin if channel def has no condition.
 */
function wrapCondition(model, condition, vgChannel, valueRef) {
    if (condition) {
        var selection = condition.selection, value = condition.value;
        return _a = {},
            _a[vgChannel] = [
                { test: selectionTest(model, selection), value: value }
            ].concat((valueRef !== undefined ? [valueRef] : [])),
            _a;
    }
    else {
        return valueRef !== undefined ? (_b = {}, _b[vgChannel] = valueRef, _b) : {};
    }
    var _a, _b;
}
function selectionTest(model, selectionName) {
    var negate = selectionName.charAt(0) === '!', name = negate ? selectionName.slice(1) : selectionName, selection = model.getComponent('selection', name);
    return (negate ? '!' : '') +
        selection_1.predicate(selection.name, selection.type, selection.resolve);
}
function text(model, vgChannel) {
    if (vgChannel === void 0) { vgChannel = 'text'; }
    var channelDef = model.encoding[vgChannel];
    var valueRef = (vgChannel === 'tooltip' && !channelDef) ? undefined : ref.text(channelDef, model.config);
    return wrapCondition(model, channelDef && channelDef.condition, vgChannel, valueRef);
}
exports.text = text;
function bandPosition(channel, model) {
    // TODO: band scale doesn't support size yet
    var fieldDef = model.encoding[channel];
    var scaleName = model.scaleName(channel);
    var sizeChannel = channel === 'x' ? 'width' : 'height';
    return _a = {},
        _a[channel] = ref.fieldRef(fieldDef, scaleName, {}),
        _a[sizeChannel] = ref.band(scaleName),
        _a;
    var _a;
}
exports.bandPosition = bandPosition;
function centeredBandPosition(channel, model, defaultPosRef, defaultSizeRef) {
    var centerChannel = channel === 'x' ? 'xc' : 'yc';
    var sizeChannel = channel === 'x' ? 'width' : 'height';
    return tslib_1.__assign({}, pointPosition(channel, model, defaultPosRef, centerChannel), nonPosition('size', model, { defaultRef: defaultSizeRef, vgChannel: sizeChannel }));
}
exports.centeredBandPosition = centeredBandPosition;
function binnedPosition(channel, model, spacing) {
    var fieldDef = model.encoding[channel];
    var scaleName = model.scaleName(channel);
    if (channel === 'x') {
        return {
            x2: ref.bin(fieldDef, scaleName, 'start', spacing),
            x: ref.bin(fieldDef, scaleName, 'end')
        };
    }
    else {
        return {
            y2: ref.bin(fieldDef, scaleName, 'start'),
            y: ref.bin(fieldDef, scaleName, 'end', spacing)
        };
    }
}
exports.binnedPosition = binnedPosition;
/**
 * Return mixins for point (non-band) position channels.
 */
function pointPosition(channel, model, defaultRef, vgChannel) {
    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613
    var encoding = model.encoding, stack = model.stack;
    var valueRef = ref.stackable(channel, encoding[channel], model.scaleName(channel), model.scale(channel), stack, defaultRef);
    return _a = {},
        _a[vgChannel || channel] = valueRef,
        _a;
    var _a;
}
exports.pointPosition = pointPosition;
/**
 * Return mixins for x2, y2.
 * If channel is not specified, return one channel based on orientation.
 */
function pointPosition2(model, defaultRef, channel) {
    var encoding = model.encoding, markDef = model.markDef, stack = model.stack;
    channel = channel || (markDef.orient === 'horizontal' ? 'x2' : 'y2');
    var baseChannel = channel === 'x2' ? 'x' : 'y';
    var valueRef = ref.stackable2(channel, encoding[baseChannel], encoding[channel], model.scaleName(baseChannel), model.scale(baseChannel), stack, defaultRef);
    return _a = {}, _a[channel] = valueRef, _a;
    var _a;
}
exports.pointPosition2 = pointPosition2;

},{"../../util":102,"../common":20,"../selection/selection":68,"./valueref":56,"tslib":10}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
var common_1 = require("../common");
var ref = require("./valueref");
function encodeEntry(model, fixedShape) {
    var config = model.config, width = model.width, height = model.height;
    return tslib_1.__assign({}, mixins.pointPosition('x', model, ref.midX(width, config)), mixins.pointPosition('y', model, ref.midY(height, config)), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('size', model), shapeMixins(model, config, fixedShape), mixins.nonPosition('opacity', model));
}
function shapeMixins(model, config, fixedShape) {
    if (fixedShape) {
        return { shape: { value: fixedShape } };
    }
    return mixins.nonPosition('shape', model, { defaultValue: common_1.getMarkConfig('shape', 'point', config) });
}
exports.shapeMixins = shapeMixins;
exports.point = {
    vgMark: 'symbol',
    defaultRole: 'point',
    encodeEntry: function (model) {
        return encodeEntry(model);
    }
};
exports.circle = {
    vgMark: 'symbol',
    defaultRole: 'circle',
    encodeEntry: function (model) {
        return encodeEntry(model, 'circle');
    }
};
exports.square = {
    vgMark: 'symbol',
    defaultRole: 'square',
    encodeEntry: function (model) {
        return encodeEntry(model, 'square');
    }
};

},{"../common":20,"./mixins":50,"./valueref":56,"tslib":10}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var mark_1 = require("../../mark");
var scale_1 = require("../../scale");
var mixins = require("./mixins");
exports.rect = {
    vgMark: 'rect',
    defaultRole: undefined,
    encodeEntry: function (model) {
        return tslib_1.__assign({}, x(model), y(model), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('opacity', model));
    }
};
function x(model) {
    var xDef = model.encoding.x;
    var x2Def = model.encoding.x2;
    var xScale = model.scale(channel_1.X);
    if (fielddef_1.isFieldDef(xDef) && xDef.bin && !x2Def) {
        return mixins.binnedPosition('x', model, 0);
    }
    else if (xScale && scale_1.hasDiscreteDomain(xScale.type)) {
        /* istanbul ignore else */
        if (xScale.type === scale_1.ScaleType.BAND) {
            return mixins.bandPosition('x', model);
        }
        else {
            // We don't support rect mark with point/ordinal scale
            throw new Error(log.message.scaleTypeNotWorkWithMark(mark_1.RECT, xScale.type));
        }
    }
    else {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMax'), mixins.pointPosition2(model, 'zeroOrMin', 'x2'));
    }
}
function y(model) {
    var yDef = model.encoding.y;
    var y2Def = model.encoding.y2;
    var yScale = model.scale(channel_1.Y);
    if (fielddef_1.isFieldDef(yDef) && yDef.bin && !y2Def) {
        return mixins.binnedPosition('y', model, 0);
    }
    else if (yScale && scale_1.hasDiscreteDomain(yScale.type)) {
        /* istanbul ignore else */
        if (yScale.type === scale_1.ScaleType.BAND) {
            return mixins.bandPosition('y', model);
        }
        else {
            // We don't support rect mark with point/ordinal scale
            throw new Error(log.message.scaleTypeNotWorkWithMark(mark_1.RECT, yScale.type));
        }
    }
    else {
        return tslib_1.__assign({}, mixins.pointPosition('y', model, 'zeroOrMax'), mixins.pointPosition2(model, 'zeroOrMin', 'y2'));
    }
}

},{"../../channel":16,"../../fielddef":87,"../../log":90,"../../mark":91,"../../scale":93,"./mixins":50,"tslib":10}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
var ref = require("./valueref");
exports.rule = {
    vgMark: 'rule',
    defaultRole: undefined,
    encodeEntry: function (model) {
        var config = model.config, markDef = model.markDef, width = model.width, height = model.height;
        var orient = markDef.orient;
        return tslib_1.__assign({}, mixins.pointPosition('x', model, orient === 'horizontal' ? 'zeroOrMin' : ref.midX(width, config)), mixins.pointPosition('y', model, orient === 'vertical' ? 'zeroOrMin' : ref.midY(height, config)), mixins.pointPosition2(model, 'zeroOrMax'), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('opacity', model), mixins.nonPosition('size', model, {
            vgChannel: 'strokeWidth' // VL's rule size is strokeWidth
        }));
    }
};

},{"./mixins":50,"./valueref":56,"tslib":10}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var common_1 = require("../common");
var fielddef_1 = require("../../fielddef");
var type_1 = require("../../type");
var mixins = require("./mixins");
var encoding_1 = require("../../encoding");
var ref = require("./valueref");
exports.text = {
    vgMark: 'text',
    defaultRole: undefined,
    encodeEntry: function (model) {
        var config = model.config, encoding = model.encoding, height = model.height;
        var textDef = encoding.text;
        return tslib_1.__assign({}, mixins.pointPosition('x', model, xDefault(config, textDef)), mixins.pointPosition('y', model, ref.midY(height, config)), mixins.text(model), mixins.color(model), mixins.text(model, 'tooltip'), mixins.nonPosition('opacity', model), mixins.nonPosition('size', model, {
            vgChannel: 'fontSize' // VL's text size is fontSize
        }), mixins.valueIfDefined('align', align(encoding, config)));
    }
};
function xDefault(config, textDef) {
    if (fielddef_1.isFieldDef(textDef) && textDef.type === type_1.QUANTITATIVE) {
        return { field: { group: 'width' }, offset: -5 };
    }
    // TODO: allow this to fit (Be consistent with ref.midX())
    return { value: config.scale.textXRangeStep / 2 };
}
function align(encoding, config) {
    var alignConfig = common_1.getMarkConfig('align', 'text', config);
    if (alignConfig === undefined) {
        return encoding_1.channelHasField(encoding, channel_1.X) ? 'center' : 'right';
    }
    // If there is a config, Vega-parser will process this already.
    return undefined;
}

},{"../../channel":16,"../../encoding":85,"../../fielddef":87,"../../type":101,"../common":20,"./mixins":50,"./valueref":56,"tslib":10}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
var ref = require("./valueref");
exports.tick = {
    vgMark: 'rect',
    defaultRole: 'tick',
    encodeEntry: function (model) {
        var config = model.config, markDef = model.markDef, width = model.width, height = model.height;
        var orient = markDef.orient;
        var vgSizeChannel = orient === 'horizontal' ? 'width' : 'height';
        var vgThicknessChannel = orient === 'horizontal' ? 'height' : 'width';
        return tslib_1.__assign({}, mixins.pointPosition('x', model, ref.midX(width, config), 'xc'), mixins.pointPosition('y', model, ref.midY(height, config), 'yc'), mixins.nonPosition('size', model, {
            defaultValue: defaultSize(model),
            vgChannel: vgSizeChannel
        }), (_a = {}, _a[vgThicknessChannel] = { value: config.tick.thickness }, _a), mixins.color(model), mixins.nonPosition('opacity', model));
        var _a;
    }
};
function defaultSize(model) {
    var config = model.config;
    var orient = model.markDef.orient;
    var scaleRangeStep = (model.scale(orient === 'horizontal' ? 'x' : 'y') || {}).rangeStep;
    if (config.tick.bandSize !== undefined) {
        return config.tick.bandSize;
    }
    else {
        var rangeStep = scaleRangeStep !== undefined ?
            scaleRangeStep :
            config.scale.rangeStep;
        if (typeof rangeStep !== 'number') {
            // FIXME consolidate this log
            throw new Error('Function does not handle non-numeric rangeStep');
        }
        return rangeStep / 1.5;
    }
}

},{"./mixins":50,"./valueref":56,"tslib":10}],56:[function(require,module,exports){
"use strict";
/**
 * Utility files for producing Vega ValueRef for marks
 */
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var common_1 = require("../common");
// TODO: we need to find a way to refactor these so that scaleName is a part of scale
// but that's complicated.  For now, this is a huge step moving forward.
/**
 * @return Vega ValueRef for stackable x or y
 */
function stackable(channel, channelDef, scaleName, scale, stack, defaultRef) {
    if (channelDef && stack && channel === stack.fieldChannel) {
        // x or y use stack_end so that stacked line's point mark use stack_end too.
        return fieldRef(channelDef, scaleName, { suffix: 'end' });
    }
    return midPoint(channel, channelDef, scaleName, scale, defaultRef);
}
exports.stackable = stackable;
/**
 * @return Vega ValueRef for stackable x2 or y2
 */
function stackable2(channel, aFieldDef, a2fieldDef, scaleName, scale, stack, defaultRef) {
    if (aFieldDef && stack &&
        // If fieldChannel is X and channel is X2 (or Y and Y2)
        channel.charAt(0) === stack.fieldChannel.charAt(0)) {
        return fieldRef(aFieldDef, scaleName, { suffix: 'start' });
    }
    return midPoint(channel, a2fieldDef, scaleName, scale, defaultRef);
}
exports.stackable2 = stackable2;
/**
 * Value Ref for binned fields
 */
function bin(fieldDef, scaleName, side, offset) {
    return fieldRef(fieldDef, scaleName, { binSuffix: side }, offset);
}
exports.bin = bin;
function fieldRef(fieldDef, scaleName, opt, offset) {
    var ref = {
        scale: scaleName,
        field: fielddef_1.field(fieldDef, opt),
    };
    if (offset) {
        ref.offset = offset;
    }
    return ref;
}
exports.fieldRef = fieldRef;
function band(scaleName, band) {
    if (band === void 0) { band = true; }
    return {
        scale: scaleName,
        band: band
    };
}
exports.band = band;
/**
 * Signal that returns the middle of a bin. Should only be used with x and y.
 */
function binMidSignal(fieldDef, scaleName) {
    return {
        signal: "(" +
            ("scale(\"" + scaleName + "\", " + fielddef_1.field(fieldDef, { binSuffix: 'start', expr: 'datum' }) + ")") +
            " + " +
            ("scale(\"" + scaleName + "\", " + fielddef_1.field(fieldDef, { binSuffix: 'end', expr: 'datum' }) + ")") +
            ")/2"
    };
}
/**
 * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.
 */
function midPoint(channel, channelDef, scaleName, scale, defaultRef) {
    // TODO: datum support
    if (channelDef) {
        /* istanbul ignore else */
        if (fielddef_1.isFieldDef(channelDef)) {
            if (scale_1.isBinScale(scale.type)) {
                // Use middle only for x an y to place marks in the center between start and end of the bin range.
                // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.
                if (util_1.contains(['x', 'y'], channel)) {
                    return binMidSignal(channelDef, scaleName);
                }
                return fieldRef(channelDef, scaleName, { binSuffix: 'start' });
            }
            if (scale_1.hasDiscreteDomain(scale.type)) {
                if (scale.type === 'band') {
                    // For band, to get mid point, need to offset by half of the band
                    return fieldRef(channelDef, scaleName, { binSuffix: 'range' }, band(scaleName, 0.5));
                }
                return fieldRef(channelDef, scaleName, { binSuffix: 'range' });
            }
            else {
                return fieldRef(channelDef, scaleName, {}); // no need for bin suffix
            }
        }
        else if (channelDef.value !== undefined) {
            return { value: channelDef.value };
        }
        else {
            throw new Error('FieldDef without field or value.'); // FIXME add this to log.message
        }
    }
    if (defaultRef === 'zeroOrMin') {
        /* istanbul ignore else */
        if (channel === channel_1.X || channel === channel_1.X2) {
            return zeroOrMinX(scaleName, scale);
        }
        else if (channel === channel_1.Y || channel === channel_1.Y2) {
            return zeroOrMinY(scaleName, scale);
        }
        else {
            throw new Error("Unsupported channel " + channel + " for base function"); // FIXME add this to log.message
        }
    }
    else if (defaultRef === 'zeroOrMax') {
        /* istanbul ignore else */
        if (channel === channel_1.X || channel === channel_1.X2) {
            return zeroOrMaxX(scaleName, scale);
        }
        else if (channel === channel_1.Y || channel === channel_1.Y2) {
            return zeroOrMaxY(scaleName, scale);
        }
        else {
            throw new Error("Unsupported channel " + channel + " for base function"); // FIXME add this to log.message
        }
    }
    return defaultRef;
}
exports.midPoint = midPoint;
function text(textDef, config) {
    // text
    if (textDef) {
        if (fielddef_1.isFieldDef(textDef)) {
            return common_1.formatSignalRef(textDef, textDef.format, 'datum', config);
        }
        else if (textDef.value) {
            return { value: textDef.value };
        }
    }
    return { value: config.text.text };
}
exports.text = text;
function midX(width, config) {
    if (width) {
        return { value: width / 2 };
    }
    if (typeof config.scale.rangeStep === 'string') {
        // TODO: For fit-mode, use middle of the width
        throw new Error('midX can not handle string rangeSteps');
    }
    return { value: config.scale.rangeStep / 2 };
}
exports.midX = midX;
function midY(height, config) {
    if (height) {
        return { value: height / 2 };
    }
    if (typeof config.scale.rangeStep === 'string') {
        // TODO: For fit-mode, use middle of the width
        throw new Error('midX can not handle string rangeSteps');
    }
    return { value: config.scale.rangeStep / 2 };
}
exports.midY = midY;
function zeroOrMinX(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    // Put the mark on the x-axis
    return { value: 0 };
}
/**
 * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist
 */
function zeroOrMaxX(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    return { field: { group: 'width' } };
}
function zeroOrMinY(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    // Put the mark on the y-axis
    return { field: { group: 'height' } };
}
/**
 * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist
 */
function zeroOrMaxY(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    // Put the mark on the y-axis
    return { value: 0 };
}

},{"../../channel":16,"../../fielddef":87,"../../scale":93,"../../util":102,"../common":20}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../channel");
var encoding_1 = require("../encoding");
var fielddef_1 = require("../fielddef");
var util_1 = require("../util");
var header_1 = require("./layout/header");
var assemble_1 = require("./scale/assemble");
var unit_1 = require("./unit");
var NameMap = (function () {
    function NameMap() {
        this.nameMap = {};
    }
    NameMap.prototype.rename = function (oldName, newName) {
        this.nameMap[oldName] = newName;
    };
    NameMap.prototype.has = function (name) {
        return this.nameMap[name] !== undefined;
    };
    NameMap.prototype.get = function (name) {
        // If the name appears in the _nameMap, we need to read its new name.
        // We have to loop over the dict just in case the new name also gets renamed.
        while (this.nameMap[name]) {
            name = this.nameMap[name];
        }
        return name;
    };
    return NameMap;
}());
exports.NameMap = NameMap;
var Model = (function () {
    function Model(spec, parent, parentGivenName, config) {
        var _this = this;
        this.children = [];
        /**
         * Corrects the data references in marks after assemble.
         */
        this.correctDataNames = function (mark) {
            // TODO: make this correct
            // for normal data references
            if (mark.from && mark.from.data) {
                mark.from.data = _this.lookupDataSource(mark.from.data);
            }
            // for access to facet data
            if (mark.from && mark.from.facet && mark.from.facet.data) {
                mark.from.facet.data = _this.lookupDataSource(mark.from.facet.data);
            }
            return mark;
        };
        this.parent = parent;
        this.config = config;
        // If name is not provided, always use parent's givenName to avoid name conflicts.
        this.name = spec.name || parentGivenName;
        // Shared name maps
        this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
        this.sizeNameMap = parent ? parent.sizeNameMap : new NameMap();
        this.data = spec.data;
        this.description = spec.description;
        this.transforms = spec.transform || [];
        this.component = {
            data: {
                sources: parent ? parent.component.data.sources : {},
                outputNodes: parent ? parent.component.data.outputNodes : {}
            },
            mark: null, scales: null, axes: { x: null, y: null },
            layoutHeaders: { row: {}, column: {} }, legends: null, selection: null
        };
    }
    Model.prototype.parse = function () {
        this.parseData();
        this.parseScale(); // depends on data name
        this.parseSelection();
        this.parseAxisAndHeader(); // depends on scale name
        this.parseLegend(); // depends on scale name
        this.parseMark(); // depends on data name and scale name, axisGroup, and children's scale, axis, legend and mark.
    };
    Model.prototype.assembleScales = function () {
        return assemble_1.assembleScale(this);
    };
    Model.prototype.assembleHeaderMarks = function () {
        var layoutHeaders = this.component.layoutHeaders;
        var headerMarks = [];
        for (var _i = 0, HEADER_CHANNELS_1 = header_1.HEADER_CHANNELS; _i < HEADER_CHANNELS_1.length; _i++) {
            var channel = HEADER_CHANNELS_1[_i];
            if (layoutHeaders[channel].title) {
                headerMarks.push(header_1.getTitleGroup(this, channel));
            }
        }
        for (var _a = 0, HEADER_CHANNELS_2 = header_1.HEADER_CHANNELS; _a < HEADER_CHANNELS_2.length; _a++) {
            var channel = HEADER_CHANNELS_2[_a];
            var layoutHeader = layoutHeaders[channel];
            for (var _b = 0, HEADER_TYPES_1 = header_1.HEADER_TYPES; _b < HEADER_TYPES_1.length; _b++) {
                var headerType = HEADER_TYPES_1[_b];
                if (layoutHeader[headerType]) {
                    for (var _c = 0, _d = layoutHeader[headerType]; _c < _d.length; _c++) {
                        var header = _d[_c];
                        var headerGroup = header_1.getHeaderGroup(this, channel, headerType, layoutHeader, header);
                        if (headerGroup) {
                            headerMarks.push(headerGroup);
                        }
                    }
                }
            }
        }
        return headerMarks;
    };
    Model.prototype.assembleAxes = function () {
        var _a = this.component.axes, x = _a.x, y = _a.y;
        return (x ? x.axes.concat(x.gridAxes) : []).concat((y ? y.axes.concat(y.gridAxes) : []));
    };
    Model.prototype.assembleLegends = function () {
        return util_1.vals(this.component.legends);
    };
    Model.prototype.assembleGroup = function (signals) {
        if (signals === void 0) { signals = []; }
        var group = {};
        signals = signals.concat(this.assembleSelectionSignals());
        if (signals.length > 0) {
            group.signals = signals;
        }
        var layout = this.assembleLayout();
        if (layout) {
            group.layout = layout;
        }
        group.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
        var scales = this.assembleScales();
        if (scales.length > 0) {
            group.scales = scales;
        }
        var axes = this.assembleAxes();
        if (axes.length > 0) {
            group.axes = axes;
        }
        var legends = this.assembleLegends();
        if (legends.length > 0) {
            group.legends = legends;
        }
        return group;
    };
    Model.prototype.hasDescendantWithFieldOnChannel = function (channel) {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child instanceof unit_1.UnitModel) {
                if (child.channelHasField(channel)) {
                    return true;
                }
            }
            else {
                if (child.hasDescendantWithFieldOnChannel(channel)) {
                    return true;
                }
            }
        }
        return false;
    };
    Model.prototype.getName = function (text) {
        return util_1.varName((this.name ? this.name + '_' : '') + text);
    };
    /**
     * Request a data source name for the given data source type and mark that data source as required. This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
     */
    Model.prototype.requestDataName = function (name) {
        var fullName = this.getName(name);
        return this.lookupDataSource(fullName);
    };
    Model.prototype.getSizeSignalRef = function (sizeType) {
        // TODO: this could change in the future once we have sizeSignal merging
        return {
            signal: this.getName(sizeType)
        };
    };
    /**
     * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
     */
    Model.prototype.lookupDataSource = function (name) {
        var node = this.component.data.outputNodes[name];
        if (!node) {
            // name not found in map so let's just return what we got
            return name;
        }
        return node.source;
    };
    Model.prototype.renameSize = function (oldName, newName) {
        this.sizeNameMap.rename(oldName, newName);
    };
    Model.prototype.channelSizeName = function (channel) {
        return this.sizeName(channel === channel_1.X || channel === channel_1.COLUMN ? 'width' : 'height');
    };
    Model.prototype.sizeName = function (size) {
        return this.sizeNameMap.get(this.getName(size));
    };
    Model.prototype.renameScale = function (oldName, newName) {
        this.scaleNameMap.rename(oldName, newName);
    };
    // FIXME: remove this, but currently the scaleName() method below depends on this.
    Model.prototype.scale = function (channel) {
        return null;
    };
    /**
     * @return scale name for a given channel after the scale has been parsed and named.
     */
    Model.prototype.scaleName = function (originalScaleName, parse) {
        if (parse) {
            // During the parse phase always return a value
            // No need to refer to rename map because a scale can't be renamed
            // before it has the original name.
            return this.getName(originalScaleName);
        }
        // If there is a scale for the channel, it should either
        // be in the _scale mapping or exist in the name map
        if (
        // in the scale map (the scale is not merged by its parent)
        (this.scale && channel_1.isChannel(originalScaleName) && this.scale(originalScaleName)) ||
            // in the scale name map (the the scale get merged by its parent)
            this.scaleNameMap.has(this.getName(originalScaleName))) {
            return this.scaleNameMap.get(this.getName(originalScaleName));
        }
        return undefined;
    };
    /**
     * Traverse a model's hierarchy to get the specified component.
     * @param type Scales or Selection
     * @param name Name of the component
     */
    Model.prototype.getComponent = function (type, name) {
        return this.component[type][name] || this.parent.getComponent(type, name);
    };
    return Model;
}());
exports.Model = Model;
/** Abstract class for UnitModel and FacetModel.  Both of which can contain fieldDefs as a part of its own specification. */
var ModelWithField = (function (_super) {
    tslib_1.__extends(ModelWithField, _super);
    function ModelWithField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** Get "field" reference for vega */
    ModelWithField.prototype.field = function (channel, opt) {
        if (opt === void 0) { opt = {}; }
        var fieldDef = this.fieldDef(channel);
        if (fieldDef.bin) {
            opt = util_1.extend({
                binSuffix: this.hasDiscreteDomain(channel) ? 'range' : 'start'
            }, opt);
        }
        return fielddef_1.field(fieldDef, opt);
    };
    ModelWithField.prototype.reduceFieldDef = function (f, init, t) {
        return encoding_1.reduce(this.getMapping(), function (acc, cd, c) {
            return fielddef_1.isFieldDef(cd) ? f(acc, cd, c) : acc;
        }, init, t);
    };
    ModelWithField.prototype.forEachFieldDef = function (f, t) {
        encoding_1.forEach(this.getMapping(), function (cd, c) {
            if (fielddef_1.isFieldDef(cd)) {
                f(cd, c);
            }
        }, t);
    };
    return ModelWithField;
}(Model));
exports.ModelWithField = ModelWithField;

},{"../channel":16,"../encoding":85,"../fielddef":87,"../util":102,"./layout/header":40,"./scale/assemble":59,"./unit":78,"tslib":10}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vega_util_1 = require("vega-util");
var channel_1 = require("../channel");
var fielddef_1 = require("../fielddef");
var log = require("../log");
var util_1 = require("../util");
var vega_schema_1 = require("../vega.schema");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_1 = require("./data/parse");
var model_1 = require("./model");
var domain_1 = require("./scale/domain");
function replaceRepeaterInFacet(facet, repeater) {
    return replaceRepeater(facet, repeater);
}
exports.replaceRepeaterInFacet = replaceRepeaterInFacet;
function replaceRepeaterInEncoding(encoding, repeater) {
    return replaceRepeater(encoding, repeater);
}
exports.replaceRepeaterInEncoding = replaceRepeaterInEncoding;
/**
 * Replace repeater values in a field def with the concrete field name.
 */
function replaceRepeaterInFieldDef(fieldDef, repeater) {
    var field = fieldDef.field;
    if (fielddef_1.isRepeatRef(field)) {
        if (field.repeat in repeater) {
            return tslib_1.__assign({}, fieldDef, { field: repeater[field.repeat] });
        }
        else {
            log.warn(log.message.noSuchRepeatedValue(field.repeat));
            return null;
        }
    }
    else {
        // field is not a repeat ref so we can just return the field def
        return fieldDef;
    }
}
function replaceRepeater(mapping, repeater) {
    var out = {};
    for (var channel in mapping) {
        if (mapping.hasOwnProperty(channel)) {
            var fieldDef = mapping[channel];
            if (vega_util_1.isArray(fieldDef)) {
                out[channel] = fieldDef.map(function (fd) { return replaceRepeaterInFieldDef(fd, repeater); })
                    .filter(function (fd) { return fd !== null; });
            }
            else {
                var fd = replaceRepeaterInFieldDef(fieldDef, repeater);
                if (fd !== null) {
                    out[channel] = fd;
                }
            }
        }
    }
    return out;
}
var RepeatModel = (function (_super) {
    tslib_1.__extends(RepeatModel, _super);
    function RepeatModel(spec, parent, parentGivenName, repeatValues, config) {
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.repeat = spec.repeat;
        _this.children = _this._initChildren(spec, _this.repeat, repeatValues, config);
        return _this;
    }
    RepeatModel.prototype._initChildren = function (spec, repeat, repeater, config) {
        var children = [];
        var row = repeat.row || [repeater ? repeater.row : null];
        var column = repeat.column || [repeater ? repeater.column : null];
        // cross product
        for (var _i = 0, row_1 = row; _i < row_1.length; _i++) {
            var rowField = row_1[_i];
            for (var _a = 0, column_1 = column; _a < column_1.length; _a++) {
                var columnField = column_1[_a];
                var name_1 = (rowField ? '_' + rowField : '') + (columnField ? '_' + columnField : '');
                var childRepeat = {
                    row: rowField,
                    column: columnField
                };
                children.push(common_1.buildModel(spec.spec, this, this.getName('child' + name_1), undefined, childRepeat, config));
            }
        }
        return children;
    };
    RepeatModel.prototype.parseData = function () {
        this.component.data = parse_1.parseData(this);
        this.children.forEach(function (child) {
            child.parseData();
        });
    };
    RepeatModel.prototype.parseSelection = function () {
        var _this = this;
        // Merge selections up the hierarchy so that they may be referenced
        // across unit specs. Persist their definitions within each child
        // to assemble signals which remain within output Vega unit groups.
        this.component.selection = {};
        var _loop_1 = function (child) {
            child.parseSelection();
            util_1.keys(child.component.selection).forEach(function (key) {
                _this.component.selection[key] = child.component.selection[key];
            });
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_1(child);
        }
    };
    RepeatModel.prototype.parseScale = function () {
        var model = this;
        var scaleComponent = this.component.scales = {};
        this.children.forEach(function (child) {
            child.parseScale();
            // FIXME(#1602): correctly implement independent scale
            // Also need to check whether the scales are actually compatible, e.g. use the same sort or throw error
            if (true) {
                util_1.keys(child.component.scales).forEach(function (channel) {
                    if (util_1.contains(channel_1.NONSPATIAL_SCALE_CHANNELS, channel)) {
                        var childScale = child.component.scales[channel];
                        var modelScale = scaleComponent[channel];
                        if (!childScale || vega_schema_1.isSignalRefDomain(childScale.domain) || (modelScale && vega_schema_1.isSignalRefDomain(modelScale.domain))) {
                            // TODO: merge signal ref domains
                            return;
                        }
                        if (modelScale) {
                            modelScale.domain = domain_1.unionDomains(modelScale.domain, childScale.domain);
                        }
                        else {
                            scaleComponent[channel] = childScale;
                        }
                        // rename child scale to parent scales
                        var scaleNameWithoutPrefix = childScale.name.substr(child.getName('').length);
                        var newName = model.scaleName(scaleNameWithoutPrefix, true);
                        child.renameScale(childScale.name, newName);
                        childScale.name = newName;
                        // remove merged scales from children
                        delete child.component.scales[channel];
                    }
                });
            }
        });
    };
    RepeatModel.prototype.parseMark = function () {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseMark();
        }
    };
    RepeatModel.prototype.parseAxisAndHeader = function () {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.parseAxisAndHeader();
        }
    };
    RepeatModel.prototype.parseAxisGroup = function () {
        return null;
    };
    RepeatModel.prototype.parseLegend = function () {
        var legendComponent = this.component.legends = {};
        var _loop_2 = function (child) {
            child.parseLegend();
            // TODO: correctly implement independent legends
            if (true) {
                util_1.keys(child.component.legends).forEach(function (channel) {
                    // just use the first legend definition for each channel
                    if (!legendComponent[channel]) {
                        legendComponent[channel] = child.component.legends[channel];
                    }
                    delete child.component.legends[channel];
                });
            }
        };
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            _loop_2(child);
        }
    };
    RepeatModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    RepeatModel.prototype.assembleParentGroupProperties = function () {
        return null;
    };
    RepeatModel.prototype.assembleSelectionTopLevelSignals = function (signals) {
        return this.children.reduce(function (sg, child) { return child.assembleSelectionTopLevelSignals(sg); }, signals);
    };
    RepeatModel.prototype.assembleSelectionSignals = function () {
        this.children.forEach(function (child) { return child.assembleSelectionSignals(); });
        return [];
    };
    RepeatModel.prototype.assembleLayoutSignals = function () {
        return this.children.reduce(function (signals, child) {
            return signals.concat(child.assembleLayoutSignals());
        }, []);
    };
    RepeatModel.prototype.assembleSelectionData = function (data) {
        return this.children.reduce(function (db, child) { return child.assembleSelectionData(db); }, []);
    };
    RepeatModel.prototype.assembleScales = function () {
        // combine with scales from children
        return this.children.reduce(function (scales, c) {
            return scales.concat(c.assembleScales());
        }, _super.prototype.assembleScales.call(this));
    };
    RepeatModel.prototype.assembleLayout = function () {
        // TODO: allow customization
        return {
            padding: { row: 10, column: 10 },
            offset: 10,
            columns: this.repeat && this.repeat.column ? this.repeat.column.length : 1,
            bounds: 'full',
            align: 'all'
        };
    };
    RepeatModel.prototype.assembleMarks = function () {
        // only children have marks
        return this.children.map(function (child) {
            var encodeEntry = child.assembleParentGroupProperties();
            return tslib_1.__assign({ type: 'group', name: child.getName('group') }, (encodeEntry ? {
                encode: {
                    update: encodeEntry
                }
            } : {}), child.assembleGroup());
        });
    };
    return RepeatModel;
}(model_1.Model));
exports.RepeatModel = RepeatModel;

},{"../channel":16,"../fielddef":87,"../log":90,"../util":102,"../vega.schema":104,"./common":20,"./data/assemble":24,"./data/parse":32,"./model":57,"./scale/domain":60,"tslib":10,"vega-util":106}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vega_util_1 = require("vega-util");
var log = require("../../log");
var util_1 = require("../../util");
var vega_schema_1 = require("../../vega.schema");
var SELECTION_OPS = {
    global: 'union', independent: 'intersect',
    union: 'union', union_others: 'union',
    intersect: 'intersect', intersect_others: 'intersect'
};
function assembleScale(model) {
    return util_1.vals(model.component.scales).map(function (scale) {
        // As selections are parsed _after_ scales, we can only shim in a domainRaw
        // in the output Vega during assembly. FIXME: This should be moved to
        // selection.ts, but any reference to it throws an error. Possible circular dependency?
        var raw = scale.domainRaw;
        if (raw && raw.selection) {
            raw.field = raw.field || null;
            raw.encoding = raw.encoding || null;
            var selName = raw.selection;
            var selCmpt = model.component.selection && model.component.selection[selName];
            if (selCmpt) {
                log.warn('Use "bind": "scales" to setup a binding for scales and selections within the same view.');
            }
            else {
                selCmpt = model.getComponent('selection', selName);
                scale.domainRaw = {
                    signal: (selCmpt.type === 'interval' ? 'vlIntervalDomain' : 'vlPointDomain') +
                        ("(" + util_1.stringValue(selCmpt.name + '_store') + ", " + util_1.stringValue(raw.encoding) + ", " + util_1.stringValue(raw.field) + ", ") +
                        (util_1.stringValue(SELECTION_OPS[selCmpt.resolve]) + ")")
                };
            }
        }
        // correct references to data
        var domain = scale.domain;
        if (vega_schema_1.isDataRefDomain(domain) || vega_schema_1.isFieldRefUnionDomain(domain)) {
            domain.data = model.lookupDataSource(domain.data);
            return scale;
        }
        else if (vega_schema_1.isDataRefUnionedDomain(domain)) {
            domain.fields = domain.fields.map(function (f) {
                return tslib_1.__assign({}, f, { data: model.lookupDataSource(f.data) });
            });
            return scale;
        }
        else if (vega_schema_1.isSignalRefDomain(domain) || vega_util_1.isArray(domain)) {
            return scale;
        }
        else {
            throw new Error('invalid scale domain');
        }
    });
}
exports.assembleScale = assembleScale;

},{"../../log":90,"../../util":102,"../../vega.schema":104,"tslib":10,"vega-util":106}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var aggregate_1 = require("../../aggregate");
var bin_1 = require("../../bin");
var datetime_1 = require("../../datetime");
var scale_1 = require("../../scale");
var sort_1 = require("../../sort");
var util = require("../../util");
var vega_schema_1 = require("../../vega.schema");
var data_1 = require("../../data");
function initDomain(domain, fieldDef, scale, scaleConfig) {
    if (domain === 'unaggregated') {
        var _a = canUseUnaggregatedDomain(fieldDef, scale), valid = _a.valid, reason = _a.reason;
        if (!valid) {
            log.warn(reason);
            return undefined;
        }
    }
    else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {
        // Apply config if domain is not specified.
        var valid = canUseUnaggregatedDomain(fieldDef, scale).valid;
        if (valid) {
            return 'unaggregated';
        }
    }
    return domain;
}
exports.initDomain = initDomain;
function parseDomain(model, channel) {
    var scale = model.scale(channel);
    // If channel is either X or Y then union them with X2 & Y2 if they exist
    if (channel === 'x' && model.channelHasField('x2')) {
        if (model.channelHasField('x')) {
            return unionDomains(parseSingleChannelDomain(scale, model, 'x'), parseSingleChannelDomain(scale, model, 'x2'));
        }
        else {
            return parseSingleChannelDomain(scale, model, 'x2');
        }
    }
    else if (channel === 'y' && model.channelHasField('y2')) {
        if (model.channelHasField('y')) {
            return unionDomains(parseSingleChannelDomain(scale, model, 'y'), parseSingleChannelDomain(scale, model, 'y2'));
        }
        else {
            return parseSingleChannelDomain(scale, model, 'y2');
        }
    }
    return parseSingleChannelDomain(scale, model, channel);
}
exports.parseDomain = parseDomain;
function parseSingleChannelDomain(scale, model, channel) {
    var fieldDef = model.fieldDef(channel);
    if (scale.domain && scale.domain !== 'unaggregated' && !scale_1.isSelectionDomain(scale.domain)) {
        if (datetime_1.isDateTime(scale.domain[0])) {
            return scale.domain.map(function (dt) {
                return datetime_1.timestamp(dt, true);
            });
        }
        return scale.domain;
    }
    var stack = model.stack;
    if (stack && channel === stack.fieldChannel) {
        if (stack.offset === 'normalize') {
            return [0, 1];
        }
        return {
            data: model.requestDataName(data_1.MAIN),
            fields: [
                model.field(channel, { suffix: 'start' }),
                model.field(channel, { suffix: 'end' })
            ]
        };
    }
    var sort = domainSort(model, channel, scale.type);
    if (scale.domain === 'unaggregated') {
        return {
            data: model.requestDataName(data_1.MAIN),
            fields: [
                model.field(channel, { aggregate: 'min' }),
                model.field(channel, { aggregate: 'max' })
            ]
        };
    }
    else if (fieldDef.bin) {
        if (scale_1.isBinScale(scale.type)) {
            var signal = model.getName(bin_1.binToString(fieldDef.bin) + "_" + fieldDef.field + "_bins");
            return { signal: "sequence(" + signal + ".start, " + signal + ".stop + " + signal + ".step, " + signal + ".step)" };
        }
        if (scale_1.hasDiscreteDomain(scale.type)) {
            // ordinal bin scale takes domain from bin_range, ordered by bin_start
            // This is useful for both axis-based scale (x, y, column, and row) and legend-based scale (other channels).
            return {
                data: model.requestDataName(data_1.MAIN),
                field: model.field(channel, { binSuffix: 'range' }),
                sort: {
                    field: model.field(channel, { binSuffix: 'start' }),
                    op: 'min' // min or max doesn't matter since same _range would have the same _start
                }
            };
        }
        else {
            if (channel === 'x' || channel === 'y') {
                // X/Y position have to include start and end for non-ordinal scale
                return {
                    data: model.requestDataName(data_1.MAIN),
                    fields: [
                        model.field(channel, { binSuffix: 'start' }),
                        model.field(channel, { binSuffix: 'end' })
                    ]
                };
            }
            else {
                // TODO: use bin_mid
                return {
                    data: model.requestDataName(data_1.MAIN),
                    field: model.field(channel, { binSuffix: 'start' })
                };
            }
        }
    }
    else if (sort) {
        return {
            // If sort by aggregation of a specified sort field, we need to use RAW table,
            // so we can aggregate values for the scale independently from the main aggregation.
            data: util.isBoolean(sort) ? model.requestDataName(data_1.MAIN) : model.requestDataName(data_1.RAW),
            field: model.field(channel),
            sort: sort
        };
    }
    else {
        return {
            data: model.requestDataName(data_1.MAIN),
            field: model.field(channel)
        };
    }
}
function domainSort(model, channel, scaleType) {
    if (!scale_1.hasDiscreteDomain(scaleType)) {
        return undefined;
    }
    var sort = model.sort(channel);
    // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)
    if (sort_1.isSortField(sort)) {
        return {
            op: sort.op,
            field: sort.field
        };
    }
    if (util.contains(['ascending', 'descending', undefined /* default =ascending*/], sort)) {
        return true;
    }
    // sort === 'none'
    return undefined;
}
exports.domainSort = domainSort;
/**
 * Determine if a scale can use unaggregated domain.
 * @return {Boolean} Returns true if all of the following conditons applies:
 * 1. `scale.domain` is `unaggregated`
 * 2. Aggregation function is not `count` or `sum`
 * 3. The scale is quantitative or time scale.
 */
function canUseUnaggregatedDomain(fieldDef, scaleType) {
    if (!fieldDef.aggregate) {
        return {
            valid: false,
            reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)
        };
    }
    if (!aggregate_1.SHARED_DOMAIN_OP_INDEX[fieldDef.aggregate]) {
        return {
            valid: false,
            reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)
        };
    }
    if (fieldDef.type === 'quantitative') {
        if (scaleType === 'log') {
            return {
                valid: false,
                reason: log.message.unaggregatedDomainWithLogScale(fieldDef)
            };
        }
    }
    return { valid: true };
}
exports.canUseUnaggregatedDomain = canUseUnaggregatedDomain;
/**
 * Convert the domain to an array of data refs or an array of values. Also, throw
 * away sorting information since we always sort the domain when we union two domains.
 */
function normalizeDomain(domain) {
    if (util.isArray(domain)) {
        return [domain];
    }
    else if (vega_schema_1.isDataRefDomain(domain)) {
        delete domain.sort;
        return [domain];
    }
    else if (vega_schema_1.isFieldRefUnionDomain(domain)) {
        return domain.fields.map(function (d) {
            return {
                data: domain.data,
                field: d
            };
        });
    }
    else if (vega_schema_1.isDataRefUnionedDomain(domain)) {
        return domain.fields.map(function (d) {
            if (util.isArray(d)) {
                return d;
            }
            return {
                data: d.data,
                field: d.field
            };
        });
    }
    /* istanbul ignore next: This should never happen. */
    throw new Error(log.message.INVAID_DOMAIN);
}
/**
 * Union two data domains. A unioned domain is always sorted.
 */
function unionDomains(domain1, domain2) {
    if (vega_schema_1.isSignalRefDomain(domain1) || vega_schema_1.isSignalRefDomain(domain2)) {
        if (!vega_schema_1.isSignalRefDomain(domain1) || !vega_schema_1.isSignalRefDomain(domain2) || domain1.signal !== domain2.signal) {
            throw new Error(log.message.UNABLE_TO_MERGE_DOMAINS);
        }
        return domain1;
    }
    var normalizedDomain1 = normalizeDomain(domain1);
    var normalizedDomain2 = normalizeDomain(domain2);
    var domains = normalizedDomain1.concat(normalizedDomain2);
    domains = util.unique(domains, util.hash);
    if (domains.length > 1) {
        var allData = domains.map(function (d) {
            if (vega_schema_1.isDataRefDomain(d)) {
                return d.data;
            }
            return null;
        });
        if (util.unique(allData, function (x) { return x; }).length === 1 && allData[0] !== null) {
            return {
                data: allData[0],
                fields: domains.map(function (d) { return d.field; })
            };
        }
        return { fields: domains, sort: true };
    }
    else {
        return domains[0];
    }
}
exports.unionDomains = unionDomains;

},{"../../aggregate":13,"../../bin":15,"../../data":83,"../../datetime":84,"../../log":90,"../../scale":93,"../../sort":95,"../../util":102,"../../vega.schema":104}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var scale_1 = require("../../scale");
var util = require("../../util");
var domain_1 = require("./domain");
var range_1 = require("./range");
var rules = require("./rules");
var type_1 = require("./type");
/**
 * All scale properties except type and all range properties.
 */
exports.NON_TYPE_RANGE_SCALE_PROPERTIES = [
    // general properties
    'domain',
    'round',
    // quantitative / time
    'clamp', 'nice',
    // quantitative
    'exponent', 'zero',
    'interpolate',
    // ordinal
    'padding', 'paddingInner', 'paddingOuter' // padding
];
/**
 * Initialize Vega-Lite Scale's properties
 *
 * Note that we have to apply these rules here because:
 * - many other scale and non-scale properties (including layout, mark) depend on scale type
 * - layout depends on padding
 * - range depends on zero and size (width and height) depends on range
 */
function init(channel, fieldDef, config, mark, topLevelSize, xyRangeSteps) {
    var specifiedScale = (fieldDef || {}).scale || {};
    var scale = {
        type: type_1.default(specifiedScale.type, channel, fieldDef, mark, topLevelSize !== undefined, specifiedScale.rangeStep, config.scale)
    };
    // Use specified value if compatible or determine default values for each property
    exports.NON_TYPE_RANGE_SCALE_PROPERTIES.forEach(function (property) {
        var specifiedValue = specifiedScale[property];
        var supportedByScaleType = scale_1.scaleTypeSupportProperty(scale.type, property);
        var channelIncompatability = scale_1.channelScalePropertyIncompatability(channel, property);
        if (specifiedValue !== undefined) {
            // If there is a specified value, check if it is compatible with scale type and channel
            if (!supportedByScaleType) {
                log.warn(log.message.scalePropertyNotWorkWithScaleType(scale.type, property, channel));
            }
            else if (channelIncompatability) {
                log.warn(channelIncompatability);
            }
        }
        if (supportedByScaleType && channelIncompatability === undefined) {
            var value = getValue(specifiedValue, property, scale, channel, fieldDef, config.scale);
            if (value !== undefined) {
                scale[property] = value;
            }
        }
    });
    return util.extend(scale, range_1.default(channel, scale.type, fieldDef.type, specifiedScale, config, scale.zero, mark, topLevelSize, xyRangeSteps));
}
exports.default = init;
function getValue(specifiedValue, property, scale, channel, fieldDef, scaleConfig) {
    // For domain, we might override specified value
    if (property === 'domain') {
        return domain_1.initDomain(specifiedValue, fieldDef, scale.type, scaleConfig);
    }
    // Other properties, no overriding default values
    if (specifiedValue !== undefined) {
        return specifiedValue;
    }
    return getDefaultValue(property, scale, channel, fieldDef, scaleConfig);
}
function getDefaultValue(property, scale, channel, fieldDef, scaleConfig) {
    // If we have default rule-base, determine default value first
    switch (property) {
        case 'nice':
            return rules.nice(scale.type, channel, fieldDef);
        case 'padding':
            return rules.padding(channel, scale.type, scaleConfig);
        case 'paddingInner':
            return rules.paddingInner(scale.padding, channel, scaleConfig);
        case 'paddingOuter':
            return rules.paddingOuter(scale.padding, channel, scale.type, scale.paddingInner, scaleConfig);
        case 'round':
            return rules.round(channel, scaleConfig);
        case 'zero':
            return rules.zero(scale, channel, fieldDef);
    }
    // Otherwise, use scale config
    return scaleConfig[property];
}

},{"../../log":90,"../../scale":93,"../../util":102,"./domain":60,"./range":63,"./rules":64,"./type":65}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scale_1 = require("../../scale");
var sort_1 = require("../../sort");
var domain_1 = require("./domain");
var range_1 = require("./range");
/**
 * Parse scales for all channels of a model.
 */
function parseScaleComponent(model) {
    // TODO: should model.channels() inlcude X2/Y2?
    return model.channels().reduce(function (scaleComponentsIndex, channel) {
        var scaleComponents = parseScale(model, channel);
        if (scaleComponents) {
            scaleComponentsIndex[channel] = scaleComponents;
        }
        return scaleComponentsIndex;
    }, {});
}
exports.default = parseScaleComponent;
exports.NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = [
    'round',
    // quantitative / time
    'clamp', 'nice',
    // quantitative
    'exponent', 'interpolate', 'zero',
    // ordinal
    'padding', 'paddingInner', 'paddingOuter',
];
/**
 * Parse scales for a single channel of a model.
 */
function parseScale(model, channel) {
    if (!model.scale(channel)) {
        return null;
    }
    var scale = model.scale(channel);
    var sort = model.sort(channel);
    var scaleComponent = {
        name: model.scaleName(channel + '', true),
        type: scale.type,
        domain: domain_1.parseDomain(model, channel),
        range: range_1.parseRange(scale)
    };
    if (scale_1.isSelectionDomain(scale.domain)) {
        scaleComponent.domainRaw = scale.domain;
    }
    exports.NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES.forEach(function (property) {
        scaleComponent[property] = scale[property];
    });
    if (sort && (sort_1.isSortField(sort) ? sort.order : sort) === 'descending') {
        scaleComponent.reverse = true;
    }
    return scaleComponent;
}
exports.parseScale = parseScale;

},{"../../scale":93,"../../sort":95,"./domain":60,"./range":63}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var channel_1 = require("../../channel");
var scale_1 = require("../../scale");
var util = require("../../util");
function parseRange(scale) {
    if (scale.rangeStep) {
        return { step: scale.rangeStep };
    }
    else if (scale.scheme) {
        var scheme = scale.scheme;
        if (scale_1.isExtendedScheme(scheme)) {
            var r = { scheme: scheme.name };
            if (scheme.count) {
                r.count = scheme.count;
            }
            if (scheme.extent) {
                r.extent = scheme.extent;
            }
            return r;
        }
        else {
            return { scheme: scheme };
        }
    }
    return scale.range;
}
exports.parseRange = parseRange;
exports.RANGE_PROPERTIES = ['range', 'rangeStep', 'scheme'];
/**
 * Return mixins that includes one of the range properties (range, rangeStep, scheme).
 */
function rangeMixins(channel, scaleType, type, specifiedScale, config, zero, mark, topLevelSize, xyRangeSteps) {
    var specifiedRangeStepIsNull = false;
    // Check if any of the range properties is specified.
    // If so, check if it is compatible and make sure that we only output one of the properties
    for (var _i = 0, RANGE_PROPERTIES_1 = exports.RANGE_PROPERTIES; _i < RANGE_PROPERTIES_1.length; _i++) {
        var property = RANGE_PROPERTIES_1[_i];
        if (specifiedScale[property] !== undefined) {
            var supportedByScaleType = scale_1.scaleTypeSupportProperty(scaleType, property);
            var channelIncompatability = scale_1.channelScalePropertyIncompatability(channel, property);
            if (!supportedByScaleType) {
                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));
            }
            else if (channelIncompatability) {
                log.warn(channelIncompatability);
            }
            else {
                switch (property) {
                    case 'range':
                        return { range: specifiedScale[property] };
                    case 'scheme':
                        return { scheme: specifiedScale[property] };
                    case 'rangeStep':
                        if (topLevelSize === undefined) {
                            var stepSize = specifiedScale[property];
                            if (stepSize !== null) {
                                return { rangeStep: stepSize };
                            }
                            else {
                                specifiedRangeStepIsNull = true;
                            }
                        }
                        else {
                            // If top-level size is specified, we ignore specified rangeStep.
                            log.warn(log.message.rangeStepDropped(channel));
                        }
                }
            }
        }
    }
    switch (channel) {
        // TODO: revise row/column when facetSpec has top-level width/height
        case channel_1.ROW:
            return { range: 'height' };
        case channel_1.COLUMN:
            return { range: 'width' };
        case channel_1.X:
        case channel_1.Y:
            if (topLevelSize === undefined) {
                if (util.contains(['point', 'band'], scaleType) && !specifiedRangeStepIsNull) {
                    if (channel === channel_1.X && mark === 'text') {
                        if (config.scale.textXRangeStep) {
                            return { rangeStep: config.scale.textXRangeStep };
                        }
                    }
                    else {
                        if (config.scale.rangeStep) {
                            return { rangeStep: config.scale.rangeStep };
                        }
                    }
                }
                // If specified range step is null or the range step config is null.
                // Use default topLevelSize rule/config
                topLevelSize = channel === channel_1.X ? config.cell.width : config.cell.height;
            }
            return { range: channel === channel_1.X ? [0, topLevelSize] : [topLevelSize, 0] };
        case channel_1.SIZE:
            // TODO: support custom rangeMin, rangeMax
            var rangeMin = sizeRangeMin(mark, zero, config);
            var rangeMax = sizeRangeMax(mark, xyRangeSteps, config);
            return { range: [rangeMin, rangeMax] };
        case channel_1.SHAPE:
        case channel_1.COLOR:
            return { range: defaultRange(channel, scaleType, type, mark) };
        case channel_1.OPACITY:
            // TODO: support custom rangeMin, rangeMax
            return { range: [config.scale.minOpacity, config.scale.maxOpacity] };
    }
    /* istanbul ignore next: should never reach here */
    throw new Error("Scale range undefined for channel " + channel);
}
exports.default = rangeMixins;
function defaultRange(channel, scaleType, type, mark) {
    switch (channel) {
        case channel_1.SHAPE:
            return 'symbol';
        case channel_1.COLOR:
            if (scaleType === 'ordinal') {
                // Only nominal data uses ordinal scale by default
                return type === 'nominal' ? 'category' : 'ordinal';
            }
            return mark === 'rect' ? 'heatmap' : 'ramp';
    }
}
function sizeRangeMin(mark, zero, config) {
    if (zero) {
        return 0;
    }
    switch (mark) {
        case 'bar':
            return config.scale.minBandSize !== undefined ? config.scale.minBandSize : config.bar.continuousBandSize;
        case 'tick':
            return config.scale.minBandSize;
        case 'line':
        case 'rule':
            return config.scale.minStrokeWidth;
        case 'text':
            return config.scale.minFontSize;
        case 'point':
        case 'square':
        case 'circle':
            if (config.scale.minSize) {
                return config.scale.minSize;
            }
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMin not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
function sizeRangeMax(mark, xyRangeSteps, config) {
    var scaleConfig = config.scale;
    // TODO(#1168): make max size scale based on rangeStep / overall plot size
    switch (mark) {
        case 'bar':
        case 'tick':
            if (config.scale.maxBandSize !== undefined) {
                return config.scale.maxBandSize;
            }
            return minXYRangeStep(xyRangeSteps, config.scale) - 1;
        case 'line':
        case 'rule':
            return config.scale.maxStrokeWidth;
        case 'text':
            return config.scale.maxFontSize;
        case 'point':
        case 'square':
        case 'circle':
            if (config.scale.maxSize) {
                return config.scale.maxSize;
            }
            // FIXME this case totally should be refactored
            var pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);
            return (pointStep - 2) * (pointStep - 2);
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMax not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
/**
 * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.
 */
function minXYRangeStep(xyRangeSteps, scaleConfig) {
    if (xyRangeSteps.length > 0) {
        return Math.min.apply(null, xyRangeSteps);
    }
    if (scaleConfig.rangeStep) {
        return scaleConfig.rangeStep;
    }
    return 21; // FIXME: re-evaluate the default value here.
}

},{"../../channel":16,"../../log":90,"../../scale":93,"../../util":102}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var scale_1 = require("../../scale");
var timeunit_1 = require("../../timeunit");
var util = require("../../util");
function nice(scaleType, channel, fieldDef) {
    if (util.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scaleType)) {
        return timeunit_1.smallestUnit(fieldDef.timeUnit);
    }
    return util.contains([channel_1.X, channel_1.Y], channel); // return true for quantitative X/Y
}
exports.nice = nice;
function padding(channel, scaleType, scaleConfig) {
    if (util.contains([channel_1.X, channel_1.Y], channel)) {
        if (scaleType === scale_1.ScaleType.POINT) {
            return scaleConfig.pointPadding;
        }
    }
    return undefined;
}
exports.padding = padding;
function paddingInner(padding, channel, scaleConfig) {
    if (padding !== undefined) {
        // If user has already manually specified "padding", no need to add default paddingInner.
        return undefined;
    }
    if (util.contains([channel_1.X, channel_1.Y], channel)) {
        // Padding is only set for X and Y by default.
        // Basically it doesn't make sense to add padding for color and size.
        // paddingOuter would only be called if it's a band scale, just return the default for bandScale.
        return scaleConfig.bandPaddingInner;
    }
    return undefined;
}
exports.paddingInner = paddingInner;
function paddingOuter(padding, channel, scaleType, paddingInner, scaleConfig) {
    if (padding !== undefined) {
        // If user has already manually specified "padding", no need to add default paddingOuter.
        return undefined;
    }
    if (util.contains([channel_1.X, channel_1.Y], channel)) {
        // Padding is only set for X and Y by default.
        // Basically it doesn't make sense to add padding for color and size.
        if (scaleType === scale_1.ScaleType.BAND) {
            if (scaleConfig.bandPaddingOuter !== undefined) {
                return scaleConfig.bandPaddingOuter;
            }
            /* By default, paddingOuter is paddingInner / 2. The reason is that
                size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
                and we want the width/height to be integer by default.
                Note that step (by default) and cardinality are integers.) */
            return paddingInner / 2;
        }
    }
    return undefined;
}
exports.paddingOuter = paddingOuter;
function round(channel, scaleConfig) {
    if (util.contains(['x', 'y', 'row', 'column'], channel)) {
        return scaleConfig.round;
    }
    return undefined;
}
exports.round = round;
function zero(specifiedScale, channel, fieldDef) {
    // By default, return true only for the following cases:
    // 1) using quantitative field with size
    // While this can be either ratio or interval fields, our assumption is that
    // ratio are more common.
    if (channel === 'size' && fieldDef.type === 'quantitative') {
        return true;
    }
    // 2) non-binned, quantitative x-scale or y-scale if no custom domain is provided.
    // (For binning, we should not include zero by default because binning are calculated without zero.
    // Similar, if users explicitly provide a domain range, we should not augment zero as that will be unexpected.)
    if (!specifiedScale.domain && !fieldDef.bin && util.contains([channel_1.X, channel_1.Y], channel)) {
        return true;
    }
    return false;
}
exports.zero = zero;

},{"../../channel":16,"../../scale":93,"../../timeunit":98,"../../util":102}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var channel_1 = require("../../channel");
var scale_1 = require("../../scale");
var timeunit_1 = require("../../timeunit");
var scale_2 = require("../../scale");
var type_1 = require("../../type");
var util = require("../../util");
var util_1 = require("../../util");
/**
 * Determine if there is a specified scale type and if it is appropriate,
 * or determine default type if type is unspecified or inappropriate.
 */
// NOTE: CompassQL uses this method.
function type(specifiedType, channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    var defaultScaleType = defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
    if (!channel_1.hasScale(channel)) {
        // There is no scale for these channels
        return null;
    }
    if (specifiedType !== undefined) {
        // Check if explicitly specified scale type is supported by the channel
        if (!channel_1.supportScaleType(channel, specifiedType)) {
            log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, defaultScaleType));
            return defaultScaleType;
        }
        // Check if explicitly specified scale type is supported by the data type
        if (!fieldDefMatchScaleType(specifiedType, fieldDef)) {
            log.warn(log.message.scaleTypeNotWorkWithFieldDef(specifiedType, defaultScaleType));
            return defaultScaleType;
        }
        return specifiedType;
    }
    return defaultScaleType;
}
exports.default = type;
/**
 * Determine appropriate default scale type.
 */
function defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    if (util.contains(['row', 'column'], channel)) {
        return 'band';
    }
    switch (fieldDef.type) {
        case 'nominal':
            if (channel === 'color' || channel_1.rangeType(channel) === 'discrete') {
                return 'ordinal';
            }
            return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
        case 'ordinal':
            if (channel === 'color') {
                return 'ordinal';
            }
            else if (channel_1.rangeType(channel) === 'discrete') {
                log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));
                return 'ordinal';
            }
            return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
        case 'temporal':
            if (channel === 'color') {
                // Always use `sequential` as the default color scale for continuous data
                // since it supports both array range and scheme range.
                return 'sequential';
            }
            else if (channel_1.rangeType(channel) === 'discrete') {
                log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));
                // TODO: consider using quantize (equivalent to binning) once we have it
                return 'ordinal';
            }
            if (timeunit_1.isDiscreteByDefault(fieldDef.timeUnit)) {
                return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
            }
            return 'time';
        case 'quantitative':
            if (channel === 'color') {
                if (fieldDef.bin) {
                    return 'bin-ordinal';
                }
                // Use `sequential` as the default color scale for continuous data
                // since it supports both array range and scheme range.
                return 'sequential';
            }
            else if (channel_1.rangeType(channel) === 'discrete') {
                log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));
                // TODO: consider using quantize (equivalent to binning) once we have it
                return 'ordinal';
            }
            if (fieldDef.bin) {
                return 'bin-linear';
            }
            return 'linear';
    }
    /* istanbul ignore next: should never reach this */
    throw new Error(log.message.invalidFieldType(fieldDef.type));
}
/**
 * Determines default scale type for nominal/ordinal field.
 * @returns BAND or POINT scale based on channel, mark, and rangeStep
 */
function discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    if (util.contains(['x', 'y'], channel)) {
        if (mark === 'rect') {
            // The rect mark should fit into a band.
            return 'band';
        }
        if (mark === 'bar') {
            // For bar, use band only if there is no rangeStep since we need to use band for fit mode.
            // However, for non-fit mode, point scale provides better center position.
            if (haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig)) {
                return 'point';
            }
            return 'band';
        }
    }
    // Otherwise, use ordinal point scale so we can easily get center positions of the marks.
    return 'point';
}
function haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    if (hasTopLevelSize) {
        // if topLevelSize is provided, rangeStep will be dropped.
        return false;
    }
    if (specifiedRangeStep !== undefined) {
        return specifiedRangeStep !== null;
    }
    return !!scaleConfig.rangeStep;
}
function fieldDefMatchScaleType(specifiedType, fieldDef) {
    var type = fieldDef.type;
    if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {
        return specifiedType === undefined || scale_2.hasDiscreteDomain(specifiedType);
    }
    else if (type === type_1.Type.TEMPORAL) {
        if (!fieldDef.timeUnit) {
            return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], specifiedType);
        }
        else {
            return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], specifiedType) || scale_2.hasDiscreteDomain(specifiedType);
        }
    }
    else if (type === type_1.Type.QUANTITATIVE) {
        if (fieldDef.bin) {
            return specifiedType === scale_1.ScaleType.BIN_LINEAR || specifiedType === scale_1.ScaleType.BIN_ORDINAL;
        }
        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], specifiedType);
    }
    return true;
}
exports.fieldDefMatchScaleType = fieldDefMatchScaleType;

},{"../../channel":16,"../../log":90,"../../scale":93,"../../timeunit":98,"../../type":101,"../../util":102}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var log_1 = require("../../log");
var util_1 = require("../../util");
var selection_1 = require("./selection");
var scales_1 = require("./transforms/scales");
exports.BRUSH = '_brush', exports.SIZE = '_size';
var interval = {
    predicate: 'vlInterval',
    signals: function (model, selCmpt) {
        var signals = [], intervals = [], name = selCmpt.name, size = name + exports.SIZE;
        if (selCmpt.translate && !(scales_1.default.has(selCmpt))) {
            events(selCmpt, function (_, evt) {
                var filters = evt.between[0].filter || (evt.between[0].filter = []);
                filters.push('!event.item || (event.item && ' +
                    ("event.item.mark.name !== " + util_1.stringValue(name + exports.BRUSH) + ")"));
            });
        }
        selCmpt.project.forEach(function (p) {
            if (p.encoding !== channel_1.X && p.encoding !== channel_1.Y) {
                log_1.warn('Interval selections only support x and y encoding channels.');
                return;
            }
            var cs = channelSignal(model, selCmpt, p.encoding);
            signals.push(cs);
            intervals.push("{encoding: " + util_1.stringValue(p.encoding) + ", " +
                ("field: " + util_1.stringValue(p.field) + ", extent: " + cs.name + "}"));
        });
        signals.push({
            name: size,
            value: [],
            on: events(selCmpt, function (on, evt) {
                on.push({
                    events: evt.between[0],
                    update: '{x: x(unit), y: y(unit), width: 0, height: 0}'
                });
                on.push({
                    events: evt,
                    update: "{x: " + size + ".x, y: " + size + ".y, " +
                        ("width: abs(x(unit) - " + size + ".x), height: abs(y(unit) - " + size + ".y)}")
                });
                return on;
            })
        }, {
            name: name,
            update: "[" + intervals.join(', ') + "]"
        });
        return signals;
    },
    tupleExpr: function (model, selCmpt) {
        return "intervals: " + selCmpt.name;
    },
    modifyExpr: function (model, selCmpt) {
        var tpl = selCmpt.name + selection_1.TUPLE;
        return tpl + ', ' +
            (selCmpt.resolve === 'global' ? 'true' : "{unit: " + tpl + ".unit}");
    },
    marks: function (model, selCmpt, marks) {
        var name = selCmpt.name, _a = projections(selCmpt), xi = _a.xi, yi = _a.yi, tpl = name + selection_1.TUPLE, store = "data(" + util_1.stringValue(selCmpt.name + selection_1.STORE) + ")";
        // Do not add a brush if we're binding to scales.
        if (scales_1.default.has(selCmpt)) {
            return marks;
        }
        var update = {
            x: util_1.extend({}, xi !== null ?
                { scale: model.scaleName(channel_1.X), signal: name + "[" + xi + "].extent[0]" } :
                { value: 0 }),
            x2: util_1.extend({}, xi !== null ?
                { scale: model.scaleName(channel_1.X), signal: name + "[" + xi + "].extent[1]" } :
                { field: { group: 'width' } }),
            y: util_1.extend({}, yi !== null ?
                { scale: model.scaleName(channel_1.Y), signal: name + "[" + yi + "].extent[0]" } :
                { value: 0 }),
            y2: util_1.extend({}, yi !== null ?
                { scale: model.scaleName(channel_1.Y), signal: name + "[" + yi + "].extent[1]" } :
                { field: { group: 'height' } })
        };
        // If the selection is resolved to global, only a single interval is in
        // the store. Wrap brush mark's encodings with a production rule to test
        // this based on the `unit` property. Hide the brush mark if it corresponds
        // to a unit different from the one in the store.
        if (selCmpt.resolve === 'global') {
            util_1.keys(update).forEach(function (key) {
                update[key] = [tslib_1.__assign({ test: store + ".length && " + tpl + " && " + tpl + ".unit === " + store + "[0].unit" }, update[key]), { value: 0 }];
            });
        }
        return [{
                name: undefined,
                type: 'rect',
                encode: {
                    enter: { fill: { value: '#eee' } },
                    update: update
                }
            }].concat(marks, {
            name: name + exports.BRUSH,
            type: 'rect',
            encode: {
                enter: { fill: { value: 'transparent' } },
                update: update
            }
        });
    }
};
exports.default = interval;
function projections(selCmpt) {
    var x = null, xi = null, y = null, yi = null;
    selCmpt.project.forEach(function (p, i) {
        if (p.encoding === channel_1.X) {
            x = p;
            xi = i;
        }
        else if (p.encoding === channel_1.Y) {
            y = p;
            yi = i;
        }
    });
    return { x: x, xi: xi, y: y, yi: yi };
}
exports.projections = projections;
function channelSignal(model, selCmpt, channel) {
    var name = selection_1.channelSignalName(selCmpt, channel), size = model.getSizeSignalRef(channel === channel_1.X ? 'width' : 'height').signal, coord = channel + "(unit)", invert = selection_1.invert.bind(null, model, selCmpt, channel);
    return {
        name: name,
        value: [],
        on: scales_1.default.has(selCmpt) ? [] : events(selCmpt, function (on, evt) {
            on.push({
                events: evt.between[0],
                update: invert("[" + coord + ", " + coord + "]")
            });
            on.push({
                events: evt,
                update: "[" + name + "[0], " + invert("clamp(" + coord + ", 0, " + size + ")") + ']'
            });
            return on;
        })
    };
}
function events(selCmpt, cb) {
    return selCmpt.events.reduce(function (on, evt) {
        if (!evt.between) {
            log_1.warn(evt + " is not an ordered event stream for interval selections");
            return on;
        }
        return cb(on, evt);
    }, []);
}

},{"../../channel":16,"../../log":90,"../../util":102,"./selection":68,"./transforms/scales":73,"tslib":10}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var selection_1 = require("./selection");
var multi = {
    predicate: 'vlPoint',
    signals: function (model, selCmpt) {
        var proj = selCmpt.project, datum = '(item().isVoronoi ? datum.datum : datum)', encodings = proj.map(function (p) { return util_1.stringValue(p.encoding); }).join(', '), fields = proj.map(function (p) { return util_1.stringValue(p.field); }).join(', '), values = proj.map(function (p) { return datum + "[" + util_1.stringValue(p.field) + "]"; }).join(', ');
        return [{
                name: selCmpt.name,
                value: {},
                on: [{
                        events: selCmpt.events,
                        update: "{encodings: [" + encodings + "], fields: [" + fields + "], values: [" + values + "]}"
                    }]
            }];
    },
    tupleExpr: function (model, selCmpt) {
        var name = selCmpt.name;
        return "encodings: " + name + ".encodings, fields: " + name + ".fields, values: " + name + ".values";
    },
    modifyExpr: function (model, selCmpt) {
        var tpl = selCmpt.name + selection_1.TUPLE;
        return tpl + ', ' +
            (selCmpt.resolve === 'global' ? 'null' : "{unit: " + tpl + ".unit}");
    }
};
exports.default = multi;

},{"../../util":102,"./selection":68}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var util_1 = require("../../util");
var layer_1 = require("../layer");
var interval_1 = require("./interval");
var multi_1 = require("./multi");
var single_1 = require("./single");
var transforms_1 = require("./transforms/transforms");
exports.STORE = '_store';
exports.TUPLE = '_tuple';
exports.MODIFY = '_modify';
function parseUnitSelection(model, selDefs) {
    var selCmpts = {}, selectionConfig = model.config.selection;
    var _loop_1 = function (name_1) {
        if (!selDefs.hasOwnProperty(name_1)) {
            return "continue";
        }
        var selDef = selDefs[name_1], cfg = selectionConfig[selDef.type];
        // Set default values from config if a property hasn't been specified,
        // or if it is true. E.g., "translate": true should use the default
        // event handlers for translate. However, true may be a valid value for
        // a property (e.g., "nearest": true).
        for (var key in cfg) {
            // A selection should contain either `encodings` or `fields`, only use
            // default values for these two values if neither of them is specified.
            if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {
                continue;
            }
            if (selDef[key] === undefined || selDef[key] === true) {
                selDef[key] = cfg[key] || selDef[key];
            }
        }
        var selCmpt = selCmpts[name_1] = util_1.extend({}, selDef, {
            name: name_1,
            events: util_1.isString(selDef.on) ? vega_event_selector_1.selector(selDef.on, 'scope') : selDef.on,
            domain: 'data',
        });
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.parse) {
                txCompiler.parse(model, selDef, selCmpt);
            }
        });
    };
    for (var name_1 in selDefs) {
        _loop_1(name_1);
    }
    return selCmpts;
}
exports.parseUnitSelection = parseUnitSelection;
function assembleUnitSelectionSignals(model, signals) {
    forEachSelection(model, function (selCmpt, selCompiler) {
        var name = selCmpt.name, tupleExpr = selCompiler.tupleExpr(model, selCmpt);
        var modifyExpr = selCompiler.modifyExpr(model, selCmpt);
        signals.push.apply(signals, selCompiler.signals(model, selCmpt));
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.signals) {
                signals = txCompiler.signals(model, selCmpt, signals);
            }
            if (txCompiler.modifyExpr) {
                modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);
            }
        });
        signals.push({
            name: name + exports.TUPLE,
            on: [{
                    events: { signal: name },
                    update: "{unit: unit.datum && unit.datum._id, " + tupleExpr + "}"
                }]
        }, {
            name: name + exports.MODIFY,
            on: [{
                    events: { signal: name },
                    update: "modify(" + util_1.stringValue(selCmpt.name + exports.STORE) + ", " + modifyExpr + ")"
                }]
        });
    });
    return signals;
}
exports.assembleUnitSelectionSignals = assembleUnitSelectionSignals;
function assembleTopLevelSignals(model, signals) {
    var hasUnit = signals.filter(function (s) { return s.name === 'unit'; });
    if (!(hasUnit.length)) {
        signals.push({
            name: 'unit',
            value: {},
            on: [{ events: 'mousemove', update: 'group()._id ? group() : unit' }]
        });
    }
    forEachSelection(model, function (selCmpt, selCompiler) {
        if (selCompiler.topLevelSignals) {
            signals.push.apply(signals, selCompiler.topLevelSignals(model, selCmpt));
        }
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.topLevelSignals) {
                signals = txCompiler.topLevelSignals(model, selCmpt, signals);
            }
        });
    });
    return signals;
}
exports.assembleTopLevelSignals = assembleTopLevelSignals;
function assembleUnitSelectionData(model, data) {
    forEachSelection(model, function (selCmpt) {
        var contains = data.filter(function (d) { return d.name === selCmpt.name + exports.STORE; });
        if (!contains.length) {
            data.push({ name: selCmpt.name + exports.STORE });
        }
    });
    return data;
}
exports.assembleUnitSelectionData = assembleUnitSelectionData;
function assembleUnitSelectionMarks(model, marks) {
    var clipGroup = false, selMarks = marks;
    forEachSelection(model, function (selCmpt, selCompiler) {
        selMarks = selCompiler.marks ? selCompiler.marks(model, selCmpt, selMarks) : selMarks;
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            clipGroup = clipGroup || txCompiler.clipGroup;
            if (txCompiler.marks) {
                selMarks = txCompiler.marks(model, selCmpt, marks, selMarks);
            }
        });
    });
    // In a layered spec, we want to clip all layers together rather than
    // only the layer within which the selection is defined. Propagate
    // our assembled state up and let the LayerModel make the right call.
    if (model.parent && model.parent instanceof layer_1.LayerModel) {
        return [selMarks, clipMarks];
    }
    else {
        return clipGroup ? clipMarks(selMarks) : selMarks;
    }
}
exports.assembleUnitSelectionMarks = assembleUnitSelectionMarks;
function assembleLayerSelectionMarks(model, marks) {
    var clipGroup = false;
    model.children.forEach(function (child) {
        var unit = assembleUnitSelectionMarks(child, marks);
        marks = unit[0];
        clipGroup = clipGroup || unit[1];
    });
    return clipGroup ? clipMarks(marks) : marks;
}
exports.assembleLayerSelectionMarks = assembleLayerSelectionMarks;
var PREDICATES_OPS = {
    global: '"union", "all"',
    independent: '"intersect", "unit"',
    union: '"union", "all"',
    union_others: '"union", "others"',
    intersect: '"intersect", "all"',
    intersect_others: '"intersect", "others"'
};
// TODO: How to better differentiate unit than parent._id?
function predicate(name, type, resolve, datum, parent) {
    var store = util_1.stringValue(name + exports.STORE), op = PREDICATES_OPS[resolve || 'global'];
    datum = datum || 'datum';
    parent = parent === null ? null : 'parent._id';
    return compiler(type).predicate + ("(" + store + ", " + parent + ", " + datum + ", " + op + ")");
}
exports.predicate = predicate;
// Utility functions
function forEachSelection(model, cb) {
    var selections = model.component.selection;
    for (var name_2 in selections) {
        if (selections.hasOwnProperty(name_2)) {
            var sel = selections[name_2];
            cb(sel, compiler(sel.type));
        }
    }
}
function compiler(type) {
    switch (type) {
        case 'single':
            return single_1.default;
        case 'multi':
            return multi_1.default;
        case 'interval':
            return interval_1.default;
    }
    return null;
}
function invert(model, selCmpt, channel, expr) {
    var scale = util_1.stringValue(model.scaleName(channel));
    return selCmpt.domain === 'data' ? "invert(" + scale + ", " + expr + ")" : expr;
}
exports.invert = invert;
function channelSignalName(selCmpt, channel) {
    return selCmpt.name + '_' + selCmpt.fields[channel];
}
exports.channelSignalName = channelSignalName;
function clipMarks(marks) {
    return marks.map(function (m) { return (m.clip = true, m); });
}

},{"../../util":102,"../layer":39,"./interval":66,"./multi":67,"./single":69,"./transforms/transforms":75,"vega-event-selector":11}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var multi_1 = require("./multi");
var selection_1 = require("./selection");
var single = {
    predicate: multi_1.default.predicate,
    signals: multi_1.default.signals,
    topLevelSignals: function (model, selCmpt) {
        return [{
                name: selCmpt.name,
                update: "data(" + util_1.stringValue(selCmpt.name + selection_1.STORE) + ")[0]"
            }];
    },
    tupleExpr: function (model, selCmpt) {
        var name = selCmpt.name, values = name + ".values";
        return "encodings: " + name + ".encodings, fields: " + name + ".fields, " +
            ("values: " + values + ", ") +
            selCmpt.project.map(function (p, i) {
                return p.field + ": " + values + "[" + i + "]";
            }).join(', ');
    },
    modifyExpr: function (model, selCmpt) {
        var tpl = selCmpt.name + selection_1.TUPLE;
        return tpl + ', ' +
            (selCmpt.resolve === 'global' ? 'true' : "{unit: " + tpl + ".unit}");
    }
};
exports.default = single;

},{"../../util":102,"./multi":67,"./selection":68}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../../util");
var inputBindings = {
    has: function (selCmpt) {
        return selCmpt.type === 'single' && selCmpt.resolve === 'global' &&
            selCmpt.bind && selCmpt.bind !== 'scales';
    },
    topLevelSignals: function (model, selCmpt, signals) {
        var name = selCmpt.name, proj = selCmpt.project, bind = selCmpt.bind, datum = '(item().isVoronoi ? datum.datum : datum)';
        proj.forEach(function (p) {
            signals.unshift({
                name: name + id(p.field),
                value: '',
                on: [{
                        events: selCmpt.events,
                        update: datum + "[" + util_1.stringValue(p.field) + "]"
                    }],
                bind: bind[p.field] || bind[p.encoding] || bind
            });
        });
        return signals;
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name, proj = selCmpt.project, signal = signals.filter(function (s) { return s.name === name; })[0], fields = proj.map(function (p) { return util_1.stringValue(p.field); }).join(', '), values = proj.map(function (p) { return name + id(p.field); }).join(', ');
        signal.update = "{fields: [" + fields + "], values: [" + values + "]}";
        delete signal.value;
        delete signal.on;
        return signals;
    }
};
exports.default = inputBindings;
function id(str) {
    return '_' + str.replace(/\W/g, '_');
}

},{"../../../util":102}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var VORONOI = 'voronoi';
var nearest = {
    has: function (selCmpt) {
        return selCmpt.nearest !== undefined && selCmpt.nearest !== false;
    },
    marks: function (model, selCmpt, marks, selMarks) {
        var mark = marks[0], index = selMarks.indexOf(mark), isPathgroup = mark.name === model.getName('pathgroup'), exists = (function (m) { return m.name && m.name.indexOf(VORONOI) >= 0; }), cellDef = {
            name: model.getName(VORONOI),
            type: 'path',
            from: { data: model.getName('marks') },
            encode: {
                enter: {
                    fill: { value: 'transparent' },
                    strokeWidth: { value: 0.35 },
                    stroke: { value: 'transparent' },
                    isVoronoi: { value: true }
                }
            },
            transform: [{
                    type: 'voronoi',
                    x: 'datum.x',
                    y: 'datum.y',
                    size: [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')]
                }]
        };
        if (isPathgroup && !mark.marks.filter(exists).length) {
            mark.marks.push(cellDef);
            selMarks.splice(index, 1, mark);
        }
        else if (!isPathgroup && !selMarks.filter(exists).length) {
            selMarks.splice(index + 1, 0, cellDef);
        }
        return selMarks;
    }
};
exports.default = nearest;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var project = {
    has: function (selDef) {
        return selDef.fields !== undefined || selDef.encodings !== undefined;
    },
    parse: function (model, selDef, selCmpt) {
        var fields = {};
        // TODO: find a possible channel mapping for these fields.
        (selDef.fields || []).forEach(function (f) { return fields[f] = null; });
        (selDef.encodings || []).forEach(function (c) { return fields[model.fieldDef(c).field] = c; });
        var projection = selCmpt.project || (selCmpt.project = []);
        for (var field in fields) {
            if (fields.hasOwnProperty(field)) {
                projection.push({ field: field, encoding: fields[field] });
            }
        }
        fields = selCmpt.fields || (selCmpt.fields = {});
        projection.filter(function (p) { return p.encoding; }).forEach(function (p) { return fields[p.encoding] = p.field; });
    }
};
exports.default = project;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = require("../../../log");
var scale_1 = require("../../../scale");
var util_1 = require("../../../util");
var interval_1 = require("../interval");
var selection_1 = require("../selection");
var scaleBindings = {
    clipGroup: true,
    has: function (selCmpt) {
        return selCmpt.type === 'interval' && selCmpt.resolve === 'global' &&
            selCmpt.bind && selCmpt.bind === 'scales';
    },
    parse: function (model, selDef, selCmpt) {
        var bound = selCmpt.scales = [];
        selCmpt.project.forEach(function (p) {
            var channel = p.encoding;
            var scale = model.getComponent('scales', channel);
            if (!scale || !scale_1.hasContinuousDomain(scale.type)) {
                log_1.warn('Scale bindings are currently only supported for scales with continuous domains.');
                return;
            }
            scale.domainRaw = { signal: selection_1.channelSignalName(selCmpt, channel) };
            bound.push(channel);
        });
    },
    topLevelSignals: function (model, selCmpt, signals) {
        var channels = selCmpt.scales.filter(function (channel) {
            return !(signals.filter(function (s) { return s.name === selection_1.channelSignalName(selCmpt, channel); }).length);
        });
        return signals.concat(channels.map(function (channel) {
            return { name: selection_1.channelSignalName(selCmpt, channel) };
        }));
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name;
        signals = signals.filter(function (s) {
            return s.name !== name + interval_1.SIZE &&
                s.name !== name + selection_1.TUPLE && s.name !== selection_1.MODIFY;
        });
        selCmpt.scales.forEach(function (channel) {
            var signal = signals.filter(function (s) { return s.name === selection_1.channelSignalName(selCmpt, channel); })[0];
            signal.push = 'outer';
            delete signal.value;
            delete signal.update;
        });
        return signals;
    }
};
exports.default = scaleBindings;
function domain(model, channel) {
    var scale = util_1.stringValue(model.scaleName(channel));
    return "domain(" + scale + ")";
}
exports.domain = domain;

},{"../../../log":90,"../../../scale":93,"../../../util":102,"../interval":66,"../selection":68}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selection_1 = require("../selection");
var TOGGLE = '_toggle';
var toggle = {
    has: function (selCmpt) {
        return selCmpt.toggle !== undefined && selCmpt.toggle !== false;
    },
    signals: function (model, selCmpt, signals) {
        return signals.concat({
            name: selCmpt.name + TOGGLE,
            value: false,
            on: [{ events: selCmpt.events, update: selCmpt.toggle }]
        });
    },
    modifyExpr: function (model, selCmpt, expr) {
        var tpl = selCmpt.name + selection_1.TUPLE, signal = selCmpt.name + TOGGLE;
        return signal + " ? null : " + tpl + ", " +
            (selCmpt.resolve === 'global' ?
                signal + " ? null : true, " :
                signal + " ? null : {unit: " + tpl + ".unit}, ") +
            (signal + " ? " + tpl + " : null");
    }
};
exports.default = toggle;

},{"../selection":68}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var inputs_1 = require("./inputs");
var nearest_1 = require("./nearest");
var project_1 = require("./project");
var scales_1 = require("./scales");
var toggle_1 = require("./toggle");
var translate_1 = require("./translate");
var zoom_1 = require("./zoom");
var compilers = { project: project_1.default, toggle: toggle_1.default, scales: scales_1.default,
    translate: translate_1.default, zoom: zoom_1.default, inputs: inputs_1.default, nearest: nearest_1.default };
function forEachTransform(selCmpt, cb) {
    for (var t in compilers) {
        if (compilers[t].has(selCmpt)) {
            cb(compilers[t]);
        }
    }
}
exports.forEachTransform = forEachTransform;

},{"./inputs":70,"./nearest":71,"./project":72,"./scales":73,"./toggle":74,"./translate":76,"./zoom":77}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var channel_1 = require("../../../channel");
var util_1 = require("../../../util");
var interval_1 = require("../interval");
var selection_1 = require("../selection");
var scales_1 = require("./scales");
var ANCHOR = '_translate_anchor', DELTA = '_translate_delta';
var translate = {
    has: function (selCmpt) {
        return selCmpt.type === 'interval' && selCmpt.translate !== undefined && selCmpt.translate !== false;
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name, scales = scales_1.default.has(selCmpt), size = scales ? 'unit' : name + interval_1.SIZE, anchor = name + ANCHOR, _a = interval_1.projections(selCmpt), x = _a.x, y = _a.y;
        var events = vega_event_selector_1.selector(selCmpt.translate, 'scope');
        if (!scales) {
            events = events.map(function (e) { return (e.between[0].markname = name + interval_1.BRUSH, e); });
        }
        signals.push({
            name: anchor,
            value: {},
            on: [{
                    events: events.map(function (e) { return e.between[0]; }),
                    update: '{x: x(unit), y: y(unit), ' +
                        ("width: " + size + ".width, height: " + size + ".height, ") +
                        (x !== null ? 'extent_x: ' + (scales ? scales_1.domain(model, channel_1.X) :
                            "slice(" + name + "_" + x.field + ")") + ', ' : '') +
                        (y !== null ? 'extent_y: ' + (scales ? scales_1.domain(model, channel_1.Y) :
                            "slice(" + name + "_" + y.field + ")") + ', ' : '') + '}'
                }]
        }, {
            name: name + DELTA,
            value: {},
            on: [{
                    events: events,
                    update: "{x: x(unit) - " + anchor + ".x, y: y(unit) - " + anchor + ".y}"
                }]
        });
        if (x !== null) {
            onDelta(model, selCmpt, channel_1.X, 'width', signals);
        }
        if (y !== null) {
            onDelta(model, selCmpt, channel_1.Y, 'height', signals);
        }
        return signals;
    }
};
exports.default = translate;
function getSign(selCmpt, channel) {
    var s = channel === channel_1.X ? '+' : '-';
    if (scales_1.default.has(selCmpt)) {
        s = s === '+' ? '-' : '+';
    }
    return s;
}
function onDelta(model, selCmpt, channel, size, signals) {
    var name = selCmpt.name, signal = signals.filter(function (s) { return s.name === selection_1.channelSignalName(selCmpt, channel); })[0], anchor = name + ANCHOR, delta = name + DELTA, scale = util_1.stringValue(model.scaleName(channel)), extent = ".extent_" + channel, sign = getSign(selCmpt, channel), offset = sign + " abs(span(" + anchor + extent + ")) * " +
        (delta + "." + channel + " / " + anchor + "." + size), range = "[" + anchor + extent + "[0] " + offset + ", " +
        ("" + anchor + extent + "[1] " + offset + "]"), lo = "invert(" + scale + (channel === channel_1.X ? ', 0' : ", unit." + size) + ')', hi = "invert(" + scale + (channel === channel_1.X ? ", unit." + size : ', 0') + ')';
    signal.on.push({
        events: { signal: delta },
        update: scales_1.default.has(selCmpt) ? range : "clampRange(" + range + ", " + lo + ", " + hi + ")"
    });
}

},{"../../../channel":16,"../../../util":102,"../interval":66,"../selection":68,"./scales":73,"vega-event-selector":11}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var channel_1 = require("../../../channel");
var util_1 = require("../../../util");
var interval_1 = require("../interval");
var selection_1 = require("../selection");
var scales_1 = require("./scales");
var ANCHOR = '_zoom_anchor', DELTA = '_zoom_delta';
var zoom = {
    has: function (selCmpt) {
        return selCmpt.type === 'interval' && selCmpt.zoom !== undefined && selCmpt.zoom !== false;
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name, delta = name + DELTA, _a = interval_1.projections(selCmpt), x = _a.x, y = _a.y, sx = util_1.stringValue(model.scaleName(channel_1.X)), sy = util_1.stringValue(model.scaleName(channel_1.Y));
        var events = vega_event_selector_1.selector(selCmpt.zoom, 'scope');
        if (!scales_1.default.has(selCmpt)) {
            events = events.map(function (e) { return (e.markname = name + interval_1.BRUSH, e); });
        }
        signals.push({
            name: name + ANCHOR,
            on: [{
                    events: events,
                    update: "{x: invert(" + sx + ", x(unit)), y: invert(" + sy + ", y(unit))}"
                }]
        }, {
            name: delta,
            on: [{
                    events: events,
                    force: true,
                    update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'
                }]
        });
        if (x !== null) {
            onDelta(model, selCmpt, 'x', 'width', signals);
        }
        if (y !== null) {
            onDelta(model, selCmpt, 'y', 'height', signals);
        }
        var size = signals.filter(function (s) { return s.name === name + interval_1.SIZE; });
        if (size.length) {
            var sname = size[0].name;
            size[0].on.push({
                events: { signal: delta },
                update: "{x: " + sname + ".x, y: " + sname + ".y, " +
                    ("width: " + sname + ".width * " + delta + " , ") +
                    ("height: " + sname + ".height * " + delta + "}")
            });
        }
        return signals;
    }
};
exports.default = zoom;
function onDelta(model, selCmpt, channel, size, signals) {
    var name = selCmpt.name, signal = signals.filter(function (s) { return s.name === selection_1.channelSignalName(selCmpt, channel); })[0], scales = scales_1.default.has(selCmpt), base = scales ? scales_1.domain(model, channel) : signal.name, anchor = "" + name + ANCHOR + "." + channel, delta = name + DELTA, scale = util_1.stringValue(model.scaleName(channel)), range = "[" + anchor + " + (" + base + "[0] - " + anchor + ") * " + delta + ", " +
        (anchor + " + (" + base + "[1] - " + anchor + ") * " + delta + "]"), lo = "invert(" + scale + (channel === channel_1.X ? ', 0' : ", unit." + size) + ')', hi = "invert(" + scale + (channel === channel_1.X ? ", unit." + size : ', 0') + ')';
    signal.on.push({
        events: { signal: delta },
        update: scales ? range : "clampRange(" + range + ", " + lo + ", " + hi + ")"
    });
}

},{"../../../channel":16,"../../../util":102,"../interval":66,"../selection":68,"./scales":73,"vega-event-selector":11}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../channel");
var encoding_1 = require("../encoding");
var vlEncoding = require("../encoding"); // TODO: remove
var fielddef_1 = require("../fielddef");
var mark_1 = require("../mark");
var scale_1 = require("../scale");
var stack_1 = require("../stack");
var util_1 = require("../util");
var parse_1 = require("./axis/parse");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_2 = require("./data/parse");
var facet_1 = require("./facet");
var layer_1 = require("./layer");
var index_1 = require("./layout/index");
var parse_3 = require("./legend/parse");
var init_1 = require("./mark/init");
var mark_2 = require("./mark/mark");
var model_1 = require("./model");
var repeat_1 = require("./repeat");
var init_2 = require("./scale/init");
var parse_4 = require("./scale/parse");
var selection_1 = require("./selection/selection");
/**
 * Internal model of Vega-Lite specification for the compiler.
 */
var UnitModel = (function (_super) {
    tslib_1.__extends(UnitModel, _super);
    function UnitModel(spec, parent, parentGivenName, parentUnitSize, repeater, config) {
        if (parentUnitSize === void 0) { parentUnitSize = {}; }
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.scales = {};
        _this.axes = {};
        _this.legends = {};
        _this.selection = {};
        _this.children = [];
        // FIXME(#2041): copy config.facet.cell to config.cell -- this seems incorrect and should be rewritten
        _this.initFacetCellConfig();
        // use top-level width / height or ancestor's width / height
        var providedWidth = spec.width || parentUnitSize.width;
        var providedHeight = spec.height || parentUnitSize.height;
        var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
        var encoding = _this.encoding = encoding_1.normalizeEncoding(repeat_1.replaceRepeaterInEncoding(spec.encoding || {}, repeater), mark);
        // calculate stack properties
        _this.stack = stack_1.stack(mark, encoding, _this.config.stack);
        _this.scales = _this.initScales(mark, encoding, providedWidth, providedHeight);
        _this.markDef = init_1.initMarkDef(spec.mark, encoding, _this.scales, _this.config);
        _this.encoding = init_1.initEncoding(mark, encoding, _this.stack, _this.config);
        _this.axes = _this.initAxes(encoding);
        _this.legends = _this.initLegend(encoding);
        // Selections will be initialized upon parse.
        _this.selection = spec.selection;
        // width / height
        var _a = _this.initSize(mark, _this.scales, providedWidth, providedHeight), _b = _a.width, width = _b === void 0 ? _this.width : _b, _c = _a.height, height = _c === void 0 ? _this.height : _c;
        _this.width = width;
        _this.height = height;
        return _this;
    }
    UnitModel.prototype.scale = function (channel) {
        return this.scales[channel];
    };
    UnitModel.prototype.hasDiscreteDomain = function (channel) {
        var scale = this.scale(channel);
        return scale && scale_1.hasDiscreteDomain(scale.type);
    };
    UnitModel.prototype.sort = function (channel) {
        return (this.getMapping()[channel] || {}).sort;
    };
    UnitModel.prototype.axis = function (channel) {
        return this.axes[channel];
    };
    UnitModel.prototype.legend = function (channel) {
        return this.legends[channel];
    };
    UnitModel.prototype.initFacetCellConfig = function () {
        var config = this.config;
        var ancestor = this.parent;
        var hasFacetAncestor = false;
        while (ancestor !== null) {
            if (ancestor instanceof facet_1.FacetModel) {
                hasFacetAncestor = true;
                break;
            }
            ancestor = ancestor.parent;
        }
        if (hasFacetAncestor) {
            config.cell = util_1.extend({}, config.cell, config.facet.cell);
        }
    };
    UnitModel.prototype.initScales = function (mark, encoding, topLevelWidth, topLevelHeight) {
        var _this = this;
        var xyRangeSteps = [];
        return channel_1.UNIT_SCALE_CHANNELS.reduce(function (scales, channel) {
            if (vlEncoding.channelHasField(encoding, channel) ||
                (channel === channel_1.X && vlEncoding.channelHasField(encoding, channel_1.X2)) ||
                (channel === channel_1.Y && vlEncoding.channelHasField(encoding, channel_1.Y2))) {
                var scale = scales[channel] = init_2.default(channel, encoding[channel], _this.config, mark, channel === channel_1.X ? topLevelWidth : channel === channel_1.Y ? topLevelHeight : undefined, xyRangeSteps // for determine point / bar size
                );
                if (channel === channel_1.X || channel === channel_1.Y) {
                    if (scale.rangeStep) {
                        xyRangeSteps.push(scale.rangeStep);
                    }
                }
            }
            return scales;
        }, {});
    };
    // TODO: consolidate this with scale?  Current scale range is in parseScale (later),
    // but not in initScale because scale range depends on size,
    // but size depends on scale type and rangeStep
    UnitModel.prototype.initSize = function (mark, scale, width, height) {
        var cellConfig = this.config.cell;
        var scaleConfig = this.config.scale;
        if (width === undefined) {
            if (scale[channel_1.X]) {
                if (!scale_1.hasDiscreteDomain(scale[channel_1.X].type) || !scale[channel_1.X].rangeStep) {
                    width = cellConfig.width;
                } // else: Do nothing, use dynamic width.
            }
            else {
                if (mark === mark_1.TEXT) {
                    // for text table without x/y scale we need wider rangeStep
                    width = scaleConfig.textXRangeStep;
                }
                else {
                    if (typeof scaleConfig.rangeStep === 'string') {
                        throw new Error('_initSize does not handle string rangeSteps');
                    }
                    width = scaleConfig.rangeStep;
                }
            }
        }
        if (height === undefined) {
            if (scale[channel_1.Y]) {
                if (!scale_1.hasDiscreteDomain(scale[channel_1.Y].type) || !scale[channel_1.Y].rangeStep) {
                    height = cellConfig.height;
                } // else: Do nothing, use dynamic height .
            }
            else {
                if (typeof scaleConfig.rangeStep === 'string') {
                    throw new Error('_initSize does not handle string rangeSteps');
                }
                height = scaleConfig.rangeStep;
            }
        }
        return { width: width, height: height };
    };
    UnitModel.prototype.initAxes = function (encoding) {
        return [channel_1.X, channel_1.Y].reduce(function (_axis, channel) {
            // Position Axis
            var channelDef = encoding[channel];
            if (fielddef_1.isFieldDef(channelDef) ||
                (channel === channel_1.X && fielddef_1.isFieldDef(encoding.x2)) ||
                (channel === channel_1.Y && fielddef_1.isFieldDef(encoding.y2))) {
                var axisSpec = fielddef_1.isFieldDef(channelDef) ? channelDef.axis : null;
                // We no longer support false in the schema, but we keep false here for backward compatability.
                if (axisSpec !== null && axisSpec !== false) {
                    _axis[channel] = tslib_1.__assign({}, axisSpec);
                }
            }
            return _axis;
        }, {});
    };
    UnitModel.prototype.initLegend = function (encoding) {
        return channel_1.NONSPATIAL_SCALE_CHANNELS.reduce(function (_legend, channel) {
            var channelDef = encoding[channel];
            if (fielddef_1.isFieldDef(channelDef)) {
                var legendSpec = channelDef.legend;
                if (legendSpec !== null && legendSpec !== false) {
                    _legend[channel] = tslib_1.__assign({}, legendSpec);
                }
            }
            return _legend;
        }, {});
    };
    UnitModel.prototype.parseData = function () {
        this.component.data = parse_2.parseData(this);
    };
    UnitModel.prototype.parseSelection = function () {
        this.component.selection = selection_1.parseUnitSelection(this, this.selection);
    };
    UnitModel.prototype.parseScale = function () {
        this.component.scales = parse_4.default(this);
    };
    UnitModel.prototype.parseMark = function () {
        this.component.mark = mark_2.parseMark(this);
    };
    UnitModel.prototype.parseAxisAndHeader = function () {
        this.component.axes = parse_1.parseAxisComponent(this, [channel_1.X, channel_1.Y]);
    };
    UnitModel.prototype.parseLegend = function () {
        this.component.legends = parse_3.parseLegendComponent(this);
    };
    UnitModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    UnitModel.prototype.assembleSelectionTopLevelSignals = function (signals) {
        return selection_1.assembleTopLevelSignals(this, signals);
    };
    UnitModel.prototype.assembleSelectionSignals = function () {
        return selection_1.assembleUnitSelectionSignals(this, []);
    };
    UnitModel.prototype.assembleSelectionData = function (data) {
        return selection_1.assembleUnitSelectionData(this, data);
    };
    UnitModel.prototype.assembleLayout = function () {
        return null;
    };
    UnitModel.prototype.assembleLayoutSignals = function () {
        return index_1.assembleLayoutUnitSignals(this);
    };
    UnitModel.prototype.assembleMarks = function () {
        var marks = this.component.mark || [];
        // If this unit is part of a layer, selections should augment
        // all in concert rather than each unit individually. This
        // ensures correct interleaving of clipping and brushed marks.
        if (!this.parent || !(this.parent instanceof layer_1.LayerModel)) {
            marks = selection_1.assembleUnitSelectionMarks(this, marks);
        }
        return marks.map(this.correctDataNames);
    };
    UnitModel.prototype.assembleParentGroupProperties = function () {
        return tslib_1.__assign({ width: this.getSizeSignalRef('width'), height: this.getSizeSignalRef('height') }, common_1.applyConfig({}, this.config.cell, mark_1.FILL_STROKE_CONFIG.concat(['clip'])));
    };
    UnitModel.prototype.channels = function () {
        return channel_1.UNIT_CHANNELS;
    };
    UnitModel.prototype.getMapping = function () {
        return this.encoding;
    };
    UnitModel.prototype.toSpec = function (excludeConfig, excludeData) {
        var encoding = util_1.duplicate(this.encoding);
        var spec;
        spec = {
            mark: this.markDef,
            encoding: encoding
        };
        if (!excludeConfig) {
            spec.config = util_1.duplicate(this.config);
        }
        if (!excludeData) {
            spec.data = util_1.duplicate(this.data);
        }
        // remove defaults
        return spec;
    };
    UnitModel.prototype.mark = function () {
        return this.markDef.type;
    };
    UnitModel.prototype.channelHasField = function (channel) {
        return vlEncoding.channelHasField(this.encoding, channel);
    };
    UnitModel.prototype.fieldDef = function (channel) {
        // TODO: remove this || {}
        // Currently we have it to prevent null pointer exception.
        return this.encoding[channel] || {};
    };
    /** Get "field" reference for vega */
    UnitModel.prototype.field = function (channel, opt) {
        if (opt === void 0) { opt = {}; }
        var fieldDef = this.fieldDef(channel);
        if (fieldDef.bin) {
            opt = util_1.extend({
                binSuffix: scale_1.hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'
            }, opt);
        }
        return fielddef_1.field(fieldDef, opt);
    };
    return UnitModel;
}(model_1.ModelWithField));
exports.UnitModel = UnitModel;

},{"../channel":16,"../encoding":85,"../fielddef":87,"../mark":91,"../scale":93,"../stack":97,"../util":102,"./axis/parse":18,"./common":20,"./data/assemble":24,"./data/parse":32,"./facet":38,"./layer":39,"./layout/index":41,"./legend/parse":43,"./mark/init":47,"./mark/mark":49,"./model":57,"./repeat":58,"./scale/init":61,"./scale/parse":62,"./selection/selection":68,"tslib":10}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fielddef_1 = require("./../fielddef");
exports.BOXPLOT = 'box-plot';
function normalizeBoxPlot(spec, config) {
    var _m = spec.mark, encoding = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "encoding"]);
    var _x = encoding.x, _y = encoding.y, nonPositionEncoding = tslib_1.__rest(encoding, ["x", "y"]);
    var size = nonPositionEncoding.size, nonPositionEncodingWithoutSize = tslib_1.__rest(nonPositionEncoding, ["size"]);
    var _color = nonPositionEncodingWithoutSize.color, nonPositionEncodingWithoutColorSize = tslib_1.__rest(nonPositionEncodingWithoutSize, ["color"]);
    var midTickAndBarSizeChannelDef = size ? { size: size } : { size: { value: config.box.size } };
    var discreteAxisFieldDef, continuousAxisChannelDef;
    var discreteAxis, continuousAxis;
    if (encoding.x && encoding.y) {
        // 2D
        if (fielddef_1.isDiscrete(encoding.x) && fielddef_1.isContinuous(encoding.y)) {
            // vertical
            discreteAxis = 'x';
            continuousAxis = 'y';
            continuousAxisChannelDef = encoding.y;
            discreteAxisFieldDef = encoding.x;
        }
        else if (fielddef_1.isDiscrete(encoding.y) && fielddef_1.isContinuous(encoding.x)) {
            // horizontal
            discreteAxis = 'y';
            continuousAxis = 'x';
            continuousAxisChannelDef = encoding.x;
            discreteAxisFieldDef = encoding.y;
        }
        else {
            throw new Error('Need one continuous and one discrete axis for 2D boxplots');
        }
    }
    else if (encoding.x && fielddef_1.isContinuous(encoding.x) && encoding.y === undefined) {
        // 1D horizontal
        continuousAxis = 'x';
        continuousAxisChannelDef = encoding.x;
    }
    else if (encoding.x === undefined && encoding.y && fielddef_1.isContinuous(encoding.y)) {
        // 1D vertical
        continuousAxis = 'y';
        continuousAxisChannelDef = encoding.y;
    }
    else {
        throw new Error('Need a continuous axis for 1D boxplots');
    }
    if (continuousAxisChannelDef.aggregate !== undefined && continuousAxisChannelDef.aggregate !== exports.BOXPLOT) {
        throw new Error('Continuous axis should not be aggregated');
    }
    var baseContinuousFieldDef = {
        field: continuousAxisChannelDef.field,
        type: continuousAxisChannelDef.type
    };
    var minFieldDef = tslib_1.__assign({ aggregate: 'min' }, baseContinuousFieldDef);
    var minWithAxisFieldDef = tslib_1.__assign({ axis: continuousAxisChannelDef.axis }, minFieldDef);
    var q1FieldDef = tslib_1.__assign({ aggregate: 'q1' }, baseContinuousFieldDef);
    var medianFieldDef = tslib_1.__assign({ aggregate: 'median' }, baseContinuousFieldDef);
    var q3FieldDef = tslib_1.__assign({ aggregate: 'q3' }, baseContinuousFieldDef);
    var maxFieldDef = tslib_1.__assign({ aggregate: 'max' }, baseContinuousFieldDef);
    var discreteAxisEncodingMixin = discreteAxisFieldDef !== undefined ? (_a = {}, _a[discreteAxis] = discreteAxisFieldDef, _a) : {};
    return tslib_1.__assign({}, outerSpec, { layer: [
            {
                mark: {
                    type: 'rule',
                    role: 'boxWhisker'
                },
                encoding: tslib_1.__assign({}, discreteAxisEncodingMixin, (_b = {}, _b[continuousAxis] = minWithAxisFieldDef, _b[continuousAxis + '2'] = q1FieldDef, _b), nonPositionEncodingWithoutColorSize)
            }, {
                mark: {
                    type: 'rule',
                    role: 'boxWhisker'
                },
                encoding: tslib_1.__assign({}, discreteAxisEncodingMixin, (_c = {}, _c[continuousAxis] = q3FieldDef, _c[continuousAxis + '2'] = maxFieldDef, _c), nonPositionEncodingWithoutColorSize)
            }, {
                mark: {
                    type: 'bar',
                    role: 'box'
                },
                encoding: tslib_1.__assign({}, discreteAxisEncodingMixin, (_d = {}, _d[continuousAxis] = q1FieldDef, _d[continuousAxis + '2'] = q3FieldDef, _d), nonPositionEncodingWithoutSize, midTickAndBarSizeChannelDef)
            }, {
                mark: {
                    type: 'tick',
                    role: 'boxMid'
                },
                encoding: tslib_1.__assign({}, discreteAxisEncodingMixin, (_e = {}, _e[continuousAxis] = medianFieldDef, _e), nonPositionEncoding, midTickAndBarSizeChannelDef, { 'color': { 'value': 'white' } })
            }
        ] });
    var _a, _b, _c, _d, _e;
}
exports.normalizeBoxPlot = normalizeBoxPlot;

},{"./../fielddef":87,"tslib":10}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
exports.ERRORBAR = 'error-bar';
function normalizeErrorBar(spec) {
    var _m = spec.mark, encoding = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "encoding"]);
    var _s = encoding.size, encodingWithoutSize = tslib_1.__rest(encoding, ["size"]);
    var _x2 = encoding.x2, _y2 = encoding.y2, encodingWithoutX2Y2 = tslib_1.__rest(encoding, ["x2", "y2"]);
    var _x = encodingWithoutX2Y2.x, _y = encodingWithoutX2Y2.y, encodingWithoutX_X2_Y_Y2 = tslib_1.__rest(encodingWithoutX2Y2, ["x", "y"]);
    if (!encoding.x2 && !encoding.y2) {
        throw new Error('Neither x2 or y2 provided');
    }
    return tslib_1.__assign({}, outerSpec, { layer: [
            {
                mark: 'rule',
                encoding: encodingWithoutSize
            }, {
                mark: 'tick',
                encoding: encodingWithoutX2Y2
            }, {
                mark: 'tick',
                encoding: encoding.x2 ? tslib_1.__assign({ x: encoding.x2, y: encoding.y }, encodingWithoutX_X2_Y_Y2) : tslib_1.__assign({ x: encoding.x, y: encoding.y2 }, encodingWithoutX_X2_Y_Y2)
            }
        ] });
}
exports.normalizeErrorBar = normalizeErrorBar;

},{"tslib":10}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mark_1 = require("./../mark");
var boxplot_1 = require("./boxplot");
var errorbar_1 = require("./errorbar");
/**
 * Registry index for all composite mark's normalizer
 */
var normalizerRegistry = {};
function add(mark, normalizer) {
    normalizerRegistry[mark] = normalizer;
}
exports.add = add;
function remove(mark) {
    delete normalizerRegistry[mark];
}
exports.remove = remove;
add(boxplot_1.BOXPLOT, boxplot_1.normalizeBoxPlot);
add(errorbar_1.ERRORBAR, errorbar_1.normalizeErrorBar);
/**
 * Transform a unit spec with composite mark into a normal layer spec.
 */
function normalize(
    // This GenericUnitSpec has any as Encoding because unit specs with composite mark can have additional encoding channels.
    spec, config) {
    var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
    var normalizer = normalizerRegistry[mark];
    if (normalizer) {
        return normalizer(spec, config);
    }
    throw new Error("Unregistered composite mark " + mark);
}
exports.normalize = normalize;

},{"./../mark":91,"./boxplot":79,"./errorbar":80}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var legend_1 = require("./legend");
var mark = require("./mark");
var scale_1 = require("./scale");
var selection_1 = require("./selection");
var util_1 = require("./util");
exports.defaultCellConfig = {
    width: 200,
    height: 200,
    fill: 'transparent'
};
exports.defaultFacetCellConfig = {
    stroke: '#ccc',
    strokeWidth: 1
};
exports.defaultFacetConfig = {
    cell: exports.defaultFacetCellConfig
};
exports.defaultOverlayConfig = {
    line: false
};
exports.defaultConfig = {
    padding: 5,
    numberFormat: 's',
    timeFormat: '%b %d, %Y',
    countTitle: 'Number of Records',
    cell: exports.defaultCellConfig,
    mark: mark.defaultMarkConfig,
    area: {},
    bar: mark.defaultBarConfig,
    circle: {},
    line: {},
    point: {},
    rect: {},
    rule: {},
    square: {},
    text: mark.defaultTextConfig,
    tick: mark.defaultTickConfig,
    box: { size: 14 },
    boxWhisker: {},
    boxMid: {},
    overlay: exports.defaultOverlayConfig,
    scale: scale_1.defaultScaleConfig,
    axis: {},
    axisX: {},
    axisY: {},
    axisLeft: {},
    axisRight: {},
    axisTop: {},
    axisBottom: {},
    axisBand: {},
    legend: legend_1.defaultLegendConfig,
    facet: exports.defaultFacetConfig,
    selection: selection_1.defaultConfig,
};
function initConfig(config) {
    return util_1.mergeDeep(util_1.duplicate(exports.defaultConfig), config);
}
exports.initConfig = initConfig;

},{"./legend":89,"./mark":91,"./scale":93,"./selection":94,"./util":102}],83:[function(require,module,exports){
"use strict";
/*
 * Constants and utilities for data.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function isUrlData(data) {
    return !!data['url'];
}
exports.isUrlData = isUrlData;
function isInlineData(data) {
    return !!data['values'];
}
exports.isInlineData = isInlineData;
function isNamedData(data) {
    return !!data['name'];
}
exports.isNamedData = isNamedData;
exports.MAIN = 'main';
exports.RAW = 'raw';

},{}],84:[function(require,module,exports){
"use strict";
// DateTime definition object
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("./log");
var util_1 = require("./util");
/*
 * A designated year that starts on Sunday.
 */
var SUNDAY_YEAR = 2006;
function isDateTime(o) {
    return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||
        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);
}
exports.isDateTime = isDateTime;
exports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
exports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });
exports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
exports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });
function normalizeQuarter(q) {
    if (util_1.isNumber(q)) {
        if (q > 4) {
            log.warn(log.message.invalidTimeUnit('quarter', q));
        }
        // We accept 1-based quarter, so need to readjust to 0-based quarter
        return (q - 1) + '';
    }
    else {
        // Invalid quarter
        throw new Error(log.message.invalidTimeUnit('quarter', q));
    }
}
function normalizeMonth(m) {
    if (util_1.isNumber(m)) {
        // We accept 1-based month, so need to readjust to 0-based month
        return (m - 1) + '';
    }
    else {
        var lowerM = m.toLowerCase();
        var monthIndex = exports.MONTHS.indexOf(lowerM);
        if (monthIndex !== -1) {
            return monthIndex + ''; // 0 for january, ...
        }
        var shortM = lowerM.substr(0, 3);
        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);
        if (shortMonthIndex !== -1) {
            return shortMonthIndex + '';
        }
        // Invalid month
        throw new Error(log.message.invalidTimeUnit('month', m));
    }
}
function normalizeDay(d) {
    if (util_1.isNumber(d)) {
        // mod so that this can be both 0-based where 0 = sunday
        // and 1-based where 7=sunday
        return (d % 7) + '';
    }
    else {
        var lowerD = d.toLowerCase();
        var dayIndex = exports.DAYS.indexOf(lowerD);
        if (dayIndex !== -1) {
            return dayIndex + ''; // 0 for january, ...
        }
        var shortD = lowerD.substr(0, 3);
        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);
        if (shortDayIndex !== -1) {
            return shortDayIndex + '';
        }
        // Invalid day
        throw new Error(log.message.invalidTimeUnit('day', d));
    }
}
function timestamp(d, normalize) {
    var date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date
    // FIXME support UTC
    if (d.day !== undefined) {
        if (util_1.keys(d).length > 1) {
            log.warn(log.message.droppedDay(d));
            d = util_1.duplicate(d);
            delete d.day;
        }
        else {
            // Use a year that has 1/1 as Sunday so we can setDate below
            date.setFullYear(SUNDAY_YEAR);
            var day = normalize ? normalizeDay(d.day) : d.day;
            date.setDate(+day + 1); // +1 since date start at 1 in JS
        }
    }
    if (d.year !== undefined) {
        date.setFullYear(d.year);
    }
    if (d.quarter !== undefined) {
        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;
        date.setMonth(+quarter * 3);
    }
    if (d.month !== undefined) {
        var month = normalize ? normalizeMonth(d.month) : d.month;
        date.setMonth(+month);
    }
    if (d.date !== undefined) {
        date.setDate(d.date);
    }
    if (d.hours !== undefined) {
        date.setHours(d.hours);
    }
    if (d.minutes !== undefined) {
        date.setMinutes(d.minutes);
    }
    if (d.seconds !== undefined) {
        date.setSeconds(d.seconds);
    }
    if (d.milliseconds !== undefined) {
        date.setMilliseconds(d.milliseconds);
    }
    return date.getTime();
}
exports.timestamp = timestamp;
/**
 * Return Vega Expression for a particular date time.
 * @param d
 * @param normalize whether to normalize quarter, month, day.
 */
function dateTimeExpr(d, normalize) {
    if (normalize === void 0) { normalize = false; }
    var units = [];
    if (normalize && d.day !== undefined) {
        if (util_1.keys(d).length > 1) {
            log.warn(log.message.droppedDay(d));
            d = util_1.duplicate(d);
            delete d.day;
        }
    }
    if (d.year !== undefined) {
        units.push(d.year);
    }
    else if (d.day !== undefined) {
        // Set year to 2006 for working with day since January 1 2006 is a Sunday
        units.push(SUNDAY_YEAR);
    }
    else {
        units.push(0);
    }
    if (d.month !== undefined) {
        var month = normalize ? normalizeMonth(d.month) : d.month;
        units.push(month);
    }
    else if (d.quarter !== undefined) {
        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;
        units.push(quarter + '*3');
    }
    else {
        units.push(0); // months start at zero in JS
    }
    if (d.date !== undefined) {
        units.push(d.date);
    }
    else if (d.day !== undefined) {
        // HACK: Day only works as a standalone unit
        // This is only correct because we always set year to 2006 for day
        var day = normalize ? normalizeDay(d.day) : d.day;
        units.push(day + '+1');
    }
    else {
        units.push(1); // Date starts at 1 in JS
    }
    // Note: can't use TimeUnit enum here as importing it will create
    // circular dependency problem!
    for (var _i = 0, _a = ['hours', 'minutes', 'seconds', 'milliseconds']; _i < _a.length; _i++) {
        var timeUnit = _a[_i];
        if (d[timeUnit] !== undefined) {
            units.push(d[timeUnit]);
        }
        else {
            units.push(0);
        }
    }
    return 'datetime(' + units.join(', ') + ')';
}
exports.dateTimeExpr = dateTimeExpr;

},{"./log":90,"./util":102}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("./channel");
var fielddef_1 = require("./fielddef");
var log = require("./log");
var util_1 = require("./util");
function channelHasField(encoding, channel) {
    var channelDef = encoding && encoding[channel];
    if (channelDef) {
        if (util_1.isArray(channelDef)) {
            return util_1.some(channelDef, function (fieldDef) { return !!fieldDef.field; });
        }
        else {
            return fielddef_1.isFieldDef(channelDef);
        }
    }
    return false;
}
exports.channelHasField = channelHasField;
function isAggregate(encoding) {
    return util_1.some(channel_1.CHANNELS, function (channel) {
        if (channelHasField(encoding, channel)) {
            var channelDef = encoding[channel];
            if (util_1.isArray(channelDef)) {
                return util_1.some(channelDef, function (fieldDef) { return !!fieldDef.aggregate; });
            }
            else {
                return fielddef_1.isFieldDef(channelDef) && !!channelDef.aggregate;
            }
        }
        return false;
    });
}
exports.isAggregate = isAggregate;
function normalizeEncoding(encoding, mark) {
    return Object.keys(encoding).reduce(function (normalizedEncoding, channel) {
        if (!channel_1.supportMark(channel, mark)) {
            // Drop unsupported channel
            log.warn(log.message.incompatibleChannel(channel, mark));
            return normalizedEncoding;
        }
        // Drop line's size if the field is aggregated.
        if (channel === 'size' && mark === 'line') {
            var channelDef = encoding[channel];
            if (fielddef_1.isFieldDef(channelDef) && channelDef.aggregate) {
                log.warn(log.message.incompatibleChannel(channel, mark, 'when the field is aggregated.'));
                return normalizedEncoding;
            }
        }
        if (util_1.isArray(encoding[channel])) {
            // Array of fieldDefs for detail channel (or production rule)
            normalizedEncoding[channel] = encoding[channel].reduce(function (channelDefs, channelDef) {
                if (!fielddef_1.isFieldDef(channelDef) && !fielddef_1.isValueDef(channelDef)) {
                    log.warn(log.message.emptyFieldDef(channelDef, channel));
                }
                else {
                    channelDefs.push(fielddef_1.normalize(channelDef, channel));
                }
                return channelDefs;
            }, []);
        }
        else {
            var channelDef = encoding[channel];
            if (!fielddef_1.isFieldDef(channelDef) && !fielddef_1.isValueDef(channelDef)) {
                log.warn(log.message.emptyFieldDef(channelDef, channel));
                return normalizedEncoding;
            }
            normalizedEncoding[channel] = fielddef_1.normalize(channelDef, channel);
        }
        return normalizedEncoding;
    }, {});
}
exports.normalizeEncoding = normalizeEncoding;
function isRanged(encoding) {
    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));
}
exports.isRanged = isRanged;
function fieldDefs(encoding) {
    var arr = [];
    channel_1.CHANNELS.forEach(function (channel) {
        if (channelHasField(encoding, channel)) {
            var channelDef = encoding[channel];
            (util_1.isArray(channelDef) ? channelDef : [channelDef]).forEach(function (fieldDef) {
                arr.push(fieldDef);
            });
        }
    });
    return arr;
}
exports.fieldDefs = fieldDefs;
function forEach(mapping, f, thisArg) {
    if (!mapping) {
        return;
    }
    Object.keys(mapping).forEach(function (c) {
        var channel = c;
        if (util_1.isArray(mapping[channel])) {
            mapping[channel].forEach(function (channelDef) {
                f.call(thisArg, channelDef, channel);
            });
        }
        else {
            f.call(thisArg, mapping[channel], channel);
        }
    });
}
exports.forEach = forEach;
function reduce(mapping, f, init, thisArg) {
    if (!mapping) {
        return init;
    }
    return Object.keys(mapping).reduce(function (r, c) {
        var channel = c;
        if (util_1.isArray(mapping[channel])) {
            return mapping[channel].reduce(function (r1, channelDef) {
                return f.call(thisArg, r1, channelDef, channel);
            }, r);
        }
        else {
            return f.call(thisArg, r, mapping[channel], channel);
        }
    }, init);
}
exports.reduce = reduce;

},{"./channel":16,"./fielddef":87,"./log":90,"./util":102}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],87:[function(require,module,exports){
"use strict";
// utility for a field definition object
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var aggregate_1 = require("./aggregate");
var bin_1 = require("./bin");
var channel_1 = require("./channel");
var log = require("./log");
var timeunit_1 = require("./timeunit");
var type_1 = require("./type");
var util_1 = require("./util");
function isRepeatRef(field) {
    return field && !util_1.isString(field) && 'repeat' in field;
}
exports.isRepeatRef = isRepeatRef;
function isFieldDef(channelDef) {
    return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');
}
exports.isFieldDef = isFieldDef;
function isValueDef(channelDef) {
    return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;
}
exports.isValueDef = isValueDef;
function field(fieldDef, opt) {
    if (opt === void 0) { opt = {}; }
    var field = fieldDef.field;
    var prefix = opt.prefix;
    var suffix = opt.suffix;
    if (isCount(fieldDef)) {
        field = 'count_*';
    }
    else {
        var fn = undefined;
        if (!opt.nofn) {
            if (fieldDef.bin) {
                fn = bin_1.binToString(fieldDef.bin);
                suffix = opt.binSuffix;
            }
            else if (fieldDef.aggregate) {
                fn = String(opt.aggregate || fieldDef.aggregate);
            }
            else if (fieldDef.timeUnit) {
                fn = String(fieldDef.timeUnit);
            }
        }
        if (fn) {
            field = fn + "_" + field;
        }
    }
    if (suffix) {
        field = field + "_" + suffix;
    }
    if (prefix) {
        field = prefix + "_" + field;
    }
    if (opt.expr) {
        field = opt.expr + "[" + util_1.stringValue(field) + "]";
    }
    return field;
}
exports.field = field;
function isDiscrete(fieldDef) {
    switch (fieldDef.type) {
        case 'nominal':
        case 'ordinal':
            return true;
        case 'quantitative':
            return !!fieldDef.bin;
        case 'temporal':
            // TODO: deal with custom scale type case.
            return timeunit_1.isDiscreteByDefault(fieldDef.timeUnit);
    }
    throw new Error(log.message.invalidFieldType(fieldDef.type));
}
exports.isDiscrete = isDiscrete;
function isContinuous(fieldDef) {
    return !isDiscrete(fieldDef);
}
exports.isContinuous = isContinuous;
function isCount(fieldDef) {
    return fieldDef.aggregate === 'count';
}
exports.isCount = isCount;
function title(fieldDef, config) {
    if (isCount(fieldDef)) {
        return config.countTitle;
    }
    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');
    if (fn) {
        return fn.toUpperCase() + '(' + fieldDef.field + ')';
    }
    else {
        return fieldDef.field;
    }
}
exports.title = title;
function defaultType(fieldDef, channel) {
    if (fieldDef.timeUnit) {
        return 'temporal';
    }
    if (fieldDef.bin) {
        return 'quantitative';
    }
    switch (channel_1.rangeType(channel)) {
        case 'continuous':
            return 'quantitative';
        case 'discrete':
            return 'nominal';
        case 'flexible':
            return 'nominal';
        default:
            return 'quantitative';
    }
}
exports.defaultType = defaultType;
/**
 * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.
 */
function normalize(channelDef, channel) {
    // If a fieldDef contains a field, we need type.
    if (isFieldDef(channelDef)) {
        var fieldDef = channelDef;
        // Drop invalid aggregate
        if (fieldDef.aggregate && !aggregate_1.AGGREGATE_OP_INDEX[fieldDef.aggregate]) {
            var aggregate = fieldDef.aggregate, fieldDefWithoutAggregate = tslib_1.__rest(fieldDef, ["aggregate"]);
            log.warn(log.message.invalidAggregate(fieldDef.aggregate));
            fieldDef = fieldDefWithoutAggregate;
        }
        // Normalize bin
        if (fieldDef.bin) {
            var bin = fieldDef.bin;
            if (util_1.isBoolean(bin)) {
                fieldDef = tslib_1.__assign({}, fieldDef, { bin: { maxbins: bin_1.autoMaxBins(channel) } });
            }
            else if (!bin.maxbins && !bin.step) {
                fieldDef = tslib_1.__assign({}, fieldDef, { bin: tslib_1.__assign({}, bin, { maxbins: bin_1.autoMaxBins(channel) }) });
            }
        }
        // Normalize Type
        if (fieldDef.type) {
            var fullType = type_1.getFullName(fieldDef.type);
            if (fieldDef.type !== fullType) {
                // convert short type to full type
                fieldDef = tslib_1.__assign({}, fieldDef, { type: fullType });
            }
        }
        else {
            // If type is empty / invalid, then augment with default type
            var newType = defaultType(fieldDef, channel);
            log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));
            fieldDef = tslib_1.__assign({}, fieldDef, { type: newType });
        }
        var _a = channelCompatibility(fieldDef, channel), compatible = _a.compatible, warning = _a.warning;
        if (!compatible) {
            log.warn(warning);
        }
        return fieldDef;
    }
    return channelDef;
}
exports.normalize = normalize;
var COMPATIBLE = { compatible: true };
function channelCompatibility(fieldDef, channel) {
    switch (channel) {
        case 'row':
        case 'column':
            if (isContinuous(fieldDef) && !fieldDef.timeUnit) {
                // TODO:(https://github.com/vega/vega-lite/issues/2011):
                // with timeUnit it's not always strictly continuous
                return {
                    compatible: false,
                    warning: log.message.facetChannelShouldBeDiscrete(channel)
                };
            }
            return COMPATIBLE;
        case 'x':
        case 'y':
        case 'color':
        case 'text':
        case 'detail':
        case 'tooltip':
            return COMPATIBLE;
        case 'opacity':
        case 'size':
        case 'x2':
        case 'y2':
            if (isDiscrete(fieldDef) && !fieldDef.bin) {
                return {
                    compatible: false,
                    warning: "Channel " + channel + " should not be used with discrete field."
                };
            }
            return COMPATIBLE;
        case 'shape':
            if (fieldDef.type !== 'nominal') {
                return {
                    compatible: false,
                    warning: 'Shape channel should be used with nominal data only'
                };
            }
            return COMPATIBLE;
        case 'order':
            if (fieldDef.type === 'nominal') {
                return {
                    compatible: false,
                    warning: "Channel order is inappropriate for nominal field, which has no inherent order."
                };
            }
            return COMPATIBLE;
    }
    throw new Error('channelCompatability not implemented for channel ' + channel);
}
exports.channelCompatibility = channelCompatibility;

},{"./aggregate":13,"./bin":15,"./channel":16,"./log":90,"./timeunit":98,"./type":101,"./util":102,"tslib":10}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selection_1 = require("./compile/selection/selection");
var datetime_1 = require("./datetime");
var fielddef_1 = require("./fielddef");
var timeunit_1 = require("./timeunit");
var util_1 = require("./util");
function isSelectionFilter(filter) {
    return filter && filter['selection'];
}
exports.isSelectionFilter = isSelectionFilter;
function isEqualFilter(filter) {
    return filter && !!filter.field && filter.equal !== undefined;
}
exports.isEqualFilter = isEqualFilter;
function isRangeFilter(filter) {
    if (filter && filter.field) {
        if (util_1.isArray(filter.range) && filter.range.length === 2) {
            return true;
        }
    }
    return false;
}
exports.isRangeFilter = isRangeFilter;
function isOneOfFilter(filter) {
    return filter && !!filter.field && (util_1.isArray(filter.oneOf) ||
        util_1.isArray(filter.in) // backward compatibility
    );
}
exports.isOneOfFilter = isOneOfFilter;
/**
 * Converts a filter into an expression.
 */
// model is only used for selection filters.
function expression(model, filter) {
    if (util_1.isString(filter)) {
        return filter;
    }
    else if (isSelectionFilter(filter)) {
        var selection = model.getComponent('selection', filter.selection);
        return selection_1.predicate(filter.selection, selection.type, selection.resolve, null, null);
    }
    else {
        var fieldExpr = filter.timeUnit ?
            // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
            // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
            // TODO: support utc
            ('time(' + timeunit_1.fieldExpr(filter.timeUnit, filter.field) + ')') :
            fielddef_1.field(filter, { expr: 'datum' });
        if (isEqualFilter(filter)) {
            return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);
        }
        else if (isOneOfFilter(filter)) {
            // "oneOf" was formerly "in" -- so we need to add backward compatibility
            var oneOf = filter.oneOf || filter['in'];
            return 'indexof([' +
                oneOf.map(function (v) { return valueExpr(v, filter.timeUnit); }).join(',') +
                '], ' + fieldExpr + ') !== -1';
        }
        else if (isRangeFilter(filter)) {
            var lower = filter.range[0];
            var upper = filter.range[1];
            if (lower !== null && upper !== null) {
                return 'inrange(' + fieldExpr + ', ' +
                    valueExpr(lower, filter.timeUnit) + ', ' +
                    valueExpr(upper, filter.timeUnit) + ')';
            }
            else if (lower !== null) {
                return fieldExpr + ' >= ' + lower;
            }
            else if (upper !== null) {
                return fieldExpr + ' <= ' + upper;
            }
        }
    }
    return undefined;
}
exports.expression = expression;
function valueExpr(v, timeUnit) {
    if (datetime_1.isDateTime(v)) {
        var expr = datetime_1.dateTimeExpr(v, true);
        return 'time(' + expr + ')';
    }
    if (timeunit_1.isSingleTimeUnit(timeUnit)) {
        var datetime = {};
        datetime[timeUnit] = v;
        var expr = datetime_1.dateTimeExpr(datetime, true);
        return 'time(' + expr + ')';
    }
    return JSON.stringify(v);
}

},{"./compile/selection/selection":68,"./datetime":84,"./fielddef":87,"./timeunit":98,"./util":102}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultLegendConfig = {
    orient: undefined,
};
exports.LEGEND_PROPERTIES = ['entryPadding', 'format', 'offset', 'orient', 'tickCount', 'title', 'type', 'values', 'zindex'];

},{}],90:[function(require,module,exports){
"use strict";
///<reference path="../typings/vega-util.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Vega-Lite's singleton logger utility.
 */
var vega_util_1 = require("vega-util");
/**
 * Main (default) Vega Logger instance for Vega-Lite
 */
var main = vega_util_1.logger(vega_util_1.Warn);
var current = main;
/**
 * Logger tool for checking if the code throws correct warning
 */
var LocalLogger = (function () {
    function LocalLogger() {
        this.warns = [];
        this.infos = [];
        this.debugs = [];
    }
    LocalLogger.prototype.level = function () {
        return this;
    };
    LocalLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.warns).push.apply(_a, args);
        return this;
        var _a;
    };
    LocalLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.infos).push.apply(_a, args);
        return this;
        var _a;
    };
    LocalLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.debugs).push.apply(_a, args);
        return this;
        var _a;
    };
    return LocalLogger;
}());
exports.LocalLogger = LocalLogger;
function runLocalLogger(f) {
    var localLogger = current = new LocalLogger();
    f(localLogger);
    reset();
}
exports.runLocalLogger = runLocalLogger;
function wrap(f) {
    return function () {
        var logger = current = new LocalLogger();
        f(logger);
        reset();
    };
}
exports.wrap = wrap;
/**
 * Set the singleton logger to be a custom logger
 */
function set(logger) {
    current = logger;
    return current;
}
exports.set = set;
/**
 * Reset the main logger to use the default Vega Logger
 */
function reset() {
    current = main;
    return current;
}
exports.reset = reset;
function warn() {
    var _ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _[_i] = arguments[_i];
    }
    current.warn.apply(current, arguments);
}
exports.warn = warn;
function info() {
    var _ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _[_i] = arguments[_i];
    }
    current.info.apply(current, arguments);
}
exports.info = info;
function debug() {
    var _ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _[_i] = arguments[_i];
    }
    current.debug.apply(current, arguments);
}
exports.debug = debug;
/**
 * Collection of all Vega-Lite Error Messages
 */
var message;
(function (message) {
    message.INVALID_SPEC = 'Invalid spec';
    // REPEAT
    function noSuchRepeatedValue(field) {
        return "Unknown repeated value \"" + field + "\".";
    }
    message.noSuchRepeatedValue = noSuchRepeatedValue;
    // DATA
    function unrecognizedParse(p) {
        return "Unrecognized parse " + p + ".";
    }
    message.unrecognizedParse = unrecognizedParse;
    // TRANSFORMS
    function invalidTransformIgnored(transform) {
        return "Ignoring an invalid transform: " + JSON.stringify(transform) + ".";
    }
    message.invalidTransformIgnored = invalidTransformIgnored;
    // ENCODING & FACET
    function invalidFieldType(type) {
        return "Invalid field type \"" + type + "\"";
    }
    message.invalidFieldType = invalidFieldType;
    function invalidAggregate(aggregate) {
        return "Invalid aggregation operator \"" + aggregate + "\"";
    }
    message.invalidAggregate = invalidAggregate;
    function emptyOrInvalidFieldType(type, channel, newType) {
        return "Invalid field type (" + type + ") for channel " + channel + ", using " + newType + " instead.";
    }
    message.emptyOrInvalidFieldType = emptyOrInvalidFieldType;
    function emptyFieldDef(fieldDef, channel) {
        return "Dropping " + JSON.stringify(fieldDef) + " from channel " + channel + " since it does not contain data field or value.";
    }
    message.emptyFieldDef = emptyFieldDef;
    function incompatibleChannel(channel, markOrFacet, when) {
        return channel + " dropped as it is incompatible with " + markOrFacet + (when ? " when " + when : '') + ".";
    }
    message.incompatibleChannel = incompatibleChannel;
    function facetChannelShouldBeDiscrete(channel) {
        return channel + " encoding should be discrete (ordinal / nominal / binned).";
    }
    message.facetChannelShouldBeDiscrete = facetChannelShouldBeDiscrete;
    function discreteChannelCannotEncode(channel, type) {
        return "Using discrete channel " + channel + " to encode " + type + " field can be misleading as it does not encode " + (type === 'ordinal' ? 'order' : 'magnitude') + ".";
    }
    message.discreteChannelCannotEncode = discreteChannelCannotEncode;
    // Mark
    message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';
    function unclearOrientContinuous(mark) {
        return "Cannot clearly determine orientation for " + mark + " since both x and y channel encode continous fields. In this case, we use vertical by default";
    }
    message.unclearOrientContinuous = unclearOrientContinuous;
    function unclearOrientDiscreteOrEmpty(mark) {
        return "Cannot clearly determine orientation for " + mark + " since both x and y channel encode discrete or empty fields.";
    }
    message.unclearOrientDiscreteOrEmpty = unclearOrientDiscreteOrEmpty;
    function orientOverridden(original, actual) {
        return "Specified orient " + original + " overridden with " + actual;
    }
    message.orientOverridden = orientOverridden;
    // SCALE
    message.CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'custom domain scale cannot be unioned with default field-based domain';
    function cannotUseScalePropertyWithNonColor(prop) {
        return "Cannot use " + prop + " with non-color channel.";
    }
    message.cannotUseScalePropertyWithNonColor = cannotUseScalePropertyWithNonColor;
    function unaggregateDomainHasNoEffectForRawField(fieldDef) {
        return "Using unaggregated domain with raw field has no effect (" + JSON.stringify(fieldDef) + ").";
    }
    message.unaggregateDomainHasNoEffectForRawField = unaggregateDomainHasNoEffectForRawField;
    function unaggregateDomainWithNonSharedDomainOp(aggregate) {
        return "Unaggregated domain not applicable for " + aggregate + " since it produces values outside the origin domain of the source data.";
    }
    message.unaggregateDomainWithNonSharedDomainOp = unaggregateDomainWithNonSharedDomainOp;
    function unaggregatedDomainWithLogScale(fieldDef) {
        return "Unaggregated domain is currently unsupported for log scale (" + JSON.stringify(fieldDef) + ").";
    }
    message.unaggregatedDomainWithLogScale = unaggregatedDomainWithLogScale;
    message.CANNOT_USE_RANGE_WITH_POSITION = 'Cannot use custom range with x or y channel.  Please customize width, height, padding, or rangeStep instead.';
    message.CANNOT_USE_PADDING_WITH_FACET = 'Cannot use padding with facet\'s scale.  Please use spacing instead.';
    function cannotUseRangePropertyWithFacet(propName) {
        return "Cannot use custom " + propName + " with row or column channel. Please use width, height, or spacing instead.";
    }
    message.cannotUseRangePropertyWithFacet = cannotUseRangePropertyWithFacet;
    function rangeStepDropped(channel) {
        return "rangeStep for " + channel + " is dropped as top-level " + (channel === 'x' ? 'width' : 'height') + " is provided.";
    }
    message.rangeStepDropped = rangeStepDropped;
    function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {
        return "Channel " + channel + " does not work with " + scaleType + " scale. We are using " + defaultScaleType + " scale instead.";
    }
    message.scaleTypeNotWorkWithChannel = scaleTypeNotWorkWithChannel;
    function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {
        return "FieldDef does not work with " + scaleType + " scale. We are using " + defaultScaleType + " scale instead.";
    }
    message.scaleTypeNotWorkWithFieldDef = scaleTypeNotWorkWithFieldDef;
    function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {
        return channel + "-scale's \"" + propName + "\" is dropped as it does not work with " + scaleType + " scale.";
    }
    message.scalePropertyNotWorkWithScaleType = scalePropertyNotWorkWithScaleType;
    function scaleTypeNotWorkWithMark(mark, scaleType) {
        return "Scale type \"" + scaleType + "\" does not work with mark " + mark + ".";
    }
    message.scaleTypeNotWorkWithMark = scaleTypeNotWorkWithMark;
    function independentScaleMeansIndependentGuide(channel) {
        return "Setting the scale to be independent for " + channel + " means we also have to set the guide (axis or legend) to be independent.";
    }
    message.independentScaleMeansIndependentGuide = independentScaleMeansIndependentGuide;
    message.INVAID_DOMAIN = 'Invalid scale domain';
    message.UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';
    // AXIS
    message.INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';
    // STACK
    function cannotStackRangedMark(channel) {
        return "Cannot stack " + channel + " if there is already " + channel + "2";
    }
    message.cannotStackRangedMark = cannotStackRangedMark;
    function cannotStackNonLinearScale(scaleType) {
        return "Cannot stack non-linear scale (" + scaleType + ")";
    }
    message.cannotStackNonLinearScale = cannotStackNonLinearScale;
    function cannotStackNonSummativeAggregate(aggregate) {
        return "Cannot stack when the aggregate function is non-summative (" + aggregate + ")";
    }
    message.cannotStackNonSummativeAggregate = cannotStackNonSummativeAggregate;
    // TIMEUNIT
    function invalidTimeUnit(unitName, value) {
        return "Invalid " + unitName + ": " + value;
    }
    message.invalidTimeUnit = invalidTimeUnit;
    function dayReplacedWithDate(fullTimeUnit) {
        return "Time unit \"" + fullTimeUnit + "\" is not supported. We are replacing it with " + fullTimeUnit.replace('day', 'date') + ".";
    }
    message.dayReplacedWithDate = dayReplacedWithDate;
    function droppedDay(d) {
        return "Dropping day from datetime " + JSON.stringify(d) + " as day cannot be combined with other units.";
    }
    message.droppedDay = droppedDay;
})(message = exports.message || (exports.message = {}));

},{"vega-util":106}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var Mark;
(function (Mark) {
    Mark.AREA = 'area';
    Mark.BAR = 'bar';
    Mark.LINE = 'line';
    Mark.POINT = 'point';
    Mark.RECT = 'rect';
    Mark.RULE = 'rule';
    Mark.TEXT = 'text';
    Mark.TICK = 'tick';
    Mark.CIRCLE = 'circle';
    Mark.SQUARE = 'square';
})(Mark = exports.Mark || (exports.Mark = {}));
exports.AREA = Mark.AREA;
exports.BAR = Mark.BAR;
exports.LINE = Mark.LINE;
exports.POINT = Mark.POINT;
exports.TEXT = Mark.TEXT;
exports.TICK = Mark.TICK;
exports.RECT = Mark.RECT;
exports.RULE = Mark.RULE;
exports.CIRCLE = Mark.CIRCLE;
exports.SQUARE = Mark.SQUARE;
exports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RECT, exports.RULE, exports.CIRCLE, exports.SQUARE];
function isMarkDef(mark) {
    return mark['type'];
}
exports.isMarkDef = isMarkDef;
var PRIMITIVE_MARK_INDEX = util_1.toSet(exports.PRIMITIVE_MARKS);
function isPrimitiveMark(mark) {
    var markType = isMarkDef(mark) ? mark.type : mark;
    return markType in PRIMITIVE_MARK_INDEX;
}
exports.isPrimitiveMark = isPrimitiveMark;
exports.STROKE_CONFIG = ['stroke', 'strokeWidth',
    'strokeDash', 'strokeDashOffset', 'strokeOpacity'];
exports.FILL_CONFIG = ['fill', 'fillOpacity'];
exports.FILL_STROKE_CONFIG = [].concat(exports.STROKE_CONFIG, exports.FILL_CONFIG);
exports.defaultMarkConfig = {
    color: '#4c78a8',
};
exports.defaultBarConfig = {
    binSpacing: 1,
    continuousBandSize: 2
};
exports.defaultTextConfig = {
    baseline: 'middle',
};
exports.defaultTickConfig = {
    thickness: 1
};

},{"./util":102}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("./channel");
var log = require("./log");
var util_1 = require("./util");
function initLayerResolve(resolve) {
    var out = {};
    channel_1.UNIT_SCALE_CHANNELS.forEach(function (channel) {
        var res = resolve[channel] || { scale: 'shared' };
        var guide = util_1.contains(channel_1.SPATIAL_SCALE_CHANNELS, channel) ? 'axis' : 'legend';
        if (res.scale === 'independent' && (res['axis'] === 'shared' || res['legend'] === 'shared')) {
            log.warn(log.message.independentScaleMeansIndependentGuide(channel));
        }
        out[channel] = (_a = {
                scale: res.scale || 'shared'
            },
            _a[guide] = res.scale === 'independent' ? 'independent' : (res[guide] || 'shared'),
            _a);
        var _a;
    });
    return out;
}
exports.initLayerResolve = initLayerResolve;

},{"./channel":16,"./log":90,"./util":102}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("./log");
var util_1 = require("./util");
var ScaleType;
(function (ScaleType) {
    // Continuous - Quantitative
    ScaleType.LINEAR = 'linear';
    ScaleType.BIN_LINEAR = 'bin-linear';
    ScaleType.LOG = 'log';
    ScaleType.POW = 'pow';
    ScaleType.SQRT = 'sqrt';
    // Continuous - Time
    ScaleType.TIME = 'time';
    ScaleType.UTC = 'utc';
    // sequential
    ScaleType.SEQUENTIAL = 'sequential';
    // Quantile, Quantize, threshold
    ScaleType.QUANTILE = 'quantile';
    ScaleType.QUANTIZE = 'quantize';
    ScaleType.THRESHOLD = 'threshold';
    ScaleType.ORDINAL = 'ordinal';
    ScaleType.BIN_ORDINAL = 'bin-ordinal';
    ScaleType.POINT = 'point';
    ScaleType.BAND = 'band';
})(ScaleType = exports.ScaleType || (exports.ScaleType = {}));
exports.SCALE_TYPES = [
    // Continuous - Quantitative
    'linear', 'bin-linear', 'log', 'pow', 'sqrt',
    // Continuous - Time
    'time', 'utc',
    // Sequential
    'sequential',
    // Discrete
    'ordinal', 'bin-ordinal', 'point', 'band',
];
exports.CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc'];
var CONTINUOUS_TO_CONTINUOUS_INDEX = util_1.toSet(exports.CONTINUOUS_TO_CONTINUOUS_SCALES);
exports.CONTINUOUS_DOMAIN_SCALES = exports.CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);
var CONTINUOUS_DOMAIN_INDEX = util_1.toSet(exports.CONTINUOUS_DOMAIN_SCALES);
exports.DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];
var DISCRETE_DOMAIN_INDEX = util_1.toSet(exports.DISCRETE_DOMAIN_SCALES);
var BIN_SCALES_INDEX = util_1.toSet(['bin-linear', 'bin-ordinal']);
exports.TIME_SCALE_TYPES = ['time', 'utc'];
function hasDiscreteDomain(type) {
    return type in DISCRETE_DOMAIN_INDEX;
}
exports.hasDiscreteDomain = hasDiscreteDomain;
function isBinScale(type) {
    return type in BIN_SCALES_INDEX;
}
exports.isBinScale = isBinScale;
function hasContinuousDomain(type) {
    return type in CONTINUOUS_DOMAIN_INDEX;
}
exports.hasContinuousDomain = hasContinuousDomain;
function isContinuousToContinuous(type) {
    return type in CONTINUOUS_TO_CONTINUOUS_INDEX;
}
exports.isContinuousToContinuous = isContinuousToContinuous;
exports.defaultScaleConfig = {
    round: true,
    textXRangeStep: 90,
    rangeStep: 21,
    pointPadding: 0.5,
    bandPaddingInner: 0.1,
    facetSpacing: 16,
    minFontSize: 8,
    maxFontSize: 40,
    minOpacity: 0.3,
    maxOpacity: 0.8,
    // FIXME: revise if these *can* become ratios of rangeStep
    minSize: 9,
    minStrokeWidth: 1,
    maxStrokeWidth: 4,
    shapes: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']
};
function isExtendedScheme(scheme) {
    return scheme && !!scheme['name'];
}
exports.isExtendedScheme = isExtendedScheme;
function isSelectionDomain(domain) {
    return domain && domain['selection'];
}
exports.isSelectionDomain = isSelectionDomain;
exports.SCALE_PROPERTIES = [
    'type', 'domain', 'range', 'round', 'rangeStep', 'scheme', 'padding', 'paddingInner', 'paddingOuter', 'clamp', 'nice',
    'exponent', 'zero', 'interpolate'
];
function scaleTypeSupportProperty(scaleType, propName) {
    switch (propName) {
        case 'type':
        case 'domain':
        case 'range':
        case 'scheme':
            return true;
        case 'interpolate':
            return util_1.contains(['linear', 'bin-linear', 'pow', 'log', 'sqrt', 'utc', 'time'], scaleType);
        case 'round':
            return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';
        case 'rangeStep':
        case 'padding':
        case 'paddingOuter':
            return util_1.contains(['point', 'band'], scaleType);
        case 'paddingInner':
            return scaleType === 'band';
        case 'clamp':
            return isContinuousToContinuous(scaleType) || scaleType === 'sequential';
        case 'nice':
            return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType === 'quantize';
        case 'exponent':
            return scaleType === 'pow' || scaleType === 'log';
        case 'zero':
            // TODO: what about quantize, threshold?
            return scaleType === 'bin-ordinal' || (!hasDiscreteDomain(scaleType) && !util_1.contains(['log', 'time', 'utc', 'bin-linear'], scaleType));
    }
    /* istanbul ignore next: should never reach here*/
    throw new Error("Invalid scale property " + propName + ".");
}
exports.scaleTypeSupportProperty = scaleTypeSupportProperty;
/**
 * Returns undefined if the input channel supports the input scale property name
 */
function channelScalePropertyIncompatability(channel, propName) {
    switch (propName) {
        case 'range':
            // User should not customize range for position and facet channel directly.
            if (channel === 'x' || channel === 'y') {
                return log.message.CANNOT_USE_RANGE_WITH_POSITION;
            }
            if (channel === 'row' || channel === 'column') {
                return log.message.cannotUseRangePropertyWithFacet('range');
            }
            return undefined; // GOOD!
        // band / point
        case 'rangeStep':
            if (channel === 'row' || channel === 'column') {
                return log.message.cannotUseRangePropertyWithFacet('rangeStep');
            }
            return undefined; // GOOD!
        case 'padding':
        case 'paddingInner':
        case 'paddingOuter':
            if (channel === 'row' || channel === 'column') {
                /*
                 * We do not use d3 scale's padding for row/column because padding there
                 * is a ratio ([0, 1]) and it causes the padding to be decimals.
                 * Therefore, we manually calculate "spacing" in the layout by ourselves.
                 */
                return log.message.CANNOT_USE_PADDING_WITH_FACET;
            }
            return undefined; // GOOD!
        case 'interpolate':
        case 'scheme':
            if (channel !== 'color') {
                return log.message.cannotUseScalePropertyWithNonColor(channel);
            }
            return undefined;
        case 'type':
        case 'domain':
        case 'round':
        case 'clamp':
        case 'exponent':
        case 'nice':
        case 'zero':
            // These channel do not have strict requirement
            return undefined; // GOOD!
    }
    /* istanbul ignore next: it should never reach here */
    throw new Error('Invalid scale property "${propName}".');
}
exports.channelScalePropertyIncompatability = channelScalePropertyIncompatability;

},{"./log":90,"./util":102}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = {
    single: { on: 'click', fields: ['_id'], resolve: 'global' },
    multi: { on: 'click', fields: ['_id'], toggle: 'event.shiftKey', resolve: 'global' },
    interval: {
        on: '[mousedown, window:mouseup] > window:mousemove!',
        encodings: ['x', 'y'],
        translate: '[mousedown, window:mouseup] > window:mousemove!',
        zoom: 'wheel',
        resolve: 'global'
    }
};

},{}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isSortField(sort) {
    return !!sort && !!sort['field'] && !!sort['op'];
}
exports.isSortField = isSortField;

},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("./channel");
var compositeMark = require("./compositemark");
var encoding_1 = require("./encoding");
var vlEncoding = require("./encoding");
var log = require("./log");
var mark_1 = require("./mark");
var stack_1 = require("./stack");
var util_1 = require("./util");
/* Custom type guards */
function isFacetSpec(spec) {
    return spec['facet'] !== undefined;
}
exports.isFacetSpec = isFacetSpec;
function isUnitSpec(spec) {
    return !!spec['mark'];
}
exports.isUnitSpec = isUnitSpec;
function isLayerSpec(spec) {
    return spec['layer'] !== undefined;
}
exports.isLayerSpec = isLayerSpec;
function isRepeatSpec(spec) {
    return spec['repeat'] !== undefined;
}
exports.isRepeatSpec = isRepeatSpec;
function isConcatSpec(spec) {
    return isVConcatSpec(spec) || isHConcatSpec(spec);
}
exports.isConcatSpec = isConcatSpec;
function isVConcatSpec(spec) {
    return spec['vconcat'] !== undefined;
}
exports.isVConcatSpec = isVConcatSpec;
function isHConcatSpec(spec) {
    return spec['hconcat'] !== undefined;
}
exports.isHConcatSpec = isHConcatSpec;
/**
 * Decompose extended unit specs into composition of pure unit specs.
 */
// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize
function normalize(spec, config) {
    if (isFacetSpec(spec)) {
        return normalizeFacet(spec, config);
    }
    if (isLayerSpec(spec)) {
        return normalizeLayer(spec, config);
    }
    if (isRepeatSpec(spec)) {
        return normalizeRepeat(spec, spec.config);
    }
    if (isVConcatSpec(spec)) {
        return normalizeVConcat(spec, spec.config);
    }
    if (isHConcatSpec(spec)) {
        return normalizeHConcat(spec, spec.config);
    }
    if (isUnitSpec(spec)) {
        var hasRow = encoding_1.channelHasField(spec.encoding, channel_1.ROW);
        var hasColumn = encoding_1.channelHasField(spec.encoding, channel_1.COLUMN);
        if (hasRow || hasColumn) {
            return normalizeFacetedUnit(spec, config);
        }
        return normalizeNonFacetUnit(spec, config);
    }
    throw new Error(log.message.INVALID_SPEC);
}
exports.normalize = normalize;
function normalizeNonFacet(spec, config) {
    if (isLayerSpec(spec)) {
        return normalizeLayer(spec, config);
    }
    if (isRepeatSpec(spec)) {
        return normalizeRepeat(spec, config);
    }
    return normalizeNonFacetUnit(spec, config);
}
function normalizeNonFacetWithRepeat(spec, config) {
    if (isLayerSpec(spec)) {
        return normalizeLayer(spec, config);
    }
    if (isRepeatSpec(spec)) {
        return normalizeRepeat(spec, config);
    }
    return normalizeNonFacetUnit(spec, config);
}
function normalizeFacet(spec, config) {
    var subspec = spec.spec, rest = tslib_1.__rest(spec, ["spec"]);
    return tslib_1.__assign({}, rest, { spec: normalizeNonFacet(subspec, config) });
}
function normalizeLayer(spec, config) {
    var layer = spec.layer, rest = tslib_1.__rest(spec, ["layer"]);
    return tslib_1.__assign({}, rest, { layer: layer.map(function (subspec) { return isLayerSpec(subspec) ? normalizeLayer(subspec, config) : normalizeNonFacetUnit(subspec, config); }) });
}
function normalizeRepeat(spec, config) {
    var subspec = spec.spec, rest = tslib_1.__rest(spec, ["spec"]);
    return tslib_1.__assign({}, rest, { spec: normalizeNonFacetWithRepeat(subspec, config) });
}
function normalizeVConcat(spec, config) {
    var vconcat = spec.vconcat, rest = tslib_1.__rest(spec, ["vconcat"]);
    return tslib_1.__assign({}, rest, { vconcat: vconcat.map(function (subspec) { return normalizeNonFacet(subspec, config); }) });
}
function normalizeHConcat(spec, config) {
    var hconcat = spec.hconcat, rest = tslib_1.__rest(spec, ["hconcat"]);
    return tslib_1.__assign({}, rest, { hconcat: hconcat.map(function (subspec) { return normalizeNonFacet(subspec, config); }) });
}
function normalizeFacetedUnit(spec, config) {
    // New encoding in the inside spec should not contain row / column
    // as row/column should be moved to facet
    var _a = spec.encoding, row = _a.row, column = _a.column, encoding = tslib_1.__rest(_a, ["row", "column"]);
    // Mark and encoding should be moved into the inner spec
    var mark = spec.mark, selection = spec.selection, _ = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "selection", "encoding"]);
    return tslib_1.__assign({}, outerSpec, { facet: tslib_1.__assign({}, (row ? { row: row } : {}), (column ? { column: column } : {})), spec: normalizeNonFacetUnit(tslib_1.__assign({ mark: mark,
            encoding: encoding }, (selection ? { selection: selection } : {})), config) });
}
function isNonFacetUnitSpecWithPrimitiveMark(spec) {
    return mark_1.isPrimitiveMark(spec.mark);
}
function normalizeNonFacetUnit(spec, config) {
    if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {
        // TODO: thoroughly test
        if (encoding_1.isRanged(spec.encoding)) {
            return normalizeRangedUnit(spec);
        }
        var overlayConfig = config && config.overlay;
        var overlayWithLine = overlayConfig && spec.mark === mark_1.AREA &&
            util_1.contains(['linepoint', 'line'], overlayConfig.area);
        var overlayWithPoint = overlayConfig && ((overlayConfig.line && spec.mark === mark_1.LINE) ||
            (overlayConfig.area === 'linepoint' && spec.mark === mark_1.AREA));
        // TODO: consider moving this to become another case of compositeMark
        if (overlayWithPoint || overlayWithLine) {
            return normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config);
        }
        return spec; // Nothing to normalize
    }
    else {
        return compositeMark.normalize(spec, config);
    }
}
function normalizeRangedUnit(spec) {
    var hasX = encoding_1.channelHasField(spec.encoding, channel_1.X);
    var hasY = encoding_1.channelHasField(spec.encoding, channel_1.Y);
    var hasX2 = encoding_1.channelHasField(spec.encoding, channel_1.X2);
    var hasY2 = encoding_1.channelHasField(spec.encoding, channel_1.Y2);
    if ((hasX2 && !hasX) || (hasY2 && !hasY)) {
        var normalizedSpec = util_1.duplicate(spec);
        if (hasX2 && !hasX) {
            normalizedSpec.encoding.x = normalizedSpec.encoding.x2;
            delete normalizedSpec.encoding.x2;
        }
        if (hasY2 && !hasY) {
            normalizedSpec.encoding.y = normalizedSpec.encoding.y2;
            delete normalizedSpec.encoding.y2;
        }
        return normalizedSpec;
    }
    return spec;
}
// FIXME(#1804): re-design this
function normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config) {
    var mark = spec.mark, encoding = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "encoding"]);
    var layer = [{ mark: mark, encoding: encoding }];
    // Need to copy stack config to overlayed layer
    var stackProps = stack_1.stack(mark, encoding, config ? config.stack : undefined);
    var overlayEncoding = encoding;
    if (stackProps) {
        var stackFieldChannel = stackProps.fieldChannel, offset = stackProps.offset;
        overlayEncoding = tslib_1.__assign({}, encoding, (_a = {}, _a[stackFieldChannel] = tslib_1.__assign({}, encoding[stackFieldChannel], (offset ? { stack: offset } : {})), _a));
    }
    if (overlayWithLine) {
        layer.push({
            mark: {
                type: 'line',
                role: 'lineOverlay'
            },
            encoding: overlayEncoding
        });
    }
    if (overlayWithPoint) {
        layer.push({
            mark: {
                type: 'point',
                filled: true,
                role: 'pointOverlay'
            },
            encoding: overlayEncoding
        });
    }
    return tslib_1.__assign({}, outerSpec, { layer: layer });
    var _a;
}
// TODO: add vl.spec.validate & move stuff from vl.validate to here
/* Accumulate non-duplicate fieldDefs in a dictionary */
function accumulate(dict, fieldDefs) {
    fieldDefs.forEach(function (fieldDef) {
        // Consider only pure fieldDef properties (ignoring scale, axis, legend)
        var pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce(function (f, key) {
            if (fieldDef[key] !== undefined) {
                f[key] = fieldDef[key];
            }
            return f;
        }, {});
        var key = util_1.hash(pureFieldDef);
        dict[key] = dict[key] || fieldDef;
    });
    return dict;
}
/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */
function fieldDefIndex(spec, dict) {
    if (dict === void 0) { dict = {}; }
    // TODO: Support repeat and concat
    if (isLayerSpec(spec)) {
        spec.layer.forEach(function (layer) {
            if (isUnitSpec(layer)) {
                accumulate(dict, vlEncoding.fieldDefs(layer.encoding));
            }
            else {
                fieldDefIndex(layer, dict);
            }
        });
    }
    else if (isFacetSpec(spec)) {
        accumulate(dict, vlEncoding.fieldDefs(spec.facet));
        fieldDefIndex(spec.spec, dict);
    }
    else if (isRepeatSpec(spec)) {
        accumulate(dict, vlEncoding.fieldDefs(spec.spec));
        fieldDefIndex(spec.spec, dict);
    }
    else if (isConcatSpec(spec)) {
        var childSpec = isVConcatSpec(spec) ? spec.vconcat : spec.hconcat;
        childSpec.forEach(function (child) {
            if (isUnitSpec(child)) {
                accumulate(dict, vlEncoding.fieldDefs(child.encoding));
            }
            else {
                fieldDefIndex(child, dict);
            }
        });
    }
    else {
        accumulate(dict, vlEncoding.fieldDefs(spec.encoding));
    }
    return dict;
}
/* Returns all non-duplicate fieldDefs in a spec in a flat array */
function fieldDefs(spec) {
    return util_1.vals(fieldDefIndex(spec));
}
exports.fieldDefs = fieldDefs;
function isStacked(spec, config) {
    config = config || spec.config;
    if (mark_1.isPrimitiveMark(spec.mark)) {
        return stack_1.stack(spec.mark, spec.encoding, config ? config.stack : undefined) !== null;
    }
    return false;
}
exports.isStacked = isStacked;

},{"./channel":16,"./compositemark":81,"./encoding":85,"./log":90,"./mark":91,"./stack":97,"./util":102,"tslib":10}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("./log");
var aggregate_1 = require("./aggregate");
var channel_1 = require("./channel");
var encoding_1 = require("./encoding");
var fielddef_1 = require("./fielddef");
var mark_1 = require("./mark");
var scale_1 = require("./scale");
var util_1 = require("./util");
exports.STACKABLE_MARKS = [mark_1.BAR, mark_1.AREA, mark_1.RULE, mark_1.POINT, mark_1.CIRCLE, mark_1.SQUARE, mark_1.LINE, mark_1.TEXT, mark_1.TICK];
exports.STACK_BY_DEFAULT_MARKS = [mark_1.BAR, mark_1.AREA];
// Note: CompassQL uses this method and only pass in required properties of each argument object.
// If required properties change, make sure to update CompassQL.
function stack(m, encoding, stackConfig) {
    var mark = mark_1.isMarkDef(m) ? m.type : m;
    // Should have stackable mark
    if (!util_1.contains(exports.STACKABLE_MARKS, mark)) {
        return null;
    }
    // Should be aggregate plot
    if (!encoding_1.isAggregate(encoding)) {
        return null;
    }
    // Should have grouping level of detail
    var stackBy = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {
        if (encoding_1.channelHasField(encoding, channel)) {
            var channelDef = encoding[channel];
            (util_1.isArray(channelDef) ? channelDef : [channelDef]).forEach(function (fieldDef) {
                if (fielddef_1.isFieldDef(fieldDef) && !fieldDef.aggregate) {
                    sc.push({
                        channel: channel,
                        fieldDef: fieldDef
                    });
                }
            });
        }
        return sc;
    }, []);
    if (stackBy.length === 0) {
        return null;
    }
    // Has only one aggregate axis
    var hasXField = fielddef_1.isFieldDef(encoding.x);
    var hasYField = fielddef_1.isFieldDef(encoding.y);
    var xIsAggregate = fielddef_1.isFieldDef(encoding.x) && !!encoding.x.aggregate;
    var yIsAggregate = fielddef_1.isFieldDef(encoding.y) && !!encoding.y.aggregate;
    if (xIsAggregate !== yIsAggregate) {
        var fieldChannel = xIsAggregate ? channel_1.X : channel_1.Y;
        var fieldDef = encoding[fieldChannel];
        var fieldChannelAggregate = fieldDef.aggregate;
        var fieldChannelScale = fieldDef.scale;
        var stackOffset = null;
        if (fieldDef.stack !== undefined) {
            stackOffset = fieldDef.stack;
        }
        else if (util_1.contains(exports.STACK_BY_DEFAULT_MARKS, mark)) {
            // Bar and Area with sum ops are automatically stacked by default
            stackOffset = stackConfig === undefined ? 'zero' : stackConfig;
        }
        else {
            stackOffset = stackConfig;
        }
        if (!stackOffset || stackOffset === 'none') {
            return null;
        }
        // If stacked, check if it qualifies for stacking (and log warning if not qualified.)
        if (fieldChannelScale && fieldChannelScale.type && fieldChannelScale.type !== scale_1.ScaleType.LINEAR) {
            log.warn(log.message.cannotStackNonLinearScale(fieldChannelScale.type));
            return null;
        }
        if (encoding_1.channelHasField(encoding, fieldChannel === channel_1.X ? channel_1.X2 : channel_1.Y2)) {
            log.warn(log.message.cannotStackRangedMark(fieldChannel));
            return null;
        }
        if (!util_1.contains(aggregate_1.SUM_OPS, fieldChannelAggregate)) {
            log.warn(log.message.cannotStackNonSummativeAggregate(fieldChannelAggregate));
            return null;
        }
        return {
            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),
            fieldChannel: fieldChannel,
            stackBy: stackBy,
            offset: stackOffset
        };
    }
    return null;
}
exports.stack = stack;

},{"./aggregate":13,"./channel":16,"./encoding":85,"./fielddef":87,"./log":90,"./mark":91,"./scale":93,"./util":102}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var datetime_1 = require("./datetime");
var log = require("./log");
var util_1 = require("./util");
var TimeUnit;
(function (TimeUnit) {
    TimeUnit.YEAR = 'year';
    TimeUnit.MONTH = 'month';
    TimeUnit.DAY = 'day';
    TimeUnit.DATE = 'date';
    TimeUnit.HOURS = 'hours';
    TimeUnit.MINUTES = 'minutes';
    TimeUnit.SECONDS = 'seconds';
    TimeUnit.MILLISECONDS = 'milliseconds';
    TimeUnit.YEARMONTH = 'yearmonth';
    TimeUnit.YEARMONTHDATE = 'yearmonthdate';
    TimeUnit.YEARMONTHDATEHOURS = 'yearmonthdatehours';
    TimeUnit.YEARMONTHDATEHOURSMINUTES = 'yearmonthdatehoursminutes';
    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS = 'yearmonthdatehoursminutesseconds';
    // MONTHDATE always include 29 February since we use year 0th (which is a leap year);
    TimeUnit.MONTHDATE = 'monthdate';
    TimeUnit.HOURSMINUTES = 'hoursminutes';
    TimeUnit.HOURSMINUTESSECONDS = 'hoursminutesseconds';
    TimeUnit.MINUTESSECONDS = 'minutesseconds';
    TimeUnit.SECONDSMILLISECONDS = 'secondsmilliseconds';
    TimeUnit.QUARTER = 'quarter';
    TimeUnit.YEARQUARTER = 'yearquarter';
    TimeUnit.QUARTERMONTH = 'quartermonth';
    TimeUnit.YEARQUARTERMONTH = 'yearquartermonth';
})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));
/** Time Unit that only corresponds to only one part of Date objects. */
exports.SINGLE_TIMEUNITS = [
    TimeUnit.YEAR,
    TimeUnit.QUARTER,
    TimeUnit.MONTH,
    TimeUnit.DAY,
    TimeUnit.DATE,
    TimeUnit.HOURS,
    TimeUnit.MINUTES,
    TimeUnit.SECONDS,
    TimeUnit.MILLISECONDS,
];
var SINGLE_TIMEUNIT_INDEX = exports.SINGLE_TIMEUNITS.reduce(function (d, timeUnit) {
    d[timeUnit] = true;
    return d;
}, {});
function isSingleTimeUnit(timeUnit) {
    return !!SINGLE_TIMEUNIT_INDEX[timeUnit];
}
exports.isSingleTimeUnit = isSingleTimeUnit;
/**
 * Converts a date to only have the measurements relevant to the specified unit
 * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'
 * Note: the base date is Jan 01 1900 00:00:00
 */
function convert(unit, date) {
    var result = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date
    exports.SINGLE_TIMEUNITS.forEach(function (singleUnit) {
        if (containsTimeUnit(unit, singleUnit)) {
            switch (singleUnit) {
                case TimeUnit.DAY:
                    throw new Error('Cannot convert to TimeUnits containing \'day\'');
                case TimeUnit.YEAR:
                    result.setFullYear(date.getFullYear());
                    break;
                case TimeUnit.QUARTER:
                    // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)
                    result.setMonth((Math.floor(date.getMonth() / 3)) * 3);
                    break;
                case TimeUnit.MONTH:
                    result.setMonth(date.getMonth());
                    break;
                case TimeUnit.DATE:
                    result.setDate(date.getDate());
                    break;
                case TimeUnit.HOURS:
                    result.setHours(date.getHours());
                    break;
                case TimeUnit.MINUTES:
                    result.setMinutes(date.getMinutes());
                    break;
                case TimeUnit.SECONDS:
                    result.setSeconds(date.getSeconds());
                    break;
                case TimeUnit.MILLISECONDS:
                    result.setMilliseconds(date.getMilliseconds());
                    break;
            }
        }
    });
    return result;
}
exports.convert = convert;
exports.MULTI_TIMEUNITS = [
    TimeUnit.YEARQUARTER,
    TimeUnit.YEARQUARTERMONTH,
    TimeUnit.YEARMONTH,
    TimeUnit.YEARMONTHDATE,
    TimeUnit.YEARMONTHDATEHOURS,
    TimeUnit.YEARMONTHDATEHOURSMINUTES,
    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,
    TimeUnit.QUARTERMONTH,
    TimeUnit.HOURSMINUTES,
    TimeUnit.HOURSMINUTESSECONDS,
    TimeUnit.MINUTESSECONDS,
    TimeUnit.SECONDSMILLISECONDS,
];
var MULTI_TIMEUNIT_INDEX = exports.MULTI_TIMEUNITS.reduce(function (d, timeUnit) {
    d[timeUnit] = true;
    return d;
}, {});
function isMultiTimeUnit(timeUnit) {
    return !!MULTI_TIMEUNIT_INDEX[timeUnit];
}
exports.isMultiTimeUnit = isMultiTimeUnit;
exports.TIMEUNITS = [
    TimeUnit.YEAR,
    TimeUnit.QUARTER,
    TimeUnit.MONTH,
    TimeUnit.DAY,
    TimeUnit.DATE,
    TimeUnit.HOURS,
    TimeUnit.MINUTES,
    TimeUnit.SECONDS,
    TimeUnit.MILLISECONDS,
    TimeUnit.YEARQUARTER,
    TimeUnit.YEARQUARTERMONTH,
    TimeUnit.YEARMONTH,
    TimeUnit.YEARMONTHDATE,
    TimeUnit.YEARMONTHDATEHOURS,
    TimeUnit.YEARMONTHDATEHOURSMINUTES,
    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,
    TimeUnit.QUARTERMONTH,
    TimeUnit.HOURSMINUTES,
    TimeUnit.HOURSMINUTESSECONDS,
    TimeUnit.MINUTESSECONDS,
    TimeUnit.SECONDSMILLISECONDS
];
/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */
function containsTimeUnit(fullTimeUnit, timeUnit) {
    var index = fullTimeUnit.indexOf(timeUnit);
    return index > -1 &&
        (timeUnit !== TimeUnit.SECONDS ||
            index === 0 ||
            fullTimeUnit.charAt(index - 1) !== 'i' // exclude milliseconds
        );
}
exports.containsTimeUnit = containsTimeUnit;
/**
 * Returns Vega expresssion for a given timeUnit and fieldRef
 */
function fieldExpr(fullTimeUnit, field) {
    var fieldRef = "datum[" + util_1.stringValue(field) + "]";
    function func(timeUnit) {
        if (timeUnit === TimeUnit.QUARTER) {
            // quarter starting at 0 (0,3,6,9).
            return "(quarter(" + fieldRef + ")-1)";
        }
        else {
            return timeUnit + "(" + fieldRef + ")";
        }
    }
    var d = exports.SINGLE_TIMEUNITS.reduce(function (_d, tu) {
        if (containsTimeUnit(fullTimeUnit, tu)) {
            _d[tu] = func(tu);
        }
        return _d;
    }, {});
    if (d.day && util_1.keys(d).length > 1) {
        log.warn(log.message.dayReplacedWithDate(fullTimeUnit));
        delete d.day;
        d.date = func(TimeUnit.DATE);
    }
    return datetime_1.dateTimeExpr(d);
}
exports.fieldExpr = fieldExpr;
/** returns the smallest nice unit for scale.nice */
function smallestUnit(timeUnit) {
    if (!timeUnit) {
        return undefined;
    }
    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {
        return 'second';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {
        return 'minute';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {
        return 'hour';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||
        containsTimeUnit(timeUnit, TimeUnit.DATE)) {
        return 'day';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {
        return 'month';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {
        return 'year';
    }
    return undefined;
}
exports.smallestUnit = smallestUnit;
/** returns the signal expression used for axis labels for a time unit */
function formatExpression(timeUnit, field, shortTimeLabels) {
    if (!timeUnit) {
        return undefined;
    }
    var dateComponents = [];
    var expression = '';
    var hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);
    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {
        // special expression for quarter as prefix
        expression = "'Q' + quarter(" + field + ")";
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {
        // By default use short month name
        dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {
        dateComponents.push(shortTimeLabels ? '%a' : '%A');
    }
    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {
        dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year
    }
    if (hasYear) {
        dateComponents.push(shortTimeLabels ? '%y' : '%Y');
    }
    var timeComponents = [];
    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {
        timeComponents.push('%H');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {
        timeComponents.push('%M');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {
        timeComponents.push('%S');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {
        timeComponents.push('%L');
    }
    var dateTimeComponents = [];
    if (dateComponents.length > 0) {
        dateTimeComponents.push(dateComponents.join(' '));
    }
    if (timeComponents.length > 0) {
        dateTimeComponents.push(timeComponents.join(':'));
    }
    if (dateTimeComponents.length > 0) {
        if (expression) {
            // Add space between quarter and main time format
            expression += " + ' ' + ";
        }
        expression += "timeFormat(" + field + ", '" + dateTimeComponents.join(' ') + "')";
    }
    // If expression is still an empty string, return undefined instead.
    return expression || undefined;
}
exports.formatExpression = formatExpression;
function isDiscreteByDefault(timeUnit) {
    switch (timeUnit) {
        // These time unit use discrete scale by default
        case 'hours':
        case 'day':
        case 'month':
        case 'quarter':
            return true;
    }
    return false;
}
exports.isDiscreteByDefault = isDiscreteByDefault;

},{"./datetime":84,"./log":90,"./util":102}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TOP_LEVEL_PROPERTIES = [
    'background', 'padding'
];
function extractTopLevelProperties(t) {
    return TOP_LEVEL_PROPERTIES.reduce(function (o, p) {
        if (t && t[p] !== undefined) {
            o[p] = t[p];
        }
        return o;
    }, {});
}
exports.extractTopLevelProperties = extractTopLevelProperties;

},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFilter(t) {
    return t['filter'] !== undefined;
}
exports.isFilter = isFilter;
function isCalculate(t) {
    return t['calculate'] !== undefined;
}
exports.isCalculate = isCalculate;

},{}],101:[function(require,module,exports){
"use strict";
/** Constants and utilities for data type */
/** Data type based on level of measurement */
Object.defineProperty(exports, "__esModule", { value: true });
var Type;
(function (Type) {
    Type.QUANTITATIVE = 'quantitative';
    Type.ORDINAL = 'ordinal';
    Type.TEMPORAL = 'temporal';
    Type.NOMINAL = 'nominal';
})(Type = exports.Type || (exports.Type = {}));
exports.QUANTITATIVE = Type.QUANTITATIVE;
exports.ORDINAL = Type.ORDINAL;
exports.TEMPORAL = Type.TEMPORAL;
exports.NOMINAL = Type.NOMINAL;
/**
 * Get full, lowercase type name for a given type.
 * @param  type
 * @return Full type name.
 */
function getFullName(type) {
    if (type) {
        type = type.toLowerCase();
        switch (type) {
            case 'q':
            case exports.QUANTITATIVE:
                return 'quantitative';
            case 't':
            case exports.TEMPORAL:
                return 'temporal';
            case 'o':
            case exports.ORDINAL:
                return 'ordinal';
            case 'n':
            case exports.NOMINAL:
                return 'nominal';
        }
    }
    // If we get invalid input, return undefined type.
    return undefined;
}
exports.getFullName = getFullName;

},{}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var stringify = require("json-stable-stringify");
var vega_util_1 = require("vega-util");
exports.extend = vega_util_1.extend;
exports.isArray = vega_util_1.isArray;
exports.isObject = vega_util_1.isObject;
exports.isNumber = vega_util_1.isNumber;
exports.isString = vega_util_1.isString;
exports.truncate = vega_util_1.truncate;
exports.toSet = vega_util_1.toSet;
exports.stringValue = vega_util_1.stringValue;
var vega_util_2 = require("vega-util");
/**
 * Creates an object composed of the picked object properties.
 *
 * Example:  (from lodash)
 *
 * var object = {'a': 1, 'b': '2', 'c': 3};
 * pick(object, ['a', 'c']);
 * // → {'a': 1, 'c': 3}
 *
 */
function pick(obj, props) {
    var copy = {};
    props.forEach(function (prop) {
        if (obj.hasOwnProperty(prop)) {
            copy[prop] = obj[prop];
        }
    });
    return copy;
}
exports.pick = pick;
/**
 * The opposite of _.pick; this method creates an object composed of the own
 * and inherited enumerable string keyed properties of object that are not omitted.
 */
function omit(obj, props) {
    var copy = duplicate(obj);
    props.forEach(function (prop) {
        delete copy[prop];
    });
    return copy;
}
exports.omit = omit;
function hash(a) {
    if (vega_util_2.isString(a) || vega_util_2.isNumber(a) || isBoolean(a)) {
        return String(a);
    }
    return stringify(a);
}
exports.hash = hash;
function contains(array, item) {
    return array.indexOf(item) > -1;
}
exports.contains = contains;
/** Returns the array without the elements in item */
function without(array, excludedItems) {
    return array.filter(function (item) { return !contains(excludedItems, item); });
}
exports.without = without;
function union(array, other) {
    return array.concat(without(other, array));
}
exports.union = union;
/**
 * Returns true if any item returns true.
 */
function some(arr, f) {
    var i = 0;
    for (var k = 0; k < arr.length; k++) {
        if (f(arr[k], k, i++)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
/**
 * Returns true if all items return true.
 */
function every(arr, f) {
    var i = 0;
    for (var k = 0; k < arr.length; k++) {
        if (!f(arr[k], k, i++)) {
            return false;
        }
    }
    return true;
}
exports.every = every;
function flatten(arrays) {
    return [].concat.apply([], arrays);
}
exports.flatten = flatten;
/**
 * recursively merges src into dest
 */
function mergeDeep(dest) {
    var src = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        src[_i - 1] = arguments[_i];
    }
    for (var _a = 0, src_1 = src; _a < src_1.length; _a++) {
        var s = src_1[_a];
        dest = deepMerge_(dest, s);
    }
    return dest;
}
exports.mergeDeep = mergeDeep;
// recursively merges src into dest
function deepMerge_(dest, src) {
    if (typeof src !== 'object' || src === null) {
        return dest;
    }
    for (var p in src) {
        if (!src.hasOwnProperty(p)) {
            continue;
        }
        if (src[p] === undefined) {
            continue;
        }
        if (typeof src[p] !== 'object' || vega_util_2.isArray(src[p]) || src[p] === null) {
            dest[p] = src[p];
        }
        else if (typeof dest[p] !== 'object' || dest[p] === null) {
            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);
        }
        else {
            mergeDeep(dest[p], src[p]);
        }
    }
    return dest;
}
function unique(values, f) {
    var results = [];
    var u = {};
    var v;
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
        var val = values_1[_i];
        v = f(val);
        if (v in u) {
            continue;
        }
        u[v] = 1;
        results.push(val);
    }
    return results;
}
exports.unique = unique;
/**
 * Returns true if the two dictionaries disagree. Applies only to defined values.
 */
function differ(dict, other) {
    for (var key in dict) {
        if (dict.hasOwnProperty(key)) {
            if (other[key] && dict[key] && other[key] !== dict[key]) {
                return true;
            }
        }
    }
    return false;
}
exports.differ = differ;
function hasIntersection(a, b) {
    for (var key in a) {
        if (key in b) {
            return true;
        }
    }
    return false;
}
exports.hasIntersection = hasIntersection;
function differArray(array, other) {
    if (array.length !== other.length) {
        return true;
    }
    array.sort();
    other.sort();
    for (var i = 0; i < array.length; i++) {
        if (other[i] !== array[i]) {
            return true;
        }
    }
    return false;
}
exports.differArray = differArray;
exports.keys = Object.keys;
function vals(x) {
    var _vals = [];
    for (var k in x) {
        if (x.hasOwnProperty(k)) {
            _vals.push(x[k]);
        }
    }
    return _vals;
}
exports.vals = vals;
function duplicate(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.duplicate = duplicate;
function isBoolean(b) {
    return b === true || b === false;
}
exports.isBoolean = isBoolean;
/**
 * Convert a string into a valid variable name
 */
function varName(s) {
    // Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _
    var alphanumericS = s.replace(/\W/g, '_');
    // Add _ if the string has leading numbers.
    return (s.match(/^\d+/) ? '_' : '') + alphanumericS;
}
exports.varName = varName;

},{"json-stable-stringify":6,"vega-util":106}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mark_1 = require("./mark");
// TODO: move to vl.spec.validator?
var mark_2 = require("./mark");
var util_1 = require("./util");
/**
 * Required Encoding Channels for each mark type
 * @type {Object}
 */
exports.DEFAULT_REQUIRED_CHANNEL_MAP = {
    text: ['text'],
    line: ['x', 'y'],
    area: ['x', 'y']
};
/**
 * Supported Encoding Channel for each mark type
 */
exports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {
    bar: util_1.toSet(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),
    line: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'detail']),
    area: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'detail']),
    tick: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'detail']),
    circle: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),
    square: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),
    point: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),
    text: util_1.toSet(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise
};
// TODO: consider if we should add validate method and
// requires ZSchema in the main vega-lite repo
/**
 * Further check if encoding mapping of a spec is invalid and
 * return error if it is invalid.
 *
 * This checks if
 * (1) all the required encoding channels for the mark type are specified
 * (2) all the specified encoding channels are supported by the mark type
 * @param  {[type]} spec [description]
 * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap
 * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap
 * @return {String} Return one reason why the encoding is invalid,
 *                  or null if the encoding is valid.
 */
function getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {
    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }
    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }
    var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
    var encoding = spec.encoding;
    var requiredChannels = requiredChannelMap[mark];
    var supportedChannels = supportedChannelMap[mark];
    for (var i in requiredChannels) {
        if (!(requiredChannels[i] in encoding)) {
            return 'Missing encoding channel \"' + requiredChannels[i] +
                '\" for mark \"' + mark + '\"';
        }
    }
    for (var channel in encoding) {
        if (!supportedChannels[channel]) {
            return 'Encoding channel \"' + channel +
                '\" is not supported by mark type \"' + mark + '\"';
        }
    }
    if (mark === mark_2.BAR && !encoding.x && !encoding.y) {
        return 'Missing both x and y for bar';
    }
    return null;
}
exports.getEncodingMappingError = getEncodingMappingError;

},{"./mark":91,"./util":102}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
function isDataRefUnionedDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'fields' in domain && !('data' in domain);
    }
    return false;
}
exports.isDataRefUnionedDomain = isDataRefUnionedDomain;
function isFieldRefUnionDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'fields' in domain && 'data' in domain;
    }
    return false;
}
exports.isFieldRefUnionDomain = isFieldRefUnionDomain;
function isDataRefDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'field' in domain && 'data' in domain;
    }
    return false;
}
exports.isDataRefDomain = isDataRefDomain;
function isSignalRefDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'signal' in domain;
    }
    return false;
}
exports.isSignalRefDomain = isSignalRefDomain;

},{"./util":102}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.axis = require("./axis");
exports.aggregate = require("./aggregate");
exports.bin = require("./bin");
exports.channel = require("./channel");
exports.compositeMark = require("./compositemark");
var compile_1 = require("./compile/compile");
exports.compile = compile_1.compile;
exports.config = require("./config");
exports.data = require("./data");
exports.datetime = require("./datetime");
exports.encoding = require("./encoding");
exports.facet = require("./facet");
exports.fieldDef = require("./fielddef");
exports.legend = require("./legend");
exports.mark = require("./mark");
exports.scale = require("./scale");
exports.sort = require("./sort");
exports.spec = require("./spec");
exports.stack = require("./stack");
exports.timeUnit = require("./timeunit");
exports.transform = require("./transform");
exports.type = require("./type");
exports.util = require("./util");
exports.validate = require("./validate");
exports.version = require('../package.json').version;

},{"../package.json":12,"./aggregate":13,"./axis":14,"./bin":15,"./channel":16,"./compile/compile":21,"./compositemark":81,"./config":82,"./data":83,"./datetime":84,"./encoding":85,"./facet":86,"./fielddef":87,"./legend":89,"./mark":91,"./scale":93,"./sort":95,"./spec":96,"./stack":97,"./timeunit":98,"./transform":100,"./type":101,"./util":102,"./validate":103}],106:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.vega = global.vega || {})));
}(this, (function (exports) { 'use strict';

var accessor = function(fn, fields, name) {
  return (
    fn.fields = fields || [],
    fn.fname = name,
    fn
  );
}

function accessorName(fn) {
  return fn == null ? null : fn.fname;
}

function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}

var error = function(message) {
  throw Error(message);
}

var splitAccessPath = function(p) {
  var path = [],
      q = null,
      b = 0,
      n = p.length,
      s = '',
      i, j, c;

  p = p + '';

  function push() {
    path.push(s + p.substring(i, j));
    s = '';
    i = j + 1;
  }

  for (i=j=0; j<n; ++j) {
    c = p[j];
    if (c === '\\') s += p.substring(i, j), i = ++j;
    else if (c === q) push(), q = null, b = -1;
    else if (q) continue;
    else if (i === b && c === '"') i = j + 1, q = c;
    else if (i === b && c === "'") i = j + 1, q = c;
    else if (c === '.' && !b) (j > i) ? push() : (i = j + 1);
    else if (c === '[') {
      if (j > i) push();
      b = i = j + 1;
    }
    else if (c === ']') {
      if (!b) error('Access path missing open bracket: ' + p);
      if (b > 0) push();
      b = 0;
      i = j + 1;
    }
  }

  if (b) error('Access path missing closing bracket: ' + p);
  if (q) error('Access path missing closing quote: ' + p);
  if (j > i) ++j, push();
  return path;
}

var isArray = Array.isArray;

var isObject = function(_) {
  return _ === Object(_);
}

var isString = function(_) {
  return typeof _ === 'string';
}

function $(x) {
  return isArray(x) ? '[' + x.map($) + ']'
    : isObject(x) || isString(x) ?
      // Output valid JSON and JS source strings.
      // See http://timelessrepo.com/json-isnt-a-javascript-subset
      JSON.stringify(x).replace('\u2028','\\u2028').replace('\u2029', '\\u2029')
    : x;
}

var field = function(field, name) {
  var path = splitAccessPath(field),
      code = 'return _[' + path.map($).join('][') + '];';

  return accessor(
    Function('_', code),
    [(field = path.length===1 ? path[0] : field)],
    name || field
  );
}

var empty = [];

var id = field('id');

var identity = accessor(function(_) { return _; }, empty, 'identity');

var zero = accessor(function() { return 0; }, empty, 'zero');

var one = accessor(function() { return 1; }, empty, 'one');

var truthy = accessor(function() { return true; }, empty, 'true');

var falsy = accessor(function() { return false; }, empty, 'false');

function log(method, level, input) {
  var args = [level].concat([].slice.call(input));
  console[method].apply(console, args); // eslint-disable-line no-console
}

var None  = 0;
var Warn  = 1;
var Info  = 2;
var Debug = 3;

var logger = function(_) {
  var level = _ || None;
  return {
    level: function(_) {
      return arguments.length ? (level = +_, this) : level;
    },
    warn: function() {
      if (level >= Warn) log('warn', 'WARN', arguments);
      return this;
    },
    info: function() {
      if (level >= Info) log('log', 'INFO', arguments);
      return this;
    },
    debug: function() {
      if (level >= Debug) log('log', 'DEBUG', arguments);
      return this;
    }
  }
}

var array = function(_) {
  return _ != null ? (isArray(_) ? _ : [_]) : [];
}

var compare = function(fields, orders) {
  var idx = [],
      cmp = (fields = array(fields)).map(function(f, i) {
        return f == null ? null
          : (idx.push(i), splitAccessPath(f).map($).join(']['));
      }),
      n = idx.length - 1,
      ord = array(orders),
      code = 'var u,v;return ',
      i, j, f, u, v, d, lt, gt;

  if (n < 0) return null;

  for (j=0; j<=n; ++j) {
    i = idx[j];
    f = cmp[i];
    u = '(u=a['+f+'])';
    v = '(v=b['+f+'])';
    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';
    lt = ord[i] !== 'descending' ? (gt=1, -1) : (gt=-1, 1);
    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt
      + ':(u>v||v==null)&&u!=null?' + gt
      + ':'+d+'!==u&&v===v?' + lt
      + ':v!==v&&u===u?' + gt
      + (i < n ? ':' : ':0');
  }

  return accessor(
    Function('a', 'b', code + ';'),
    fields.filter(function(_) { return _ != null; })
  );
}

var isFunction = function(_) {
  return typeof _ === 'function';
}

var constant = function(_) {
  return isFunction(_) ? _ : function() { return _; };
}

var extend = function(_) {
  for (var x, k, i=1, len=arguments.length; i<len; ++i) {
    x = arguments[i];
    for (k in x) { _[k] = x[k]; }
  }
  return _;
}

var extentIndex = function(array, f) {
  var i = -1,
      n = array.length,
      a, b, c, u, v;

  if (f == null) {
    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
    u = v = i;
    while (++i < n) if ((b = array[i]) != null) {
      if (a > b) a = b, u = i;
      if (c < b) c = b, v = i;
    }
  } else {
    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
    u = v = i;
    while (++i < n) if ((b = f(array[i], i, array)) != null) {
      if (a > b) a = b, u = i;
      if (c < b) c = b, v = i;
    }
  }

  return [u, v];
}

var NULL = {};

var fastmap = function(input) {
  var obj = {},
      map,
      test;

  function has(key) {
    return obj.hasOwnProperty(key) && obj[key] !== NULL;
  }

  map = {
    size: 0,
    empty: 0,
    object: obj,
    has: has,
    get: function(key) {
      return has(key) ? obj[key] : undefined;
    },
    set: function(key, value) {
      if (!has(key)) {
        ++map.size;
        if (obj[key] === NULL) --map.empty;
      }
      obj[key] = value;
      return this;
    },
    delete: function(key) {
      if (has(key)) {
        --map.size;
        ++map.empty;
        obj[key] = NULL;
      }
      return this;
    },
    clear: function() {
      map.size = map.empty = 0;
      map.object = obj = {};
    },
    test: function(_) {
      return arguments.length ? (test = _, map) : test;
    },
    clean: function() {
      var next = {},
          size = 0,
          key, value;
      for (key in obj) {
        value = obj[key];
        if (value !== NULL && (!test || !test(value))) {
          next[key] = value;
          ++size;
        }
      }
      map.size = size;
      map.empty = 0;
      map.object = (obj = next);
    }
  };

  if (input) Object.keys(input).forEach(function(key) {
    map.set(key, input[key]);
  });

  return map;
}

var inherits = function(child, parent) {
  var proto = (child.prototype = Object.create(parent.prototype));
  proto.constructor = child;
  return proto;
}

var isBoolean = function(_) {
  return typeof _ === 'boolean';
}

var isDate = function(_) {
  return Object.prototype.toString.call(_) === '[object Date]';
}

var isNumber = function(_) {
  return typeof _ === 'number';
}

var isRegExp = function(_) {
  return Object.prototype.toString.call(_) === '[object RegExp]';
}

var key = function(fields) {
  fields = fields ? array(fields) : fields;
  var fn = !(fields && fields.length)
    ? function() { return ''; }
    : Function('_', 'return \'\'+' +
        fields.map(function(f) {
          return '_[' + splitAccessPath(f).map($).join('][') + ']';
        }).join('+\'|\'+') + ';');
  return accessor(fn, fields, 'key');
}

var merge = function(compare, array0, array1, output) {
  var n0 = array0.length,
      n1 = array1.length;

  if (!n1) return array0;
  if (!n0) return array1;

  var merged = output || new array0.constructor(n0 + n1),
      i0 = 0, i1 = 0, i = 0;

  for (; i0<n0 && i1<n1; ++i) {
    merged[i] = compare(array0[i0], array1[i1]) > 0
       ? array1[i1++]
       : array0[i0++];
  }

  for (; i0<n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }

  for (; i1<n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }

  return merged;
}

var repeat = function(str, reps) {
  var s = '';
  while (--reps >= 0) s += str;
  return s;
}

var pad = function(str, length, padchar, align) {
  var c = padchar || ' ',
      s = str + '',
      n = length - s.length;

  return n <= 0 ? s
    : align === 'left' ? repeat(c, n) + s
    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))
    : s + repeat(c, n);
}

var peek = function(array) {
  return array[array.length - 1];
}

var toBoolean = function(_) {
  return _ == null || _ === '' ? null : !_ || _ === 'false' ? false : !!_;
}

var toDate = function(_, parser) {
  return _ == null || _ === '' ? null : (parser ? parser(_) : Date.parse(_));
}

var toNumber = function(_) {
  return _ == null || _ === '' ? null : +_;
}

var toString = function(_) {
  return _ == null || _ === '' ? null : _ + '';
}

var toSet = function(_) {
  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;
  return s;
}

var truncate = function(str, length, align, ellipsis) {
  var e = ellipsis != null ? ellipsis : '\u2026',
      s = str + '',
      n = s.length,
      l = Math.max(0, length - e.length);

  return n <= length ? s
    : align === 'left' ? e + s.slice(n - l)
    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))
    : s.slice(0, l) + e;
}

var visitArray = function(array, filter, visitor) {
  if (array) {
    var i = 0, n = array.length, t;
    if (filter) {
      for (; i<n; ++i) {
        if (t = filter(array[i])) visitor(t, i, array);
      }
    } else {
      array.forEach(visitor);
    }
  }
}

exports.accessor = accessor;
exports.accessorName = accessorName;
exports.accessorFields = accessorFields;
exports.id = id;
exports.identity = identity;
exports.zero = zero;
exports.one = one;
exports.truthy = truthy;
exports.falsy = falsy;
exports.logger = logger;
exports.None = None;
exports.Warn = Warn;
exports.Info = Info;
exports.Debug = Debug;
exports.array = array;
exports.compare = compare;
exports.constant = constant;
exports.error = error;
exports.extend = extend;
exports.extentIndex = extentIndex;
exports.fastmap = fastmap;
exports.field = field;
exports.inherits = inherits;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isDate = isDate;
exports.isFunction = isFunction;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isRegExp = isRegExp;
exports.isString = isString;
exports.key = key;
exports.merge = merge;
exports.pad = pad;
exports.peek = peek;
exports.repeat = repeat;
exports.splitAccessPath = splitAccessPath;
exports.stringValue = $;
exports.toBoolean = toBoolean;
exports.toDate = toDate;
exports.toNumber = toNumber;
exports.toString = toString;
exports.toSet = toSet;
exports.truncate = truncate;
exports.visitArray = visitArray;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3_collection_1 = require("d3-collection");
var d3_format_1 = require("d3-format");
var d3_selection_1 = require("d3-selection");
var d3_time_1 = require("d3-time");
var d3_time_format_1 = require("d3-time-format");
var type_1 = require("vega-lite/build/src/type");
var vl = require("vega-lite/build/src/vl");
// by default, delay showing tooltip for 100 ms
var DELAY = 100;
var tooltipPromise = undefined;
var tooltipActive = false;
/**
* Export API for Vega visualizations: vg.tooltip(vgView, options)
* options can specify whether to show all fields or to show only custom fields
* It can also provide custom title and format for fields
*/
function vega(vgView, options) {
    // TODO: change item type to vega scenegraph
    if (options === void 0) { options = { showAllFields: true }; }
    // initialize tooltip with item data and options on mouse over
    vgView.addEventListener('mouseover.tooltipInit', function (event, item) {
        if (shouldShowTooltip(item)) {
            // clear existing promise because mouse can only point at one thing at a time
            cancelPromise();
            tooltipPromise = window.setTimeout(function () {
                init(event, item, options);
            }, options.delay || DELAY);
        }
    });
    // update tooltip position on mouse move
    // (important for large marks e.g. bars)
    vgView.addEventListener('mousemove.tooltipUpdate', function (event, item) {
        if (shouldShowTooltip(item) && tooltipActive) {
            update(event, item, options);
        }
    });
    // clear tooltip on mouse out
    vgView.addEventListener('mouseout.tooltipRemove', function (event, item) {
        if (shouldShowTooltip(item)) {
            cancelPromise();
            if (tooltipActive) {
                clear(event, item, options);
            }
        }
    });
    return {
        destroy: function () {
            // remove event listeners
            vgView.removeEventListener('mouseover.tooltipInit');
            vgView.removeEventListener('mousemove.tooltipUpdate');
            vgView.removeEventListener('mouseout.tooltipRemove');
            cancelPromise(); // clear tooltip promise
        }
    };
}
exports.vega = vega;
;
/**
* Export API for Vega-Lite visualizations: vl.tooltip(vgView, vlSpec, options)
* options can specify whether to show all fields or to show only custom fields
* It can also provide custom title and format for fields
* options can be supplemented by vlSpec
*/
function vegaLite(vgView, vlSpec, options) {
    if (options === void 0) { options = {}; }
    options = supplementOptions(options, vlSpec);
    // TODO: update this to use new vega-view api (addEventListener)
    // initialize tooltip with item data and options on mouse over
    vgView.addEventListener('mouseover.tooltipInit', function (event, item) {
        if (shouldShowTooltip(item)) {
            // clear existing promise because mouse can only point at one thing at a time
            cancelPromise();
            // make a new promise with time delay for tooltip
            tooltipPromise = window.setTimeout(function () {
                init(event, item, options);
            }, options.delay || DELAY);
        }
    });
    // update tooltip position on mouse move
    // (important for large marks e.g. bars)
    vgView.addEventListener('mousemove.tooltipUpdate', function (event, item) {
        if (shouldShowTooltip(item) && tooltipActive) {
            update(event, item, options);
        }
    });
    // clear tooltip on mouse out
    vgView.addEventListener('mouseout.tooltipRemove', function (event, item) {
        if (shouldShowTooltip(item)) {
            cancelPromise();
            if (tooltipActive) {
                clear(event, item, options);
            }
        }
    });
    return {
        destroy: function () {
            // remove event listeners
            vgView.removeEventListener('mouseover.tooltipInit');
            vgView.removeEventListener('mousemove.tooltipUpdate');
            vgView.removeEventListener('mouseout.tooltipRemove');
            cancelPromise(); // clear tooltip promise
        }
    };
}
exports.vegaLite = vegaLite;
;
/* Cancel tooltip promise */
function cancelPromise() {
    /* We don't check if tooltipPromise is valid because passing
     an invalid ID to clearTimeout does not have any effect
     (and doesn't throw an exception). */
    window.clearTimeout(tooltipPromise);
    tooltipPromise = undefined;
}
/* mapping from fieldDef.type to formatType */
var formatTypeMap = {
    'quantitative': 'number',
    'temporal': 'time',
    'ordinal': undefined,
    'nominal': undefined
};
/**
* (Vega-Lite only) Supplement options with vlSpec
*
* @param options - user-provided options
* @param vlSpec - vega-lite spec
* @return the vlSpec-supplemented options object
*
* if options.showAllFields is true or undefined, vlSpec will supplement
* options.fields with all fields in the spec
* if options.showAllFields is false, vlSpec will only supplement existing fields
* in options.fields
*/
function supplementOptions(options, vlSpec) {
    // fields to be supplemented by vlSpec
    var supplementedFields = [];
    // if showAllFields is true or undefined, supplement all fields in vlSpec
    if (options.showAllFields !== false) {
        vl.spec.fieldDefs(vlSpec).forEach(function (fieldDef) {
            // get a fieldOption in options that matches the fieldDef
            var fieldOption = getFieldOption(options.fields, fieldDef);
            // supplement the fieldOption with fieldDef and config
            var supplementedFieldOption = supplementFieldOption(fieldOption, fieldDef, vlSpec);
            supplementedFields.push(supplementedFieldOption);
        });
    }
    else {
        if (options.fields) {
            options.fields.forEach(function (fieldOption) {
                // get the fieldDef in vlSpec that matches the fieldOption
                var fieldDef = getFieldDef(vl.spec.fieldDefs(vlSpec), fieldOption);
                // supplement the fieldOption with fieldDef and config
                var supplementedFieldOption = supplementFieldOption(fieldOption, fieldDef, vlSpec);
                supplementedFields.push(supplementedFieldOption);
            });
        }
    }
    options.fields = supplementedFields;
    return options;
}
/**
* Find a fieldOption in fieldOptions that matches a fieldDef
*
* @param {Object[]} fieldOptionss - a list of field options (i.e. options.fields[])
* @param {Object} fieldDef - from vlSpec
* @return the matching fieldOption, or undefined if no match was found
*
* If the fieldDef is aggregated, find a fieldOption that matches the field name and
* the aggregation of the fieldDef.
* If the fieldDef is not aggregated, find a fieldOption that matches the field name.
*/
function getFieldOption(fieldOptions, fieldDef) {
    if (!fieldDef || !fieldOptions || fieldOptions.length <= 0) {
        return undefined;
    }
    // if aggregate, match field name and aggregate operation
    if (fieldDef.aggregate) {
        // try find the perfect match: field name equals, aggregate operation equals
        for (var _i = 0, fieldOptions_1 = fieldOptions; _i < fieldOptions_1.length; _i++) {
            var item = fieldOptions_1[_i];
            if (item.field === fieldDef.field && item.aggregate === fieldDef.aggregate) {
                return item;
            }
        }
        // try find the second-best match: field name equals, field.aggregate is not specified
        for (var _a = 0, fieldOptions_2 = fieldOptions; _a < fieldOptions_2.length; _a++) {
            var item = fieldOptions_2[_a];
            if (item.field === fieldDef.field && !item.aggregate) {
                return item;
            }
        }
        // return undefined if no match was found
        return undefined;
    }
    else {
        for (var _b = 0, fieldOptions_3 = fieldOptions; _b < fieldOptions_3.length; _b++) {
            var item = fieldOptions_3[_b];
            if (item.field === fieldDef.field) {
                return item;
            }
        }
        // return undefined if no match was found
        return undefined;
    }
}
/**
* Find a fieldDef that matches a fieldOption
*
* @param {Object} fieldOption - a field option (a member in options.fields[])
* @return the matching fieldDef, or undefined if no match was found
*
* A matching fieldDef should have the same field name as fieldOption.
* If the matching fieldDef is aggregated, the aggregation should not contradict
* with that of the fieldOption.
*/
function getFieldDef(fieldDefs, fieldOption) {
    if (!fieldOption || !fieldOption.field || !fieldDefs) {
        return undefined;
    }
    // field name should match, aggregation should not disagree
    for (var _i = 0, fieldDefs_1 = fieldDefs; _i < fieldDefs_1.length; _i++) {
        var item = fieldDefs_1[_i];
        if (item.field === fieldOption.field) {
            if (item.aggregate) {
                if (item.aggregate === fieldOption.aggregate || !fieldOption.aggregate) {
                    return item;
                }
            }
            else {
                return item;
            }
        }
    }
    // return undefined if no match was found
    return undefined;
}
/**
* Supplement a fieldOption (from options.fields[]) with a fieldDef, config
* (which provides timeFormat, numberFormat, countTitle)
* Either fieldOption or fieldDef can be undefined, but they cannot both be undefined.
* config (and its members timeFormat, numberFormat and countTitle) can be undefined.
* @return the supplemented fieldOption, or undefined on error
*/
function supplementFieldOption(fieldOption, fieldDef, vlSpec) {
    // many specs don't have config
    var config = vl.util.extend({}, vlSpec.config);
    // at least one of fieldOption and fieldDef should exist
    if (!fieldOption && !fieldDef) {
        console.error('[Tooltip] Cannot supplement a field when field and fieldDef are both empty.');
        return undefined;
    }
    // if either one of fieldOption and fieldDef is undefined, make it an empty object
    if (!fieldOption && fieldDef) {
        fieldOption = {};
    }
    if (fieldOption && !fieldDef) {
        fieldDef = {};
    }
    // the supplemented field option
    var supplementedFieldOption = {};
    // supplement a user-provided field name with underscore prefixes and suffixes to
    // match the field names in item.datum
    // for aggregation, this will add prefix "mean_" etc.
    // for timeUnit, this will add prefix "yearmonth_" etc.
    // for bin, this will add prefix "bin_" and suffix "_start". Later we will replace "_start" with "_range".
    supplementedFieldOption.field = fieldDef.field ?
        vl.fieldDef.field(fieldDef) : fieldOption.field;
    // If a fieldDef is a (TIMEUNIT)T, we check if the original T is present in the vlSpec.
    // If only (TIMEUNIT)T is present in vlSpec, we set `removeOriginalTemporalField` to T,
    // which will cause function removeDuplicateTimeFields() to remove T and only keep (TIMEUNIT)T
    // in item data.
    // If both (TIMEUNIT)T and T are in vlSpec, we set `removeOriginalTemporalField` to undefined,
    // which will leave both T and (TIMEUNIT)T in item data.
    // Note: user should never have to provide this boolean in options
    if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {
        // in most cases, if it's a (TIMEUNIT)T, we remove original T
        var originalTemporalField = fieldDef.field;
        supplementedFieldOption.removeOriginalTemporalField = originalTemporalField;
        // handle corner case: if T is present in vlSpec, then we keep both T and (TIMEUNIT)T
        var fieldDefs = vl.spec.fieldDefs(vlSpec);
        for (var _i = 0, fieldDefs_2 = fieldDefs; _i < fieldDefs_2.length; _i++) {
            var items = fieldDefs_2[_i];
            if (items.field === originalTemporalField && !items.timeUnit) {
                supplementedFieldOption.removeOriginalTemporalField = undefined;
                break;
            }
        }
    }
    // supplement title
    if (!config.countTitle) {
        config.countTitle = vl.config.defaultConfig.countTitle; // use vl default countTitle
    }
    supplementedFieldOption.title = fieldOption.title ?
        fieldOption.title : vl.fieldDef.title(fieldDef, config);
    // supplement formatType
    supplementedFieldOption.formatType = fieldOption.formatType ?
        fieldOption.formatType : formatTypeMap[fieldDef.type];
    // supplement format
    if (fieldOption.format) {
        supplementedFieldOption.format = fieldOption.format;
    }
    else {
        switch (supplementedFieldOption.formatType) {
            case 'time':
                supplementedFieldOption.format = fieldDef.timeUnit ?
                    // TODO(zening): use template for all time fields, to be consistent with Vega-Lite
                    vl.timeUnit.formatExpression(fieldDef.timeUnit, '', false).split("'")[1]
                    : config.timeFormat || vl.config.defaultConfig.timeFormat;
                break;
            case 'number':
                supplementedFieldOption.format = config.numberFormat;
                break;
            case 'string':
            default:
        }
    }
    // supplement bin from fieldDef, user should never have to provide bin in options
    if (fieldDef.bin) {
        supplementedFieldOption.field = supplementedFieldOption.field.replace('_start', '_range'); // replace suffix
        supplementedFieldOption.bin = true;
        supplementedFieldOption.formatType = 'string'; // we show bin range as string (e.g. "5-10")
    }
    return supplementedFieldOption;
}
/* Initialize tooltip with data */
function init(event, item, options) {
    // get tooltip HTML placeholder
    var tooltipPlaceholder = getTooltipPlaceholder();
    // prepare data for tooltip
    var tooltipData = getTooltipData(item, options);
    if (!tooltipData || tooltipData.length === 0) {
        return undefined;
    }
    // bind data to tooltip HTML placeholder
    bindData(tooltipPlaceholder, tooltipData);
    updatePosition(event, options);
    updateColorTheme(options);
    d3_selection_1.select('#vis-tooltip').style('visibility', 'visible');
    tooltipActive = true;
    // invoke user-provided callback
    if (options.onAppear) {
        options.onAppear(event, item);
    }
}
/* Update tooltip position on mousemove */
function update(event, item, options) {
    updatePosition(event, options);
    // invoke user-provided callback
    if (options.onMove) {
        options.onMove(event, item);
    }
}
/* Clear tooltip */
function clear(event, item, options) {
    // visibility hidden instead of display none
    // because we need computed tooltip width and height to best position it
    d3_selection_1.select('#vis-tooltip').style('visibility', 'hidden');
    tooltipActive = false;
    clearData();
    clearColorTheme();
    clearPosition();
    // invoke user-provided callback
    if (options.onDisappear) {
        options.onDisappear(event, item);
    }
}
/* Decide if a scenegraph item deserves tooltip */
function shouldShowTooltip(item) {
    // no data, no show
    if (!item || !item.datum) {
        return false;
    }
    // (small multiples) avoid showing tooltip for a facet's background
    if (item.datum._facetID) {
        return false;
    }
    // avoid showing tooltip for axis title and labels
    if (!item.datum._id) {
        return false;
    }
    return true;
}
/**
* Prepare data for the tooltip
* @return An array of tooltip data [{ title: ..., value: ...}]
*/
// TODO: add marktype
function getTooltipData(item, options) {
    // ignore the data for group type that represents white space
    if (item.mark.marktype === 'group' && item.mark.name === 'nested_main_group') {
        return undefined;
    }
    // this array will be bind to the tooltip element
    var tooltipData;
    var itemData = d3_collection_1.map(item.datum);
    var removeKeys = [
        '_id', '_prev', 'width', 'height',
        'count_start', 'count_end',
        'layout_start', 'layout_mid', 'layout_end', 'layout_path', 'layout_x', 'layout_y'
    ];
    removeFields(itemData, removeKeys);
    // remove duplicate time fields (if any)
    removeDuplicateTimeFields(itemData, options.fields);
    // combine multiple rows of a binned field into a single row
    combineBinFields(itemData, options.fields);
    // TODO(zening): use Vega-Lite layering to support tooltip on line and area charts (#1)
    dropFieldsForLineArea(item.mark.marktype, itemData);
    if (options.showAllFields === true) {
        tooltipData = prepareAllFieldsData(itemData, options);
    }
    else {
        tooltipData = prepareCustomFieldsData(itemData, options);
    }
    return tooltipData;
}
/**
* Prepare custom fields data for tooltip. This function formats
* field titles and values and returns an array of formatted fields.
*
* @param {time.map} itemData - a map of item.datum
* @param {Object} options - user-provided options
* @return An array of formatted fields specified by options [{ title: ..., value: ...}]
*/
function prepareCustomFieldsData(itemData, options) {
    var tooltipData = [];
    options.fields.forEach(function (fieldOption) {
        // prepare field title
        var title = fieldOption.title ? fieldOption.title : fieldOption.field;
        // get (raw) field value
        var value = getValue(itemData, fieldOption.field);
        if (value === undefined) {
            return undefined;
        }
        // format value
        var formattedValue = customFormat(value, fieldOption.formatType, fieldOption.format) || autoFormat(value);
        // add formatted data to tooltipData
        tooltipData.push({ title: title, value: formattedValue });
    });
    return tooltipData;
}
/**
* Get a field value from a data map.
* @param {time.map} itemData - a map of item.datum
* @param {string} field - the name of the field. It can contain "." to specify
* that the field is not a direct child of item.datum
* @return the field value on success, undefined otherwise
*/
// TODO(zening): Mute "Cannot find field" warnings for composite vis (issue #39)
function getValue(itemData, field) {
    var value;
    var accessors = field.split('.');
    // get the first accessor and remove it from the array
    var firstAccessor = accessors[0];
    accessors.shift();
    if (itemData.has(firstAccessor)) {
        value = itemData.get(firstAccessor);
        // if we still have accessors, use them to get the value
        accessors.forEach(function (a) {
            if (value[a]) {
                value = value[a];
            }
        });
    }
    if (value === undefined) {
        console.warn('[Tooltip] Cannot find field ' + field + ' in data.');
        return undefined;
    }
    else {
        return value;
    }
}
/**
* Prepare data for all fields in itemData for tooltip. This function
* formats field titles and values and returns an array of formatted fields.
*
* @param {time.map} itemData - a map of item.datum
* @param {Object} options - user-provided options
* @return All fields in itemData, formatted, in the form of an array: [{ title: ..., value: ...}]
*
* Please note that this function expects itemData to be simple {field:value} pairs.
* It will not try to parse value if it is an object. If value is an object, please
* use prepareCustomFieldsData() instead.
*/
function prepareAllFieldsData(itemData, options) {
    var tooltipData = [];
    // here, fieldOptions still provides format
    var fieldOptions = d3_collection_1.map(options.fields, function (d) { return d.field; });
    itemData.each(function (value, field) {
        // prepare title
        var title;
        if (fieldOptions.has(field) && fieldOptions.get(field).title) {
            title = fieldOptions.get(field).title;
        }
        else {
            title = field;
        }
        var formatType;
        var format;
        // format value
        if (fieldOptions.has(field)) {
            formatType = fieldOptions.get(field).formatType;
            format = fieldOptions.get(field).format;
        }
        var formattedValue = customFormat(value, formatType, format) || autoFormat(value);
        // add formatted data to tooltipData
        tooltipData.push({ title: title, value: formattedValue });
    });
    return tooltipData;
}
/**
* Remove multiple fields from a tooltip data map, using removeKeys
*
* Certain meta data fields (e.g. "_id", "_prev") should be hidden in the tooltip
* by default. This function can be used to remove these fields from tooltip data.
* @param {time.map} dataMap - the data map that contains tooltip data.
* @param {string[]} removeKeys - the fields that should be removed from dataMap.
*/
function removeFields(dataMap, removeKeys) {
    removeKeys.forEach(function (key) {
        dataMap.remove(key);
    });
}
/**
 * When a temporal field has timeUnit, itemData will give us duplicated fields
 * (e.g., Year and YEAR(Year)). In tooltip want to display the field WITH the
 * timeUnit and remove the field that doesn't have timeUnit.
 */
function removeDuplicateTimeFields(itemData, optFields) {
    if (!optFields) {
        return undefined;
    }
    optFields.forEach(function (optField) {
        if (optField.removeOriginalTemporalField) {
            removeFields(itemData, [optField.removeOriginalTemporalField]);
        }
    });
}
/**
* Combine multiple binned fields in itemData into one field. The value of the field
* is a string that describes the bin range.
*
* @param {time.map} itemData - a map of item.datum
* @param {Object[]} fieldOptions - a list of field options (i.e. options.fields[])
* @return itemData with combined bin fields
*/
function combineBinFields(itemData, fieldOptions) {
    if (!fieldOptions) {
        return undefined;
    }
    fieldOptions.forEach(function (fieldOption) {
        if (fieldOption.bin === true) {
            // get binned field names
            var binFieldRange = fieldOption.field;
            var binFieldStart = binFieldRange.concat('_start');
            var binFieldMid = binFieldRange.concat('_mid');
            var binFieldEnd = binFieldRange.concat('_end');
            // use start value and end value to compute range
            // save the computed range in binFieldStart
            var startValue = itemData.get(binFieldStart);
            var endValue = itemData.get(binFieldEnd);
            if ((startValue !== undefined) && (endValue !== undefined)) {
                var range = startValue + '-' + endValue;
                itemData.set(binFieldRange, range);
            }
            // remove binFieldMid, binFieldEnd, and binFieldRange from itemData
            var binRemoveKeys = [];
            binRemoveKeys.push(binFieldStart, binFieldMid, binFieldEnd);
            removeFields(itemData, binRemoveKeys);
        }
    });
    return itemData;
}
/**
* Drop fields for line and area marks.
*
* Lines and areas are defined by a series of datum. We overlay point marks
* on top of lines and areas to allow tooltip to show all data in the series.
* For the line marks and area marks underneath, we only show nominal fields
* in tooltip. This is because line / area marks only give us the last datum
* in their series. It only make sense to show the nominal fields (e.g., symbol
* = APPL, AMZN, GOOG, IBM, MSFT) because these fields don't tend to change along
* the line / area border.
*/
function dropFieldsForLineArea(marktype, itemData) {
    if (marktype === 'line' || marktype === 'area') {
        var quanKeys_1 = [];
        itemData.each(function (value, field) {
            if (value instanceof Date) {
                quanKeys_1.push(field);
            }
        });
        removeFields(itemData, quanKeys_1);
    }
}
/**
* Format value using formatType and format
* @param value - a field value to be formatted
* @param formatType - the foramtType can be: "time", "number", or "string"
* @param format - a time time format specifier, or a time number format specifier, or undefined
* @return the formatted value, or undefined if value or formatType is missing
*/
function customFormat(value, formatType, format) {
    if (value === undefined || value === null) {
        return undefined;
    }
    if (!formatType) {
        return undefined;
    }
    switch (formatType) {
        case 'time':
            return format ? d3_time_format_1.timeFormat(format)(value) : autoTimeFormat(value);
        case 'number':
            return format ? d3_format_1.format(format)(value) : autoNumberFormat(value);
        case 'string':
        default:
            return value;
    }
}
/**
* Automatically format a time, number or string value
* @return the formatted time, number or string value
*/
function autoFormat(value) {
    if (typeof value === 'number') {
        return autoNumberFormat(value);
    }
    else if (value instanceof Date) {
        return autoTimeFormat(value);
    }
    else {
        return value;
    }
}
/**
 * Automatically format a number based on its decimal.
 * @param value number to be formatted
 * @return If it's a decimal number, return a fixed two points precision.
 * If it's a whole number, return the original value without any format.
 */
function autoNumberFormat(value) {
    return value % 1 === 0 ? d3_format_1.format(',')(value) : d3_format_1.format(',.2f')(value);
}
/**
 * Automatically format a time based on its date.
 * @param date object to be formatted
 * @return a formatted time string depending on the time. For example,
 * the start of February is formatted as "February", while February second is formatted as "Feb 2".
 */
function autoTimeFormat(date) {
    var formatMillisecond = d3_time_format_1.timeFormat('.%L'), formatSecond = d3_time_format_1.timeFormat(':%S'), formatMinute = d3_time_format_1.timeFormat('%I:%M'), formatHour = d3_time_format_1.timeFormat('%I %p'), formatDay = d3_time_format_1.timeFormat('%a %d'), formatWeek = d3_time_format_1.timeFormat('%b %d'), formatMonth = d3_time_format_1.timeFormat('%B'), formatYear = d3_time_format_1.timeFormat('%Y');
    return (d3_time_1.timeSecond(date) < date ? formatMillisecond
        : d3_time_1.timeMinute(date) < date ? formatSecond
            : d3_time_1.timeHour(date) < date ? formatMinute
                : d3_time_1.timeDay(date) < date ? formatHour
                    : d3_time_1.timeMonth(date) < date ? (d3_time_1.timeWeek(date) < date ? formatDay : formatWeek)
                        : d3_time_1.timeYear(date) < date ? formatMonth
                            : formatYear)(date);
}
/**
* Get the tooltip HTML placeholder by id selector "#vis-tooltip"
* If none exists, create a placeholder.
* @returns the HTML placeholder for tooltip
*/
function getTooltipPlaceholder() {
    var tooltipPlaceholder;
    if (d3_selection_1.select('#vis-tooltip').empty()) {
        tooltipPlaceholder = d3_selection_1.select('body').append('div')
            .attr('id', 'vis-tooltip')
            .attr('class', 'vg-tooltip');
    }
    else {
        tooltipPlaceholder = d3_selection_1.select('#vis-tooltip');
    }
    return tooltipPlaceholder;
}
/**
* Bind tooltipData to the tooltip placeholder
*/
function bindData(tooltipPlaceholder, tooltipData) {
    tooltipPlaceholder.selectAll('table').remove();
    var tooltipRows = tooltipPlaceholder.append('table').selectAll('.tooltip-row')
        .data(tooltipData);
    tooltipRows.exit().remove();
    var row = tooltipRows.enter().append('tr')
        .attr('class', 'tooltip-row');
    row.append('td').attr('class', 'key').text(function (d) { return d.title + ':'; });
    row.append('td').attr('class', 'value').text(function (d) { return d.value; });
}
/**
* Clear tooltip data
*/
function clearData() {
    d3_selection_1.select('#vis-tooltip').selectAll('.tooltip-row').data([])
        .exit().remove();
}
/**
* Update tooltip position
* Default position is 10px right of and 10px below the cursor. This can be
* overwritten by options.offset
*/
function updatePosition(event, options) {
    // determine x and y offsets, defaults are 10px
    var offsetX = 10;
    var offsetY = 10;
    if (options && options.offset && (options.offset.x !== undefined) && (options.offset.x !== null)) {
        offsetX = options.offset.x;
    }
    if (options && options.offset && (options.offset.y !== undefined) && (options.offset.y !== null)) {
        offsetY = options.offset.y;
    }
    // TODO: use the correct time type
    d3_selection_1.select('#vis-tooltip')
        .style('top', function () {
        // by default: put tooltip 10px below cursor
        // if tooltip is close to the bottom of the window, put tooltip 10px above cursor
        var tooltipHeight = this.getBoundingClientRect().height;
        if (event.clientY + tooltipHeight + offsetY < window.innerHeight) {
            return '' + (event.clientY + offsetY) + 'px';
        }
        else {
            return '' + (event.clientY - tooltipHeight - offsetY) + 'px';
        }
    })
        .style('left', function () {
        // by default: put tooltip 10px to the right of cursor
        // if tooltip is close to the right edge of the window, put tooltip 10 px to the left of cursor
        var tooltipWidth = this.getBoundingClientRect().width;
        if (event.clientX + tooltipWidth + offsetX < window.innerWidth) {
            return '' + (event.clientX + offsetX) + 'px';
        }
        else {
            return '' + (event.clientX - tooltipWidth - offsetX) + 'px';
        }
    });
}
/* Clear tooltip position */
function clearPosition() {
    d3_selection_1.select('#vis-tooltip')
        .style('top', '-9999px')
        .style('left', '-9999px');
}
/**
* Update tooltip color theme according to options.colorTheme
*
* If colorTheme === "dark", apply dark theme to tooltip.
* Otherwise apply light color theme.
*/
function updateColorTheme(options) {
    clearColorTheme();
    if (options && options.colorTheme === 'dark') {
        d3_selection_1.select('#vis-tooltip').classed('dark-theme', true);
    }
    else {
        d3_selection_1.select('#vis-tooltip').classed('light-theme', true);
    }
}
/* Clear color themes */
function clearColorTheme() {
    d3_selection_1.select('#vis-tooltip').classed('dark-theme light-theme', false);
}

},{"d3-collection":1,"d3-format":2,"d3-selection":3,"d3-time":5,"d3-time-format":4,"vega-lite/build/src/type":101,"vega-lite/build/src/vl":105}]},{},[107])(107)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMtY29sbGVjdGlvbi9idWlsZC9kMy1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9kMy1mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2J1aWxkL2QzLXNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9idWlsZC9kMy10aW1lLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lL2J1aWxkL2QzLXRpbWUuanMiLCJub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtZXZlbnQtc2VsZWN0b3IvYnVpbGQvdmVnYS1ldmVudC1zZWxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvYWdncmVnYXRlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvYXhpcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2Jpbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NoYW5uZWwuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2F4aXMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9heGlzL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9heGlzL3J1bGVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9jb21tb24uanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvZGF0YS9hZ2dyZWdhdGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvYXNzZW1ibGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvYmluLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL2RhdGFmbG93LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL2ZhY2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL2Zvcm1hdHBhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL25vbnBvc2l0aXZlZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL251bGxmaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvb3B0aW1pemVycy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvZGF0YS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvZGF0YS9wYXRob3JkZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL3N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL3RpbWV1bml0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL3RyYW5zZm9ybXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2ZhY2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbGF5b3V0L2hlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbGF5b3V0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9sZWdlbmQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9sZWdlbmQvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2xlZ2VuZC9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9hcmVhLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9tYXJrL2Jhci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9pbml0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9tYXJrL2xpbmUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9taXhpbnMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvcG9pbnQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvcmVjdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9ydWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9tYXJrL3RleHQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvdGljay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay92YWx1ZXJlZi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbW9kZWwuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3JlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2NhbGUvYXNzZW1ibGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NjYWxlL2RvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2NhbGUvaW5pdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2NhbGUvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NjYWxlL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zY2FsZS9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2NhbGUvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL2ludGVydmFsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vbXVsdGkuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi9zZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi9zaW5nbGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL2lucHV0cy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3RyYW5zZm9ybXMvbmVhcmVzdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3RyYW5zZm9ybXMvcHJvamVjdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3RyYW5zZm9ybXMvc2NhbGVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vdHJhbnNmb3Jtcy90b2dnbGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL3RyYW5zZm9ybXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL3RyYW5zbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3RyYW5zZm9ybXMvem9vbS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvdW5pdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBvc2l0ZW1hcmsvYm94cGxvdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBvc2l0ZW1hcmsvZXJyb3JiYXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21wb3NpdGVtYXJrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2RhdGV0aW1lLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZW5jb2RpbmcuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9mYWNldC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2ZpZWxkZGVmLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvbGVnZW5kLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvbG9nLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3Jlc29sdmUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3NlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3NvcnQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9zcGVjLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvc3RhY2suanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy90aW1ldW5pdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3RvcGxldmVscHJvcHMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy90eXBlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3ZhbGlkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvdmVnYS5zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy92bC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLXV0aWwvYnVpbGQvdmVnYS11dGlsLmpzIiwic3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzljQSwrQ0FBZ0Q7QUFDaEQsdUNBQW1EO0FBQ25ELDZDQUE2RDtBQUM3RCxtQ0FBaUc7QUFDakcsaURBQTBDO0FBRzFDLGlEQUFrRDtBQUNsRCwyQ0FBNkM7QUFJN0MsK0NBQStDO0FBQy9DLElBQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQztBQUNsQixJQUFJLGNBQWMsR0FBVyxTQUFTLENBQUM7QUFDdkMsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBZ0IxQjs7OztFQUlFO0FBQ0YsY0FBcUIsTUFBYyxFQUFFLE9BQXVDO0lBQzFFLDRDQUE0QztJQURULHdCQUFBLEVBQUEsWUFBbUIsYUFBYSxFQUFFLElBQUksRUFBQztJQUcxRSw4REFBOEQ7SUFDOUQsTUFBTSxDQUFDLGdCQUFnQixDQUFDLHVCQUF1QixFQUFFLFVBQVUsS0FBaUIsRUFBRSxJQUFnQjtRQUM1RixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUIsNkVBQTZFO1lBQzdFLGFBQWEsRUFBRSxDQUFDO1lBRWhCLGNBQWMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO2dCQUNqQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM3QixDQUFDLEVBQUUsT0FBTyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQztRQUM3QixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCx3Q0FBd0M7SUFDeEMsd0NBQXdDO0lBQ3hDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyx5QkFBeUIsRUFBRSxVQUFVLEtBQWlCLEVBQUUsSUFBZ0I7UUFDOUYsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQztZQUM3QyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMvQixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCw2QkFBNkI7SUFDN0IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLHdCQUF3QixFQUFFLFVBQVUsS0FBaUIsRUFBRSxJQUFnQjtRQUM3RixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUIsYUFBYSxFQUFFLENBQUM7WUFFaEIsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDbEIsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDOUIsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQztRQUNMLE9BQU8sRUFBRTtZQUNQLHlCQUF5QjtZQUN6QixNQUFNLENBQUMsbUJBQW1CLENBQUMsdUJBQXVCLENBQUMsQ0FBQztZQUNwRCxNQUFNLENBQUMsbUJBQW1CLENBQUMseUJBQXlCLENBQUMsQ0FBQztZQUN0RCxNQUFNLENBQUMsbUJBQW1CLENBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUVyRCxhQUFhLEVBQUUsQ0FBQyxDQUFDLHdCQUF3QjtRQUMzQyxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUE1Q0Qsb0JBNENDO0FBQUEsQ0FBQztBQUVGOzs7OztFQUtFO0FBQ0Ysa0JBQXlCLE1BQWMsRUFBRSxNQUE0QixFQUFFLE9BQW9CO0lBQXBCLHdCQUFBLEVBQUEsWUFBb0I7SUFFekYsT0FBTyxHQUFHLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUU3QyxnRUFBZ0U7SUFDaEUsOERBQThEO0lBQzlELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyx1QkFBdUIsRUFBRSxVQUFVLEtBQWlCLEVBQUUsSUFBZ0I7UUFDNUYsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLDZFQUE2RTtZQUM3RSxhQUFhLEVBQUUsQ0FBQztZQUVoQixpREFBaUQ7WUFDakQsY0FBYyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzdCLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILHdDQUF3QztJQUN4Qyx3Q0FBd0M7SUFDeEMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixFQUFFLFVBQVUsS0FBaUIsRUFBRSxJQUFnQjtRQUM5RixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQzdDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQy9CLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILDZCQUE2QjtJQUM3QixNQUFNLENBQUMsZ0JBQWdCLENBQUMsd0JBQXdCLEVBQUUsVUFBVSxLQUFpQixFQUFFLElBQWdCO1FBQzdGLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixhQUFhLEVBQUUsQ0FBQztZQUVoQixFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO2dCQUNsQixLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM5QixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDO1FBQ0wsT0FBTyxFQUFFO1lBQ1AseUJBQXlCO1lBQ3pCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ3BELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1lBQ3RELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1lBRXJELGFBQWEsRUFBRSxDQUFDLENBQUMsd0JBQXdCO1FBQzNDLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQztBQS9DRCw0QkErQ0M7QUFBQSxDQUFDO0FBRUYsNEJBQTRCO0FBQzVCO0lBQ0U7O3lDQUVxQztJQUNyQyxNQUFNLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ3BDLGNBQWMsR0FBRyxTQUFTLENBQUM7QUFDN0IsQ0FBQztBQUVELDhDQUE4QztBQUM5QyxJQUFNLGFBQWEsR0FBd0M7SUFDekQsY0FBYyxFQUFFLFFBQVE7SUFDeEIsVUFBVSxFQUFFLE1BQU07SUFDbEIsU0FBUyxFQUFFLFNBQVM7SUFDcEIsU0FBUyxFQUFFLFNBQVM7Q0FDckIsQ0FBQztBQUVGOzs7Ozs7Ozs7OztFQVdFO0FBQ0YsMkJBQTJCLE9BQWUsRUFBRSxNQUE0QjtJQUN0RSxzQ0FBc0M7SUFDdEMsSUFBTSxrQkFBa0IsR0FBa0IsRUFBRSxDQUFDO0lBRTdDLHlFQUF5RTtJQUN6RSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDcEMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsUUFBMEI7WUFDcEUseURBQXlEO1lBQ3pELElBQU0sV0FBVyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRTdELHNEQUFzRDtZQUN0RCxJQUFNLHVCQUF1QixHQUFHLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFFckYsa0JBQWtCLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDbkQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNuQixPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLFdBQXdCO2dCQUN2RCwwREFBMEQ7Z0JBQzFELElBQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQXVCLEVBQUUsV0FBVyxDQUFDLENBQUM7Z0JBRTNGLHNEQUFzRDtnQkFDdEQsSUFBTSx1QkFBdUIsR0FBRyxxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUVyRixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQztZQUNuRCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxDQUFDLE1BQU0sR0FBRyxrQkFBa0IsQ0FBQztJQUVwQyxNQUFNLENBQUMsT0FBTyxDQUFDO0FBQ2pCLENBQUM7QUFFRDs7Ozs7Ozs7OztFQVVFO0FBQ0Ysd0JBQXdCLFlBQTJCLEVBQUUsUUFBMEI7SUFDN0UsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxZQUFZLElBQUksWUFBWSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNELE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELHlEQUF5RDtJQUN6RCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUN2Qiw0RUFBNEU7UUFDNUUsR0FBRyxDQUFDLENBQWEsVUFBWSxFQUFaLDZCQUFZLEVBQVosMEJBQVksRUFBWixJQUFZO1lBQXhCLElBQUksSUFBSSxxQkFBQTtZQUNYLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUMzRSxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2QsQ0FBQztTQUNGO1FBRUQsc0ZBQXNGO1FBQ3RGLEdBQUcsQ0FBQyxDQUFhLFVBQVksRUFBWiw2QkFBWSxFQUFaLDBCQUFZLEVBQVosSUFBWTtZQUF4QixJQUFJLElBQUkscUJBQUE7WUFDWCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDckQsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNkLENBQUM7U0FDRjtRQUVELHlDQUF5QztRQUN6QyxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLEdBQUcsQ0FBQyxDQUFhLFVBQVksRUFBWiw2QkFBWSxFQUFaLDBCQUFZLEVBQVosSUFBWTtZQUF4QixJQUFJLElBQUkscUJBQUE7WUFDWCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2QsQ0FBQztTQUNGO1FBRUQseUNBQXlDO1FBQ3pDLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7Ozs7O0VBU0U7QUFDRixxQkFBcUIsU0FBNkIsRUFBRSxXQUF3QjtJQUMxRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELDJEQUEyRDtJQUMzRCxHQUFHLENBQUMsQ0FBYSxVQUFTLEVBQVQsdUJBQVMsRUFBVCx1QkFBUyxFQUFULElBQVM7UUFBckIsSUFBSSxJQUFJLGtCQUFBO1FBQ1gsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNyQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDbkIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxXQUFXLENBQUMsU0FBUyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7b0JBQ3ZFLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ2QsQ0FBQztZQUNILENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2QsQ0FBQztRQUNILENBQUM7S0FDRjtJQUVELHlDQUF5QztJQUN6QyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRDs7Ozs7O0VBTUU7QUFDRiwrQkFBK0IsV0FBd0IsRUFBRSxRQUEwQixFQUFFLE1BQTRCO0lBQy9HLCtCQUErQjtJQUMvQixJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRWpELHdEQUF3RDtJQUN4RCxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDOUIsT0FBTyxDQUFDLEtBQUssQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO1FBQzdGLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELGtGQUFrRjtJQUNsRixFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzdCLFdBQVcsR0FBRyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDN0IsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRUQsZ0NBQWdDO0lBQ2hDLElBQU0sdUJBQXVCLEdBQTRCLEVBQUUsQ0FBQztJQUU1RCxpRkFBaUY7SUFDakYsc0NBQXNDO0lBQ3RDLHFEQUFxRDtJQUNyRCx1REFBdUQ7SUFDdkQsMEdBQTBHO0lBQzFHLHVCQUF1QixDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSztRQUM1QyxFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBRWxELHVGQUF1RjtJQUN2Rix1RkFBdUY7SUFDdkYsOEZBQThGO0lBQzlGLGdCQUFnQjtJQUNoQiw4RkFBOEY7SUFDOUYsd0RBQXdEO0lBQ3hELGtFQUFrRTtJQUNsRSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLGVBQVEsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNwRCw2REFBNkQ7UUFDN0QsSUFBTSxxQkFBcUIsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDO1FBQzdDLHVCQUF1QixDQUFDLDJCQUEyQixHQUFHLHFCQUFxQixDQUFDO1FBRTVFLHFGQUFxRjtRQUNyRixJQUFNLFNBQVMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM1QyxHQUFHLENBQUMsQ0FBYyxVQUFTLEVBQVQsdUJBQVMsRUFBVCx1QkFBUyxFQUFULElBQVM7WUFBdEIsSUFBSSxLQUFLLGtCQUFBO1lBQ1osRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssS0FBSyxxQkFBcUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUM3RCx1QkFBdUIsQ0FBQywyQkFBMkIsR0FBRyxTQUFTLENBQUM7Z0JBQ2hFLEtBQUssQ0FBQztZQUNSLENBQUM7U0FDRjtJQUNILENBQUM7SUFFRCxtQkFBbUI7SUFDbkIsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUN2QixNQUFNLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLDRCQUE0QjtJQUN0RixDQUFDO0lBQ0QsdUJBQXVCLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLO1FBQy9DLFdBQVcsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTFELHdCQUF3QjtJQUN4Qix1QkFBdUIsQ0FBQyxVQUFVLEdBQUcsV0FBVyxDQUFDLFVBQVU7UUFDekQsV0FBVyxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXhELG9CQUFvQjtJQUNwQixFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN2Qix1QkFBdUIsQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQztJQUN0RCxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixNQUFNLENBQUMsQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQzNDLEtBQUssTUFBTTtnQkFDVCx1QkFBdUIsQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLFFBQVE7b0JBQ2hELGtGQUFrRjtvQkFDbEYsRUFBRSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO3NCQUN0RSxNQUFNLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztnQkFDNUQsS0FBSyxDQUFDO1lBQ1IsS0FBSyxRQUFRO2dCQUNYLHVCQUF1QixDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDO2dCQUNyRCxLQUFLLENBQUM7WUFDUixLQUFLLFFBQVEsQ0FBQztZQUNkLFFBQVE7UUFDVixDQUFDO0lBQ0gsQ0FBQztJQUVELGlGQUFpRjtJQUNqRixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNqQix1QkFBdUIsQ0FBQyxLQUFLLEdBQUcsdUJBQXVCLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxpQkFBaUI7UUFDNUcsdUJBQXVCLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztRQUNuQyx1QkFBdUIsQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDLENBQUMsNENBQTRDO0lBQzdGLENBQUM7SUFFRCxNQUFNLENBQUMsdUJBQXVCLENBQUM7QUFDakMsQ0FBQztBQUdELGtDQUFrQztBQUNsQyxjQUFjLEtBQWlCLEVBQUUsSUFBZ0IsRUFBRSxPQUFlO0lBQ2hFLCtCQUErQjtJQUMvQixJQUFNLGtCQUFrQixHQUFHLHFCQUFxQixFQUFFLENBQUM7SUFFbkQsMkJBQTJCO0lBQzNCLElBQU0sV0FBVyxHQUFHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDbEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELHdDQUF3QztJQUN4QyxRQUFRLENBQUMsa0JBQWtCLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFFMUMsY0FBYyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMvQixnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdEQsYUFBYSxHQUFHLElBQUksQ0FBQztJQUVyQixnQ0FBZ0M7SUFDaEMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDckIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztBQUNILENBQUM7QUFFRCwwQ0FBMEM7QUFDMUMsZ0JBQWdCLEtBQWlCLEVBQUUsSUFBZ0IsRUFBRSxPQUFlO0lBQ2xFLGNBQWMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFL0IsZ0NBQWdDO0lBQ2hDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ25CLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7QUFDSCxDQUFDO0FBRUQsbUJBQW1CO0FBQ25CLGVBQWUsS0FBaUIsRUFBRSxJQUFnQixFQUFFLE9BQWU7SUFDakUsNENBQTRDO0lBQzVDLHdFQUF3RTtJQUN4RSxxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFckQsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUN0QixTQUFTLEVBQUUsQ0FBQztJQUNaLGVBQWUsRUFBRSxDQUFDO0lBQ2xCLGFBQWEsRUFBRSxDQUFDO0lBRWhCLGdDQUFnQztJQUNoQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUN4QixPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDO0FBQ0gsQ0FBQztBQUdELGtEQUFrRDtBQUNsRCwyQkFBMkIsSUFBZ0I7SUFDekMsbUJBQW1CO0lBQ25CLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFFLENBQUM7UUFDMUIsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxtRUFBbUU7SUFDbkUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0Qsa0RBQWtEO0lBQ2xELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRDs7O0VBR0U7QUFDRixxQkFBcUI7QUFDckIsd0JBQXdCLElBQWdCLEVBQUUsT0FBZTtJQUN2RCw2REFBNkQ7SUFDN0QsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUFDLENBQUMsQ0FBQztRQUM3RSxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxpREFBaUQ7SUFDakQsSUFBSSxXQUEwQixDQUFDO0lBQy9CLElBQU0sUUFBUSxHQUFhLG1CQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTdDLElBQU0sVUFBVSxHQUFHO1FBQ2pCLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVE7UUFDakMsYUFBYSxFQUFFLFdBQVc7UUFDMUIsY0FBYyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxVQUFVO0tBQ2xGLENBQUM7SUFDRixZQUFZLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRW5DLHdDQUF3QztJQUN4Qyx5QkFBeUIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRXBELDREQUE0RDtJQUM1RCxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTNDLHVGQUF1RjtJQUN2RixxQkFBcUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVwRCxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDbkMsV0FBVyxHQUFHLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixXQUFXLEdBQUcsdUJBQXVCLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFFRDs7Ozs7OztFQU9FO0FBQ0YsaUNBQWlDLFFBQWtCLEVBQUUsT0FBZTtJQUNsRSxJQUFNLFdBQVcsR0FBa0IsRUFBRSxDQUFDO0lBRXRDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsV0FBVztRQUMxQyxzQkFBc0I7UUFDdEIsSUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUM7UUFFeEUsd0JBQXdCO1FBQ3hCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BELEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDbkIsQ0FBQztRQUVELGVBQWU7UUFDZixJQUFNLGNBQWMsR0FBRyxZQUFZLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1RyxvQ0FBb0M7UUFDcEMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBQyxDQUFDLENBQUM7SUFFMUQsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFFRDs7Ozs7O0VBTUU7QUFDRixnRkFBZ0Y7QUFDaEYsa0JBQWtCLFFBQWtCLEVBQUUsS0FBYTtJQUNqRCxJQUFJLEtBQTZCLENBQUM7SUFFbEMsSUFBTSxTQUFTLEdBQWEsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUU3QyxzREFBc0Q7SUFDdEQsSUFBTSxhQUFhLEdBQVcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNsQixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUVwQyx3REFBd0Q7UUFDeEQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7WUFDM0IsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDYixLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25CLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztRQUN4QixPQUFPLENBQUMsSUFBSSxDQUFDLDhCQUE4QixHQUFHLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQztRQUNuRSxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0FBQ0gsQ0FBQztBQUdEOzs7Ozs7Ozs7OztFQVdFO0FBQ0YsOEJBQThCLFFBQWtCLEVBQUUsT0FBZTtJQUMvRCxJQUFNLFdBQVcsR0FBa0IsRUFBRSxDQUFDO0lBRXRDLDJDQUEyQztJQUMzQyxJQUFNLFlBQVksR0FBRyxtQkFBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU3RSxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsS0FBYSxFQUFFLEtBQWE7UUFDbEQsZ0JBQWdCO1FBQ2hCLElBQUksS0FBSyxDQUFDO1FBQ1YsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDN0QsS0FBSyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ3hDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDaEIsQ0FBQztRQUVELElBQUksVUFBVSxDQUFDO1FBQ2YsSUFBSSxNQUFNLENBQUM7UUFDWCxlQUFlO1FBQ2YsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUIsVUFBVSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxDQUFDO1lBQ2hELE1BQU0sR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUMxQyxDQUFDO1FBQ0QsSUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXBGLG9DQUFvQztRQUNwQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQyxXQUFXLENBQUM7QUFDckIsQ0FBQztBQUVEOzs7Ozs7O0VBT0U7QUFDRixzQkFBc0IsT0FBaUIsRUFBRSxVQUFvQjtJQUMzRCxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRztRQUM5QixPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxtQ0FBbUMsUUFBa0IsRUFBRSxTQUFvQztJQUN6RixFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDZixNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsUUFBUTtRQUNsQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRDs7Ozs7OztFQU9FO0FBQ0YsMEJBQTBCLFFBQWtCLEVBQUUsWUFBMkI7SUFDdkUsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBVSxXQUFXO1FBQ3hDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM3Qix5QkFBeUI7WUFDekIsSUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQztZQUN4QyxJQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3JELElBQU0sV0FBVyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakQsSUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVqRCxpREFBaUQ7WUFDakQsMkNBQTJDO1lBQzNDLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDL0MsSUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMzQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNELElBQU0sS0FBSyxHQUFHLFVBQVUsR0FBRyxHQUFHLEdBQUcsUUFBUSxDQUFDO2dCQUMxQyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNyQyxDQUFDO1lBRUQsbUVBQW1FO1lBQ25FLElBQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztZQUN6QixhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDNUQsWUFBWSxDQUFDLFFBQVEsRUFBRSxhQUFhLENBQUMsQ0FBQztRQUN4QyxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRDs7Ozs7Ozs7OztFQVVFO0FBQ0YsK0JBQStCLFFBQWdCLEVBQUUsUUFBa0I7SUFDakUsRUFBRSxDQUFDLENBQUMsUUFBUSxLQUFLLE1BQU0sSUFBSSxRQUFRLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMvQyxJQUFNLFVBQVEsR0FBYSxFQUFFLENBQUM7UUFDOUIsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLEtBQUssRUFBRSxLQUFLO1lBQ2hDLEVBQUUsQ0FBQyxDQUFDLEtBQUssWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUMxQixVQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZCLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUNILFlBQVksQ0FBQyxRQUFRLEVBQUUsVUFBUSxDQUFDLENBQUM7SUFDbkMsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7O0VBTUU7QUFDRixzQkFBc0IsS0FBNkIsRUFBRSxVQUFrQixFQUFFLE1BQWM7SUFDckYsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUUsQ0FBQztRQUMzQyxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDaEIsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUNuQixLQUFLLE1BQU07WUFDVCxNQUFNLENBQUMsTUFBTSxHQUFHLDJCQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBYSxDQUFDLEdBQUcsY0FBYyxDQUFDLEtBQWEsQ0FBQyxDQUFDO1FBQ3BGLEtBQUssUUFBUTtZQUNYLE1BQU0sQ0FBQyxNQUFNLEdBQUcsa0JBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFlLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxLQUFlLENBQUMsQ0FBQztRQUM5RixLQUFLLFFBQVEsQ0FBQztRQUNkO1lBQ0UsTUFBTSxDQUFDLEtBQWUsQ0FBQztJQUMzQixDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7RUFHRTtBQUNGLG9CQUFvQixLQUE2QjtJQUMvQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzlCLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDSCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCwwQkFBMEIsS0FBYTtJQUNyQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsa0JBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxrQkFBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3RGLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILHdCQUF3QixJQUFVO0lBQ2hDLElBQU0saUJBQWlCLEdBQUcsMkJBQVUsQ0FBQyxLQUFLLENBQUMsRUFDekMsWUFBWSxHQUFHLDJCQUFVLENBQUMsS0FBSyxDQUFDLEVBQ2hDLFlBQVksR0FBRywyQkFBVSxDQUFDLE9BQU8sQ0FBQyxFQUNsQyxVQUFVLEdBQUcsMkJBQVUsQ0FBQyxPQUFPLENBQUMsRUFDaEMsU0FBUyxHQUFHLDJCQUFVLENBQUMsT0FBTyxDQUFDLEVBQy9CLFVBQVUsR0FBRywyQkFBVSxDQUFDLE9BQU8sQ0FBQyxFQUNoQyxXQUFXLEdBQUcsMkJBQVUsQ0FBQyxJQUFJLENBQUMsRUFDOUIsVUFBVSxHQUFHLDJCQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFaEMsTUFBTSxDQUFDLENBQUMsb0JBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsaUJBQWlCO1VBQzdDLG9CQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLFlBQVk7Y0FDdEMsa0JBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsWUFBWTtrQkFDcEMsaUJBQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsVUFBVTtzQkFDakMsbUJBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxrQkFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxTQUFTLEdBQUcsVUFBVSxDQUFDOzBCQUN6RSxrQkFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxXQUFXOzhCQUNuQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQixDQUFDO0FBRUQ7Ozs7RUFJRTtBQUNGO0lBQ0UsSUFBSSxrQkFBa0IsQ0FBQztJQUV2QixFQUFFLENBQUMsQ0FBQyxxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNuQyxrQkFBa0IsR0FBRyxxQkFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDOUMsSUFBSSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUM7YUFDekIsSUFBSSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixrQkFBa0IsR0FBRyxxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRCxNQUFNLENBQUMsa0JBQWtCLENBQUM7QUFDNUIsQ0FBQztBQUVEOztFQUVFO0FBQ0Ysa0JBQWtCLGtCQUErRixFQUFFLFdBQTBCO0lBQzNJLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUMvQyxJQUFNLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQztTQUM3RSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFckIsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBRTVCLElBQU0sR0FBRyxHQUFHLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1NBQ3pDLElBQUksQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDaEMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQWMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBYyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUYsQ0FBQztBQUVEOztFQUVFO0FBQ0Y7SUFDRSxxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1NBQ3RELElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3JCLENBQUM7QUFFRDs7OztFQUlFO0FBQ0Ysd0JBQXdCLEtBQWlCLEVBQUUsT0FBZTtJQUN4RCwrQ0FBK0M7SUFDL0MsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUNqQixFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pHLE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBQ0QsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRyxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELGtDQUFrQztJQUNsQyxxQkFBTSxDQUFDLGNBQWMsQ0FBQztTQUNuQixLQUFLLENBQUMsS0FBSyxFQUFFO1FBQ1osNENBQTRDO1FBQzVDLGlGQUFpRjtRQUNqRixJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxNQUFNLENBQUM7UUFDMUQsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxhQUFhLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMvQyxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxhQUFhLEdBQUcsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQy9ELENBQUM7SUFDSCxDQUFDLENBQUM7U0FDRCxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2Isc0RBQXNEO1FBQ3RELCtGQUErRjtRQUMvRixJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUM7UUFDeEQsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxZQUFZLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQy9ELE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMvQyxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxZQUFZLEdBQUcsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQzlELENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFFRCw0QkFBNEI7QUFDNUI7SUFDRSxxQkFBTSxDQUFDLGNBQWMsQ0FBQztTQUNuQixLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQztTQUN2QixLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFFRDs7Ozs7RUFLRTtBQUNGLDBCQUEwQixPQUFlO0lBQ3ZDLGVBQWUsRUFBRSxDQUFDO0lBRWxCLEVBQUUsQ0FBQyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBVSxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDN0MscUJBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLHFCQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0RCxDQUFDO0FBQ0gsQ0FBQztBQUVELHdCQUF3QjtBQUN4QjtJQUNFLHFCQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLHdCQUF3QixFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ2xFLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb2xsZWN0aW9uLyBWZXJzaW9uIDEuMC4zLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBwcmVmaXggPSBcIiRcIjtcblxuZnVuY3Rpb24gTWFwKCkge31cblxuTWFwLnByb3RvdHlwZSA9IG1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNYXAsXG4gIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIChwcmVmaXggKyBrZXkpIGluIHRoaXM7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJlZml4ICsga2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1twcmVmaXggKyBrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJlZml4ICsga2V5O1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGtleXMucHVzaChwcm9wZXJ0eS5zbGljZSgxKSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH0sXG4gIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSB2YWx1ZXMucHVzaCh0aGlzW3Byb3BlcnR5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSxcbiAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZW50cmllcy5wdXNoKHtrZXk6IHByb3BlcnR5LnNsaWNlKDEpLCB2YWx1ZTogdGhpc1twcm9wZXJ0eV19KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSArK3NpemU7XG4gICAgcmV0dXJuIHNpemU7XG4gIH0sXG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGYodGhpc1twcm9wZXJ0eV0sIHByb3BlcnR5LnNsaWNlKDEpLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFwKG9iamVjdCwgZikge1xuICB2YXIgbWFwID0gbmV3IE1hcDtcblxuICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwKSBvYmplY3QuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7IG1hcC5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xuXG4gIC8vIEluZGV4IGFycmF5IGJ5IG51bWVyaWMgaW5kZXggb3Igc3BlY2lmaWVkIGtleSBmdW5jdGlvbi5cbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IG9iamVjdC5sZW5ndGgsXG4gICAgICAgIG87XG5cbiAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pO1xuICAgIGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZihvID0gb2JqZWN0W2ldLCBpLCBvYmplY3QpLCBvKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgb2JqZWN0IHRvIG1hcC5cbiAgZWxzZSBpZiAob2JqZWN0KSBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuXG4gIHJldHVybiBtYXA7XG59XG5cbnZhciBuZXN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrZXlzID0gW10sXG4gICAgICBzb3J0S2V5cyA9IFtdLFxuICAgICAgc29ydFZhbHVlcyxcbiAgICAgIHJvbGx1cCxcbiAgICAgIG5lc3Q7XG5cbiAgZnVuY3Rpb24gYXBwbHkoYXJyYXksIGRlcHRoLCBjcmVhdGVSZXN1bHQsIHNldFJlc3VsdCkge1xuICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHJvbGx1cCAhPSBudWxsXG4gICAgICAgID8gcm9sbHVwKGFycmF5KSA6IChzb3J0VmFsdWVzICE9IG51bGxcbiAgICAgICAgPyBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpXG4gICAgICAgIDogYXJyYXkpO1xuXG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgICAga2V5VmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZXNCeUtleSA9IG1hcCgpLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyBcIlwiKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24odmFsdWVzLCBrZXkpIHtcbiAgICAgIHNldFJlc3VsdChyZXN1bHQsIGtleSwgYXBwbHkodmFsdWVzLCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyaWVzKG1hcCQkMSwgZGVwdGgpIHtcbiAgICBpZiAoKytkZXB0aCA+IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwJCQxO1xuICAgIHZhciBhcnJheSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoIC0gMV07XG4gICAgaWYgKHJvbGx1cCAhPSBudWxsICYmIGRlcHRoID49IGtleXMubGVuZ3RoKSBhcnJheSA9IG1hcCQkMS5lbnRyaWVzKCk7XG4gICAgZWxzZSBhcnJheSA9IFtdLCBtYXAkJDEuZWFjaChmdW5jdGlvbih2LCBrKSB7IGFycmF5LnB1c2goe2tleTogaywgdmFsdWVzOiBlbnRyaWVzKHYsIGRlcHRoKX0pOyB9KTtcbiAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XG4gIH1cblxuICByZXR1cm4gbmVzdCA9IHtcbiAgICBvYmplY3Q6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlT2JqZWN0LCBzZXRPYmplY3QpOyB9LFxuICAgIG1hcDogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCk7IH0sXG4gICAgZW50cmllczogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGVudHJpZXMoYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKSwgMCk7IH0sXG4gICAga2V5OiBmdW5jdGlvbihkKSB7IGtleXMucHVzaChkKTsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydEtleXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydFZhbHVlczogZnVuY3Rpb24ob3JkZXIpIHsgc29ydFZhbHVlcyA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcbiAgICByb2xsdXA6IGZ1bmN0aW9uKGYpIHsgcm9sbHVwID0gZjsgcmV0dXJuIG5lc3Q7IH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBzZXRPYmplY3Qob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgcmV0dXJuIG1hcCgpO1xufVxuXG5mdW5jdGlvbiBzZXRNYXAobWFwJCQxLCBrZXksIHZhbHVlKSB7XG4gIG1hcCQkMS5zZXQoa2V5LCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIFNldCgpIHt9XG5cbnZhciBwcm90byA9IG1hcC5wcm90b3R5cGU7XG5cblNldC5wcm90b3R5cGUgPSBzZXQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2V0LFxuICBoYXM6IHByb3RvLmhhcyxcbiAgYWRkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhbHVlICs9IFwiXCI7XG4gICAgdGhpc1twcmVmaXggKyB2YWx1ZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBwcm90by5yZW1vdmUsXG4gIGNsZWFyOiBwcm90by5jbGVhcixcbiAgdmFsdWVzOiBwcm90by5rZXlzLFxuICBzaXplOiBwcm90by5zaXplLFxuICBlbXB0eTogcHJvdG8uZW1wdHksXG4gIGVhY2g6IHByb3RvLmVhY2hcbn07XG5cbmZ1bmN0aW9uIHNldChvYmplY3QsIGYpIHtcbiAgdmFyIHNldCA9IG5ldyBTZXQ7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFNldCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUpIHsgc2V0LmFkZCh2YWx1ZSk7IH0pO1xuXG4gIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl04oCZcyBhbiBhcnJheS5cbiAgZWxzZSBpZiAob2JqZWN0KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIHNldC5hZGQob2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKGYob2JqZWN0W2ldLCBpLCBvYmplY3QpKTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBrZXlzID0gZnVuY3Rpb24obWFwKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnZhciB2YWx1ZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgZW50cmllcyA9IGZ1bmN0aW9uKG1hcCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe2tleToga2V5LCB2YWx1ZTogbWFwW2tleV19KTtcbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG5leHBvcnRzLm5lc3QgPSBuZXN0O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmV4cG9ydHMuZW50cmllcyA9IGVudHJpZXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWZvcm1hdC8gVmVyc2lvbiAxLjIuMC4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxudmFyIGZvcm1hdERlY2ltYWwgPSBmdW5jdGlvbih4LCBwKSB7XG4gIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgcmV0dXJuIFtcbiAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICt4LnNsaWNlKGkgKyAxKVxuICBdO1xufTtcblxudmFyIGV4cG9uZW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn07XG5cbnZhciBmb3JtYXRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICB0ID0gW10sXG4gICAgICAgIGogPSAwLFxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gIH07XG59O1xuXG52YXIgZm9ybWF0TnVtZXJhbHMgPSBmdW5jdGlvbihudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbnZhciBmb3JtYXREZWZhdWx0ID0gZnVuY3Rpb24oeCwgcCkge1xuICB4ID0geC50b1ByZWNpc2lvbihwKTtcblxuICBvdXQ6IGZvciAodmFyIG4gPSB4Lmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgc3dpdGNoICh4W2ldKSB7XG4gICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCJlXCI6IGJyZWFrIG91dDtcbiAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGkwID4gMCA/IHguc2xpY2UoMCwgaTApICsgeC5zbGljZShpMSArIDEpIDogeDtcbn07XG5cbnZhciBwcmVmaXhFeHBvbmVudDtcblxudmFyIGZvcm1hdFByZWZpeEF1dG8gPSBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufTtcblxudmFyIGZvcm1hdFJvdW5kZWQgPSBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV07XG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn07XG5cbnZhciBmb3JtYXRUeXBlcyA9IHtcbiAgXCJcIjogZm9ybWF0RGVmYXVsdCxcbiAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxufTtcblxuLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt0eXBlXVxudmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLVxcKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyhbYS16JV0pPyQvaTtcblxuZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5mdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcblxuICB2YXIgbWF0Y2gsXG4gICAgICBmaWxsID0gbWF0Y2hbMV0gfHwgXCIgXCIsXG4gICAgICBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLFxuICAgICAgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLFxuICAgICAgc3ltYm9sID0gbWF0Y2hbNF0gfHwgXCJcIixcbiAgICAgIHplcm8gPSAhIW1hdGNoWzVdLFxuICAgICAgd2lkdGggPSBtYXRjaFs2XSAmJiArbWF0Y2hbNl0sXG4gICAgICBjb21tYSA9ICEhbWF0Y2hbN10sXG4gICAgICBwcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgICB0eXBlID0gbWF0Y2hbOV0gfHwgXCJcIjtcblxuICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gIC8vIE1hcCBpbnZhbGlkIHR5cGVzIHRvIHRoZSBkZWZhdWx0IGZvcm1hdC5cbiAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSB0eXBlID0gXCJcIjtcblxuICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgdGhpcy5maWxsID0gZmlsbDtcbiAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB0aGlzLnNpZ24gPSBzaWduO1xuICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgdGhpcy56ZXJvID0gemVybztcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmNvbW1hID0gY29tbWE7XG4gIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG52YXIgZm9ybWF0TG9jYWxlID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyAmJiBsb2NhbGUudGhvdXNhbmRzID8gZm9ybWF0R3JvdXAobG9jYWxlLmdyb3VwaW5nLCBsb2NhbGUudGhvdXNhbmRzKSA6IGlkZW50aXR5LFxuICAgICAgY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwsXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA/IGZvcm1hdE51bWVyYWxzKGxvY2FsZS5udW1lcmFscykgOiBpZGVudGl0eSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCB8fCBcIiVcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVswXSA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzFdIDogL1slcF0vLnRlc3QodHlwZSkgPyBwZXJjZW50IDogXCJcIjtcblxuICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICBtYXliZVN1ZmZpeCA9ICF0eXBlIHx8IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/ICh0eXBlID8gNiA6IDEyKVxuICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeCxcbiAgICAgICAgICBpLCBuLCBjO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gdmFsdWUgPCAwO1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdFR5cGUoTWF0aC5hYnModmFsdWUpLCBwcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gZHVyaW5nIGZvcm1hdHRpbmcsIHRyZWF0IGFzIHBvc2l0aXZlLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDApIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBcIi1cIikgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IHZhbHVlU3VmZml4ICsgKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59O1xuXG52YXIgbG9jYWxlO1xuXG5cblxuZGVmYXVsdExvY2FsZSh7XG4gIGRlY2ltYWw6IFwiLlwiLFxuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG52YXIgcHJlY2lzaW9uRml4ZWQgPSBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn07XG5cbnZhciBwcmVjaXNpb25QcmVmaXggPSBmdW5jdGlvbihzdGVwLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufTtcblxudmFyIHByZWNpc2lvblJvdW5kID0gZnVuY3Rpb24oc3RlcCwgbWF4KSB7XG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbn07XG5cbmV4cG9ydHMuZm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG5leHBvcnRzLmZvcm1hdExvY2FsZSA9IGZvcm1hdExvY2FsZTtcbmV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuZXhwb3J0cy5wcmVjaXNpb25GaXhlZCA9IHByZWNpc2lvbkZpeGVkO1xuZXhwb3J0cy5wcmVjaXNpb25QcmVmaXggPSBwcmVjaXNpb25QcmVmaXg7XG5leHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNlbGVjdGlvbi8gVmVyc2lvbiAxLjAuNi4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgeGh0bWwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxudmFyIG5hbWVzcGFjZXMgPSB7XG4gIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB4aHRtbDogeGh0bWwsXG4gIHhsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG59O1xuXG52YXIgbmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJlZml4ID0gbmFtZSArPSBcIlwiLCBpID0gcHJlZml4LmluZGV4T2YoXCI6XCIpO1xuICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gIHJldHVybiBuYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7c3BhY2U6IG5hbWVzcGFjZXNbcHJlZml4XSwgbG9jYWw6IG5hbWV9IDogbmFtZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxudmFyIGNyZWF0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn07XG5cbnZhciBuZXh0SWQgPSAwO1xuXG5mdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbDtcbn1cblxuZnVuY3Rpb24gTG9jYWwoKSB7XG4gIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG59XG5cbkxvY2FsLnByb3RvdHlwZSA9IGxvY2FsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbnZhciBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCFlbGVtZW50Lm1hdGNoZXMpIHtcbiAgICB2YXIgdmVuZG9yTWF0Y2hlcyA9IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yO1xuICAgIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmVuZG9yTWF0Y2hlcy5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWF0Y2hlciQxID0gbWF0Y2hlcjtcblxudmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnRzLmV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCQxID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoIShcIm9ubW91c2VlbnRlclwiIGluIGVsZW1lbnQkMSkpIHtcbiAgICBmaWx0ZXJFdmVudHMgPSB7bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIiwgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwifTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJDb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcykgJiA4KSkpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50MSkge1xuICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDE7XG4gICAgdHJ5IHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgaW5kZXgsIGdyb3VwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIGNhcHR1cmUpIHtcbiAgdmFyIHdyYXAgPSBmaWx0ZXJFdmVudHMuaGFzT3duUHJvcGVydHkodHlwZW5hbWUudHlwZSkgPyBmaWx0ZXJDb250ZXh0TGlzdGVuZXIgOiBjb250ZXh0TGlzdGVuZXI7XG4gIHJldHVybiBmdW5jdGlvbihkLCBpLCBncm91cCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSB3cmFwKHZhbHVlLCBpLCBncm91cCk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5jYXB0dXJlID0gY2FwdHVyZSk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIGNhcHR1cmU6IGNhcHR1cmV9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fb24gPSBmdW5jdGlvbih0eXBlbmFtZSwgdmFsdWUsIGNhcHR1cmUpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGlmIChjYXB0dXJlID09IG51bGwpIGNhcHR1cmUgPSBmYWxzZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIGNhcHR1cmUpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBjdXN0b21FdmVudChldmVudDEsIGxpc3RlbmVyLCB0aGF0LCBhcmdzKSB7XG4gIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50O1xuICBldmVudDEuc291cmNlRXZlbnQgPSBleHBvcnRzLmV2ZW50O1xuICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICB0cnkge1xuICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICB9XG59XG5cbnZhciBzb3VyY2VFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VycmVudCA9IGV4cG9ydHMuZXZlbnQsIHNvdXJjZTtcbiAgd2hpbGUgKHNvdXJjZSA9IGN1cnJlbnQuc291cmNlRXZlbnQpIGN1cnJlbnQgPSBzb3VyY2U7XG4gIHJldHVybiBjdXJyZW50O1xufTtcblxudmFyIHBvaW50ID0gZnVuY3Rpb24obm9kZSwgZXZlbnQpIHtcbiAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG5cbiAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgfVxuXG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG59O1xuXG52YXIgbW91c2UgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBldmVudCA9IHNvdXJjZUV2ZW50KCk7XG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykgZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgcmV0dXJuIHBvaW50KG5vZGUsIGV2ZW50KTtcbn07XG5cbmZ1bmN0aW9uIG5vbmUoKSB7fVxuXG52YXIgc2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbnZhciBzZWxlY3Rpb25fc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgc2VsZWN0b3JBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59O1xuXG52YXIgc2VsZWN0aW9uX3NlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufTtcblxudmFyIHNlbGVjdGlvbl9maWx0ZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlciQxKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufTtcblxudmFyIHNwYXJzZSA9IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufTtcblxudmFyIHNlbGVjdGlvbl9lbnRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9lbnRlciB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufTtcblxuZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIga2V5UHJlZml4ID0gXCIkXCI7IC8vIFByb3RlY3QgYWdhaW5zdCBrZXlzIGxpa2Ug4oCcX19wcm90b19f4oCdLlxuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IHt9LFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICAgIGlmIChrZXlWYWx1ZSBpbiBub2RlQnlLZXlWYWx1ZSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0pIHtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVzW2ldXSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2VsZWN0aW9uX2RhdGEgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBkYXRhID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaiA9IC0xO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihkKSB7IGRhdGFbKytqXSA9IGQ7IH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gdmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn07XG5cbnZhciBzZWxlY3Rpb25fZXhpdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59O1xuXG52YXIgc2VsZWN0aW9uX21lcmdlID0gZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufTtcblxudmFyIHNlbGVjdGlvbl9vcmRlciA9IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIHNlbGVjdGlvbl9zb3J0ID0gZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59O1xuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG5cbnZhciBzZWxlY3Rpb25fY2FsbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gIGFyZ3VtZW50c1swXSA9IHRoaXM7XG4gIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIHNlbGVjdGlvbl9ub2RlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBpID0gLTE7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgbm9kZXNbKytpXSA9IHRoaXM7IH0pO1xuICByZXR1cm4gbm9kZXM7XG59O1xuXG52YXIgc2VsZWN0aW9uX25vZGUgPSBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBzZWxlY3Rpb25fc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytzaXplOyB9KTtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG52YXIgc2VsZWN0aW9uX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59O1xuXG52YXIgc2VsZWN0aW9uX2VhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmVOUyhmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgdik7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgIHJldHVybiBmdWxsbmFtZS5sb2NhbFxuICAgICAgICA/IG5vZGUuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKVxuICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKGZ1bGxuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KSkpKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufTtcblxudmFyIGRlZmF1bHRWaWV3ID0gZnVuY3Rpb24obm9kZSkge1xuICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn07XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG52YXIgc2VsZWN0aW9uX3N0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBub2RlO1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IGRlZmF1bHRWaWV3KG5vZGUgPSB0aGlzLm5vZGUoKSlcbiAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKVxuICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xufTtcblxuZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufTtcblxuZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9jbGFzc2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59O1xuXG5mdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl90ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufTtcblxuZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25faHRtbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59O1xuXG5mdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxudmFyIHNlbGVjdGlvbl9yYWlzZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn07XG5cbmZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG52YXIgc2VsZWN0aW9uX2xvd2VyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufTtcblxudmFyIHNlbGVjdGlvbl9hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHNlbGVjdGlvbl9pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbnZhciBzZWxlY3Rpb25fcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn07XG5cbnZhciBzZWxlY3Rpb25fZGF0dW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9kaXNwYXRjaCA9IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn07XG5cbnZhciByb290ID0gW251bGxdO1xuXG5mdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2hcbn07XG5cbnZhciBzZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufTtcblxudmFyIHNlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn07XG5cbnZhciB0b3VjaCA9IGZ1bmN0aW9uKG5vZGUsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gcG9pbnQobm9kZSwgdG91Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIHRvdWNoZXMgPSBmdW5jdGlvbihub2RlLCB0b3VjaGVzKSB7XG4gIGlmICh0b3VjaGVzID09IG51bGwpIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLnRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCBwb2ludHMgPSBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcbiAgICBwb2ludHNbaV0gPSBwb2ludChub2RlLCB0b3VjaGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5leHBvcnRzLmNyZWF0b3IgPSBjcmVhdG9yO1xuZXhwb3J0cy5sb2NhbCA9IGxvY2FsO1xuZXhwb3J0cy5tYXRjaGVyID0gbWF0Y2hlciQxO1xuZXhwb3J0cy5tb3VzZSA9IG1vdXNlO1xuZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5leHBvcnRzLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuZXhwb3J0cy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuZXhwb3J0cy5zZWxlY3RvckFsbCA9IHNlbGVjdG9yQWxsO1xuZXhwb3J0cy50b3VjaCA9IHRvdWNoO1xuZXhwb3J0cy50b3VjaGVzID0gdG91Y2hlcztcbmV4cG9ydHMud2luZG93ID0gZGVmYXVsdFZpZXc7XG5leHBvcnRzLmN1c3RvbUV2ZW50ID0gY3VzdG9tRXZlbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUtZm9ybWF0LyBWZXJzaW9uIDIuMC41LiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXRpbWUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXRpbWUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld1llYXIoeSkge1xuICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXIsXG4gICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciB1dGNGb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIsXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgIFwiV1wiOiBwYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgIFwieVwiOiBwYXJzZVllYXIsXG4gICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICBcIiVcIjogcGFyc2VMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIsIGZvcm1hdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhZCxcbiAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkgZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKTtcblxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgIGVsc2UgcGFkID0gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiO1xuICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCk7XG4gICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgbmV3RGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBkID0gbmV3WWVhcigxOTAwKSxcbiAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcgKz0gXCJcIiwgMCk7XG4gICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAvLyBDb252ZXJ0IGRheS1vZi13ZWVrIGFuZCB3ZWVrLW9mLXllYXIgdG8gZGF5LW9mLXllYXIuXG4gICAgICBpZiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSB7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgIHZhciBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpIDogbmV3RGF0ZShuZXdZZWFyKGQueSkpLmdldERheSgpO1xuICAgICAgICBkLm0gPSAwO1xuICAgICAgICBkLmQgPSBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF5ICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICByZXR1cm4gbmV3RGF0ZShkKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgYyxcbiAgICAgICAgcGFyc2U7XG5cbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyaW9kUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQucCA9IHBlcmlvZExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSBzaG9ydFdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gbW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIGxvY2FsRGF0ZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCB1dGNEYXRlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifTtcbnZhciBudW1iZXJSZSA9IC9eXFxzKlxcZCsvO1xudmFyIHBlcmNlbnRSZSA9IC9eJS87XG52YXIgcmVxdW90ZVJlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG5mdW5jdGlvbiBwYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLFxuICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVxdW90ZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UocmVxdW90ZVJlLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmUobmFtZXMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBuYW1lcy5tYXAocmVxdW90ZSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgdmFyIG1hcCA9IHt9LCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBtYXBbbmFtZXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpO1xuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86XFw6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuWiA9IG5bMV0gPyAwIDogLShuWzJdICsgKG5bM10gfHwgXCIwMFwiKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIGQzVGltZS50aW1lRGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSwgZCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZVN1bmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlcihkKSB7XG4gIHJldHVybiBkLmdldERheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZU1vbmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudXRjRGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNTdW5kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gIHJldHVybiBkLmdldFVUQ0RheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjTW9uZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1llYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1pvbmUoKSB7XG4gIHJldHVybiBcIiswMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExpdGVyYWxQZXJjZW50KCkge1xuICByZXR1cm4gXCIlXCI7XG59XG5cbnZhciBsb2NhbGUkMTtcblxuXG5cblxuXG5kZWZhdWx0TG9jYWxlKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlJDEgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMudGltZUZvcm1hdCA9IGxvY2FsZSQxLmZvcm1hdDtcbiAgZXhwb3J0cy50aW1lUGFyc2UgPSBsb2NhbGUkMS5wYXJzZTtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBsb2NhbGUkMS51dGNGb3JtYXQ7XG4gIGV4cG9ydHMudXRjUGFyc2UgPSBsb2NhbGUkMS51dGNQYXJzZTtcbiAgcmV0dXJuIGxvY2FsZSQxO1xufVxuXG52YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nXG4gICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvTmF0aXZlKHN0cmluZykge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xufVxuXG52YXIgcGFyc2VJc28gPSArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIilcbiAgICA/IHBhcnNlSXNvTmF0aXZlXG4gICAgOiBleHBvcnRzLnV0Y1BhcnNlKGlzb1NwZWNpZmllcik7XG5cbmV4cG9ydHMudGltZUZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuZXhwb3J0cy50aW1lRm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuZXhwb3J0cy5pc29Gb3JtYXQgPSBmb3JtYXRJc287XG5leHBvcnRzLmlzb1BhcnNlID0gcGFyc2VJc287XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUvIFZlcnNpb24gMS4wLjYuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHQwID0gbmV3IERhdGU7XG52YXIgdDEgPSBuZXcgRGF0ZTtcblxuZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCwgZmllbGQpIHtcblxuICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfVxuXG4gIGludGVydmFsLmZsb29yID0gaW50ZXJ2YWw7XG5cbiAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBmbG9vcmkoZGF0ZSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGQwID0gaW50ZXJ2YWwoZGF0ZSksXG4gICAgICAgIGQxID0gaW50ZXJ2YWwuY2VpbChkYXRlKTtcbiAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgfTtcblxuICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICBzdGFydCA9IGludGVydmFsLmNlaWwoc3RhcnQpO1xuICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICBkbyByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpOyB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcClcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBpZiAoZGF0ZSA+PSBkYXRlKSB3aGlsZSAoLS1zdGVwID49IDApIHdoaWxlIChvZmZzZXRpKGRhdGUsIDEpLCAhdGVzdChkYXRlKSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgIH0pO1xuICB9O1xuXG4gIGlmIChjb3VudCkge1xuICAgIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5ldmVyeSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShzdGVwKSB8fCAhKHN0ZXAgPiAwKSA/IG51bGxcbiAgICAgICAgICA6ICEoc3RlcCA+IDEpID8gaW50ZXJ2YWxcbiAgICAgICAgICA6IGludGVydmFsLmZpbHRlcihmaWVsZFxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZpZWxkKGQpICUgc3RlcCA9PT0gMDsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGludGVydmFsLmNvdW50KDAsIGQpICUgc3RlcCA9PT0gMDsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnZhbDtcbn1cblxudmFyIG1pbGxpc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gIC8vIG5vb3Bcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG5taWxsaXNlY29uZC5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xuICBpZiAoIShrID4gMSkpIHJldHVybiBtaWxsaXNlY29uZDtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBrKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gaztcbiAgfSk7XG59O1xuXG52YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IDZlNDtcbnZhciBkdXJhdGlvbkhvdXIgPSAzNmU1O1xudmFyIGR1cmF0aW9uRGF5ID0gODY0ZTU7XG52YXIgZHVyYXRpb25XZWVrID0gNjA0OGU1O1xuXG52YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gZHVyYXRpb25TZWNvbmQpICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uU2Vjb25kO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG59KTtcblxudmFyIHNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbnZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvbk1pbnV0ZSkgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xuXG52YXIgbWludXRlcyA9IG1pbnV0ZS5yYW5nZTtcblxudmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIHZhciBvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZSAlIGR1cmF0aW9uSG91cjtcbiAgaWYgKG9mZnNldCA8IDApIG9mZnNldCArPSBkdXJhdGlvbkhvdXI7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKCgrZGF0ZSAtIG9mZnNldCkgLyBkdXJhdGlvbkhvdXIpICogZHVyYXRpb25Ib3VyICsgb2Zmc2V0KTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xufSk7XG5cbnZhciBob3VycyA9IGhvdXIucmFuZ2U7XG5cbnZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbn0pO1xuXG52YXIgZGF5cyA9IGRheS5yYW5nZTtcblxuZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25XZWVrO1xuICB9KTtcbn1cblxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxudmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG52YXIgbW9uZGF5cyA9IG1vbmRheS5yYW5nZTtcbnZhciB0dWVzZGF5cyA9IHR1ZXNkYXkucmFuZ2U7XG52YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbnZhciB0aHVyc2RheXMgPSB0aHVyc2RheS5yYW5nZTtcbnZhciBmcmlkYXlzID0gZnJpZGF5LnJhbmdlO1xudmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuXG52YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0RGF0ZSgxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG59KTtcblxudmFyIG1vbnRocyA9IG1vbnRoLnJhbmdlO1xuXG52YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG55ZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcblxudmFyIHllYXJzID0geWVhci5yYW5nZTtcblxudmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG59KTtcblxudmFyIHV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbnZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xuXG52YXIgdXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG52YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF0ZSgpIC0gMTtcbn0pO1xuXG52YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG52YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbnZhciB1dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xudmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xudmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG52YXIgdXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xudmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG52YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG52YXIgdXRjU3VuZGF5cyA9IHV0Y1N1bmRheS5yYW5nZTtcbnZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xudmFyIHV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheS5yYW5nZTtcbnZhciB1dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5LnJhbmdlO1xudmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xudmFyIHV0Y0ZyaWRheXMgPSB1dGNGcmlkYXkucmFuZ2U7XG52YXIgdXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXkucmFuZ2U7XG5cbnZhciB1dGNNb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn0pO1xuXG52YXIgdXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbnZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnV0Y1llYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG52YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IG5ld0ludGVydmFsO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbmV4cG9ydHMudGltZU1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbmV4cG9ydHMudXRjTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbmV4cG9ydHMudXRjTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy50aW1lU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy50aW1lU2Vjb25kcyA9IHNlY29uZHM7XG5leHBvcnRzLnV0Y1NlY29uZCA9IHNlY29uZDtcbmV4cG9ydHMudXRjU2Vjb25kcyA9IHNlY29uZHM7XG5leHBvcnRzLnRpbWVNaW51dGUgPSBtaW51dGU7XG5leHBvcnRzLnRpbWVNaW51dGVzID0gbWludXRlcztcbmV4cG9ydHMudGltZUhvdXIgPSBob3VyO1xuZXhwb3J0cy50aW1lSG91cnMgPSBob3VycztcbmV4cG9ydHMudGltZURheSA9IGRheTtcbmV4cG9ydHMudGltZURheXMgPSBkYXlzO1xuZXhwb3J0cy50aW1lV2VlayA9IHN1bmRheTtcbmV4cG9ydHMudGltZVdlZWtzID0gc3VuZGF5cztcbmV4cG9ydHMudGltZVN1bmRheSA9IHN1bmRheTtcbmV4cG9ydHMudGltZVN1bmRheXMgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lTW9uZGF5ID0gbW9uZGF5O1xuZXhwb3J0cy50aW1lTW9uZGF5cyA9IG1vbmRheXM7XG5leHBvcnRzLnRpbWVUdWVzZGF5ID0gdHVlc2RheTtcbmV4cG9ydHMudGltZVR1ZXNkYXlzID0gdHVlc2RheXM7XG5leHBvcnRzLnRpbWVXZWRuZXNkYXkgPSB3ZWRuZXNkYXk7XG5leHBvcnRzLnRpbWVXZWRuZXNkYXlzID0gd2VkbmVzZGF5cztcbmV4cG9ydHMudGltZVRodXJzZGF5ID0gdGh1cnNkYXk7XG5leHBvcnRzLnRpbWVUaHVyc2RheXMgPSB0aHVyc2RheXM7XG5leHBvcnRzLnRpbWVGcmlkYXkgPSBmcmlkYXk7XG5leHBvcnRzLnRpbWVGcmlkYXlzID0gZnJpZGF5cztcbmV4cG9ydHMudGltZVNhdHVyZGF5ID0gc2F0dXJkYXk7XG5leHBvcnRzLnRpbWVTYXR1cmRheXMgPSBzYXR1cmRheXM7XG5leHBvcnRzLnRpbWVNb250aCA9IG1vbnRoO1xuZXhwb3J0cy50aW1lTW9udGhzID0gbW9udGhzO1xuZXhwb3J0cy50aW1lWWVhciA9IHllYXI7XG5leHBvcnRzLnRpbWVZZWFycyA9IHllYXJzO1xuZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG5leHBvcnRzLnV0Y01pbnV0ZXMgPSB1dGNNaW51dGVzO1xuZXhwb3J0cy51dGNIb3VyID0gdXRjSG91cjtcbmV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VycztcbmV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5cztcbmV4cG9ydHMudXRjV2VlayA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjV2Vla3MgPSB1dGNTdW5kYXlzO1xuZXhwb3J0cy51dGNTdW5kYXkgPSB1dGNTdW5kYXk7XG5leHBvcnRzLnV0Y1N1bmRheXMgPSB1dGNTdW5kYXlzO1xuZXhwb3J0cy51dGNNb25kYXkgPSB1dGNNb25kYXk7XG5leHBvcnRzLnV0Y01vbmRheXMgPSB1dGNNb25kYXlzO1xuZXhwb3J0cy51dGNUdWVzZGF5ID0gdXRjVHVlc2RheTtcbmV4cG9ydHMudXRjVHVlc2RheXMgPSB1dGNUdWVzZGF5cztcbmV4cG9ydHMudXRjV2VkbmVzZGF5ID0gdXRjV2VkbmVzZGF5O1xuZXhwb3J0cy51dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5cztcbmV4cG9ydHMudXRjVGh1cnNkYXkgPSB1dGNUaHVyc2RheTtcbmV4cG9ydHMudXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXlzO1xuZXhwb3J0cy51dGNGcmlkYXkgPSB1dGNGcmlkYXk7XG5leHBvcnRzLnV0Y0ZyaWRheXMgPSB1dGNGcmlkYXlzO1xuZXhwb3J0cy51dGNTYXR1cmRheSA9IHV0Y1NhdHVyZGF5O1xuZXhwb3J0cy51dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheXM7XG5leHBvcnRzLnV0Y01vbnRoID0gdXRjTW9udGg7XG5leHBvcnRzLnV0Y01vbnRocyA9IHV0Y01vbnRocztcbmV4cG9ydHMudXRjWWVhciA9IHV0Y1llYXI7XG5leHBvcnRzLnV0Y1llYXJzID0gdXRjWWVhcnM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCJ2YXIganNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyA/IEpTT04gOiByZXF1aXJlKCdqc29uaWZ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgb3B0cyA9IHsgY21wOiBvcHRzIH07XG4gICAgdmFyIHNwYWNlID0gb3B0cy5zcGFjZSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykgc3BhY2UgPSBBcnJheShzcGFjZSsxKS5qb2luKCcgJyk7XG4gICAgdmFyIGN5Y2xlcyA9ICh0eXBlb2Ygb3B0cy5jeWNsZXMgPT09ICdib29sZWFuJykgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuICAgIHZhciByZXBsYWNlciA9IG9wdHMucmVwbGFjZXIgfHwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiAgICB2YXIgY21wID0gb3B0cy5jbXAgJiYgKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFvYmogPSB7IGtleTogYSwgdmFsdWU6IG5vZGVbYV0gfTtcbiAgICAgICAgICAgICAgICB2YXIgYm9iaiA9IHsga2V5OiBiLCB2YWx1ZTogbm9kZVtiXSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmKGFvYmosIGJvYmopO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9KShvcHRzLmNtcCk7XG5cbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiAoZnVuY3Rpb24gc3RyaW5naWZ5IChwYXJlbnQsIGtleSwgbm9kZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHNwYWNlID8gKCdcXG4nICsgbmV3IEFycmF5KGxldmVsICsgMSkuam9pbihzcGFjZSkpIDogJyc7XG4gICAgICAgIHZhciBjb2xvblNlcGFyYXRvciA9IHNwYWNlID8gJzogJyA6ICc6JztcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHJlcGxhY2VyLmNhbGwocGFyZW50LCBrZXksIG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uLnN0cmluZ2lmeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdHJpbmdpZnkobm9kZSwgaSwgbm9kZVtpXSwgbGV2ZWwrMSkgfHwganNvbi5zdHJpbmdpZnkobnVsbCk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnWycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3ljbGVzKSByZXR1cm4ganNvbi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugc2Vlbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlLCBrZXksIG5vZGVba2V5XSwgbGV2ZWwrMSk7XG5cbiAgICAgICAgICAgICAgICBpZighdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleVZhbHVlID0ganNvbi5zdHJpbmdpZnkoa2V5KVxuICAgICAgICAgICAgICAgICAgICArIGNvbG9uU2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsga2V5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbi5zcGxpY2Uoc2Vlbi5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xuICAgICAgICB9XG4gICAgfSkoeyAnJzogb2JqIH0sICcnLCBvYmosIDApO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG4iLCJleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG4iLCJ2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgZXNjYXBlZSA9IHtcbiAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgIGI6ICAgICdcXGInLFxuICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgIHI6ICAgICdcXHInLFxuICAgICAgICB0OiAgICAnXFx0J1xuICAgIH0sXG4gICAgdGV4dCxcblxuICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbmFtZTogICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG0sXG4gICAgICAgICAgICBhdDogICAgICBhdCxcbiAgICAgICAgICAgIHRleHQ6ICAgIHRleHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIG5leHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICBcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIGF0ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgfSxcblxuICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgIH0sXG5cbiAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgfTtcblxudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgd2hpdGUoKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgIH1cbn07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBcbiAgICB0ZXh0ID0gc291cmNlO1xuICAgIGF0ID0gMDtcbiAgICBjaCA9ICcgJztcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgIHdoaXRlKCk7XG4gICAgaWYgKGNoKSB7XG4gICAgICAgIGVycm9yKFwiU3ludGF4IGVycm9yXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuICAgIC8vIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVybiB0aGVcbiAgICAvLyByZXN1bHQuXG5cbiAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9KHsnJzogcmVzdWx0fSwgJycpKSA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGdhcCxcbiAgICBpbmRlbnQsXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH0sXG4gICAgcmVwO1xuXG5mdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbiAgICAvLyBzZXF1ZW5jZXMuXG4gICAgXG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG4gICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgIHBhcnRpYWwsXG4gICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgXG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcnJheS5pc0FycmF5XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlbSBpbiBicmFja2V0cy5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgdmFyIGk7XG4gICAgZ2FwID0gJyc7XG4gICAgaW5kZW50ID0gJyc7XG4gICAgXG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgIC8vIG1hbnkgc3BhY2VzLlxuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbidcbiAgICAmJiAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xufTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiB2OyB9OyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fdmFsdWVzXCIsIF9fdmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkXCIsIF9fc3ByZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxufSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLnZlZ2EgPSBnbG9iYWwudmVnYSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYXJzZSBhbiBldmVudCBzZWxlY3RvciBzdHJpbmcuXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGV2ZW50IHN0cmVhbSBkZWZpbml0aW9ucy5cbiAqL1xudmFyIGV2ZW50U2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3Rvciwgc291cmNlLCBtYXJrcykge1xuICBERUZBVUxUX1NPVVJDRSA9IHNvdXJjZSB8fCBWSUVXO1xuICBNQVJLUyA9IG1hcmtzIHx8IERFRkFVTFRfTUFSS1M7XG4gIHJldHVybiBwYXJzZU1lcmdlKHNlbGVjdG9yLnRyaW0oKSkubWFwKHBhcnNlU2VsZWN0b3IpO1xufTtcblxudmFyIFZJRVcgICAgPSAndmlldyc7XG52YXIgTEJSQUNLICA9ICdbJztcbnZhciBSQlJBQ0sgID0gJ10nO1xudmFyIExCUkFDRSAgPSAneyc7XG52YXIgUkJSQUNFICA9ICd9JztcbnZhciBDT0xPTiAgID0gJzonO1xudmFyIENPTU1BICAgPSAnLCc7XG52YXIgTkFNRSAgICA9ICdAJztcbnZhciBHVCAgICAgID0gJz4nO1xudmFyIElMTEVHQUwgPSAvW1xcW1xcXVxce1xcfV0vO1xudmFyIERFRkFVTFRfU09VUkNFO1xudmFyIE1BUktTO1xudmFyIERFRkFVTFRfTUFSS1MgPSB7XG4gICAgICAnKic6IDEsXG4gICAgICBhcmM6IDEsXG4gICAgICBhcmVhOiAxLFxuICAgICAgZ3JvdXA6IDEsXG4gICAgICBpbWFnZTogMSxcbiAgICAgIGxpbmU6IDEsXG4gICAgICBwYXRoOiAxLFxuICAgICAgcmVjdDogMSxcbiAgICAgIHJ1bGU6IDEsXG4gICAgICBzaGFwZTogMSxcbiAgICAgIHN5bWJvbDogMSxcbiAgICAgIHRleHQ6IDEsXG4gICAgICB0cmFpbDogMVxuICAgIH07XG5cbmZ1bmN0aW9uIGlzTWFya1R5cGUodHlwZSkge1xuICByZXR1cm4gTUFSS1MuaGFzT3duUHJvcGVydHkodHlwZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmQocywgaSwgZW5kQ2hhciwgcHVzaENoYXIsIHBvcENoYXIpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIG4gPSBzLmxlbmd0aCxcbiAgICAgIGM7XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIGMgPSBzW2ldO1xuICAgIGlmICghY291bnQgJiYgYyA9PT0gZW5kQ2hhcikgcmV0dXJuIGk7XG4gICAgZWxzZSBpZiAocG9wQ2hhciAmJiBwb3BDaGFyLmluZGV4T2YoYykgPj0gMCkgLS1jb3VudDtcbiAgICBlbHNlIGlmIChwdXNoQ2hhciAmJiBwdXNoQ2hhci5pbmRleE9mKGMpID49IDApICsrY291bnQ7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWVyZ2Uocykge1xuICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICBzdGFydCA9IDAsXG4gICAgICBuID0gcy5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBpID0gZmluZChzLCBpLCBDT01NQSwgTEJSQUNLICsgTEJSQUNFLCBSQlJBQ0sgKyBSQlJBQ0UpO1xuICAgIG91dHB1dC5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIHN0YXJ0ID0gKytpO1xuICB9XG5cbiAgaWYgKG91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAnRW1wdHkgZXZlbnQgc2VsZWN0b3I6ICcgKyBzO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Iocykge1xuICByZXR1cm4gc1swXSA9PT0gJ1snXG4gICAgPyBwYXJzZUJldHdlZW4ocylcbiAgICA6IHBhcnNlU3RyZWFtKHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJldHdlZW4ocykge1xuICB2YXIgbiA9IHMubGVuZ3RoLFxuICAgICAgaSA9IDEsXG4gICAgICBiLCBzdHJlYW07XG5cbiAgaSA9IGZpbmQocywgaSwgUkJSQUNLLCBMQlJBQ0ssIFJCUkFDSyk7XG4gIGlmIChpID09PSBuKSB7XG4gICAgdGhyb3cgJ0VtcHR5IGJldHdlZW4gc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgYiA9IHBhcnNlTWVyZ2Uocy5zdWJzdHJpbmcoMSwgaSkpO1xuICBpZiAoYi5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyAnQmV0d2VlbiBzZWxlY3RvciBtdXN0IGhhdmUgdHdvIGVsZW1lbnRzOiAnICsgcztcbiAgfVxuXG4gIHMgPSBzLnNsaWNlKGkgKyAxKS50cmltKCk7XG4gIGlmIChzWzBdICE9PSBHVCkge1xuICAgIHRocm93ICdFeHBlY3RlZCBcXCc+XFwnIGFmdGVyIGJldHdlZW4gc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgYiA9IGIubWFwKHBhcnNlU2VsZWN0b3IpO1xuXG4gIHN0cmVhbSA9IHBhcnNlU2VsZWN0b3Iocy5zbGljZSgxKS50cmltKCkpO1xuICBpZiAoc3RyZWFtLmJldHdlZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogYixcbiAgICAgIHN0cmVhbTogc3RyZWFtXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uYmV0d2VlbiA9IGI7XG4gIH1cblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmVhbShzKSB7XG4gIHZhciBzdHJlYW0gPSB7c291cmNlOiBERUZBVUxUX1NPVVJDRX0sXG4gICAgICBzb3VyY2UgPSBbXSxcbiAgICAgIHRocm90dGxlID0gWzAsIDBdLFxuICAgICAgbWFya25hbWUgPSAwLFxuICAgICAgc3RhcnQgPSAwLFxuICAgICAgbiA9IHMubGVuZ3RoLFxuICAgICAgaSA9IDAsIGosXG4gICAgICBmaWx0ZXI7XG5cbiAgLy8gZXh0cmFjdCB0aHJvdHRsZSBmcm9tIGVuZFxuICBpZiAoc1tuLTFdID09PSBSQlJBQ0UpIHtcbiAgICBpID0gcy5sYXN0SW5kZXhPZihMQlJBQ0UpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm90dGxlID0gcGFyc2VUaHJvdHRsZShzLnN1YnN0cmluZyhpKzEsIG4tMSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyAnSW52YWxpZCB0aHJvdHRsZSBzcGVjaWZpY2F0aW9uOiAnICsgcztcbiAgICAgIH1cbiAgICAgIHMgPSBzLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIG4gPSBzLmxlbmd0aDtcbiAgICB9IGVsc2UgdGhyb3cgJ1VubWF0Y2hlZCByaWdodCBicmFjZTogJyArIHM7XG4gICAgaSA9IDA7XG4gIH1cblxuICBpZiAoIW4pIHRocm93IHM7XG5cbiAgLy8gc2V0IG5hbWUgZmxhZyBiYXNlZCBvbiBmaXJzdCBjaGFyXG4gIGlmIChzWzBdID09PSBOQU1FKSBtYXJrbmFtZSA9ICsraTtcblxuICAvLyBleHRyYWN0IGZpcnN0IHBhcnQgb2YgbXVsdGktcGFydCBzdHJlYW0gc2VsZWN0b3JcbiAgaiA9IGZpbmQocywgaSwgQ09MT04pO1xuICBpZiAoaiA8IG4pIHtcbiAgICBzb3VyY2UucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaikudHJpbSgpKTtcbiAgICBzdGFydCA9IGkgPSArK2o7XG4gIH1cblxuICAvLyBleHRyYWN0IHJlbWFpbmluZyBwYXJ0IG9mIHN0cmVhbSBzZWxlY3RvclxuICBpID0gZmluZChzLCBpLCBMQlJBQ0spO1xuICBpZiAoaSA9PT0gbikge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBuKS50cmltKCkpO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIGZpbHRlciA9IFtdO1xuICAgIHN0YXJ0ID0gKytpO1xuICAgIGlmIChzdGFydCA9PT0gbikgdGhyb3cgJ1VubWF0Y2hlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBmaWx0ZXJzXG4gIHdoaWxlIChpIDwgbikge1xuICAgIGkgPSBmaW5kKHMsIGksIFJCUkFDSyk7XG4gICAgaWYgKGkgPT09IG4pIHRocm93ICdVbm1hdGNoZWQgbGVmdCBicmFja2V0OiAnICsgcztcbiAgICBmaWx0ZXIucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBpZiAoaSA8IG4tMSAmJiBzWysraV0gIT09IExCUkFDSykgdGhyb3cgJ0V4cGVjdGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gICAgc3RhcnQgPSArK2k7XG4gIH1cblxuICAvLyBtYXJzaGFsbCBldmVudCBzdHJlYW0gc3BlY2lmaWNhdGlvblxuICBpZiAoIShuID0gc291cmNlLmxlbmd0aCkgfHwgSUxMRUdBTC50ZXN0KHNvdXJjZVtuLTFdKSkge1xuICAgIHRocm93ICdJbnZhbGlkIGV2ZW50IHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIGlmIChuID4gMSkge1xuICAgIHN0cmVhbS50eXBlID0gc291cmNlWzFdO1xuICAgIGlmIChtYXJrbmFtZSkge1xuICAgICAgc3RyZWFtLm1hcmtuYW1lID0gc291cmNlWzBdLnNsaWNlKDEpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXJrVHlwZShzb3VyY2VbMF0pKSB7XG4gICAgICBzdHJlYW0ubWFya3R5cGUgPSBzb3VyY2VbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5zb3VyY2UgPSBzb3VyY2VbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS50eXBlID0gc291cmNlWzBdO1xuICB9XG4gIGlmIChzdHJlYW0udHlwZS5zbGljZSgtMSkgPT09ICchJykge1xuICAgIHN0cmVhbS5jb25zdW1lID0gdHJ1ZTtcbiAgICBzdHJlYW0udHlwZSA9IHN0cmVhbS50eXBlLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBpZiAoZmlsdGVyICE9IG51bGwpIHN0cmVhbS5maWx0ZXIgPSBmaWx0ZXI7XG4gIGlmICh0aHJvdHRsZVswXSkgc3RyZWFtLnRocm90dGxlID0gdGhyb3R0bGVbMF07XG4gIGlmICh0aHJvdHRsZVsxXSkgc3RyZWFtLmRlYm91bmNlID0gdGhyb3R0bGVbMV07XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaHJvdHRsZShzKSB7XG4gIHZhciBhID0gcy5zcGxpdChDT01NQSk7XG4gIGlmICghcy5sZW5ndGggfHwgYS5sZW5ndGggPiAyKSB0aHJvdyBzO1xuICByZXR1cm4gYS5tYXAoZnVuY3Rpb24oXykge1xuICAgIHZhciB4ID0gK187XG4gICAgaWYgKHggIT09IHgpIHRocm93IHM7XG4gICAgcmV0dXJuIHg7XG4gIH0pO1xufVxuXG5leHBvcnRzLnNlbGVjdG9yID0gZXZlbnRTZWxlY3RvcjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwidmVnYS1saXRlXCIsXG4gIFwiYXV0aG9yXCI6IFwiSmVmZnJleSBIZWVyLCBEb21pbmlrIE1vcml0eiwgS2FuaXQgXFxcIkhhbVxcXCIgV29uZ3N1cGhhc2F3YXRcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4wLjAtYmV0YS4yXCIsXG4gIFwiY29sbGFib3JhdG9yc1wiOiBbXG4gICAgXCJLYW5pdCBXb25nc3VwaGFzYXdhdCA8a2FuaXR3QGdtYWlsLmNvbT4gKGh0dHA6Ly9rYW5pdHcueWVsbG93cGlnei5jb20pXCIsXG4gICAgXCJEb21pbmlrIE1vcml0eiA8ZG9tb3JpdHpAY3Mud2FzaGluZ3Rvbi5lZHU+IChodHRwczovL3d3dy5kb21vcml0ei5kZSlcIixcbiAgICBcIkplZmZyZXkgSGVlciA8amhlZXJAdXcuZWR1PiAoaHR0cDovL2poZWVyLm9yZylcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby92ZWdhLWxpdGUvXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJWZWdhLWxpdGUgcHJvdmlkZXMgYSBoaWdoZXItbGV2ZWwgZ3JhbW1hciBmb3IgdmlzdWFsIGFuYWx5c2lzLCBjb21wYXJhYmxlIHRvIGdncGxvdCBvciBUYWJsZWF1LCB0aGF0IGdlbmVyYXRlcyBjb21wbGV0ZSBWZWdhIHNwZWNpZmljYXRpb25zLlwiLFxuICBcIm1haW5cIjogXCJidWlsZC9zcmMvdmwuanNcIixcbiAgXCJ0eXBlc1wiOiBcImJ1aWxkL3NyYy92bC5kLnRzXCIsXG4gIFwiYmluXCI6IHtcbiAgICBcInZsMnBuZ1wiOiBcIi4vYmluL3ZsMnBuZ1wiLFxuICAgIFwidmwyc3ZnXCI6IFwiLi9iaW4vdmwyc3ZnXCIsXG4gICAgXCJ2bDJ2Z1wiOiBcIi4vYmluL3ZsMnZnXCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwidGVzdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0c2NcIjogXCJybSAtcmYgYnVpbGQvKi8qKiAmJiB0c2NcIixcbiAgICBcInByZWJ1aWxkXCI6IFwibWtkaXIgLXAgYnVpbGQvc2l0ZSBidWlsZC9leGFtcGxlcy9pbWFnZXMgYnVpbGQvdGVzdC1nYWxsZXJ5XCIsXG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gdHNjICYmIGNwIHBhY2thZ2UuanNvbiBidWlsZCAmJiBicm93c2VyaWZ5IHNyYy92bC50cyAtcCB0c2lmeSAtZCAtcyB2bCB8IGV4b3JjaXN0IGJ1aWxkL3ZlZ2EtbGl0ZS5qcy5tYXAgPiBidWlsZC92ZWdhLWxpdGUuanNcIixcbiAgICBcInBvc3RidWlsZFwiOiBcInVnbGlmeWpzIGJ1aWxkL3ZlZ2EtbGl0ZS5qcyAtY20gLS1pbi1zb3VyY2UtbWFwIGJ1aWxkL3ZlZ2EtbGl0ZS5qcy5tYXAgLS1zb3VyY2UtbWFwIGJ1aWxkL3ZlZ2EtbGl0ZS5taW4uanMubWFwID4gYnVpbGQvdmVnYS1saXRlLm1pbi5qcyAmJiBucG0gcnVuIHNjaGVtYVwiLFxuICAgIFwiYnVpbGQ6ZXhhbXBsZXNcIjogXCIuL3NjcmlwdHMvYnVpbGQtZXhhbXBsZXMuc2ggJiYgcm0gLXJmIGV4YW1wbGVzL3NwZWNzL25vcm1hbGl6ZWQvKiAmJiBzY3JpcHRzL2J1aWxkLW5vcm1hbGl6ZWQtZXhhbXBsZXNcIixcbiAgICBcImJ1aWxkOmltYWdlc1wiOiBcIm5wbSBydW4gZGF0YSAmJiBzY3JpcHRzL2dlbmVyYXRlLWltYWdlcy5zaFwiLFxuICAgIFwiYnVpbGQ6dG9jXCI6IFwiYnVuZGxlIGV4ZWMgamVreWxsIGJ1aWxkIC1xICYmIHNjcmlwdHMvZ2VuZXJhdGUtdG9jXCIsXG4gICAgXCJidWlsZDpzaXRlXCI6IFwibnBtIHJ1biBsaW5rICYmIGJyb3dzZXJpZnkgc2l0ZS9zdGF0aWMvbWFpbi50cyAtcCBbdHNpZnkgLXAgc2l0ZV0gLWQgfCBleG9yY2lzdCBidWlsZC9zaXRlL21haW4uanMubWFwID4gYnVpbGQvc2l0ZS9tYWluLmpzXCIsXG4gICAgXCJidWlsZDp2ZXJzaW9uc1wiOiBcInNjcmlwdHMvdXBkYXRlLXZlcnNpb24uc2hcIixcbiAgICBcImJ1aWxkOnRlc3QtZ2FsbGVyeVwiOiBcImJyb3dzZXJpZnkgdGVzdC1nYWxsZXJ5L21haW4udHMgLXAgW3RzaWZ5IC1wIHRlc3QtZ2FsbGVyeV0gLWQgPiBidWlsZC90ZXN0LWdhbGxlcnkvbWFpbi5qc1wiLFxuICAgIFwiY2hlY2s6ZXhhbXBsZXNcIjogXCJzY3JpcHRzL2NoZWNrLWV4YW1wbGVzLnNoXCIsXG4gICAgXCJjaGVjazpzY2hlbWFcIjogXCJzY3JpcHRzL2NoZWNrLXNjaGVtYS5zaFwiLFxuICAgIFwiY2xlYW5cIjogXCJybSAtcmYgYnVpbGQgJiYgcm0gLWYgdmVnYS1saXRlLiogJiBmaW5kIC1FIHNyYyB0ZXN0IHNpdGUgZXhhbXBsZXMgLXJlZ2V4ICcuKlxcXFwuKGpzfGpzLm1hcHxkLnRzfHZnLmpzb24pJyAtZGVsZXRlICYgcm0gLXJmIGRhdGFcIixcbiAgICBcImRhdGFcIjogXCJyc3luYyAtciBub2RlX21vZHVsZXMvdmVnYS1kYXRhc2V0cy9kYXRhLyogZGF0YVwiLFxuICAgIFwibGlua1wiOiBcIm5wbSBsaW5rICYmIG5wbSBsaW5rIHZlZ2EtbGl0ZVwiLFxuXG4gICAgXCJkZXBsb3lcIjogXCJzY3JpcHRzL2RlcGxveS5zaFwiLFxuICAgIFwiZGVwbG95OmdoXCI6IFwic2NyaXB0cy9kZXBsb3ktZ2guc2hcIixcbiAgICBcImRlcGxveTpzY2hlbWFcIjogXCJzY3JpcHRzL2RlcGxveS1zY2hlbWEuc2hcIixcblxuICAgIFwicHJlc3RhcnRcIjogXCJucG0gcnVuIGRhdGEgJiYgbnBtIHJ1biBidWlsZCAmJiBzY3JpcHRzL2luZGV4LWV4YW1wbGVzXCIsXG4gICAgXCJzdGFydFwiOiBcIm5vZGVtb24gLXggJ25wbSBydW4gYnVpbGQ6dGVzdC1nYWxsZXJ5JyAmIGJyb3dzZXItc3luYyBzdGFydCAtLXNlcnZlciAtLWZpbGVzICdidWlsZC90ZXN0LWdhbGxlcnkvbWFpbi5qcycgLS1pbmRleCAndGVzdC1nYWxsZXJ5L2luZGV4Lmh0bWwnXCIsXG4gICAgXCJwb3N0c3RhcnRcIjogXCJybSBleGFtcGxlcy9hbGwtZXhhbXBsZXMuanNvblwiLFxuXG4gICAgXCJwcmVzY2hlbWFcIjogXCJucG0gcnVuIHByZWJ1aWxkXCIsXG4gICAgXCJzY2hlbWFcIjogXCJ0eXBlc2NyaXB0LWpzb24tc2NoZW1hIC0tcmVxdWlyZWQgdHJ1ZSAtLW5vRXh0cmFQcm9wcyB0cnVlIHNyYy9zcGVjLnRzIFRvcExldmVsRXh0ZW5kZWRTcGVjID4gYnVpbGQvdmVnYS1saXRlLXNjaGVtYS5qc29uICYmIHJtIC1mIF9kYXRhL3ZlZ2EtbGl0ZS1zY2hlbWEuanNvbiAmJiBucG0gcnVuIHJlcGxhY2VzY2hlbWEgJiYgY3AgYnVpbGQvdmVnYS1saXRlLXNjaGVtYS5qc29uIF9kYXRhL1wiLFxuICAgIFwicmVwbGFjZXNjaGVtYVwiOiBcInNlZCAtaSAtZSAncy9HZW5lcmljTGF5ZXJTcGVjPC4qLi5cXFxcLi9MYXllclNwZWMvZycgYnVpbGQvdmVnYS1saXRlLXNjaGVtYS5qc29uICYmIHNlZCAtaSAtZSAncy9HZW5lcmljUmVwZWF0U3BlYzwuKi4uXFxcXC4vUmVwZWF0U3BlYy9nJyBidWlsZC92ZWdhLWxpdGUtc2NoZW1hLmpzb24gJiYgc2VkIC1pIC1lICdzL0dlbmVyaWNVbml0U3BlYzxFbmNvZGluZzwuKi4uXFxcXC4vVW5pdFNwZWMvZycgYnVpbGQvdmVnYS1saXRlLXNjaGVtYS5qc29uICYmIHNlZCAtaSAtZSAncy9HZW5lcmljVW5pdFNwZWM8RW5jb2RpbmdXaXRoRmFjZXQ8LiouLlxcXFwuL0ZhY2V0ZWRVbml0U3BlYy9nJyBidWlsZC92ZWdhLWxpdGUtc2NoZW1hLmpzb24gJiYgc2VkIC1pIC1lICdzLzxGaWVsZD4vL2cnIGJ1aWxkL3ZlZ2EtbGl0ZS1zY2hlbWEuanNvblwiLFxuICAgIFwicHJlc2l0ZVwiOiBcIm5wbSBydW4gYnVpbGQgJiYgbnBtIHJ1biBkYXRhICYmIG5wbSBydW4gYnVpbGQ6c2l0ZSAmJiBucG0gcnVuIGJ1aWxkOnRvYyAmJiBucG0gcnVuIGJ1aWxkOnZlcnNpb25zXCIsXG4gICAgXCJzaXRlXCI6IFwiYnVuZGxlIGV4ZWMgamVreWxsIHNlcnZlXCIsXG5cbiAgICBcImxpbnRcIjogXCJ0c2xpbnQgLS1wcm9qZWN0IHRzY29uZmlnLmpzb24gLWMgdHNsaW50Lmpzb24gLS10eXBlLWNoZWNrXCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biB0c2MgJiYgbnBtIHJ1biBzY2hlbWEgJiYgbnBtIHJ1biB0ZXN0Om9ubHkgJiYgbnBtIHJ1biBsaW50XCIsXG4gICAgXCJwb3N0dGVzdFwiOiBcIm5wbSBydW4gZGF0YSAmJiBucG0gcnVuIG1vY2hhOmV4YW1wbGVzXCIsXG4gICAgXCJ0ZXN0Om5vY29tcGlsZVwiOiBcIm5wbSBydW4gdGVzdDpvbmx5ICYmIG5wbSBydW4gbGludCAmJiBucG0gcnVuIG1vY2hhOmV4YW1wbGVzXCIsXG4gICAgXCJ0ZXN0Om9ubHlcIjogXCJueWMgLS1yZXBvcnRlcj1odG1sIC0tcmVwb3J0ZXI9dGV4dC1zdW1tYXJ5IG5wbSBydW4gbW9jaGE6dGVzdFwiLFxuICAgIFwidGVzdDpkZWJ1Z1wiOiBcIm5wbSBydW4gdHNjICYmIG5wbSBydW4gc2NoZW1hICYmIG1vY2hhIC0tcmVjdXJzaXZlIC0tZGVidWctYnJrIC0taW5zcGVjdCBidWlsZC90ZXN0IGJ1aWxkL2V4YW1wbGVzXCIsXG4gICAgXCJtb2NoYTp0ZXN0XCI6IFwibW9jaGEgLS1yZXF1aXJlIHNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlciAtLXJlcG9ydGVyIGRvdCAtLXJlY3Vyc2l2ZSBidWlsZC90ZXN0XCIsXG4gICAgXCJtb2NoYTpleGFtcGxlc1wiOiBcIm1vY2hhIC0tcmVxdWlyZSBzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXIgLS1yZXBvcnRlciBkb3QgLS1yZWN1cnNpdmUgYnVpbGQvZXhhbXBsZXNcIixcblxuICAgIFwiY29kZWNvdlwiOiBcIm55YyByZXBvcnQgLS1yZXBvcnRlcj1qc29uICYmIGNvZGVjb3YgLWYgY292ZXJhZ2UvKi5qc29uXCIsXG4gICAgXCJ3YXRjaDpidWlsZFwiOiBcIndhdGNoaWZ5IHNyYy92bC50cyAtcCB0c2lmeSAtdiAtZCAtcyB2bCAtbyAnZXhvcmNpc3QgYnVpbGQvdmVnYS1saXRlLmpzLm1hcCA+IGJ1aWxkL3ZlZ2EtbGl0ZS5qcydcIixcbiAgICBcIndhdGNoOnRlc3RcIjogXCJub2RlbW9uIC14ICducG0gdGVzdCdcIixcbiAgICBcIndhdGNoXCI6IFwibm9kZW1vbiAteCAnbnBtIHJ1biBidWlsZCAmJiBucG0gcnVuIHRlc3Q6bm9jb21waWxlJyAjIGFscmVhZHkgcmFuIHNjaGVtYSBpbiBidWlsZFwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUuZ2l0XCJcbiAgfSxcbiAgXCJsaWNlbnNlXCI6IFwiQlNELTMtQ2xhdXNlXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHR5cGVzL2NoYWlcIjogXCJeMy41LjJcIixcbiAgICBcIkB0eXBlcy9kM1wiOiBcIl40LjguMFwiLFxuICAgIFwiQHR5cGVzL2hpZ2hsaWdodC5qc1wiOiBcIl45LjEuOVwiLFxuICAgIFwiQHR5cGVzL2pzb24tc3RhYmxlLXN0cmluZ2lmeVwiOiBcIl4xLjAuMzFcIixcbiAgICBcIkB0eXBlcy9tb2NoYVwiOiBcIl4yLjIuNDFcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiXjcuMC4xNFwiLFxuICAgIFwiYWp2XCI6IFwiNS4wLjFcIixcbiAgICBcImJyb3dzZXItc3luY1wiOiBcIl4yLjE4LjhcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTQuMy4wXCIsXG4gICAgXCJicm93c2VyaWZ5LXNoaW1cIjogXCJeMy44LjE0XCIsXG4gICAgXCJjaGFpXCI6IFwiXjMuNS4wXCIsXG4gICAgXCJjaGVlcmlvXCI6IFwiXjAuMjIuMFwiLFxuICAgIFwiY29kZWNvdlwiOiBcIl4yLjEuMFwiLFxuICAgIFwiZDNcIjogXCJeNC44LjBcIixcbiAgICBcImV4b3JjaXN0XCI6IFwiXjAuNC4wXCIsXG4gICAgXCJoaWdobGlnaHQuanNcIjogXCJeOS4xMS4wXCIsXG4gICAgXCJtb2NoYVwiOiBcIl4zLjMuMFwiLFxuICAgIFwibm9kZW1vblwiOiBcIl4xLjExLjBcIixcbiAgICBcIm55Y1wiOiBcIl4xMC4zLjBcIixcbiAgICBcInNvdXJjZS1tYXAtc3VwcG9ydFwiOiBcIl4wLjQuMTVcIixcbiAgICBcInRzaWZ5XCI6IFwiXjMuMC4xXCIsXG4gICAgXCJ0c2xpbnRcIjogXCJeNS4xLjBcIixcbiAgICBcInRzbGludC1lc2xpbnQtcnVsZXNcIjogXCJeNC4wLjBcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCJeMi4zLjJcIixcbiAgICBcInR5cGVzY3JpcHQtanNvbi1zY2hlbWFcIjogXCJeMC4xMS4wXCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJeMi44LjIyXCIsXG4gICAgXCJ2ZWdhXCI6IFwiMy4wLjAtYmV0YS4zMFwiLFxuICAgIFwidmVnYS1kYXRhc2V0c1wiOiBcInZlZ2EvdmVnYS1kYXRhc2V0cyNnaC1wYWdlc1wiLFxuICAgIFwidmVnYS1lbWJlZFwiOiBcIjMuMC4wLWJldGEuMTRcIixcbiAgICBcIndhdGNoaWZ5XCI6IFwiXjMuOS4wXCIsXG4gICAgXCJ5YW1sLWZyb250LW1hdHRlclwiOiBcIl4zLjQuMFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiOiBcIl4xLjAuMVwiLFxuICAgIFwidHNsaWJcIjogXCJeMS42LjFcIixcbiAgICBcInZlZ2EtZXZlbnQtc2VsZWN0b3JcIjogXCJeMi4wLjAtYmV0YVwiLFxuICAgIFwidmVnYS11dGlsXCI6IFwiXjEuMi4wXCIsXG4gICAgXCJ5YXJnc1wiOiBcIl43LjEuMFwiXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLkFHR1JFR0FURV9PUFMgPSBbXG4gICAgJ3ZhbHVlcycsXG4gICAgJ2NvdW50JyxcbiAgICAndmFsaWQnLFxuICAgICdtaXNzaW5nJyxcbiAgICAnZGlzdGluY3QnLFxuICAgICdzdW0nLFxuICAgICdtZWFuJyxcbiAgICAnYXZlcmFnZScsXG4gICAgJ3ZhcmlhbmNlJyxcbiAgICAndmFyaWFuY2VwJyxcbiAgICAnc3RkZXYnLFxuICAgICdzdGRldnAnLFxuICAgICdtZWRpYW4nLFxuICAgICdxMScsXG4gICAgJ3EzJyxcbiAgICAnY2kwJyxcbiAgICAnY2kxJyxcbiAgICAnbW9kZXNrZXcnLFxuICAgICdtaW4nLFxuICAgICdtYXgnLFxuICAgICdhcmdtaW4nLFxuICAgICdhcmdtYXgnLFxuXTtcbmV4cG9ydHMuQUdHUkVHQVRFX09QX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuQUdHUkVHQVRFX09QUyk7XG4vKiogQWRkaXRpdmUtYmFzZWQgYWdncmVnYXRpb24gb3BlcmF0aW9ucy4gIFRoZXNlIGNhbiBiZSBhcHBsaWVkIHRvIHN0YWNrLiAqL1xuZXhwb3J0cy5TVU1fT1BTID0gW1xuICAgICdjb3VudCcsXG4gICAgJ3N1bScsXG4gICAgJ2Rpc3RpbmN0JyxcbiAgICAndmFsaWQnLFxuICAgICdtaXNzaW5nJ1xuXTtcbi8qKlxuICogQWdncmVnYXRpb24gb3BlcmF0b3JzIHRoYXQgYWx3YXlzIHByb2R1Y2UgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW2RvbWFpbk1pbiwgZG9tYWluTWF4XS5cbiAqL1xuZXhwb3J0cy5TSEFSRURfRE9NQUlOX09QUyA9IFtcbiAgICAnbWVhbicsXG4gICAgJ2F2ZXJhZ2UnLFxuICAgICdtZWRpYW4nLFxuICAgICdxMScsXG4gICAgJ3EzJyxcbiAgICAnbWluJyxcbiAgICAnbWF4Jyxcbl07XG5leHBvcnRzLlNIQVJFRF9ET01BSU5fT1BfSU5ERVggPSB1dGlsXzEudG9TZXQoZXhwb3J0cy5TSEFSRURfRE9NQUlOX09QUyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZV2RuY21WbllYUmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyRm5aM0psWjJGMFpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVVGQkxDdENRVUUyUWp0QlFVMW9RaXhSUVVGQkxHRkJRV0VzUjBGQmEwSTdTVUZEZUVNc1VVRkJVVHRKUVVOU0xFOUJRVTg3U1VGRFVDeFBRVUZQTzBsQlExQXNVMEZCVXp0SlFVTlVMRlZCUVZVN1NVRkRWaXhMUVVGTE8wbEJRMHdzVFVGQlRUdEpRVU5PTEZOQlFWTTdTVUZEVkN4VlFVRlZPMGxCUTFZc1YwRkJWenRKUVVOWUxFOUJRVTg3U1VGRFVDeFJRVUZSTzBsQlExSXNVVUZCVVR0SlFVTlNMRWxCUVVrN1NVRkRTaXhKUVVGSk8wbEJRMG9zUzBGQlN6dEpRVU5NTEV0QlFVczdTVUZEVEN4VlFVRlZPMGxCUTFZc1MwRkJTenRKUVVOTUxFdEJRVXM3U1VGRFRDeFJRVUZSTzBsQlExSXNVVUZCVVR0RFFVTllMRU5CUVVNN1FVRkZWeXhSUVVGQkxHdENRVUZyUWl4SFFVRkhMRmxCUVVzc1EwRkJReXh4UWtGQllTeERRVUZETEVOQlFVTTdRVUZGZGtRc05rVkJRVFpGTzBGQlEyaEZMRkZCUVVFc1QwRkJUeXhIUVVGclFqdEpRVU5zUXl4UFFVRlBPMGxCUTFBc1MwRkJTenRKUVVOTUxGVkJRVlU3U1VGRFZpeFBRVUZQTzBsQlExQXNVMEZCVXp0RFFVTmFMRU5CUVVNN1FVRkZSanM3UjBGRlJ6dEJRVU5WTEZGQlFVRXNhVUpCUVdsQ0xFZEJRV3RDTzBsQlF6VkRMRTFCUVUwN1NVRkRUaXhUUVVGVE8wbEJRMVFzVVVGQlVUdEpRVU5TTEVsQlFVazdTVUZEU2l4SlFVRkpPMGxCUTBvc1MwRkJTenRKUVVOTUxFdEJRVXM3UTBGRFVpeERRVUZETzBGQlJWY3NVVUZCUVN4elFrRkJjMElzUjBGQlJ5eFpRVUZMTEVOQlFVTXNlVUpCUVdsQ0xFTkJRVU1zUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVhJU19QUk9QRVJUSUVTID0gW1xuICAgICdkb21haW4nLCAnZm9ybWF0JywgJ2dyaWQnLCAnbGFiZWxQYWRkaW5nJywgJ2xhYmVscycsICdtYXhFeHRlbnQnLCAnbWluRXh0ZW50JywgJ29mZnNldCcsICdvcmllbnQnLCAncG9zaXRpb24nLCAndGlja0NvdW50JywgJ3RpY2tzJywgJ3RpY2tTaXplJywgJ3RpdGxlJywgJ3RpdGxlUGFkZGluZycsICd2YWx1ZXMnLCAnemluZGV4J1xuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlYaHBjeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWhlR2x6TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJkMFZoTEZGQlFVRXNaVUZCWlN4SFFVRnJRanRKUVVNMVF5eFJRVUZSTEVWQlFVVXNVVUZCVVN4RlFVRkZMRTFCUVUwc1JVRkJSU3hqUVVGakxFVkJRVVVzVVVGQlVTeEZRVUZGTEZkQlFWY3NSVUZCUlN4WFFVRlhMRVZCUVVVc1VVRkJVU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFZRVUZWTEVWQlFVVXNWMEZCVnl4RlFVRkZMRTlCUVU4c1JVRkJSU3hWUVVGVkxFVkJRVVVzVDBGQlR5eEZRVUZGTEdOQlFXTXNSVUZCUlN4UlFVRlJMRVZCUVVVc1VVRkJVVHREUVVNNVRDeERRVUZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGJpblRvU3RyaW5nKGJpbikge1xuICAgIGlmICh1dGlsXzEuaXNCb29sZWFuKGJpbikpIHtcbiAgICAgICAgcmV0dXJuICdiaW4nO1xuICAgIH1cbiAgICByZXR1cm4gJ2JpbicgKyBPYmplY3Qua2V5cyhiaW4pLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gXCJfXCIgKyBwICsgXCJfXCIgKyBiaW5bcF07IH0pLmpvaW4oJycpO1xufVxuZXhwb3J0cy5iaW5Ub1N0cmluZyA9IGJpblRvU3RyaW5nO1xuZnVuY3Rpb24gYXV0b01heEJpbnMoY2hhbm5lbCkge1xuICAgIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgICAgICBjYXNlIGNoYW5uZWxfMS5ST1c6XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLkNPTFVNTjpcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0laRTpcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuQ09MT1I6XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLk9QQUNJVFk6XG4gICAgICAgIC8vIEZhY2V0cyBhbmQgU2l6ZSBzaG91bGRuJ3QgaGF2ZSB0b28gbWFueSBiaW5zXG4gICAgICAgIC8vIFdlIGNob29zZSA2IGxpa2Ugc2hhcGUgdG8gc2ltcGxpZnkgdGhlIHJ1bGVcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4gNjsgLy8gVmVnYSdzIFwic2hhcGVcIiBoYXMgNiBkaXN0aW5jdCB2YWx1ZXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICB9XG59XG5leHBvcnRzLmF1dG9NYXhCaW5zID0gYXV0b01heEJpbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZbWx1TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMkpwYmk1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEhGRFFVRTBSVHRCUVVNMVJTd3JRa0ZCYVVNN1FVRXlSR3BETEhGQ1FVRTBRaXhIUVVGclFqdEpRVU0xUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhuUWtGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVFpeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hOUVVGSkxFTkJRVU1zVTBGQlNTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkhMRVZCUVdwQ0xFTkJRV2xDTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03UVVGRGRrVXNRMEZCUXp0QlFVeEVMR3REUVV0RE8wRkJSVVFzY1VKQlFUUkNMRTlCUVdkQ08wbEJRekZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFSXNTMEZCU3l4aFFVRkhMRU5CUVVNN1VVRkRWQ3hMUVVGTExHZENRVUZOTEVOQlFVTTdVVUZEV2l4TFFVRkxMR05CUVVrc1EwRkJRenRSUVVOV0xFdEJRVXNzWlVGQlN5eERRVUZETzFGQlExZ3NTMEZCU3l4cFFrRkJUeXhEUVVGRE8xRkJRMWdzSzBOQlFTdERPMUZCUXk5RExEaERRVUU0UXp0UlFVTm9SQ3hMUVVGTExHVkJRVXM3V1VGRFVpeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc2RVTkJRWFZETzFGQlEyNUVPMWxCUTBVc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5rTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCWkVRc2EwTkJZME1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvbnN0YW50cyBhbmQgdXRpbGl0aWVzIGZvciBlbmNvZGluZyBjaGFubmVscyAoVmlzdWFsIHZhcmlhYmxlcylcbiAqIHN1Y2ggYXMgJ3gnLCAneScsICdjb2xvcicuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4vc2NhbGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBDaGFubmVsO1xuKGZ1bmN0aW9uIChDaGFubmVsKSB7XG4gICAgLy8gRmFjZXRcbiAgICBDaGFubmVsLlJPVyA9ICdyb3cnO1xuICAgIENoYW5uZWwuQ09MVU1OID0gJ2NvbHVtbic7XG4gICAgLy8gUG9zaXRpb25cbiAgICBDaGFubmVsLlggPSAneCc7XG4gICAgQ2hhbm5lbC5ZID0gJ3knO1xuICAgIENoYW5uZWwuWDIgPSAneDInO1xuICAgIENoYW5uZWwuWTIgPSAneTInO1xuICAgIC8vIE1hcmsgcHJvcGVydHkgd2l0aCBzY2FsZVxuICAgIENoYW5uZWwuQ09MT1IgPSAnY29sb3InO1xuICAgIENoYW5uZWwuU0hBUEUgPSAnc2hhcGUnO1xuICAgIENoYW5uZWwuU0laRSA9ICdzaXplJztcbiAgICBDaGFubmVsLk9QQUNJVFkgPSAnb3BhY2l0eSc7XG4gICAgLy8gTm9uLXNjYWxlIGNoYW5uZWxcbiAgICBDaGFubmVsLlRFWFQgPSAndGV4dCc7XG4gICAgQ2hhbm5lbC5PUkRFUiA9ICdvcmRlcic7XG4gICAgQ2hhbm5lbC5ERVRBSUwgPSAnZGV0YWlsJztcbiAgICBDaGFubmVsLlRPT0xUSVAgPSAndG9vbHRpcCc7XG59KShDaGFubmVsID0gZXhwb3J0cy5DaGFubmVsIHx8IChleHBvcnRzLkNoYW5uZWwgPSB7fSkpO1xuZXhwb3J0cy5YID0gQ2hhbm5lbC5YO1xuZXhwb3J0cy5ZID0gQ2hhbm5lbC5ZO1xuZXhwb3J0cy5YMiA9IENoYW5uZWwuWDI7XG5leHBvcnRzLlkyID0gQ2hhbm5lbC5ZMjtcbmV4cG9ydHMuUk9XID0gQ2hhbm5lbC5ST1c7XG5leHBvcnRzLkNPTFVNTiA9IENoYW5uZWwuQ09MVU1OO1xuZXhwb3J0cy5TSEFQRSA9IENoYW5uZWwuU0hBUEU7XG5leHBvcnRzLlNJWkUgPSBDaGFubmVsLlNJWkU7XG5leHBvcnRzLkNPTE9SID0gQ2hhbm5lbC5DT0xPUjtcbmV4cG9ydHMuVEVYVCA9IENoYW5uZWwuVEVYVDtcbmV4cG9ydHMuREVUQUlMID0gQ2hhbm5lbC5ERVRBSUw7XG5leHBvcnRzLk9SREVSID0gQ2hhbm5lbC5PUkRFUjtcbmV4cG9ydHMuT1BBQ0lUWSA9IENoYW5uZWwuT1BBQ0lUWTtcbmV4cG9ydHMuVE9PTFRJUCA9IENoYW5uZWwuVE9PTFRJUDtcbmV4cG9ydHMuQ0hBTk5FTFMgPSBbZXhwb3J0cy5YLCBleHBvcnRzLlksIGV4cG9ydHMuWDIsIGV4cG9ydHMuWTIsIGV4cG9ydHMuUk9XLCBleHBvcnRzLkNPTFVNTiwgZXhwb3J0cy5TSVpFLCBleHBvcnRzLlNIQVBFLCBleHBvcnRzLkNPTE9SLCBleHBvcnRzLk9SREVSLCBleHBvcnRzLk9QQUNJVFksIGV4cG9ydHMuVEVYVCwgZXhwb3J0cy5ERVRBSUwsIGV4cG9ydHMuVE9PTFRJUF07XG52YXIgQ0hBTk5FTF9JTkRFWCA9IHV0aWxfMS50b1NldChleHBvcnRzLkNIQU5ORUxTKTtcbmZ1bmN0aW9uIGlzQ2hhbm5lbChzdHIpIHtcbiAgICByZXR1cm4gISFDSEFOTkVMX0lOREVYW3N0cl07XG59XG5leHBvcnRzLmlzQ2hhbm5lbCA9IGlzQ2hhbm5lbDtcbi8vIENIQU5ORUxTIHdpdGhvdXQgQ09MVU1OLCBST1dcbmV4cG9ydHMuVU5JVF9DSEFOTkVMUyA9IFtleHBvcnRzLlgsIGV4cG9ydHMuWSwgZXhwb3J0cy5YMiwgZXhwb3J0cy5ZMiwgZXhwb3J0cy5TSVpFLCBleHBvcnRzLlNIQVBFLCBleHBvcnRzLkNPTE9SLCBleHBvcnRzLk9SREVSLCBleHBvcnRzLk9QQUNJVFksIGV4cG9ydHMuVEVYVCwgZXhwb3J0cy5ERVRBSUwsIGV4cG9ydHMuVE9PTFRJUF07XG4vLyBVTklUX0NIQU5ORUxTIHdpdGhvdXQgWDIsIFkyLCBPUkRFUiwgREVUQUlMLCBURVhULCBUT09MVElQXG5leHBvcnRzLlVOSVRfU0NBTEVfQ0hBTk5FTFMgPSBbZXhwb3J0cy5YLCBleHBvcnRzLlksIGV4cG9ydHMuU0laRSwgZXhwb3J0cy5TSEFQRSwgZXhwb3J0cy5DT0xPUiwgZXhwb3J0cy5PUEFDSVRZXTtcbi8vIFVOSVRfU0NBTEVfQ0hBTk5FTFMgd2l0aCBST1csIENPTFVNTlxuZXhwb3J0cy5TQ0FMRV9DSEFOTkVMUyA9IFtleHBvcnRzLlgsIGV4cG9ydHMuWSwgZXhwb3J0cy5TSVpFLCBleHBvcnRzLlNIQVBFLCBleHBvcnRzLkNPTE9SLCBleHBvcnRzLk9QQUNJVFksIGV4cG9ydHMuUk9XLCBleHBvcnRzLkNPTFVNTl07XG4vLyBVTklUX0NIQU5ORUxTIHdpdGhvdXQgWCwgWSwgWDIsIFkyO1xuZXhwb3J0cy5OT05TUEFUSUFMX0NIQU5ORUxTID0gW2V4cG9ydHMuU0laRSwgZXhwb3J0cy5TSEFQRSwgZXhwb3J0cy5DT0xPUiwgZXhwb3J0cy5PUkRFUiwgZXhwb3J0cy5PUEFDSVRZLCBleHBvcnRzLlRFWFQsIGV4cG9ydHMuREVUQUlMLCBleHBvcnRzLlRPT0xUSVBdO1xuLy8gWCBhbmQgWTtcbmV4cG9ydHMuU1BBVElBTF9TQ0FMRV9DSEFOTkVMUyA9IFtleHBvcnRzLlgsIGV4cG9ydHMuWV07XG4vLyBVTklUX1NDQUxFX0NIQU5ORUxTIHdpdGhvdXQgWCwgWTtcbmV4cG9ydHMuTk9OU1BBVElBTF9TQ0FMRV9DSEFOTkVMUyA9IFtleHBvcnRzLlNJWkUsIGV4cG9ydHMuU0hBUEUsIGV4cG9ydHMuQ09MT1IsIGV4cG9ydHMuT1BBQ0lUWV07XG5leHBvcnRzLkxFVkVMX09GX0RFVEFJTF9DSEFOTkVMUyA9IHV0aWxfMS53aXRob3V0KGV4cG9ydHMuTk9OU1BBVElBTF9DSEFOTkVMUywgWydvcmRlciddKTtcbi8qKiBDaGFubmVscyB0aGF0IGNhbiBzZXJ2ZSBhcyBncm91cGluZ3MgZm9yIHN0YWNrZWQgY2hhcnRzLiAqL1xuZXhwb3J0cy5TVEFDS19HUk9VUF9DSEFOTkVMUyA9IFtleHBvcnRzLkNPTE9SLCBleHBvcnRzLkRFVEFJTCwgZXhwb3J0cy5PUkRFUiwgZXhwb3J0cy5PUEFDSVRZLCBleHBvcnRzLlNJWkVdO1xuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIGNoYW5uZWwgc3VwcG9ydHMgYSBwYXJ0aWN1bGFyIG1hcmsgdHlwZS5cbiAqIEBwYXJhbSBjaGFubmVsICBjaGFubmVsIG5hbWVcbiAqIEBwYXJhbSBtYXJrIHRoZSBtYXJrIHR5cGVcbiAqIEByZXR1cm4gd2hldGhlciB0aGUgbWFyayBzdXBwb3J0cyB0aGUgY2hhbm5lbFxuICovXG5mdW5jdGlvbiBzdXBwb3J0TWFyayhjaGFubmVsLCBtYXJrKSB7XG4gICAgcmV0dXJuIG1hcmsgaW4gZ2V0U3VwcG9ydGVkTWFyayhjaGFubmVsKTtcbn1cbmV4cG9ydHMuc3VwcG9ydE1hcmsgPSBzdXBwb3J0TWFyaztcbi8qKlxuICogUmV0dXJuIGEgZGljdGlvbmFyeSBzaG93aW5nIHdoZXRoZXIgYSBjaGFubmVsIHN1cHBvcnRzIG1hcmsgdHlwZS5cbiAqIEBwYXJhbSBjaGFubmVsXG4gKiBAcmV0dXJuIEEgZGljdGlvbmFyeSBtYXBwaW5nIG1hcmsgdHlwZXMgdG8gYm9vbGVhbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZE1hcmsoY2hhbm5lbCkge1xuICAgIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuWDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlk6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5DT0xPUjpcbiAgICAgICAgY2FzZSBleHBvcnRzLkRFVEFJTDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlRPT0xUSVA6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5PUkRFUjogLy8gVE9ETzogcmV2aXNlIChvcmRlciBtaWdodCBub3Qgc3VwcG9ydCByZWN0LCB3aGljaCBpcyBub3Qgc3RhY2thYmxlPylcbiAgICAgICAgY2FzZSBleHBvcnRzLk9QQUNJVFk6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ST1c6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5DT0xVTU46XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBydWxlOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBiYXI6IHRydWUsIHJlY3Q6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIHRleHQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgZXhwb3J0cy5YMjpcbiAgICAgICAgY2FzZSBleHBvcnRzLlkyOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBydWxlOiB0cnVlLCBiYXI6IHRydWUsIHJlY3Q6IHRydWUsIGFyZWE6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TSVpFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgcnVsZTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgYmFyOiB0cnVlLCB0ZXh0OiB0cnVlLCBsaW5lOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGV4cG9ydHMuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4geyBwb2ludDogdHJ1ZSB9O1xuICAgICAgICBjYXNlIGV4cG9ydHMuVEVYVDpcbiAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IHRydWUgfTtcbiAgICB9XG59XG5leHBvcnRzLmdldFN1cHBvcnRlZE1hcmsgPSBnZXRTdXBwb3J0ZWRNYXJrO1xuZnVuY3Rpb24gaGFzU2NhbGUoY2hhbm5lbCkge1xuICAgIHJldHVybiAhdXRpbF8xLmNvbnRhaW5zKFtleHBvcnRzLkRFVEFJTCwgZXhwb3J0cy5URVhULCBleHBvcnRzLk9SREVSLCBleHBvcnRzLlRPT0xUSVBdLCBjaGFubmVsKTtcbn1cbmV4cG9ydHMuaGFzU2NhbGUgPSBoYXNTY2FsZTtcbi8vIFBvc2l0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBvcmRpbmFsIChsb29rdXApIHNjYWxlIGFuZCBzZXF1ZW50aWFsICh3aGljaCBpcyBvbmx5IGZvciBjb2xvcilcbnZhciBQT1NJVElPTl9TQ0FMRV9UWVBFX0lOREVYID0gdXRpbF8xLnRvU2V0KHV0aWxfMS53aXRob3V0KHNjYWxlXzEuU0NBTEVfVFlQRVMsIFsnb3JkaW5hbCcsICdzZXF1ZW50aWFsJ10pKTtcbmZ1bmN0aW9uIHN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgc2NhbGVUeXBlKSB7XG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ST1c6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5DT0xVTU46XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVUeXBlID09PSAnYmFuZCc7IC8vIHJvdyAvIGNvbHVtbiBjdXJyZW50bHkgc3VwcG9ydHMgYmFuZCBvbmx5XG4gICAgICAgIGNhc2UgZXhwb3J0cy5YOlxuICAgICAgICBjYXNlIGV4cG9ydHMuWTpcbiAgICAgICAgY2FzZSBleHBvcnRzLlNJWkU6IC8vIFRPRE86IHNpemUgYW5kIG9wYWNpdHkgY2FuIHN1cHBvcnQgb3JkaW5hbCB3aXRoIG1vcmUgbW9kaWZpY2F0aW9uXG4gICAgICAgIGNhc2UgZXhwb3J0cy5PUEFDSVRZOlxuICAgICAgICAgICAgLy8gQWx0aG91Z2ggaXQgZ2VuZXJhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byB1c2UgYmFuZCB3aXRoIHNpemUgYW5kIG9wYWNpdHksXG4gICAgICAgICAgICAvLyBpdCBjYW4gYWxzbyB3b3JrIHNpbmNlIHdlIHVzZSBiYW5kOiAwLjUgdG8gZ2V0IG1pZHBvaW50LlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlVHlwZSBpbiBQT1NJVElPTl9TQ0FMRV9UWVBFX0lOREVYO1xuICAgICAgICBjYXNlIGV4cG9ydHMuQ09MT1I6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVUeXBlICE9PSAnYmFuZCc7IC8vIGJhbmQgZG9lcyBub3QgbWFrZSBzZW5zZSB3aXRoIGNvbG9yXG4gICAgICAgIGNhc2UgZXhwb3J0cy5TSEFQRTpcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJzsgLy8gc2hhcGUgPSBsb29rdXAgb25seVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaXQgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnN1cHBvcnRTY2FsZVR5cGUgPSBzdXBwb3J0U2NhbGVUeXBlO1xuZnVuY3Rpb24gcmFuZ2VUeXBlKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLlg6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ZOlxuICAgICAgICBjYXNlIGV4cG9ydHMuU0laRTpcbiAgICAgICAgY2FzZSBleHBvcnRzLk9QQUNJVFk6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVvdXMnO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUk9XOlxuICAgICAgICBjYXNlIGV4cG9ydHMuQ09MVU1OOlxuICAgICAgICBjYXNlIGV4cG9ydHMuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4gJ2Rpc2NyZXRlJztcbiAgICAgICAgLy8gQ29sb3IgY2FuIGJlIGVpdGhlciBjb250aW51b3VzIG9yIGRpc2NyZXRlLCBkZXBlbmRpbmcgb24gc2NhbGUgdHlwZS5cbiAgICAgICAgY2FzZSBleHBvcnRzLkNPTE9SOlxuICAgICAgICAgICAgcmV0dXJuICdmbGV4aWJsZSc7XG4gICAgICAgIC8vIE5vIHNjYWxlLCBubyByYW5nZSB0eXBlLlxuICAgICAgICBjYXNlIGV4cG9ydHMuWDI6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ZMjpcbiAgICAgICAgY2FzZSBleHBvcnRzLkRFVEFJTDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlRFWFQ6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5PUkRFUjpcbiAgICAgICAgY2FzZSBleHBvcnRzLlRPT0xUSVA6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuICovXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXRTdXBwb3J0ZWRSb2xlIG5vdCBpbXBsZW1lbnRlZCBmb3IgJyArIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5yYW5nZVR5cGUgPSByYW5nZVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMmhoYm01bGJDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5amFHRnVibVZzTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3TzBkQlIwYzdPMEZCVFVnc2FVTkJRU3RETzBGQlF5OURMQ3RDUVVGblJEdEJRVVZvUkN4SlFVRnBRaXhQUVVGUExFTkJjMEoyUWp0QlFYUkNSQ3hYUVVGcFFpeFBRVUZQTzBsQlEzUkNMRkZCUVZFN1NVRkRTeXhYUVVGSExFZEJRVlVzUzBGQlN5eERRVUZETzBsQlEyNUNMR05CUVUwc1IwRkJZU3hSUVVGUkxFTkJRVU03U1VGRmVrTXNWMEZCVnp0SlFVTkZMRk5CUVVNc1IwRkJVU3hIUVVGSExFTkJRVU03U1VGRFlpeFRRVUZETEVkQlFWRXNSMEZCUnl4RFFVRkRPMGxCUTJJc1ZVRkJSU3hIUVVGVExFbEJRVWtzUTBGQlF6dEpRVU5vUWl4VlFVRkZMRWRCUVZNc1NVRkJTU3hEUVVGRE8wbEJSVGRDTERKQ1FVRXlRanRKUVVOa0xHRkJRVXNzUjBGQldTeFBRVUZQTEVOQlFVTTdTVUZEZWtJc1lVRkJTeXhIUVVGWkxFOUJRVThzUTBGQlF6dEpRVU42UWl4WlFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wbEJRM1JDTEdWQlFVOHNSMEZCWXl4VFFVRlRMRU5CUVVNN1NVRkZOVU1zYjBKQlFXOUNPMGxCUTFBc1dVRkJTU3hIUVVGWExFMUJRVTBzUTBGQlF6dEpRVU4wUWl4aFFVRkxMRWRCUVZrc1QwRkJUeXhEUVVGRE8wbEJRM3BDTEdOQlFVMHNSMEZCWVN4UlFVRlJMRU5CUVVNN1NVRkROVUlzWlVGQlR5eEhRVUZqTEZOQlFWTXNRMEZCUXp0QlFVTTVReXhEUVVGRExFVkJkRUpuUWl4UFFVRlBMRWRCUVZBc1pVRkJUeXhMUVVGUUxHVkJRVThzVVVGelFuWkNPMEZCU1Zrc1VVRkJRU3hEUVVGRExFZEJRVWNzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTmtMRkZCUVVFc1EwRkJReXhIUVVGSExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZEWkN4UlFVRkJMRVZCUVVVc1IwRkJSeXhQUVVGUExFTkJRVU1zUlVGQlJTeERRVUZETzBGQlEyaENMRkZCUVVFc1JVRkJSU3hIUVVGSExFOUJRVThzUTBGQlF5eEZRVUZGTEVOQlFVTTdRVUZEYUVJc1VVRkJRU3hIUVVGSExFZEJRVWNzVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXp0QlFVTnNRaXhSUVVGQkxFMUJRVTBzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRPMEZCUTNoQ0xGRkJRVUVzUzBGQlN5eEhRVUZITEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNN1FVRkRkRUlzVVVGQlFTeEpRVUZKTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOd1FpeFJRVUZCTEV0QlFVc3NSMEZCUnl4UFFVRlBMRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRM1JDTEZGQlFVRXNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRGNFSXNVVUZCUVN4TlFVRk5MRWRCUVVjc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF6dEJRVU40UWl4UlFVRkJMRXRCUVVzc1IwRkJSeXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzBGQlEzUkNMRkZCUVVFc1QwRkJUeXhIUVVGSExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTTdRVUZETVVJc1VVRkJRU3hQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXp0QlFVY3hRaXhSUVVGQkxGRkJRVkVzUjBGQlJ5eERRVUZETEZOQlFVTXNSVUZCUlN4VFFVRkRMRVZCUVVVc1ZVRkJSU3hGUVVGRkxGVkJRVVVzUlVGQlJTeFhRVUZITEVWQlFVVXNZMEZCVFN4RlFVRkZMRmxCUVVrc1JVRkJSU3hoUVVGTExFVkJRVVVzWVVGQlN5eEZRVUZGTEdGQlFVc3NSVUZCUlN4bFFVRlBMRVZCUVVVc1dVRkJTU3hGUVVGRkxHTkJRVTBzUlVGQlJTeGxRVUZQTEVOQlFVTXNRMEZCUXp0QlFVTXZSeXhKUVVGTkxHRkJRV0VzUjBGQlJ5eFpRVUZMTEVOQlFVTXNaMEpCUVZFc1EwRkJReXhEUVVGRE8wRkJSWFJETEcxQ1FVRXdRaXhIUVVGWE8wbEJRMjVETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1lVRkJZU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzBGQlF6bENMRU5CUVVNN1FVRkdSQ3c0UWtGRlF6dEJRVVZFTEN0Q1FVRXJRanRCUVVOc1FpeFJRVUZCTEdGQlFXRXNSMEZCUnl4RFFVRkRMRk5CUVVNc1JVRkJSU3hUUVVGRExFVkJRVVVzVlVGQlJTeEZRVUZGTEZWQlFVVXNSVUZCUlN4WlFVRkpMRVZCUVVVc1lVRkJTeXhGUVVGRkxHRkJRVXNzUlVGQlJTeGhRVUZMTEVWQlFVVXNaVUZCVHl4RlFVRkZMRmxCUVVrc1JVRkJSU3hqUVVGTkxFVkJRVVVzWlVGQlR5eERRVUZETEVOQlFVTTdRVUZGZGtjc05rUkJRVFpFTzBGQlEyaEVMRkZCUVVFc2JVSkJRVzFDTEVkQlFVY3NRMEZCUXl4VFFVRkRMRVZCUVVVc1UwRkJReXhGUVVGRkxGbEJRVWtzUlVGQlJTeGhRVUZMTEVWQlFVVXNZVUZCU3l4RlFVRkZMR1ZCUVU4c1EwRkJReXhEUVVGRE8wRkJSWFpGTEhWRFFVRjFRenRCUVVNeFFpeFJRVUZCTEdOQlFXTXNSMEZCUnl4RFFVRkRMRk5CUVVNc1JVRkJSU3hUUVVGRExFVkJRVVVzV1VGQlNTeEZRVUZGTEdGQlFVc3NSVUZCUlN4aFFVRkxMRVZCUVVVc1pVRkJUeXhGUVVGRkxGZEJRVWNzUlVGQlJTeGpRVUZOTEVOQlFVTXNRMEZCUXp0QlFVY3ZSU3h6UTBGQmMwTTdRVUZEZWtJc1VVRkJRU3h0UWtGQmJVSXNSMEZCUnl4RFFVRkRMRmxCUVVrc1JVRkJSU3hoUVVGTExFVkJRVVVzWVVGQlN5eEZRVUZGTEdGQlFVc3NSVUZCUlN4bFFVRlBMRVZCUVVVc1dVRkJTU3hGUVVGRkxHTkJRVTBzUlVGQlJTeGxRVUZQTEVOQlFVTXNRMEZCUXp0QlFVVXZSaXhYUVVGWE8wRkJRMFVzVVVGQlFTeHpRa0ZCYzBJc1IwRkJSeXhEUVVGRExGTkJRVU1zUlVGQlJTeFRRVUZETEVOQlFVTXNRMEZCUXp0QlFVYzNReXh2UTBGQmIwTTdRVUZEZGtJc1VVRkJRU3g1UWtGQmVVSXNSMEZCUnl4RFFVRkRMRmxCUVVrc1JVRkJSU3hoUVVGTExFVkJRVVVzWVVGQlN5eEZRVUZGTEdWQlFVOHNRMEZCUXl4RFFVRkRPMEZCUnpGRUxGRkJRVUVzZDBKQlFYZENMRWRCUVVjc1kwRkJUeXhEUVVGRExESkNRVUZ0UWl4RlFVRkZMRU5CUVVNc1QwRkJUeXhEUVVGakxFTkJRVU1zUTBGQlF6dEJRVVUzUml3clJFRkJLMFE3UVVGRGJFUXNVVUZCUVN4dlFrRkJiMElzUjBGQlJ5eERRVUZETEdGQlFVc3NSVUZCUlN4alFVRk5MRVZCUVVVc1lVRkJTeXhGUVVGRkxHVkJRVThzUlVGQlJTeFpRVUZKTEVOQlFVTXNRMEZCUXp0QlFXZENNVVU3T3pzN08wZEJTMGM3UVVGRFNDeHhRa0ZCTkVJc1QwRkJaMElzUlVGQlJTeEpRVUZWTzBsQlEzUkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFbEJRVWtzWjBKQlFXZENMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03UVVGRE0wTXNRMEZCUXp0QlFVWkVMR3REUVVWRE8wRkJSVVE3T3pzN1IwRkpSenRCUVVOSUxEQkNRVUZwUXl4UFFVRm5RanRKUVVNdlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEV0QlFVc3NVMEZCUXl4RFFVRkRPMUZCUTFBc1MwRkJTeXhUUVVGRExFTkJRVU03VVVGRFVDeExRVUZMTEdGQlFVc3NRMEZCUXp0UlFVTllMRXRCUVVzc1kwRkJUU3hEUVVGRE8xRkJRMW9zUzBGQlN5eGxRVUZQTEVOQlFVTTdVVUZEWWl4TFFVRkxMR0ZCUVVzc1EwRkJReXhEUVVGSkxIVkZRVUYxUlR0UlFVTjBSaXhMUVVGTExHVkJRVThzUTBGQlF6dFJRVU5pTEV0QlFVc3NWMEZCUnl4RFFVRkRPMUZCUTFRc1MwRkJTeXhqUVVGTk8xbEJRMVFzVFVGQlRTeERRVUZETzJkQ1FVTk1MRXRCUVVzc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFMUJRVTBzUlVGQlJTeEpRVUZKTEVWQlFVVXNUVUZCVFN4RlFVRkZMRWxCUVVrN1owSkJReTlFTEVkQlFVY3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVazdZVUZETVVRc1EwRkJRenRSUVVOS0xFdEJRVXNzVlVGQlJTeERRVUZETzFGQlExSXNTMEZCU3l4VlFVRkZPMWxCUTB3c1RVRkJUU3hEUVVGRE8yZENRVU5NTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1IwRkJSeXhGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSk8yRkJRemxETEVOQlFVTTdVVUZEU2l4TFFVRkxMRmxCUVVrN1dVRkRVQ3hOUVVGTkxFTkJRVU03WjBKQlEwd3NTMEZCU3l4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1RVRkJUU3hGUVVGRkxFbEJRVWtzUlVGQlJTeE5RVUZOTEVWQlFVVXNTVUZCU1R0blFrRkRMMFFzUjBGQlJ5eEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTzJGQlEyeERMRU5CUVVNN1VVRkRTaXhMUVVGTExHRkJRVXM3V1VGRFVpeE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hGUVVGRExFTkJRVU03VVVGRGRrSXNTMEZCU3l4WlFVRkpPMWxCUTFBc1RVRkJUU3hEUVVGRExFVkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUXl4RFFVRkRPMGxCUTNoQ0xFTkJRVU03UVVGRFNDeERRVUZETzBGQk9VSkVMRFJEUVRoQ1F6dEJRVVZFTEd0Q1FVRjVRaXhQUVVGblFqdEpRVU4yUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eGpRVUZOTEVWQlFVVXNXVUZCU1N4RlFVRkZMR0ZCUVVzc1JVRkJSU3hsUVVGUExFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0QlFVTTFSQ3hEUVVGRE8wRkJSa1FzTkVKQlJVTTdRVUZGUkN3NFJrRkJPRVk3UVVGRE9VWXNTVUZCVFN4NVFrRkJlVUlzUjBGQlJ5eFpRVUZMTEVOQlFVTXNZMEZCVHl4RFFVRkRMRzFDUVVGWExFVkJRVVVzUTBGQlF5eFRRVUZUTEVWQlFVVXNXVUZCV1N4RFFVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVVY0Unl3d1FrRkJhVU1zVDBGQlowSXNSVUZCUlN4VFFVRnZRanRKUVVOeVJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEV0QlFVc3NWMEZCUnl4RFFVRkRPMUZCUTFRc1MwRkJTeXhqUVVGTk8xbEJRMVFzVFVGQlRTeERRVUZETEZOQlFWTXNTMEZCU3l4TlFVRk5MRU5CUVVNc1EwRkJReXcwUTBGQk5FTTdVVUZETTBVc1MwRkJTeXhUUVVGRExFTkJRVU03VVVGRFVDeExRVUZMTEZOQlFVTXNRMEZCUXp0UlFVTlFMRXRCUVVzc1dVRkJTU3hEUVVGRExFTkJRVU1zYjBWQlFXOUZPMUZCUXk5RkxFdEJRVXNzWlVGQlR6dFpRVU5XTERoRlFVRTRSVHRaUVVNNVJTd3lSRUZCTWtRN1dVRkRNMFFzVFVGQlRTeERRVUZETEZOQlFWTXNTVUZCU1N4NVFrRkJlVUlzUTBGQlF6dFJRVU5vUkN4TFFVRkxMR0ZCUVVzN1dVRkRVaXhOUVVGTkxFTkJRVU1zVTBGQlV5eExRVUZMTEUxQlFVMHNRMEZCUXl4RFFVRkpMSE5EUVVGelF6dFJRVU40UlN4TFFVRkxMR0ZCUVVzN1dVRkRVaXhOUVVGTkxFTkJRVU1zVTBGQlV5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMSE5DUVVGelFqdEpRVU14UkN4RFFVRkRPMGxCUTBRc2MwUkJRWE5FTzBsQlEzUkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQmJrSkVMRFJEUVcxQ1F6dEJRVVZFTEcxQ1FVRXdRaXhQUVVGblFqdEpRVU40UXl4TlFVRk5MRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRXRCUVVzc1UwRkJReXhEUVVGRE8xRkJRMUFzUzBGQlN5eFRRVUZETEVOQlFVTTdVVUZEVUN4TFFVRkxMRmxCUVVrc1EwRkJRenRSUVVOV0xFdEJRVXNzWlVGQlR6dFpRVU5XTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNN1VVRkZkRUlzUzBGQlN5eFhRVUZITEVOQlFVTTdVVUZEVkN4TFFVRkxMR05CUVUwc1EwRkJRenRSUVVOYUxFdEJRVXNzWVVGQlN6dFpRVU5TTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1VVRkZjRUlzZFVWQlFYVkZPMUZCUTNaRkxFdEJRVXNzWVVGQlN6dFpRVU5TTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1VVRkZjRUlzTWtKQlFUSkNPMUZCUXpOQ0xFdEJRVXNzVlVGQlJTeERRVUZETzFGQlExSXNTMEZCU3l4VlFVRkZMRU5CUVVNN1VVRkRVaXhMUVVGTExHTkJRVTBzUTBGQlF6dFJRVU5hTEV0QlFVc3NXVUZCU1N4RFFVRkRPMUZCUTFZc1MwRkJTeXhoUVVGTExFTkJRVU03VVVGRFdDeExRVUZMTEdWQlFVODdXVUZEVml4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRM0pDTEVOQlFVTTdTVUZEUkN4dlJFRkJiMFE3U1VGRGNFUXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXgxUTBGQmRVTXNSMEZCUnl4UFFVRlBMRU5CUVVNc1EwRkJRenRCUVVOeVJTeERRVUZETzBGQk5VSkVMRGhDUVRSQ1F5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBsYWJlbHMobW9kZWwsIGNoYW5uZWwsIGxhYmVsc1NwZWMsIGRlZikge1xuICAgIHZhciBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgIHZhciBheGlzID0gbW9kZWwuYXhpcyhjaGFubmVsKTtcbiAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnO1xuICAgIC8vIFRleHRcbiAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLlRFTVBPUkFMKSB7XG4gICAgICAgIGxhYmVsc1NwZWMgPSB1dGlsXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBzaWduYWw6IGNvbW1vbl8xLnRpbWVGb3JtYXRFeHByZXNzaW9uKCdkYXR1bS52YWx1ZScsIGZpZWxkRGVmLnRpbWVVbml0LCBheGlzLmZvcm1hdCwgY29uZmlnLmF4aXMuc2hvcnRUaW1lTGFiZWxzLCBjb25maWcudGltZUZvcm1hdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbGFiZWxzU3BlYyk7XG4gICAgfVxuICAgIC8vIExhYmVsIEFuZ2xlXG4gICAgaWYgKGF4aXMubGFiZWxBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhYmVsc1NwZWMuYW5nbGUgPSB7IHZhbHVlOiBheGlzLmxhYmVsQW5nbGUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGF1dG8gcm90YXRlIGZvciBYXG4gICAgICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCAmJiAodXRpbF8xLmNvbnRhaW5zKFt0eXBlXzEuTk9NSU5BTCwgdHlwZV8xLk9SRElOQUxdLCBmaWVsZERlZi50eXBlKSB8fCAhIWZpZWxkRGVmLmJpbiB8fCBmaWVsZERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUwpKSB7XG4gICAgICAgICAgICBsYWJlbHNTcGVjLmFuZ2xlID0geyB2YWx1ZTogMjcwIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXV0byBzZXQgYWxpZ24gaWYgcm90YXRlZFxuICAgIC8vIFRPRE86IGNvbnNpZGVyIG90aGVyIHZhbHVlIGJlc2lkZXMgMjcwLCA5MFxuICAgIGlmIChsYWJlbHNTcGVjLmFuZ2xlKSB7XG4gICAgICAgIGlmIChsYWJlbHNTcGVjLmFuZ2xlLnZhbHVlID09PSAyNzApIHtcbiAgICAgICAgICAgIGxhYmVsc1NwZWMuYWxpZ24gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZi5vcmllbnQgPT09ICd0b3AnID8gJ2xlZnQnIDpcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YKSA/ICdyaWdodCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NlbnRlcidcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFiZWxzU3BlYy5hbmdsZS52YWx1ZSA9PT0gOTApIHtcbiAgICAgICAgICAgIGxhYmVsc1NwZWMuYWxpZ24gPSB7IHZhbHVlOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsYWJlbHNTcGVjLmFuZ2xlKSB7XG4gICAgICAgIC8vIEF1dG8gc2V0IGJhc2VsaW5lIGlmIHJvdGF0ZWRcbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgb3RoZXIgdmFsdWUgYmVzaWRlcyAyNzAsIDkwXG4gICAgICAgIGlmIChsYWJlbHNTcGVjLmFuZ2xlLnZhbHVlID09PSAyNzApIHtcbiAgICAgICAgICAgIGxhYmVsc1NwZWMuYmFzZWxpbmUgPSB7IHZhbHVlOiAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlgpID8gJ21pZGRsZScgOiAnYm90dG9tJyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhYmVsc1NwZWMuYW5nbGUudmFsdWUgPT09IDkwKSB7XG4gICAgICAgICAgICBsYWJlbHNTcGVjLmJhc2VsaW5lID0geyB2YWx1ZTogJ2JvdHRvbScgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXRpbF8xLmtleXMobGFiZWxzU3BlYykubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogbGFiZWxzU3BlYztcbn1cbmV4cG9ydHMubGFiZWxzID0gbGFiZWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWlc1amIyUmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2WVhocGN5OWxibU52WkdVdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4NVEwRkJlVU03UVVGRGVrTXNiVU5CUVhORU8wRkJRM1JFTEcxRFFVRnJSRHRCUVVkc1JDeHZRMEZCSzBNN1FVRkhMME1zWjBKQlFYVkNMRXRCUVdkQ0xFVkJRVVVzVDBGQlowSXNSVUZCUlN4VlFVRmxMRVZCUVVVc1IwRkJWenRKUVVOeVJpeEpRVUZOTEZGQlFWRXNSMEZCUnl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlEzcERMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRha01zU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVVMVFpeFBRVUZQTzBsQlExQXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUzBGQlN5eGxRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xGVkJRVlVzUjBGQlJ5eGhRVUZOTEVOQlFVTTdXVUZEYkVJc1NVRkJTU3hGUVVGRk8yZENRVU5LTEUxQlFVMHNSVUZCUlN3MlFrRkJiMElzUTBGQlF5eGhRVUZoTEVWQlFVVXNVVUZCVVN4RFFVRkRMRkZCUVZFc1JVRkJSU3hKUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdZVUZETlVnN1UwRkRSaXhGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzBsQlEycENMRU5CUVVNN1NVRkZSQ3hqUVVGak8wbEJRMlFzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRlZCUVZVc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyeERMRlZCUVZVc1EwRkJReXhMUVVGTExFZEJRVWNzUlVGQlF5eExRVUZMTEVWQlFVVXNTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJReXhEUVVGRE8wbEJRemxETEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xHOUNRVUZ2UWp0UlFVTndRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NWMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJVU3hEUVVGRExFTkJRVU1zWTBGQlR5eEZRVUZGTEdOQlFVOHNRMEZCUXl4RlFVRkZMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1NVRkJTU3hSUVVGUkxFTkJRVU1zU1VGQlNTeExRVUZMTEdWQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVNDeFZRVUZWTEVOQlFVTXNTMEZCU3l4SFFVRkhMRVZCUVVNc1MwRkJTeXhGUVVGRkxFZEJRVWNzUlVGQlF5eERRVUZETzFGQlEyeERMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJSVVFzTkVKQlFUUkNPMGxCUXpWQ0xEWkRRVUUyUXp0SlFVTTNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1MwRkJTeXhEUVVGRExFdEJRVXNzUzBGQlN5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExGVkJRVlVzUTBGQlF5eExRVUZMTEVkQlFVYzdaMEpCUTJwQ0xFdEJRVXNzUlVGQlJTeEhRVUZITEVOQlFVTXNUVUZCVFN4TFFVRkxMRXRCUVVzc1IwRkJSeXhOUVVGTk8yOUNRVU0xUWl4RFFVRkRMRTlCUVU4c1MwRkJTeXhYUVVGRExFTkJRVU1zUjBGQlJ5eFBRVUZQTzNkQ1FVTjZRaXhSUVVGUk8yRkJRMnBDTEVOQlFVTTdVVUZEU2l4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtNc1ZVRkJWU3hEUVVGRExFdEJRVXNzUjBGQlJ5eEZRVUZETEV0QlFVc3NSVUZCUlN4UlFVRlJMRVZCUVVNc1EwRkJRenRSUVVOMlF5eERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKQ0xDdENRVUVyUWp0UlFVTXZRaXcyUTBGQk5rTTdVVUZETjBNc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4VlFVRlZMRU5CUVVNc1VVRkJVU3hIUVVGSExFVkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNUMEZCVHl4TFFVRkxMRmRCUVVNc1EwRkJReXhIUVVGSExGRkJRVkVzUjBGQlJ5eFJRVUZSTEVWQlFVTXNRMEZCUXp0UlFVTjJSU3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRla01zVlVGQlZTeERRVUZETEZGQlFWRXNSMEZCUnl4RlFVRkRMRXRCUVVzc1JVRkJSU3hSUVVGUkxFVkJRVU1zUTBGQlF6dFJRVU14UXl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eFhRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUjBGQlJ5eFRRVUZUTEVkQlFVY3NWVUZCVlN4RFFVRkRPMEZCUTJoRkxFTkJRVU03UVVGcVJFUXNkMEpCYVVSREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBheGlzXzEgPSByZXF1aXJlKFwiLi4vLi4vYXhpc1wiKTtcbnZhciBlbmNvZGUgPSByZXF1aXJlKFwiLi9lbmNvZGVcIik7XG52YXIgcnVsZXMgPSByZXF1aXJlKFwiLi9ydWxlc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBBWElTX1BBUlRTID0gWydkb21haW4nLCAnZ3JpZCcsICdsYWJlbHMnLCAndGlja3MnLCAndGl0bGUnXTtcbmZ1bmN0aW9uIHBhcnNlQXhpc0NvbXBvbmVudChtb2RlbCwgYXhpc0NoYW5uZWxzKSB7XG4gICAgcmV0dXJuIGF4aXNDaGFubmVscy5yZWR1Y2UoZnVuY3Rpb24gKGF4aXMsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIGF4aXNDb21wb25lbnQgPSB7IGF4ZXM6IFtdLCBncmlkQXhlczogW10gfTtcbiAgICAgICAgaWYgKG1vZGVsLmF4aXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgbXVsdGlwbGUgYXhpc1xuICAgICAgICAgICAgdmFyIG1haW4gPSBwYXJzZU1haW5BeGlzKGNoYW5uZWwsIG1vZGVsKTtcbiAgICAgICAgICAgIGlmIChtYWluICYmIGlzVmlzaWJsZUF4aXMobWFpbikpIHtcbiAgICAgICAgICAgICAgICBheGlzQ29tcG9uZW50LmF4ZXMucHVzaChtYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmlkID0gcGFyc2VHcmlkQXhpcyhjaGFubmVsLCBtb2RlbCk7XG4gICAgICAgICAgICBpZiAoZ3JpZCAmJiBpc1Zpc2libGVBeGlzKGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgYXhpc0NvbXBvbmVudC5ncmlkQXhlcy5wdXNoKGdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXhpc1tjaGFubmVsXSA9IGF4aXNDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5wYXJzZUF4aXNDb21wb25lbnQgPSBwYXJzZUF4aXNDb21wb25lbnQ7XG5mdW5jdGlvbiBpc0ZhbHNlT3JOdWxsKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gZmFsc2UgfHwgdiA9PT0gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJuIGlmIGFuIGF4aXMgaXMgdmlzaWJsZSAoc2hvd3MgYXQgbGVhc3Qgb25lIHBhcnQgb2YgdGhlIGF4aXMpLlxuICovXG5mdW5jdGlvbiBpc1Zpc2libGVBeGlzKGF4aXMpIHtcbiAgICByZXR1cm4gdXRpbF8xLnNvbWUoQVhJU19QQVJUUywgZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIGhhc0F4aXNQYXJ0KGF4aXMsIHBhcnQpOyB9KTtcbn1cbmZ1bmN0aW9uIGhhc0F4aXNQYXJ0KGF4aXMsIHBhcnQpIHtcbiAgICAvLyBGSVhNRSB0aGlzIG1ldGhvZCBjYW4gYmUgd3JvbmcgaWYgdXNlcnMgdXNlIGEgVmVnYSB0aGVtZS5cbiAgICAvLyAoTm90IHN1cmUgaG93IHRvIGNvcnJlY3RseSBoYW5kbGUgdGhhdCB5ZXQuKS5cbiAgICBpZiAocGFydCA9PT0gJ2dyaWQnIHx8IHBhcnQgPT09ICd0aXRsZScpIHtcbiAgICAgICAgcmV0dXJuICEhYXhpc1twYXJ0XTtcbiAgICB9XG4gICAgLy8gT3RoZXIgcGFydHMgYXJlIGVuYWJsZWQgYnkgZGVmYXVsdCwgc28gdGhleSBzaG91bGQgbm90IGJlIGZhbHNlIG9yIG51bGwuXG4gICAgcmV0dXJuICFpc0ZhbHNlT3JOdWxsKGF4aXNbcGFydF0pO1xufVxuLyoqXG4gKiBNYWtlIGFuIGlubmVyIGF4aXMgZm9yIHNob3dpbmcgZ3JpZCBmb3Igc2hhcmVkIGF4aXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlR3JpZEF4aXMoY2hhbm5lbCwgbW9kZWwpIHtcbiAgICAvLyBGSVhNRTogc3VwcG9ydCBhZGRpbmcgdGlja3MgZm9yIGdyaWQgYXhpcyB0aGF0IGFyZSBpbm5lciBheGVzIG9mIGZhY2V0ZWQgcGxvdHMuXG4gICAgcmV0dXJuIHBhcnNlQXhpcyhjaGFubmVsLCBtb2RlbCwgdHJ1ZSk7XG59XG5leHBvcnRzLnBhcnNlR3JpZEF4aXMgPSBwYXJzZUdyaWRBeGlzO1xuZnVuY3Rpb24gcGFyc2VNYWluQXhpcyhjaGFubmVsLCBtb2RlbCkge1xuICAgIHJldHVybiBwYXJzZUF4aXMoY2hhbm5lbCwgbW9kZWwsIGZhbHNlKTtcbn1cbmV4cG9ydHMucGFyc2VNYWluQXhpcyA9IHBhcnNlTWFpbkF4aXM7XG5mdW5jdGlvbiBwYXJzZUF4aXMoY2hhbm5lbCwgbW9kZWwsIGlzR3JpZEF4aXMpIHtcbiAgICB2YXIgYXhpcyA9IG1vZGVsLmF4aXMoY2hhbm5lbCk7XG4gICAgdmFyIHZnQXhpcyA9IHtcbiAgICAgICAgc2NhbGU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKVxuICAgIH07XG4gICAgLy8gMS4yLiBBZGQgcHJvcGVydGllc1xuICAgIGF4aXNfMS5BWElTX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUocHJvcGVydHksIGF4aXMsIGNoYW5uZWwsIG1vZGVsLCBpc0dyaWRBeGlzKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZnQXhpc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZ3JpZFNjYWxlIHNpbmNlIGdyaWRTY2FsZSBpcyBub3QgYSBWZWdhLUxpdGUgQXhpcyBwcm9wZXJ0eS5cbiAgICB2YXIgZ3JpZFNjYWxlID0gZ2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUoJ2dyaWRTY2FsZScsIGF4aXMsIGNoYW5uZWwsIG1vZGVsLCBpc0dyaWRBeGlzKTtcbiAgICBpZiAoZ3JpZFNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmdBeGlzLmdyaWRTY2FsZSA9IGdyaWRTY2FsZTtcbiAgICB9XG4gICAgLy8gMikgQWRkIGd1aWRlIGVuY29kZSBkZWZpbml0aW9uIGdyb3Vwc1xuICAgIHZhciBlbmNvZGVTcGVjID0gYXhpcy5lbmNvZGUgfHwge307XG4gICAgQVhJU19QQVJUUy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIGlmICghaGFzQXhpc1BhcnQodmdBeGlzLCBwYXJ0KSkge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjcmVhdGUgZW5jb2RlIGZvciBhIGRpc2FibGVkIHBhcnQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhAeXVoYW5sdSk6IGluc3RlYWQgb2YgY2FsbGluZyBlbmNvZGVbcGFydF0sIGJyZWFrIHRoaXMgbGluZSBiYXNlZCBvbiBwYXJ0IHR5cGVcbiAgICAgICAgLy8gYXMgZGlmZmVyZW50IHJlcXVpcmUgZGlmZmVyZW50IHBhcmFtZXRlcnMuXG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHBhcnQgPT09ICdsYWJlbHMnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGVuY29kZS5sYWJlbHMobW9kZWwsIGNoYW5uZWwsIGVuY29kZVNwZWMubGFiZWxzIHx8IHt9LCB2Z0F4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVTcGVjW3BhcnRdIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHV0aWxfMS5rZXlzKHZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2Z0F4aXMuZW5jb2RlID0gdmdBeGlzLmVuY29kZSB8fCB7fTtcbiAgICAgICAgICAgIHZnQXhpcy5lbmNvZGVbcGFydF0gPSB7IHVwZGF0ZTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2Z0F4aXM7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWZpZWRPckRlZmF1bHRWYWx1ZShwcm9wZXJ0eSwgc3BlY2lmaWVkQXhpcywgY2hhbm5lbCwgbW9kZWwsIGlzR3JpZEF4aXMpIHtcbiAgICB2YXIgZmllbGREZWYgPSBtb2RlbC5maWVsZERlZihjaGFubmVsKTtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgIGNhc2UgJ2xhYmVscyc6XG4gICAgICAgICAgICByZXR1cm4gaXNHcmlkQXhpcyA/IGZhbHNlIDogc3BlY2lmaWVkQXhpc1twcm9wZXJ0eV07XG4gICAgICAgIGNhc2UgJ2RvbWFpbic6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMuZG9tYWluKHByb3BlcnR5LCBzcGVjaWZpZWRBeGlzLCBpc0dyaWRBeGlzLCBjaGFubmVsKTtcbiAgICAgICAgY2FzZSAndGlja3MnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnRpY2tzKHByb3BlcnR5LCBzcGVjaWZpZWRBeGlzLCBpc0dyaWRBeGlzLCBjaGFubmVsKTtcbiAgICAgICAgY2FzZSAnZm9ybWF0JzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5mb3JtYXQoc3BlY2lmaWVkQXhpcywgY2hhbm5lbCwgZmllbGREZWYsIG1vZGVsLmNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ2dyaWQnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmdyaWQobW9kZWwsIGNoYW5uZWwsIGlzR3JpZEF4aXMpOyAvLyBGSVhNRTogcmVmYWN0b3IgdGhpc1xuICAgICAgICBjYXNlICdncmlkU2NhbGUnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmdyaWRTY2FsZShtb2RlbCwgY2hhbm5lbCwgaXNHcmlkQXhpcyk7XG4gICAgICAgIGNhc2UgJ29yaWVudCc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMub3JpZW50KHNwZWNpZmllZEF4aXMsIGNoYW5uZWwpO1xuICAgICAgICBjYXNlICd0aWNrQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnRpY2tDb3VudChzcGVjaWZpZWRBeGlzLCBjaGFubmVsLCBmaWVsZERlZik7IC8vIFRPRE86IHNjYWxlVHlwZVxuICAgICAgICBjYXNlICd0aXRsZSc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMudGl0bGUoc3BlY2lmaWVkQXhpcywgZmllbGREZWYsIG1vZGVsLmNvbmZpZywgaXNHcmlkQXhpcyk7XG4gICAgICAgIGNhc2UgJ3ZhbHVlcyc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMudmFsdWVzKHNwZWNpZmllZEF4aXMpO1xuICAgICAgICBjYXNlICd6aW5kZXgnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnppbmRleChzcGVjaWZpZWRBeGlzLCBpc0dyaWRBeGlzKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gc3BlY2lmaWVkIHByb3BlcnR5LlxuICAgIHJldHVybiBzcGVjaWZpZWRBeGlzW3Byb3BlcnR5XTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNHRnljMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5aGVHbHpMM0JoY25ObExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFc2JVTkJRV2xFTzBGQlNXcEVMR2xEUVVGdFF6dEJRVU51UXl3clFrRkJhVU03UVVGRmFrTXNiVU5CUVRSRE8wRkJTelZETEVsQlFVMHNWVUZCVlN4SFFVRmxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFMUJRVTBzUlVGQlJTeFJRVUZSTEVWQlFVVXNUMEZCVHl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wRkJSVGxGTERSQ1FVRnRReXhMUVVGblFpeEZRVUZGTEZsQlFYVkNPMGxCUXpGRkxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZNc1NVRkJTU3hGUVVGRkxFOUJRVTg3VVVGREwwTXNTVUZCVFN4aFFVRmhMRWRCUVd0Q0xFVkJRVU1zU1VGQlNTeEZRVUZETEVWQlFVVXNSVUZCUlN4UlFVRlJMRVZCUVVVc1JVRkJSU3hGUVVGRExFTkJRVU03VVVGRE4wUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRlRUlzT0VKQlFUaENPMWxCUXpsQ0xFbEJRVTBzU1VGQlNTeEhRVUZITEdGQlFXRXNRMEZCUXl4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03V1VGRE0wTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hKUVVGSkxHRkJRV0VzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMmhETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEyaERMRU5CUVVNN1dVRkZSQ3hKUVVGTkxFbEJRVWtzUjBGQlJ5eGhRVUZoTEVOQlFVTXNUMEZCVHl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRek5ETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOb1F5eGhRVUZoTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4RFFVRkRPMWxCUlVRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEdGQlFXRXNRMEZCUXp0UlFVTm9ReXhEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTmtMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZ1UWtRc1owUkJiVUpETzBGQlJVUXNkVUpCUVhWQ0xFTkJRV2xDTzBsQlEzUkRMRTFCUVUwc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eEpRVUZKTEVOQlFVTXNTMEZCU3l4SlFVRkpMRU5CUVVNN1FVRkRia01zUTBGQlF6dEJRVVZFT3p0SFFVVkhPMEZCUTBnc2RVSkJRWFZDTEVsQlFWazdTVUZEYWtNc1RVRkJUU3hEUVVGRExGZEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNWVUZCUXl4SlFVRkpMRWxCUVVzc1QwRkJRU3hYUVVGWExFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RlFVRjJRaXhEUVVGMVFpeERRVUZETEVOQlFVTTdRVUZETjBRc1EwRkJRenRCUVVWRUxIRkNRVUZ4UWl4SlFVRlpMRVZCUVVVc1NVRkJZenRKUVVNdlF5dzBSRUZCTkVRN1NVRkROVVFzWjBSQlFXZEVPMGxCUldoRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4TlFVRk5MRWxCUVVrc1NVRkJTU3hMUVVGTExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRkRUlzUTBGQlF6dEpRVU5FTERKRlFVRXlSVHRKUVVNelJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZEY0VNc1EwRkJRenRCUVVWRU96dEhRVVZITzBGQlEwZ3NkVUpCUVRoQ0xFOUJRV2RDTEVWQlFVVXNTMEZCWjBJN1NVRkRPVVFzYTBaQlFXdEdPMGxCUTJ4R0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4RlFVRkZMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dEJRVU42UXl4RFFVRkRPMEZCU0VRc2MwTkJSME03UVVGRlJDeDFRa0ZCT0VJc1QwRkJaMElzUlVGQlJTeExRVUZuUWp0SlFVTTVSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03UVVGRE1VTXNRMEZCUXp0QlFVWkVMSE5EUVVWRE8wRkJSVVFzYlVKQlFXMUNMRTlCUVdkQ0xFVkJRVVVzUzBGQlowSXNSVUZCUlN4VlFVRnRRanRKUVVONFJTeEpRVUZOTEVsQlFVa3NSMEZCUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlJXcERMRWxCUVUwc1RVRkJUU3hIUVVGWE8xRkJRM0pDTEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUTBGQlF6dExRVU5vUXl4RFFVRkRPMGxCUlVZc2MwSkJRWE5DTzBsQlEzUkNMSE5DUVVGbExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWTXNVVUZCVVR0UlFVTjJReXhKUVVGTkxFdEJRVXNzUjBGQlJ5d3dRa0ZCTUVJc1EwRkJReXhSUVVGUkxFVkJRVVVzU1VGQlNTeEZRVUZGTEU5QlFVOHNSVUZCUlN4TFFVRkxMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRGNrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVJc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXp0UlFVTXpRaXhEUVVGRE8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGU0N3clJVRkJLMFU3U1VGREwwVXNTVUZCVFN4VFFVRlRMRWRCUVVjc01FSkJRVEJDTEVOQlFVTXNWMEZCVnl4RlFVRkZMRWxCUVVrc1JVRkJSU3hQUVVGUExFVkJRVVVzUzBGQlN5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRPMGxCUXpWR0xFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRekZDTEUxQlFVMHNRMEZCUXl4VFFVRlRMRWRCUVVjc1UwRkJVeXhEUVVGRE8wbEJRMnBETEVOQlFVTTdTVUZGUkN4M1EwRkJkME03U1VGRmVFTXNTVUZCVFN4VlFVRlZMRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzU1VGQlNTeEZRVUZGTEVOQlFVTTdTVUZEY2tNc1ZVRkJWU3hEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZUTEVsQlFVazdVVUZET1VJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12UWl4blJFRkJaMFE3V1VGRGFFUXNUVUZCVFN4RFFVRkRPMUZCUTFRc1EwRkJRenRSUVVORUxITkdRVUZ6Ump0UlFVTjBSaXcyUTBGQk5rTTdVVUZETjBNc1NVRkJTU3hMUVVGTExFTkJRVU03VVVGRFZpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UWl4TFFVRkxMRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkZMRlZCUVZVc1EwRkJReXhOUVVGTkxFbEJRVWtzUlVGQlJTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUXpORkxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTktMRXRCUVVzc1IwRkJSeXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRPMUZCUTI1RExFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRXRCUVVzc1UwRkJVeXhKUVVGSkxGZEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUkN4TlFVRk5MRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eE5RVUZOTEVsQlFVa3NSVUZCUlN4RFFVRkRPMWxCUTNCRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1JVRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eEZRVUZETEVOQlFVTTdVVUZEZUVNc1EwRkJRenRKUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlJVZ3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRCUVVOb1FpeERRVUZETzBGQlJVUXNiME5CUVc5RExGRkJRWE5DTEVWQlFVVXNZVUZCYlVJc1JVRkJSU3hQUVVGblFpeEZRVUZGTEV0QlFXZENMRVZCUVVVc1ZVRkJiVUk3U1VGRGRFa3NTVUZCVFN4UlFVRlJMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVVjZReXhOUVVGTkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwQ0xFdEJRVXNzVVVGQlVUdFpRVU5ZTEUxQlFVMHNRMEZCUXl4VlFVRlZMRWRCUVVjc1MwRkJTeXhIUVVGSExHRkJRV0VzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVTjBSQ3hMUVVGTExGRkJRVkU3V1VGRFdDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhSUVVGUkxFVkJRVVVzWVVGQllTeEZRVUZGTEZWQlFWVXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVOd1JTeExRVUZMTEU5QlFVODdXVUZEVml4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNZVUZCWVN4RlFVRkZMRlZCUVZVc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU51UlN4TFFVRkxMRkZCUVZFN1dVRkRXQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4aFFVRmhMRVZCUVVVc1QwRkJUeXhGUVVGRkxGRkJRVkVzUlVGQlJTeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRkRVVzUzBGQlN5eE5RVUZOTzFsQlExUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExIVkNRVUYxUWp0UlFVTjRSU3hMUVVGTExGZEJRVmM3V1VGRFpDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRPMUZCUTNKRUxFdEJRVXNzVVVGQlVUdFpRVU5ZTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExHRkJRV0VzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTTVReXhMUVVGTExGZEJRVmM3V1VGRFpDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhoUVVGaExFVkJRVVVzVDBGQlR5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc2EwSkJRV3RDTzFGQlF6bEZMRXRCUVVzc1QwRkJUenRaUVVOV0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMR0ZCUVdFc1JVRkJSU3hSUVVGUkxFVkJRVVVzUzBGQlN5eERRVUZETEUxQlFVMHNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRSUVVONFJTeExRVUZMTEZGQlFWRTdXVUZEV0N4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0UlFVTnlReXhMUVVGTExGRkJRVkU3V1VGRFdDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhoUVVGaExFVkJRVVVzVlVGQlZTeERRVUZETEVOQlFVTTdTVUZEYmtRc1EwRkJRenRKUVVORUxIZERRVUYzUXp0SlFVTjRReXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMEZCUTJwRExFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgZGF0ZXRpbWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9kYXRldGltZVwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpZWxkZGVmXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGZvcm1hdChzcGVjaWZpZWRBeGlzLCBjaGFubmVsLCBmaWVsZERlZiwgY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbW1vbl8xLm51bWJlckZvcm1hdChmaWVsZERlZiwgc3BlY2lmaWVkQXhpcy5mb3JtYXQsIGNvbmZpZywgY2hhbm5lbCk7XG59XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbi8vIFRPRE86IHdlIG5lZWQgdG8gcmVmYWN0b3IgdGhpcyBtZXRob2QgYWZ0ZXIgd2UgdGFrZSBjYXJlIG9mIGNvbmZpZyByZWZhY3RvcmluZ1xuLyoqXG4gKiBEZWZhdWx0IHJ1bGVzIGZvciB3aGV0aGVyIHRvIHNob3cgYSBncmlkIHNob3VsZCBiZSBzaG93biBmb3IgYSBjaGFubmVsLlxuICogSWYgYGdyaWRgIGlzIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAgZm9yIG9yZGluYWwgc2NhbGVzIHRoYXQgYXJlIG5vdCBiaW5uZWRcbiAqL1xuZnVuY3Rpb24gZ3JpZFNob3cobW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgZ3JpZCA9IG1vZGVsLmF4aXMoY2hhbm5lbCkuZ3JpZDtcbiAgICBpZiAoZ3JpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBncmlkO1xuICAgIH1cbiAgICByZXR1cm4gIW1vZGVsLmhhc0Rpc2NyZXRlRG9tYWluKGNoYW5uZWwpICYmICFtb2RlbC5maWVsZERlZihjaGFubmVsKS5iaW47XG59XG5leHBvcnRzLmdyaWRTaG93ID0gZ3JpZFNob3c7XG5mdW5jdGlvbiBncmlkKG1vZGVsLCBjaGFubmVsLCBpc0dyaWRBeGlzKSB7XG4gICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ST1cgfHwgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLkNPTFVNTikge1xuICAgICAgICAvLyBuZXZlciBhcHBseSBncmlkIGZvciBST1cgYW5kIENPTFVNTiBzaW5jZSB3ZSBtYW51YWxseSBjcmVhdGUgcnVsZS1ncm91cCBmb3IgdGhlbVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNHcmlkQXhpcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZ3JpZFNob3cobW9kZWwsIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5ncmlkID0gZ3JpZDtcbmZ1bmN0aW9uIGdyaWRTY2FsZShtb2RlbCwgY2hhbm5lbCwgaXNHcmlkQXhpcykge1xuICAgIGlmIChpc0dyaWRBeGlzKSB7XG4gICAgICAgIHZhciBncmlkQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgICAgICAgaWYgKG1vZGVsLnNjYWxlKGdyaWRDaGFubmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnNjYWxlTmFtZShncmlkQ2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ3JpZFNjYWxlID0gZ3JpZFNjYWxlO1xuZnVuY3Rpb24gb3JpZW50KHNwZWNpZmllZEF4aXMsIGNoYW5uZWwpIHtcbiAgICB2YXIgb3JpZW50ID0gc3BlY2lmaWVkQXhpcy5vcmllbnQ7XG4gICAgaWYgKG9yaWVudCkge1xuICAgICAgICByZXR1cm4gb3JpZW50O1xuICAgIH1cbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuQ09MVU1OOlxuICAgICAgICAgICAgLy8gRklYTUUgdGVzdCBhbmQgZGVjaWRlXG4gICAgICAgICAgICByZXR1cm4gJ3RvcCc7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlg6XG4gICAgICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlJPVzpcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuWTpcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uICovXG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLklOVkFMSURfQ0hBTk5FTF9GT1JfQVhJUyk7XG59XG5leHBvcnRzLm9yaWVudCA9IG9yaWVudDtcbmZ1bmN0aW9uIHRpY2tDb3VudChzcGVjaWZpZWRBeGlzLCBjaGFubmVsLCBmaWVsZERlZikge1xuICAgIHZhciBjb3VudCA9IHNwZWNpZmllZEF4aXMudGlja0NvdW50O1xuICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gRklYTUUgZGVwZW5kcyBvbiBzY2FsZSB0eXBlIHRvb1xuICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCAmJiAhZmllbGREZWYuYmluKSB7XG4gICAgICAgIC8vIFZlZ2EncyBkZWZhdWx0IHRpY2tDb3VudCBvZnRlbiBsZWFkIHRvIGEgbG90IG9mIGxhYmVsIG9jY2x1c2lvbiBvbiBYIHdpdGhvdXQgOTAgZGVncmVlIHJvdGF0aW9uXG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy50aWNrQ291bnQgPSB0aWNrQ291bnQ7XG5mdW5jdGlvbiB0aXRsZShzcGVjaWZpZWRBeGlzLCBmaWVsZERlZiwgY29uZmlnLCBpc0dyaWRBeGlzKSB7XG4gICAgaWYgKGlzR3JpZEF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHNwZWNpZmllZEF4aXMudGl0bGUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzcGVjaWZpZWRBeGlzLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllZEF4aXMudGl0bGU7XG4gICAgfVxuICAgIC8vIGlmIG5vdCBkZWZpbmVkLCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSBheGlzIHRpdGxlIGZyb20gZmllbGQgZGVmXG4gICAgdmFyIGZpZWxkVGl0bGUgPSBmaWVsZGRlZl8xLnRpdGxlKGZpZWxkRGVmLCBjb25maWcpO1xuICAgIHZhciBtYXhMZW5ndGggPSBzcGVjaWZpZWRBeGlzLnRpdGxlTWF4TGVuZ3RoO1xuICAgIHJldHVybiBtYXhMZW5ndGggPyB1dGlsXzEudHJ1bmNhdGUoZmllbGRUaXRsZSwgbWF4TGVuZ3RoKSA6IGZpZWxkVGl0bGU7XG59XG5leHBvcnRzLnRpdGxlID0gdGl0bGU7XG5mdW5jdGlvbiB2YWx1ZXMoc3BlY2lmaWVkQXhpcykge1xuICAgIHZhciB2YWxzID0gc3BlY2lmaWVkQXhpcy52YWx1ZXM7XG4gICAgaWYgKHNwZWNpZmllZEF4aXMudmFsdWVzICYmIGRhdGV0aW1lXzEuaXNEYXRlVGltZSh2YWxzWzBdKSkge1xuICAgICAgICByZXR1cm4gdmFscy5tYXAoZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgPSB0cnVlIGFzIGVuZCB1c2VyIHdvbid0IHB1dCAwID0gSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIGRhdGV0aW1lXzEudGltZXN0YW1wKGR0LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWxzO1xufVxuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5mdW5jdGlvbiB6aW5kZXgoc3BlY2lmaWVkQXhpcywgaXNHcmlkQXhpcykge1xuICAgIHZhciB6ID0gc3BlY2lmaWVkQXhpcy56aW5kZXg7XG4gICAgaWYgKHogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gejtcbiAgICB9XG4gICAgaWYgKGlzR3JpZEF4aXMpIHtcbiAgICAgICAgLy8gaWYgZ3JpZCBpcyB0cnVlLCBuZWVkIHRvIHB1dCBsYXllciBvbiB0aGUgYmFjayBzbyB0aGF0IGdyaWQgaXMgYmVoaW5kIG1hcmtzXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gMTsgLy8gb3RoZXJ3aXNlIHJldHVybiB1bmRlZmluZWQgYW5kIHVzZSBWZWdhJ3MgZGVmYXVsdC5cbn1cbmV4cG9ydHMuemluZGV4ID0gemluZGV4O1xuZnVuY3Rpb24gZG9tYWluQW5kVGlja3MocHJvcGVydHksIHNwZWNpZmllZEF4aXMsIGlzR3JpZEF4aXMsIGNoYW5uZWwpIHtcbiAgICBpZiAoaXNHcmlkQXhpcyB8fCBjaGFubmVsID09PSBjaGFubmVsXzEuUk9XIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5DT0xVTU4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3BlY2lmaWVkQXhpc1twcm9wZXJ0eV07XG59XG5leHBvcnRzLmRvbWFpbkFuZFRpY2tzID0gZG9tYWluQW5kVGlja3M7XG5leHBvcnRzLmRvbWFpbiA9IGRvbWFpbkFuZFRpY2tzO1xuZXhwb3J0cy50aWNrcyA9IGRvbWFpbkFuZFRpY2tzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY25Wc1pYTXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzloZUdsekwzSjFiR1Z6TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzSzBKQlFXbERPMEZCUjJwRExIbERRVUY1UkR0QlFVVjZSQ3d5UTBGQkswUTdRVUZETDBRc01rTkJRV2RGTzBGQlEyaEZMRzFEUVVGdlF6dEJRVWR3UXl4dlEwRkJkVU03UVVGSGRrTXNaMEpCUVhWQ0xHRkJRVzFDTEVWQlFVVXNUMEZCWjBJc1JVRkJSU3hSUVVFd1FpeEZRVUZGTEUxQlFXTTdTVUZEZEVjc1RVRkJUU3hEUVVGRExIRkNRVUZaTEVOQlFVTXNVVUZCVVN4RlFVRkZMR0ZCUVdFc1EwRkJReXhOUVVGTkxFVkJRVVVzVFVGQlRTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMEZCUTNaRkxFTkJRVU03UVVGR1JDeDNRa0ZGUXp0QlFVVkVMR2xHUVVGcFJqdEJRVU5xUmpzN08wZEJSMGM3UVVGRFNDeHJRa0ZCZVVJc1MwRkJaMElzUlVGQlJTeFBRVUZuUWp0SlFVTjZSQ3hKUVVGTkxFbEJRVWtzUjBGQlJ5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU4wUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETzBGQlF6TkZMRU5CUVVNN1FVRlFSQ3cwUWtGUFF6dEJRVVZFTEdOQlFYRkNMRXRCUVdkQ0xFVkJRVVVzVDBGQlowSXNSVUZCUlN4VlFVRnRRanRKUVVNeFJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1lVRkJSeXhKUVVGSkxFOUJRVThzUzBGQlN5eG5Ra0ZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNeFF5eHRSa0ZCYlVZN1VVRkRia1lzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0SlFVTm1MRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRhRUlzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03UVVGRGJFTXNRMEZCUXp0QlFWaEVMRzlDUVZkRE8wRkJSVVFzYlVKQlFUQkNMRXRCUVdkQ0xFVkJRVVVzVDBGQlowSXNSVUZCUlN4VlFVRnRRanRKUVVNdlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMllzU1VGQlRTeFhRVUZYTEVkQlFWa3NUMEZCVHl4TFFVRkxMRWRCUVVjc1IwRkJSeXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETzFGQlEzcEVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRDTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzFGQlEzUkRMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0QlFVTnVRaXhEUVVGRE8wRkJVa1FzT0VKQlVVTTdRVUZGUkN4blFrRkJkVUlzWVVGQmJVSXNSVUZCUlN4UFFVRm5RanRKUVVNeFJDeEpRVUZOTEUxQlFVMHNSMEZCUnl4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRM0JETEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFdDeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTJoQ0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEV0QlFVc3NaMEpCUVUwN1dVRkRWQ3gzUWtGQmQwSTdXVUZEZUVJc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU5tTEV0QlFVc3NWMEZCUXp0WlFVTktMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03VVVGRGJFSXNTMEZCU3l4aFFVRkhMRU5CUVVNN1VVRkRWQ3hMUVVGTExGZEJRVU03V1VGRFNpeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03U1VGRFJDeHhSRUZCY1VRN1NVRkRja1FzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExIZENRVUYzUWl4RFFVRkRMRU5CUVVNN1FVRkRlRVFzUTBGQlF6dEJRV3hDUkN4M1FrRnJRa003UVVGRlJDeHRRa0ZCTUVJc1lVRkJiVUlzUlVGQlJTeFBRVUZuUWl4RlFVRkZMRkZCUVRCQ08wbEJRM3BHTEVsQlFVMHNTMEZCU3l4SFFVRkhMR0ZCUVdFc1EwRkJReXhUUVVGVExFTkJRVU03U1VGRGRFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVJc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU5tTEVOQlFVTTdTVUZGUkN4clEwRkJhME03U1VGRGJFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhMUVVGTExGZEJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMjVETEd0SFFVRnJSenRSUVVOc1J5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTFnc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVdKRUxEaENRV0ZETzBGQlJVUXNaVUZCYzBJc1lVRkJiVUlzUlVGQlJTeFJRVUV3UWl4RlFVRkZMRTFCUVdNc1JVRkJSU3hWUVVGdFFqdEpRVU40Unl4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyWXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRKUVVOdVFpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1lVRkJZU3hEUVVGRExFdEJRVXNzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZEYmtJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEdGQlFXRXNRMEZCUXl4TFFVRkxMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUXl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU0zUWl4RFFVRkRPMGxCUlVRc2IwVkJRVzlGTzBsQlEzQkZMRWxCUVUwc1ZVRkJWU3hIUVVGSExHZENRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8wbEJSVzVFTEVsQlFVMHNVMEZCVXl4SFFVRlhMR0ZCUVdFc1EwRkJReXhqUVVGakxFTkJRVU03U1VGRGRrUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1IwRkJSeXhsUVVGUkxFTkJRVU1zVlVGQlZTeEZRVUZGTEZOQlFWTXNRMEZCUXl4SFFVRkhMRlZCUVZVc1EwRkJRenRCUVVOc1JTeERRVUZETzBGQmJFSkVMSE5DUVd0Q1F6dEJRVVZFTEdkQ1FVRjFRaXhoUVVGdFFqdEpRVU40UXl4SlFVRk5MRWxCUVVrc1IwRkJSeXhoUVVGaExFTkJRVU1zVFVGQlRTeERRVUZETzBsQlEyeERMRVZCUVVVc1EwRkJReXhEUVVGRExHRkJRV0VzUTBGQlF5eE5RVUZOTEVsQlFVa3NjVUpCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRhRVFzVFVGQlRTeERRVUZGTEVsQlFXMUNMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVU1zUlVGQlJUdFpRVU5xUXl4eFJFRkJjVVE3V1VGRGNrUXNUVUZCVFN4RFFVRkRMRzlDUVVGVExFTkJRVU1zUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUXpkQ0xFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlZFUXNkMEpCVTBNN1FVRkZSQ3huUWtGQmRVSXNZVUZCYlVJc1JVRkJSU3hWUVVGdFFqdEpRVU0zUkN4SlFVRk5MRU5CUVVNc1IwRkJSeXhoUVVGaExFTkJRVU1zVFVGQlRTeERRVUZETzBsQlF5OUNMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCQ0xFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEV0N4RFFVRkRPMGxCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm1MRGhGUVVFNFJUdFJRVU01UlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMWdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXh4UkVGQmNVUTdRVUZEYWtVc1EwRkJRenRCUVZaRUxIZENRVlZETzBGQlJVUXNkMEpCUVN0Q0xGRkJRWE5DTEVWQlFVVXNZVUZCYlVJc1JVRkJSU3hWUVVGdFFpeEZRVUZGTEU5QlFXZENPMGxCUXk5SExFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNTVUZCU1N4UFFVRlBMRXRCUVVzc1lVRkJSeXhKUVVGSkxFOUJRVThzUzBGQlN5eG5Ra0ZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFJDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRha01zUTBGQlF6dEJRVXhFTEhkRFFVdERPMEZCUlZrc1VVRkJRU3hOUVVGTkxFZEJRVWNzWTBGQll5eERRVUZETzBGQlEzaENMRkZCUVVFc1MwRkJTeXhIUVVGSExHTkJRV01zUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi9jaGFubmVsXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vZmllbGRkZWZcIik7XG52YXIgc3BlY18xID0gcmVxdWlyZShcIi4uL3NwZWNcIik7XG52YXIgdGltZXVuaXRfMSA9IHJlcXVpcmUoXCIuLi90aW1ldW5pdFwiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoXCIuL2NvbmNhdFwiKTtcbnZhciBmYWNldF8xID0gcmVxdWlyZShcIi4vZmFjZXRcIik7XG52YXIgbGF5ZXJfMSA9IHJlcXVpcmUoXCIuL2xheWVyXCIpO1xudmFyIHJlcGVhdF8xID0gcmVxdWlyZShcIi4vcmVwZWF0XCIpO1xudmFyIHVuaXRfMSA9IHJlcXVpcmUoXCIuL3VuaXRcIik7XG5mdW5jdGlvbiBidWlsZE1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCB1bml0U2l6ZSwgcmVwZWF0ZXIsIGNvbmZpZykge1xuICAgIGlmIChzcGVjXzEuaXNGYWNldFNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWNldF8xLkZhY2V0TW9kZWwoc3BlYywgcGFyZW50LCBwYXJlbnRHaXZlbk5hbWUsIHJlcGVhdGVyLCBjb25maWcpO1xuICAgIH1cbiAgICBpZiAoc3BlY18xLmlzTGF5ZXJTcGVjKHNwZWMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgbGF5ZXJfMS5MYXllck1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCB1bml0U2l6ZSwgcmVwZWF0ZXIsIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChzcGVjXzEuaXNVbml0U3BlYyhzcGVjKSkge1xuICAgICAgICByZXR1cm4gbmV3IHVuaXRfMS5Vbml0TW9kZWwoc3BlYywgcGFyZW50LCBwYXJlbnRHaXZlbk5hbWUsIHVuaXRTaXplLCByZXBlYXRlciwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKHNwZWNfMS5pc1JlcGVhdFNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZXBlYXRfMS5SZXBlYXRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgcmVwZWF0ZXIsIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChzcGVjXzEuaXNDb25jYXRTcGVjKHNwZWMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29uY2F0XzEuQ29uY2F0TW9kZWwoc3BlYywgcGFyZW50LCBwYXJlbnRHaXZlbk5hbWUsIHJlcGVhdGVyLCBjb25maWcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuSU5WQUxJRF9TUEVDKTtcbn1cbmV4cG9ydHMuYnVpbGRNb2RlbCA9IGJ1aWxkTW9kZWw7XG5mdW5jdGlvbiBhcHBseUNvbmZpZyhlLCBjb25maWcsIC8vIFRPRE8oIzE4NDIpOiBjb25zb2xpZGF0ZSBNYXJrQ29uZmlnIHwgVGV4dENvbmZpZz9cbiAgICBwcm9wc0xpc3QpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHByb3BzTGlzdF8xID0gcHJvcHNMaXN0OyBfaSA8IHByb3BzTGlzdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wc0xpc3RfMVtfaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlW3Byb3BlcnR5XSA9IHsgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG59XG5leHBvcnRzLmFwcGx5Q29uZmlnID0gYXBwbHlDb25maWc7XG5mdW5jdGlvbiBhcHBseU1hcmtDb25maWcoZSwgbW9kZWwsIHByb3BzTGlzdCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgcHJvcHNMaXN0XzIgPSBwcm9wc0xpc3Q7IF9pIDwgcHJvcHNMaXN0XzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BzTGlzdF8yW19pXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0TWFya0NvbmZpZyhwcm9wZXJ0eSwgbW9kZWwubWFyaygpLCBtb2RlbC5jb25maWcpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZVtwcm9wZXJ0eV0gPSB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xufVxuZXhwb3J0cy5hcHBseU1hcmtDb25maWcgPSBhcHBseU1hcmtDb25maWc7XG4vKipcbiAqIFJldHVybiB2YWx1ZSBtYXJrIHNwZWNpZmljIGNvbmZpZyBwcm9wZXJ0eSBpZiBleGlzdHMuXG4gKiBPdGhlcndpc2UsIHJldHVybiBnZW5lcmFsIG1hcmsgc3BlY2lmaWMgY29uZmlnLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrQ29uZmlnKHByb3AsIG1hcmssIGNvbmZpZykge1xuICAgIHZhciBtYXJrU3BlY2lmaWNDb25maWcgPSBjb25maWdbbWFya107XG4gICAgaWYgKG1hcmtTcGVjaWZpY0NvbmZpZ1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtYXJrU3BlY2lmaWNDb25maWdbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBjb25maWcubWFya1twcm9wXTtcbn1cbmV4cG9ydHMuZ2V0TWFya0NvbmZpZyA9IGdldE1hcmtDb25maWc7XG5mdW5jdGlvbiBmb3JtYXRTaWduYWxSZWYoZmllbGREZWYsIHNwZWNpZmllZEZvcm1hdCwgZXhwciwgY29uZmlnLCB1c2VCaW5SYW5nZSkge1xuICAgIGlmIChmaWVsZERlZi50eXBlID09PSAncXVhbnRpdGF0aXZlJykge1xuICAgICAgICB2YXIgZm9ybWF0ID0gbnVtYmVyRm9ybWF0KGZpZWxkRGVmLCBzcGVjaWZpZWRGb3JtYXQsIGNvbmZpZywgJ3RleHQnKTtcbiAgICAgICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgaWYgKHVzZUJpblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGJpbiByYW5nZSwgbm8gbmVlZCB0byBhcHBseSBmb3JtYXQgYXMgdGhlIGZvcm11bGEgdGhhdCBjcmVhdGVzIHJhbmdlIGFscmVhZHkgaW5jbHVkZSBmb3JtYXRcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzaWduYWw6IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgZXhwcjogZXhwciwgYmluU3VmZml4OiAncmFuZ2UnIH0pIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IFwiZm9ybWF0KFwiICsgZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwgeyBleHByOiBleHByLCBiaW5TdWZmaXg6ICdzdGFydCcgfSkgKyBcIiwgJ1wiICsgZm9ybWF0ICsgXCInKVwiICsgXCIrJy0nK1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImZvcm1hdChcIiArIGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgZXhwcjogZXhwciwgYmluU3VmZml4OiAnZW5kJyB9KSArIFwiLCAnXCIgKyBmb3JtYXQgKyBcIicpXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbmFsOiBcImZvcm1hdChcIiArIGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgZXhwcjogZXhwciB9KSArIFwiLCAnXCIgKyBmb3JtYXQgKyBcIicpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGREZWYudHlwZSA9PT0gJ3RlbXBvcmFsJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnbmFsOiB0aW1lRm9ybWF0RXhwcmVzc2lvbihmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGV4cHI6IGV4cHIgfSksIGZpZWxkRGVmLnRpbWVVbml0LCBzcGVjaWZpZWRGb3JtYXQsIGNvbmZpZy50ZXh0LnNob3J0VGltZUxhYmVscywgY29uZmlnLnRpbWVGb3JtYXQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBzaWduYWw6IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgZXhwcjogZXhwciB9KSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZm9ybWF0U2lnbmFsUmVmID0gZm9ybWF0U2lnbmFsUmVmO1xuLyoqXG4gKiBSZXR1cm5zIG51bWJlciBmb3JtYXQgZm9yIGEgZmllbGREZWZcbiAqXG4gKiBAcGFyYW0gZm9ybWF0IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBudW1iZXJGb3JtYXQoZmllbGREZWYsIHNwZWNpZmllZEZvcm1hdCwgY29uZmlnLCBjaGFubmVsKSB7XG4gICAgLy8gU3BlY2lmaWVkIGZvcm1hdCBpbiBheGlzL2xlZ2VuZCBoYXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBmaWVsZERlZi5mb3JtYXRcbiAgICB2YXIgZm9ybWF0ID0gc3BlY2lmaWVkRm9ybWF0O1xuICAgIGlmIChmaWVsZERlZi50eXBlID09PSB0eXBlXzEuUVVBTlRJVEFUSVZFKSB7XG4gICAgICAgIC8vIGFkZCBudW1iZXIgZm9ybWF0IGZvciBxdWFudGl0YXRpdmUgdHlwZSBvbmx5XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGREZWYuYWdncmVnYXRlID09PSAnY291bnQnICYmIGNoYW5uZWwgPT09IGNoYW5uZWxfMS5URVhUKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogbmVlZCBhIG1vcmUgaG9saXN0aWMgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgcmV0dXJuICdkJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIG1ha2UgdGhpcyB3b3JrIGNvcnJlY3RseSBmb3IgbnVtZXJpYyBvcmRpbmFsIC8gbm9taW5hbCB0eXBlXG4gICAgICAgIHJldHVybiBjb25maWcubnVtYmVyRm9ybWF0O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5udW1iZXJGb3JtYXQgPSBudW1iZXJGb3JtYXQ7XG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWUgZXhwcmVzc2lvbiB1c2VkIGZvciBheGlzL2xlZ2VuZCBsYWJlbHMgb3IgdGV4dCBtYXJrIGZvciBhIHRlbXBvcmFsIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIHRpbWVGb3JtYXRFeHByZXNzaW9uKGZpZWxkLCB0aW1lVW5pdCwgZm9ybWF0LCBzaG9ydFRpbWVMYWJlbHMsIHRpbWVGb3JtYXRDb25maWcpIHtcbiAgICBpZiAoIXRpbWVVbml0IHx8IGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3QgdGltZSB1bml0LCBvciBpZiB1c2VyIGV4cGxpY2l0bHkgc3BlY2lmeSBmb3JtYXQgZm9yIGF4aXMvbGVnZW5kL3RleHQuXG4gICAgICAgIHZhciBfZm9ybWF0ID0gZm9ybWF0IHx8IHRpbWVGb3JtYXRDb25maWc7IC8vIG9ubHkgdXNlIGNvbmZpZy50aW1lRm9ybWF0IGlmIHRoZXJlIGlzIG5vIHRpbWVVbml0LlxuICAgICAgICByZXR1cm4gXCJ0aW1lRm9ybWF0KFwiICsgZmllbGQgKyBcIiwgJ1wiICsgX2Zvcm1hdCArIFwiJylcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aW1ldW5pdF8xLmZvcm1hdEV4cHJlc3Npb24odGltZVVuaXQsIGZpZWxkLCBzaG9ydFRpbWVMYWJlbHMpO1xuICAgIH1cbn1cbmV4cG9ydHMudGltZUZvcm1hdEV4cHJlc3Npb24gPSB0aW1lRm9ybWF0RXhwcmVzc2lvbjtcbi8qKlxuICogUmV0dXJuIFZlZ2Egc29ydCBwYXJhbWV0ZXJzICh0dXBsZSBvZiBmaWVsZCBhbmQgb3JkZXIpLlxuICovXG5mdW5jdGlvbiBzb3J0UGFyYW1zKG9yZGVyRGVmKSB7XG4gICAgcmV0dXJuICh1dGlsXzEuaXNBcnJheShvcmRlckRlZikgPyBvcmRlckRlZiA6IFtvcmRlckRlZl0pLnJlZHVjZShmdW5jdGlvbiAocywgb3JkZXJDaGFubmVsRGVmKSB7XG4gICAgICAgIHMuZmllbGQucHVzaChmaWVsZGRlZl8xLmZpZWxkKG9yZGVyQ2hhbm5lbERlZiwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSkpO1xuICAgICAgICBzLm9yZGVyLnB1c2gob3JkZXJDaGFubmVsRGVmLnNvcnQgfHwgJ2FzY2VuZGluZycpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9LCB7IGZpZWxkOiBbXSwgb3JkZXI6IFtdIH0pO1xufVxuZXhwb3J0cy5zb3J0UGFyYW1zID0gc29ydFBhcmFtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyOXRiVzl1TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2WTI5dGJXOXVMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNORUpCUVRoQ08wRkJSVGxDTEhORFFVRjVRenRCUVVWNlF5eDNRMEZCTWtRN1FVRkZNMFFzWjBOQlFYbEhPMEZCUlhwSExIZERRVUUyUXp0QlFVTTNReXhuUTBGQmNVTTdRVUZEY2tNc1owTkJRV2RETzBGQlJXaERMRzFEUVVGeFF6dEJRVU55UXl4cFEwRkJiVU03UVVGRGJrTXNhVU5CUVcxRE8wRkJSVzVETEcxRFFVRnZSRHRCUVVOd1JDd3JRa0ZCYVVNN1FVRkhha01zYjBKQlFUSkNMRWxCUVZVc1JVRkJSU3hOUVVGaExFVkJRVVVzWlVGQmRVSXNSVUZETTBVc1VVRkJhMElzUlVGQlJTeFJRVUYxUWl4RlFVRkZMRTFCUVdNN1NVRkRNMFFzUlVGQlJTeERRVUZETEVOQlFVTXNhMEpCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVJc1RVRkJUU3hEUVVGRExFbEJRVWtzYTBKQlFWVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1RVRkJUU3hGUVVGRkxHVkJRV1VzUlVGQlJTeFJRVUZSTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRla1VzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR3RDUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEd0Q1FVRlZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUlVGQlJTeGxRVUZsTEVWQlFVVXNVVUZCVVN4RlFVRkZMRkZCUVZFc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU51Uml4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zYVVKQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1owSkJRVk1zUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RlFVRkZMR1ZCUVdVc1JVRkJSU3hSUVVGUkxFVkJRVVVzVVVGQlVTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTJ4R0xFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4dFFrRkJXU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeHZRa0ZCVnl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFVkJRVVVzWlVGQlpTeEZRVUZGTEZGQlFWRXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVNeFJTeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc2JVSkJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRka0lzVFVGQlRTeERRVUZETEVsQlFVa3NiMEpCUVZjc1EwRkJReXhKUVVGSkxFVkJRVVVzVFVGQlRTeEZRVUZGTEdWQlFXVXNSVUZCUlN4UlFVRlJMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRE1VVXNRMEZCUXp0SlFVVkVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRenRCUVVNMVF5eERRVUZETzBGQmRrSkVMR2REUVhWQ1F6dEJRVVZFTEhGQ1FVRTBRaXhEUVVGblFpeEZRVU40UXl4TlFVRTBReXhGUVVGRkxHOUVRVUZ2UkR0SlFVTnNSeXhUUVVGdFFqdEpRVU55UWl4SFFVRkhMRU5CUVVNc1EwRkJiVUlzVlVGQlV5eEZRVUZVTEhWQ1FVRlRMRVZCUVZRc2RVSkJRVk1zUlVGQlZDeEpRVUZUTzFGQlFUTkNMRWxCUVUwc1VVRkJVU3hyUWtGQlFUdFJRVU5xUWl4SlFVRk5MRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdVVUZETDBJc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRlRUlzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRVZCUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUlVGQlF5eERRVUZETzFGQlF5OUNMRU5CUVVNN1MwRkRSanRKUVVORUxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZEV0N4RFFVRkRPMEZCVmtRc2EwTkJWVU03UVVGRlJDeDVRa0ZCWjBNc1EwRkJaMElzUlVGQlJTeExRVUZuUWl4RlFVRkZMRk5CUVN0Q08wbEJRMnBITEVkQlFVY3NRMEZCUXl4RFFVRnRRaXhWUVVGVExFVkJRVlFzZFVKQlFWTXNSVUZCVkN4MVFrRkJVeXhGUVVGVUxFbEJRVk03VVVGQk0wSXNTVUZCVFN4UlFVRlJMR3RDUVVGQk8xRkJRMnBDTEVsQlFVMHNTMEZCU3l4SFFVRkhMR0ZCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4RlFVRkZMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU5zUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjRRaXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhGUVVGRExFTkJRVU03VVVGREwwSXNRMEZCUXp0TFFVTkdPMGxCUTBRc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU5ZTEVOQlFVTTdRVUZTUkN3d1EwRlJRenRCUVVWRU96czdSMEZIUnp0QlFVTklMSFZDUVVFd1JDeEpRVUZQTEVWQlFVVXNTVUZCVlN4RlFVRkZMRTFCUVdNN1NVRkRNMFlzU1VGQlRTeHJRa0ZCYTBJc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEZUVNc1JVRkJSU3hEUVVGRExFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXpReXhOUVVGTkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRGJFTXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMEZCUXpOQ0xFTkJRVU03UVVGT1JDeHpRMEZOUXp0QlFVVkVMSGxDUVVGblF5eFJRVUV3UWl4RlFVRkZMR1ZCUVhWQ0xFVkJRVVVzU1VGQmQwSXNSVUZCUlN4TlFVRmpMRVZCUVVVc1YwRkJjVUk3U1VGRGJFb3NSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUzBGQlN5eGpRVUZqTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKRExFbEJRVTBzVFVGQlRTeEhRVUZITEZsQlFWa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1pVRkJaU3hGUVVGRkxFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTjJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOcVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5vUWl4clIwRkJhMGM3WjBKQlEyeEhMRTFCUVUwc1EwRkJReXhGUVVGRExFMUJRVTBzUlVGQlJTeG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRExFbEJRVWtzVFVGQlFTeEZRVUZGTEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJReXhGUVVGRExFTkJRVU03V1VGREwwUXNRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5PTEUxQlFVMHNRMEZCUXp0dlFrRkRUQ3hOUVVGTkxFVkJRVVVzV1VGQlZTeG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRExFbEJRVWtzVFVGQlFTeEZRVUZGTEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJReXhYUVVGTkxFMUJRVTBzVDBGQlNTeEhRVUZITEU5QlFVODdlVUpCUTNKR0xGbEJRVlVzWjBKQlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJReXhKUVVGSkxFMUJRVUVzUlVGQlJTeFRRVUZUTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNc1YwRkJUU3hOUVVGTkxFOUJRVWtzUTBGQlFUdHBRa0ZEZEVVc1EwRkJRenRaUVVOS0xFTkJRVU03VVVGRFNDeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXhOUVVGTkxFTkJRVU03WjBKQlEwd3NUVUZCVFN4RlFVRkZMRmxCUVZVc1owSkJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNSVUZCUXl4SlFVRkpMRTFCUVVFc1JVRkJReXhEUVVGRExGZEJRVTBzVFVGQlRTeFBRVUZKTzJGQlF6RkVMRU5CUVVNN1VVRkRTaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zU1VGQlNTeExRVUZMTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRlRU1zVFVGQlRTeERRVUZETzFsQlEwd3NUVUZCVFN4RlFVRkZMRzlDUVVGdlFpeERRVUZETEdkQ1FVRkxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFVkJRVU1zU1VGQlNTeE5RVUZCTEVWQlFVTXNRMEZCUXl4RlFVRkZMRkZCUVZFc1EwRkJReXhSUVVGUkxFVkJRVVVzWlVGQlpTeEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdVMEZETVVrc1EwRkJRenRKUVVOS0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJReXhGUVVGRExFMUJRVTBzUlVGQlJTeG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRExFbEJRVWtzVFVGQlFTeEZRVUZETEVOQlFVTXNSVUZCUXl4RFFVRkRPMGxCUXpORExFTkJRVU03UVVGRFNDeERRVUZETzBGQmVrSkVMREJEUVhsQ1F6dEJRVVZFT3pzN08wZEJTVWM3UVVGRFNDeHpRa0ZCTmtJc1VVRkJNRUlzUlVGQlJTeGxRVUYxUWl4RlFVRkZMRTFCUVdNc1JVRkJSU3hQUVVGblFqdEpRVU5vU0N3MlJVRkJOa1U3U1VGRE4wVXNTVUZCVFN4TlFVRk5MRWRCUVVjc1pVRkJaU3hEUVVGRE8wbEJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFdEJRVXNzYlVKQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRia01zSzBOQlFTdERPMUZCUlM5RExFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRXQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlEyaENMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRk5CUVZNc1MwRkJTeXhQUVVGUExFbEJRVWtzVDBGQlR5eExRVUZMTEdOQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRPVVFzY1VSQlFYRkVPMWxCUTNKRUxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTTdVVUZEWWl4RFFVRkRPMUZCUTBRc05FVkJRVFJGTzFGQlF6VkZMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETzBsQlF6ZENMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzBGQlEyNUNMRU5CUVVNN1FVRm9Ra1FzYjBOQlowSkRPMEZCUlVRN08wZEJSVWM3UVVGRFNDdzRRa0ZCY1VNc1MwRkJZU3hGUVVGRkxGRkJRV3RDTEVWQlFVVXNUVUZCWXl4RlFVRkZMR1ZCUVhkQ0xFVkJRVVVzWjBKQlFYZENPMGxCUTNoSkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4SlFVRkpMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFSXNkMFpCUVhkR08xRkJRM2hHTEVsQlFVMHNUMEZCVHl4SFFVRkhMRTFCUVUwc1NVRkJTU3huUWtGQlowSXNRMEZCUXl4RFFVRkRMSE5FUVVGelJEdFJRVU5zUnl4TlFVRk5MRU5CUVVNc1owSkJRV01zUzBGQlN5eFhRVUZOTEU5QlFVOHNUMEZCU1N4RFFVRkRPMGxCUXpsRExFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJReXd5UWtGQlowSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1MwRkJTeXhGUVVGRkxHVkJRV1VzUTBGQlF5eERRVUZETzBsQlF6VkVMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJVa1FzYjBSQlVVTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxHOUNRVUV5UWl4UlFVRjVSRHRKUVVOc1JpeE5RVUZOTEVOQlFVTXNRMEZCUXl4alFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzVVVGQlVTeEhRVUZITEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eERRVUZETEVWQlFVVXNaVUZCWlR0UlFVTXpSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4blFrRkJTeXhEUVVGRExHVkJRV1VzUlVGQlJTeEZRVUZETEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE0wUXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeERRVUZETEVsQlFVa3NTVUZCU1N4WFFVRlhMRU5CUVVNc1EwRkJRenRSUVVOc1JDeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTFnc1EwRkJReXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZETEVWQlFVVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1JVRkJSU3hGUVVGRExFTkJRVU1zUTBGQlF6dEJRVU0xUWl4RFFVRkRPMEZCVGtRc1owTkJUVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vKipcbiAqIE1vZHVsZSBmb3IgY29tcGlsaW5nIFZlZ2EtbGl0ZSBzcGVjIGludG8gVmVnYSBzcGVjLlxuICovXG52YXIgY29uZmlnXzEgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dcIik7XG52YXIgc3BlY18xID0gcmVxdWlyZShcIi4uL3NwZWNcIik7XG52YXIgdG9wbGV2ZWxwcm9wc18xID0gcmVxdWlyZShcIi4uL3RvcGxldmVscHJvcHNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5mdW5jdGlvbiBjb21waWxlKGlucHV0U3BlYywgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICAvLyBzZXQgdGhlIHNpbmdsZXRvbiBsb2dnZXIgdG8gdGhlIHByb3ZpZGVkIGxvZ2dlclxuICAgICAgICBsb2cuc2V0KGxvZ2dlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIDEuIGluaXRpYWxpemUgY29uZmlnXG4gICAgICAgIHZhciBjb25maWcgPSBjb25maWdfMS5pbml0Q29uZmlnKGlucHV0U3BlYy5jb25maWcpO1xuICAgICAgICAvLyAyLiBDb252ZXJ0IGlucHV0IHNwZWMgaW50byBhIG5vcm1hbCBmb3JtXG4gICAgICAgIC8vIChEZWNvbXBvc2UgYWxsIGV4dGVuZGVkIHVuaXQgc3BlY3MgaW50byBjb21wb3NpdGlvbiBvZiB1bml0IHNwZWMuKVxuICAgICAgICB2YXIgc3BlYyA9IHNwZWNfMS5ub3JtYWxpemUoaW5wdXRTcGVjLCBjb25maWcpO1xuICAgICAgICAvLyAzLiBJbnN0YW50aWF0ZSB0aGUgbW9kZWwgd2l0aCBkZWZhdWx0IGNvbmZpZ1xuICAgICAgICB2YXIgbW9kZWwgPSBjb21tb25fMS5idWlsZE1vZGVsKHNwZWMsIG51bGwsICcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnKTtcbiAgICAgICAgLy8gNC4gUGFyc2UgZWFjaCBwYXJ0IG9mIHRoZSBtb2RlbCB0byBwcm9kdWNlIGNvbXBvbmVudHMgdGhhdCB3aWxsIGJlIGFzc2VtYmxlZCBsYXRlclxuICAgICAgICAvLyBXZSB0cmF2ZXJzZSB0aGUgd2hvbGUgdHJlZSB0byBwYXJzZSBvbmNlIGZvciBlYWNoIHR5cGUgb2YgY29tcG9uZW50c1xuICAgICAgICAvLyAoZS5nLiwgZGF0YSwgbGF5b3V0LCBtYXJrLCBzY2FsZSkuXG4gICAgICAgIC8vIFBsZWFzZSBzZWUgaW5zaWRlIG1vZGVsLnBhcnNlKCkgZm9yIG9yZGVyIGZvciBjb21waWxhdGlvbi5cbiAgICAgICAgbW9kZWwucGFyc2UoKTtcbiAgICAgICAgLy8gNS4gQXNzZW1ibGUgYSBWZWdhIFNwZWMgZnJvbSB0aGUgcGFyc2VkIGNvbXBvbmVudHMgaW4gMy5cbiAgICAgICAgcmV0dXJuIGFzc2VtYmxlKG1vZGVsLCBnZXRUb3BMZXZlbFByb3BlcnRpZXMoaW5wdXRTcGVjLCBjb25maWcpKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBzaW5nbGV0b24gbG9nZ2VyIGlmIGEgbG9nZ2VyIGlzIHByb3ZpZGVkXG4gICAgICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgICAgIGxvZy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmZ1bmN0aW9uIGdldFRvcExldmVsUHJvcGVydGllcyh0b3BMZXZlbFNwZWMsIGNvbmZpZykge1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCB0b3BsZXZlbHByb3BzXzEuZXh0cmFjdFRvcExldmVsUHJvcGVydGllcyhjb25maWcpLCB0b3BsZXZlbHByb3BzXzEuZXh0cmFjdFRvcExldmVsUHJvcGVydGllcyh0b3BMZXZlbFNwZWMpKTtcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlKG1vZGVsLCB0b3BMZXZlbFByb3BlcnRpZXMpIHtcbiAgICAvLyBUT0RPOiBjaGFuZ2UgdHlwZSB0byBiZWNvbWUgVmdTcGVjXG4gICAgdmFyIG91dHB1dCA9IHRzbGliXzEuX19hc3NpZ24oeyAkc2NoZW1hOiAnaHR0cDovL3ZlZ2EuZ2l0aHViLmlvL3NjaGVtYS92ZWdhL3YzLjAuanNvbicgfSwgKG1vZGVsLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfSA6IHt9KSwgeyBhdXRvc2l6ZTogJ3BhZCcgfSwgdG9wTGV2ZWxQcm9wZXJ0aWVzLCB7IGRhdGE6IFtdLmNvbmNhdChtb2RlbC5hc3NlbWJsZVNlbGVjdGlvbkRhdGEoW10pLCBtb2RlbC5hc3NlbWJsZURhdGEoKSksIHNpZ25hbHM6IChbXS5jb25jYXQoXG4gICAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL2lzc3Vlcy8yMTk4KTpcbiAgICAgICAgLy8gTWVyZ2UgdGhlIHRvcC1sZXZlbCdzIHdpZHRoL2hlaWdodCBzaWduYWwgd2l0aCB0aGUgdG9wLWxldmVsIG1vZGVsXG4gICAgICAgIC8vIHNvIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2luZyBiYXNlZCBvbiBtb2RlbC5uYW1lXG4gICAgICAgIChtb2RlbC5uYW1lID8gW1xuICAgICAgICAgICAgLy8gSWYgbW9kZWwgaGFzIG5hbWUsIGl0cyBjYWxjdWxhdGVkIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBub3QgYmUgbmFtZWQgd2lkdGggYW5kIGhlaWdodCwgbmVlZCB0byBtYXAgaXQgdG8gdGhlIGdsb2JhbCB3aWR0aCBhbmQgaGVpZ2h0IHNpZ25hbHMuXG4gICAgICAgICAgICB7IG5hbWU6ICd3aWR0aCcsIHVwZGF0ZTogbW9kZWwuZ2V0TmFtZSgnd2lkdGgnKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaGVpZ2h0JywgdXBkYXRlOiBtb2RlbC5nZXROYW1lKCdoZWlnaHQnKSB9XG4gICAgICAgIF0gOiBbXSksIG1vZGVsLmFzc2VtYmxlTGF5b3V0U2lnbmFscygpLCBtb2RlbC5hc3NlbWJsZVNlbGVjdGlvblRvcExldmVsU2lnbmFscyhbXSkpKSB9LCBhc3NlbWJsZU5lc3RlZE1haW5Hcm91cChtb2RlbCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNwZWM6IG91dHB1dFxuICAgICAgICAvLyBUT0RPOiBhZGQgd2FybmluZyAvIGVycm9ycyBoZXJlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlTmVzdGVkTWFpbkdyb3VwKG1vZGVsKSB7XG4gICAgdmFyIF9hID0gbW9kZWwuYXNzZW1ibGVHcm91cChbXSksIGxheW91dCA9IF9hLmxheW91dCwgc2lnbmFscyA9IF9hLnNpZ25hbHMsIGdyb3VwID0gdHNsaWJfMS5fX3Jlc3QoX2EsIFtcImxheW91dFwiLCBcInNpZ25hbHNcIl0pO1xuICAgIHZhciBtYXJrcyA9IGdyb3VwLm1hcmtzO1xuICAgIHZhciBwYXJlbnRFbmNvZGVFbnRyeSA9IG1vZGVsLmFzc2VtYmxlUGFyZW50R3JvdXBQcm9wZXJ0aWVzKCk7XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIGdyb3VwLCB7IG1hcmtzOiBbdHNsaWJfMS5fX2Fzc2lnbih7IG5hbWU6IG1vZGVsLmdldE5hbWUoJ25lc3RlZF9tYWluX2dyb3VwJyksIHR5cGU6ICdncm91cCcsIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgIHNpZ25hbHM6IHNpZ25hbHMgfSwgKHBhcmVudEVuY29kZUVudHJ5ID8ge1xuICAgICAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHBhcmVudEVuY29kZUVudHJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IHt9KSwgeyBtYXJrczogbWFya3MgfSldIH0pO1xufVxuZXhwb3J0cy5hc3NlbWJsZU5lc3RlZE1haW5Hcm91cCA9IGFzc2VtYmxlTmVzdGVkTWFpbkdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTI5dGNHbHNaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMk52YlhCcGJHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlFVRTdPMGRCUlVjN1FVRkRTQ3h2UTBGQk5rTTdRVUZETjBNc05FSkJRVGhDTzBGQlF6bENMR2REUVVGclJUdEJRVU5zUlN4clJFRkJLMFU3UVVGRkwwVXNiVU5CUVc5RE8wRkJSM0JETEdsQ1FVRjNRaXhUUVVFclFpeEZRVUZGTEUxQlFUUkNPMGxCUTI1R0xFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRXQ3hyUkVGQmEwUTdVVUZEYkVRc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJSVVFzU1VGQlNTeERRVUZETzFGQlEwZ3NkVUpCUVhWQ08xRkJRM1pDTEVsQlFVMHNUVUZCVFN4SFFVRkhMRzFDUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUlRWRExESkRRVUV5UXp0UlFVTXpReXh4UlVGQmNVVTdVVUZEY2tVc1NVRkJUU3hKUVVGSkxFZEJRVWNzWjBKQlFWTXNRMEZCUXl4VFFVRlRMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRk1VTXNLME5CUVN0RE8xRkJReTlETEVsQlFVMHNTMEZCU3l4SFFVRkhMRzFDUVVGVkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4RlFVRkZMRVZCUVVVc1UwRkJVeXhGUVVGRkxGTkJRVk1zUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVVjJSU3h4UmtGQmNVWTdVVUZEY2tZc2RVVkJRWFZGTzFGQlEzWkZMSEZEUVVGeFF6dFJRVU55UXl3MlJFRkJOa1E3VVVGRE4wUXNTMEZCU3l4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRE8xRkJSV1FzTWtSQlFUSkVPMUZCUXpORUxFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RlFVRkZMSEZDUVVGeFFpeERRVUZETEZOQlFWTXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMjVGTEVOQlFVTTdXVUZCVXl4RFFVRkRPMUZCUTFRc2NVUkJRWEZFTzFGQlEzSkVMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEV0N4SFFVRkhMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03VVVGRFpDeERRVUZETzBsQlEwZ3NRMEZCUXp0QlFVTklMRU5CUVVNN1FVRXZRa1FzTUVKQkswSkRPMEZCUjBRc0swSkJRU3RDTEZsQlFUSkNMRVZCUVVVc1RVRkJZenRKUVVONFJTeE5RVUZOTEhOQ1FVTkVMSGxEUVVGNVFpeERRVUZETEUxQlFVMHNRMEZCUXl4RlFVTnFReXg1UTBGQmVVSXNRMEZCUXl4WlFVRlpMRU5CUVVNc1JVRkRNVU03UVVGRFNpeERRVUZETzBGQlJVUXNhMEpCUVd0Q0xFdEJRVmtzUlVGQlJTeHJRa0ZCYzBNN1NVRkRjRVVzY1VOQlFYRkRPMGxCUlhKRExFbEJRVTBzVFVGQlRTeHpRa0ZEVml4UFFVRlBMRVZCUVVVc05rTkJRVFpETEVsQlEyNUVMRU5CUVVNc1MwRkJTeXhEUVVGRExGZEJRVmNzUjBGQlJ5eEZRVUZETEZkQlFWY3NSVUZCUlN4TFFVRkxMRU5CUVVNc1YwRkJWeXhGUVVGRExFZEJRVWNzUlVGQlJTeERRVUZETEVsQlF6bEVMRkZCUVZFc1JVRkJSU3hMUVVGTExFbEJRMW9zYTBKQlFXdENMRWxCUTNKQ0xFbEJRVWtzUlVGQlJTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVTmlMRXRCUVVzc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkRMMElzUzBGQlN5eERRVUZETEZsQlFWa3NSVUZCUlN4RFFVTnlRaXhGUVVORUxFOUJRVThzUlVGQlJTeERRVU5RTEVWQlFVVXNRMEZCUXl4TlFVRk5PMUZCUTFBc2RVUkJRWFZFTzFGQlEzWkVMSEZGUVVGeFJUdFJRVU55UlN3eVJFRkJNa1E3VVVGRE0wUXNRMEZEUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hIUVVGSE8xbEJRMWdzWjBwQlFXZEtPMWxCUTJoS0xFVkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNSVUZCUlN4TlFVRk5MRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUXp0WlFVTXZReXhGUVVGRExFbEJRVWtzUlVGQlJTeFJRVUZSTEVWQlFVVXNUVUZCVFN4RlFVRkZMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVTTdVMEZEYkVRc1IwRkJSeXhGUVVGRkxFTkJRMUFzUlVGRFJDeExRVUZMTEVOQlFVTXNjVUpCUVhGQ0xFVkJRVVVzUlVGRE4wSXNTMEZCU3l4RFFVRkRMR2REUVVGblF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVTXpReXhEUVVOR0xFbEJUVVVzZFVKQlFYVkNMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRMnhETEVOQlFVTTdTVUZGUml4TlFVRk5MRU5CUVVNN1VVRkRUQ3hKUVVGSkxFVkJRVVVzVFVGQlRUdFJRVU5hTEd0RFFVRnJRenRMUVVOdVF5eERRVUZETzBGQlEwb3NRMEZCUXp0QlFVVkVMR2xEUVVGM1F5eExRVUZaTzBsQlEyeEVMRWxCUVUwc05FSkJRWE5FTEVWQlFYSkVMR3RDUVVGTkxFVkJRVVVzYjBKQlFVOHNSVUZCUlN4cFJFRkJiME1zUTBGQlF6dEpRVU0zUkN4SlFVRk5MRXRCUVVzc1IwRkJSeXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETzBsQlJURkNMRWxCUVUwc2FVSkJRV2xDTEVkQlFVY3NTMEZCU3l4RFFVRkRMRFpDUVVFMlFpeEZRVUZGTEVOQlFVTTdTVUZGYUVVc1RVRkJUU3h6UWtGRFJDeExRVUZMTEVsQlExSXNTMEZCU3l4RlFVRkZMRzlDUVVOTUxFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRzFDUVVGdFFpeERRVUZETEVWQlEzaERMRWxCUVVrc1JVRkJSU3hQUVVGUExFVkJRMklzVFVGQlRTeFJRVUZCTzJkQ1FVTk9MRTlCUVU4c1UwRkJRU3hKUVVOS0xFTkJRVU1zYVVKQlFXbENMRWRCUVVjN1owSkJRM1JDTEUxQlFVMHNSVUZCUlR0dlFrRkRUaXhOUVVGTkxFVkJRVVVzYVVKQlFXbENPMmxDUVVNeFFqdGhRVU5HTEVkQlFVY3NSVUZCUlN4RFFVRkRMRWxCUTFBc1MwRkJTeXhQUVVGQkxFbEJRMHdzU1VGRFJqdEJRVU5LTEVOQlFVTTdRVUZ5UWtRc01FUkJjVUpESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc3BlY18xID0gcmVxdWlyZShcIi4uL3NwZWNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgYXNzZW1ibGVfMSA9IHJlcXVpcmUoXCIuL2RhdGEvYXNzZW1ibGVcIik7XG52YXIgcGFyc2VfMSA9IHJlcXVpcmUoXCIuL2RhdGEvcGFyc2VcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIENvbmNhdE1vZGVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25jYXRNb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgcmVwZWF0ZXIsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pc1ZDb25jYXQgPSBzcGVjXzEuaXNWQ29uY2F0U3BlYyhzcGVjKTtcbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSAoc3BlY18xLmlzVkNvbmNhdFNwZWMoc3BlYykgPyBzcGVjLnZjb25jYXQgOiBzcGVjLmhjb25jYXQpLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5idWlsZE1vZGVsKGNoaWxkLCBfdGhpcywgX3RoaXMuZ2V0TmFtZSgnY29uY2F0XycgKyBpKSwgdW5kZWZpbmVkLCByZXBlYXRlciwgY29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLnBhcnNlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuZGF0YSA9IHBhcnNlXzEucGFyc2VEYXRhKHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZURhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXRNb2RlbC5wcm90b3R5cGUucGFyc2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE1lcmdlIHNlbGVjdGlvbnMgdXAgdGhlIGhpZXJhcmNoeSBzbyB0aGF0IHRoZXkgbWF5IGJlIHJlZmVyZW5jZWRcbiAgICAgICAgLy8gYWNyb3NzIHVuaXQgc3BlY3MuIFBlcnNpc3QgdGhlaXIgZGVmaW5pdGlvbnMgd2l0aGluIGVhY2ggY2hpbGRcbiAgICAgICAgLy8gdG8gYXNzZW1ibGUgc2lnbmFscyB3aGljaCByZW1haW4gd2l0aGluIG91dHB1dCBWZWdhIHVuaXQgZ3JvdXBzLlxuICAgICAgICB0aGlzLmNvbXBvbmVudC5zZWxlY3Rpb24gPSB7fTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB1dGlsXzEua2V5cyhjaGlsZC5jb21wb25lbnQuc2VsZWN0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnQuc2VsZWN0aW9uW2tleV0gPSBjaGlsZC5jb21wb25lbnQuc2VsZWN0aW9uW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBfbG9vcF8xKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLnBhcnNlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgIHZhciBzY2FsZUNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50LnNjYWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZVNjYWxlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLnBhcnNlTWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBjaGlsZC5wYXJzZU1hcmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLnBhcnNlQXhpc0FuZEhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBjaGlsZC5wYXJzZUF4aXNBbmRIZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLnBhcnNlQXhpc0dyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENvbmNhdE1vZGVsLnByb3RvdHlwZS5wYXJzZUxlZ2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZ2VuZENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50LmxlZ2VuZHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBjaGlsZC5wYXJzZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25jYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBvbmx5IGFzc2VtYmxlIGRhdGEgaW4gdGhlIHJvb3RcbiAgICAgICAgICAgIHJldHVybiBhc3NlbWJsZV8xLmFzc2VtYmxlRGF0YSh1dGlsXzEudmFscyh0aGlzLmNvbXBvbmVudC5kYXRhLnNvdXJjZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBDb25jYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uVG9wTGV2ZWxTaWduYWxzID0gZnVuY3Rpb24gKHNpZ25hbHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChzZywgY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmFzc2VtYmxlU2VsZWN0aW9uVG9wTGV2ZWxTaWduYWxzKHNnKTsgfSwgc2lnbmFscyk7XG4gICAgfTtcbiAgICBDb25jYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTZWxlY3Rpb25TaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5hc3NlbWJsZVNlbGVjdGlvblNpZ25hbHMoKTsgfSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIENvbmNhdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUxheW91dFNpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoc2lnbmFscywgY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduYWxzLmNvbmNhdChjaGlsZC5hc3NlbWJsZUxheW91dFNpZ25hbHMoKSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIENvbmNhdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNlbGVjdGlvbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGRiLCBjaGlsZCkgeyByZXR1cm4gY2hpbGQuYXNzZW1ibGVTZWxlY3Rpb25EYXRhKGRiKTsgfSwgW10pO1xuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2NhbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb21iaW5lIHdpdGggc2NhbGVzIGZyb20gY2hpbGRyZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChzY2FsZXMsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZXMuY29uY2F0KGMuYXNzZW1ibGVTY2FsZXMoKSk7XG4gICAgICAgIH0sIF9zdXBlci5wcm90b3R5cGUuYXNzZW1ibGVTY2FsZXMuY2FsbCh0aGlzKSk7XG4gICAgfTtcbiAgICBDb25jYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IGFsbG93IGN1c3RvbWl6YXRpb25cbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oeyBwYWRkaW5nOiB7IHJvdzogMTAsIGNvbHVtbjogMTAgfSwgb2Zmc2V0OiAxMCB9LCAodGhpcy5pc1ZDb25jYXQgPyB7IGNvbHVtbnM6IDEgfSA6IHt9KSwgeyBib3VuZHM6ICdmdWxsJywgYWxpZ246ICdhbGwnIH0pO1xuICAgIH07XG4gICAgQ29uY2F0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG9ubHkgY2hpbGRyZW4gaGF2ZSBtYXJrc1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlRW50cnkgPSBjaGlsZC5hc3NlbWJsZVBhcmVudEdyb3VwUHJvcGVydGllcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oeyB0eXBlOiAnZ3JvdXAnLCBuYW1lOiBjaGlsZC5nZXROYW1lKCdncm91cCcpIH0sIChlbmNvZGVFbnRyeSA/IHtcbiAgICAgICAgICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBlbmNvZGVFbnRyeVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiB7fSksIGNoaWxkLmFzc2VtYmxlR3JvdXAoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhdE1vZGVsO1xufShtb2RlbF8xLk1vZGVsKSk7XG5leHBvcnRzLkNvbmNhdE1vZGVsID0gQ29uY2F0TW9kZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMjl1WTJGMExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdlkyOXVZMkYwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096dEJRVVZCTEdkRFFVRTRSRHRCUVVNNVJDeG5RMEZCZVVNN1FVRkZla01zYlVOQlFXOURPMEZCUTNCRExEUkRRVUUyUXp0QlFVTTNReXh6UTBGQmRVTTdRVUZEZGtNc2FVTkJRVGhDTzBGQlNUbENPMGxCUVdsRExIVkRRVUZMTzBsQlRYQkRMSEZDUVVGWkxFbEJRV2RDTEVWQlFVVXNUVUZCWVN4RlFVRkZMR1ZCUVhWQ0xFVkJRVVVzVVVGQmRVSXNSVUZCUlN4TlFVRmpPMUZCUVRkSExGbEJRMFVzYTBKQlFVMHNTVUZCU1N4RlFVRkZMRTFCUVUwc1JVRkJSU3hsUVVGbExFVkJRVVVzVFVGQlRTeERRVUZETEZOQlR6ZERPMUZCVEVNc1MwRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eHZRa0ZCWVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJSWEpETEV0QlFVa3NRMEZCUXl4UlFVRlJMRWRCUVVjc1EwRkJReXh2UWtGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFZEJRVWNzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzFsQlF5OUZMRTFCUVUwc1EwRkJReXh0UWtGQlZTeERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkpMRVZCUVVVc1MwRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1UwRkJVeXhGUVVGRkxGRkJRVkVzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTXpSaXhEUVVGRExFTkJRVU1zUTBGQlF6czdTVUZEVEN4RFFVRkRPMGxCUlUwc0swSkJRVk1zUjBGQmFFSTdVVUZEUlN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUjBGQlJ5eHBRa0ZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM1JETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUzBGQlN6dFpRVU14UWl4TFFVRkxMRU5CUVVNc1UwRkJVeXhGUVVGRkxFTkJRVU03VVVGRGNFSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVTBzYjBOQlFXTXNSMEZCY2tJN1VVRkJRU3hwUWtGWFF6dFJRVlpETEcxRlFVRnRSVHRSUVVOdVJTeHBSVUZCYVVVN1VVRkRha1VzYlVWQlFXMUZPMUZCUTI1RkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNVMEZCVXl4SFFVRkhMRVZCUVVVc1EwRkJRenRuUTBGRGJrSXNTMEZCU3p0WlFVTmtMRXRCUVVzc1EwRkJReXhqUVVGakxFVkJRVVVzUTBGQlF6dFpRVU4yUWl4WFFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJReXhIUVVGSE8yZENRVU14UXl4TFFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTnFSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZNUkN4SFFVRkhMRU5CUVVNc1EwRkJaMElzVlVGQllTeEZRVUZpTEV0QlFVRXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJZaXhqUVVGaExFVkJRV0lzU1VGQllUdFpRVUUxUWl4SlFVRk5MRXRCUVVzc1UwRkJRVHR2UWtGQlRDeExRVUZMTzFOQlMyWTdTVUZEU0N4RFFVRkRPMGxCUlUwc1owTkJRVlVzUjBGQmFrSTdVVUZEUlN4SlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRmJrSXNTVUZCVFN4alFVRmpMRWRCUVd0Q0xFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVWcVJTeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGVExFdEJRVXM3V1VGRGJFTXNTMEZCU3l4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRM0pDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVWTkxDdENRVUZUTEVkQlFXaENPMUZCUTBVc1IwRkJSeXhEUVVGRExFTkJRV2RDTEZWQlFXRXNSVUZCWWl4TFFVRkJMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRV0lzWTBGQllTeEZRVUZpTEVsQlFXRTdXVUZCTlVJc1NVRkJUU3hMUVVGTExGTkJRVUU3V1VGRFpDeExRVUZMTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1UwRkRia0k3U1VGRFNDeERRVUZETzBsQlJVMHNkME5CUVd0Q0xFZEJRWHBDTzFGQlEwVXNSMEZCUnl4RFFVRkRMRU5CUVdkQ0xGVkJRV0VzUlVGQllpeExRVUZCTEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVdJc1kwRkJZU3hGUVVGaUxFbEJRV0U3V1VGQk5VSXNTVUZCVFN4TFFVRkxMRk5CUVVFN1dVRkRaQ3hMUVVGTExFTkJRVU1zYTBKQlFXdENMRVZCUVVVc1EwRkJRenRUUVVNMVFqdEpRVU5JTEVOQlFVTTdTVUZGVFN4dlEwRkJZeXhIUVVGeVFqdFJRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJSVTBzYVVOQlFWY3NSMEZCYkVJN1VVRkRSU3hKUVVGTkxHVkJRV1VzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRmNFUXNSMEZCUnl4RFFVRkRMRU5CUVdkQ0xGVkJRV0VzUlVGQllpeExRVUZCTEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVdJc1kwRkJZU3hGUVVGaUxFbEJRV0U3V1VGQk5VSXNTVUZCVFN4TFFVRkxMRk5CUVVFN1dVRkRaQ3hMUVVGTExFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTTdVMEZEY2tJN1NVRkRTQ3hEUVVGRE8wbEJSVTBzYTBOQlFWa3NSMEZCYmtJN1VVRkRSeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnhDTEdsRFFVRnBRenRaUVVOcVF5eE5RVUZOTEVOQlFVTXNkVUpCUVZrc1EwRkJReXhYUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU42UkN4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5hTEVOQlFVTTdTVUZGVFN4dFJFRkJOa0lzUjBGQmNFTTdVVUZEUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZOTEhORVFVRm5ReXhIUVVGMlF5eFZRVUYzUXl4UFFVRmpPMUZCUTNCRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGRExFVkJRVVVzUlVGQlJTeExRVUZMTEVsQlFVc3NUMEZCUVN4TFFVRkxMRU5CUVVNc1owTkJRV2RETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVRGRExFTkJRVEJETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRiRWNzUTBGQlF6dEpRVVZOTERoRFFVRjNRaXhIUVVFdlFqdFJRVU5GTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUzBGQlN5eEpRVUZMTEU5QlFVRXNTMEZCU3l4RFFVRkRMSGRDUVVGM1FpeEZRVUZGTEVWQlFXaERMRU5CUVdkRExFTkJRVU1zUTBGQlF6dFJRVU51UlN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZOTERKRFFVRnhRaXhIUVVFMVFqdFJRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxPMWxCUTNwRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXh4UWtGQmNVSXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRka1FzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVOTkxESkRRVUZ4UWl4SFFVRTFRaXhWUVVFMlFpeEpRVUZqTzFGQlEzcERMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRVZCUVVVc1JVRkJSU3hMUVVGTExFbEJRVXNzVDBGQlFTeExRVUZMTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFTOUNMRU5CUVN0Q0xFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEYkVZc1EwRkJRenRKUVVWTkxHOURRVUZqTEVkQlFYSkNPMUZCUTBVc2IwTkJRVzlETzFGQlEzQkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8xbEJRM0JETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eGpRVUZqTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUXpORExFTkJRVU1zUlVGQlJTeHBRa0ZCVFN4alFVRmpMRmRCUVVVc1EwRkJReXhEUVVGRE8wbEJRemRDTEVOQlFVTTdTVUZGVFN4dlEwRkJZeXhIUVVGeVFqdFJRVU5GTERSQ1FVRTBRanRSUVVNMVFpeE5RVUZOTEc5Q1FVTktMRTlCUVU4c1JVRkJSU3hGUVVGRExFZEJRVWNzUlVGQlJTeEZRVUZGTEVWQlFVVXNUVUZCVFN4RlFVRkZMRVZCUVVVc1JVRkJReXhGUVVNNVFpeE5RVUZOTEVWQlFVVXNSVUZCUlN4SlFVTlFMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eEZRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMRVZCUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zU1VGRGRrTXNUVUZCVFN4RlFVRkZMRTFCUVUwc1JVRkRaQ3hMUVVGTExFVkJRVVVzUzBGQlN5eEpRVU5hTzBsQlEwb3NRMEZCUXp0SlFVVk5MRzFEUVVGaExFZEJRWEJDTzFGQlEwVXNNa0pCUVRKQ08xRkJRek5DTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZCTEV0QlFVczdXVUZETlVJc1NVRkJUU3hYUVVGWExFZEJRVWNzUzBGQlN5eERRVUZETERaQ1FVRTJRaXhGUVVGRkxFTkJRVU03V1VGRE1VUXNUVUZCVFN4dlFrRkRTaXhKUVVGSkxFVkJRVVVzVDBGQlR5eEZRVU5pTEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVU42UWl4RFFVRkRMRmRCUVZjc1IwRkJSenRuUWtGRGFFSXNUVUZCVFN4RlFVRkZPMjlDUVVOT0xFMUJRVTBzUlVGQlJTeFhRVUZYTzJsQ1FVTndRanRoUVVOR0xFZEJRVWNzUlVGQlJTeERRVUZETEVWQlEwb3NTMEZCU3l4RFFVRkRMR0ZCUVdFc1JVRkJSU3hGUVVONFFqdFJRVU5LTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVOSUxHdENRVUZETzBGQlFVUXNRMEZCUXl4QlFYWkpSQ3hEUVVGcFF5eGhRVUZMTEVkQmRVbHlRenRCUVhaSldTeHJRMEZCVnlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vLi4vbG9nXCIpO1xudmFyIHR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGRhdGFmbG93XzEgPSByZXF1aXJlKFwiLi9kYXRhZmxvd1wiKTtcbmZ1bmN0aW9uIGFkZERpbWVuc2lvbihkaW1zLCBmaWVsZERlZikge1xuICAgIGlmIChmaWVsZERlZi5iaW4pIHtcbiAgICAgICAgZGltc1tmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ3N0YXJ0JyB9KV0gPSB0cnVlO1xuICAgICAgICBkaW1zW2ZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAnZW5kJyB9KV0gPSB0cnVlO1xuICAgICAgICAvLyBXZSBuZWVkIHRoZSByYW5nZSBvbmx5IHdoZW4gdGhlIHVzZXIgZXhwbGljaXRseSBmb3JjZXMgYSBiaW5uZWQgZmllbGQgdG8gYmUgb3JkaW5hbCAocmFuZ2UgdXNlZCBpbiBheGlzIGFuZCBsZWdlbmQgbGFiZWxzKS5cbiAgICAgICAgLy8gV2UgY291bGQgY2hlY2sgd2hldGhlciB0aGUgYXhpcyBvciBsZWdlbmQgZXhpc3RzIGJ1dCB0aGF0IHNlZW1zIG92ZXJraWxsLiBJbiBheGVzIGFuZCBsZWdlbmRzLCB3ZSBjaGVjayBoYXNEaXNjcmV0ZURvbWFpbihzY2FsZVR5cGUpLlxuICAgICAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLk9SRElOQUwpIHtcbiAgICAgICAgICAgIGRpbXNbZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwgeyBiaW5TdWZmaXg6ICdyYW5nZScgfSldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGltc1tmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmKV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbn1cbmZ1bmN0aW9uIG1lcmdlTWVhc3VyZXMocGFyZW50TWVhc3VyZXMsIGNoaWxkTWVhc3VyZXMpIHtcbiAgICBmb3IgKHZhciBmaWVsZF8xIGluIGNoaWxkTWVhc3VyZXMpIHtcbiAgICAgICAgaWYgKGNoaWxkTWVhc3VyZXMuaGFzT3duUHJvcGVydHkoZmllbGRfMSkpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgbWVyZ2UgYSBtZWFzdXJlLCB3ZSBlaXRoZXIgaGF2ZSB0byBhZGQgYW4gYWdncmVnYXRpb24gb3BlcmF0b3Igb3IgZXZlbiBhIG5ldyBmaWVsZFxuICAgICAgICAgICAgdmFyIG9wcyA9IGNoaWxkTWVhc3VyZXNbZmllbGRfMV07XG4gICAgICAgICAgICBmb3IgKHZhciBvcCBpbiBvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3BzLmhhc093blByb3BlcnR5KG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRfMSBpbiBwYXJlbnRNZWFzdXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG9wZXJhdG9yIHRvIGV4aXN0aW5nIG1lYXN1cmUgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE1lYXN1cmVzW2ZpZWxkXzFdW29wXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZWFzdXJlc1tmaWVsZF8xXSA9IHsgb3A6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBBZ2dyZWdhdGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBZ2dyZWdhdGVOb2RlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkaW1lbnNpb25zIHN0cmluZyBzZXQgZm9yIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gbWVhc3VyZXMgZGljdGlvbmFyeSBtYXBwaW5nIGZpZWxkIG5hbWUgPT4gZGljdCBzZXQgb2YgYWdncmVnYXRpb24gZnVuY3Rpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWdncmVnYXRlTm9kZShkaW1lbnNpb25zLCBtZWFzdXJlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgICAgX3RoaXMubWVhc3VyZXMgPSBtZWFzdXJlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZ2dyZWdhdGVOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVOb2RlKHV0aWxfMS5leHRlbmQoe30sIHRoaXMuZGltZW5zaW9ucyksIHV0aWxfMS5kdXBsaWNhdGUodGhpcy5tZWFzdXJlcykpO1xuICAgIH07XG4gICAgQWdncmVnYXRlTm9kZS5tYWtlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBpc0FnZ3JlZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBtb2RlbC5mb3JFYWNoRmllbGREZWYoZnVuY3Rpb24gKGZkKSB7XG4gICAgICAgICAgICBpZiAoZmQuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgaXNBZ2dyZWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1lYXMgPSB7fTtcbiAgICAgICAgdmFyIGRpbXMgPSB7fTtcbiAgICAgICAgaWYgKCFpc0FnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBjcmVhdGUgdGhpcyBub2RlIGlmIHRoZSBtb2RlbCBoYXMgbm8gYWdncmVnYXRpb25cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLmZvckVhY2hGaWVsZERlZihmdW5jdGlvbiAoZmllbGREZWYsIGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGREZWYuYWdncmVnYXRlID09PSAnY291bnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lYXNbJyonXSA9IG1lYXNbJyonXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tc3RyaW5nLWxpdGVyYWwgKi9cbiAgICAgICAgICAgICAgICAgICAgbWVhc1snKiddWydjb3VudCddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1zdHJpbmctbGl0ZXJhbCAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVhc1tmaWVsZERlZi5maWVsZF0gPSBtZWFzW2ZpZWxkRGVmLmZpZWxkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbWVhc1tmaWVsZERlZi5maWVsZF1bZmllbGREZWYuYWdncmVnYXRlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBtaW4vbWF4IHNvIHdlIGNhbiB1c2UgdGhlaXIgdW5pb24gYXMgdW5hZ2dyZWdhdGVkIGRvbWFpblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlICYmIHNjYWxlLmRvbWFpbiA9PT0gJ3VuYWdncmVnYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXNbZmllbGREZWYuZmllbGRdWydtaW4nXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFzW2ZpZWxkRGVmLmZpZWxkXVsnbWF4J10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkRGltZW5zaW9uKGRpbXMsIGZpZWxkRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoT2JqZWN0LmtleXMoZGltcykubGVuZ3RoICsgT2JqZWN0LmtleXMobWVhcykubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGVOb2RlKGRpbXMsIG1lYXMpO1xuICAgIH07XG4gICAgQWdncmVnYXRlTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKCF1dGlsXzEuZGlmZmVyKHRoaXMuZGltZW5zaW9ucywgb3RoZXIuZGltZW5zaW9ucykpIHtcbiAgICAgICAgICAgIG1lcmdlTWVhc3VyZXModGhpcy5tZWFzdXJlcywgb3RoZXIubWVhc3VyZXMpO1xuICAgICAgICAgICAgb3RoZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoJ2RpZmZlcmVudCBkaW1lbnNpb25zLCBjYW5ub3QgbWVyZ2UnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWdncmVnYXRlTm9kZS5wcm90b3R5cGUuYWRkRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChmaWVsZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIF90aGlzLmRpbWVuc2lvbnNbZl0gPSB0cnVlOyB9KTtcbiAgICB9O1xuICAgIEFnZ3JlZ2F0ZU5vZGUucHJvdG90eXBlLmRlcGVuZGVudEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB1dGlsXzEua2V5cyh0aGlzLmRpbWVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG91dFtmXSA9IHRydWU7IH0pO1xuICAgICAgICB1dGlsXzEua2V5cyh0aGlzLm1lYXN1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBvdXRbbV0gPSB0cnVlOyB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIEFnZ3JlZ2F0ZU5vZGUucHJvdG90eXBlLnByb2R1Y2VkRmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIHV0aWxfMS5rZXlzKHRoaXMubWVhc3VyZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICB1dGlsXzEua2V5cyhfdGhpcy5tZWFzdXJlc1tmaWVsZF0pLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgb3V0W29wICsgXCJfXCIgKyBmaWVsZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQWdncmVnYXRlTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHMgPSBbXTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICB1dGlsXzEua2V5cyh0aGlzLm1lYXN1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdXRpbF8xLmtleXMoX3RoaXMubWVhc3VyZXNbZmllbGRdKS5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgIGdyb3VwYnk6IHV0aWxfMS5rZXlzKHRoaXMuZGltZW5zaW9ucyksXG4gICAgICAgICAgICBvcHM6IG9wcyxcbiAgICAgICAgICAgIGZpZWxkczogZmllbGRzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQWdncmVnYXRlTm9kZTtcbn0oZGF0YWZsb3dfMS5EYXRhRmxvd05vZGUpKTtcbmV4cG9ydHMuQWdncmVnYXRlTm9kZSA9IEFnZ3JlZ2F0ZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZV2RuY21WbllYUmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2WkdGMFlTOWhaMmR5WldkaGRHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlEwRXNNa05CUVN0RE8wRkJReTlETEN0Q1FVRnBRenRCUVVOcVF5eHRRMEZCYlVNN1FVRkRia01zYlVOQlFUUkZPMEZCU1RWRkxIVkRRVUYzUXp0QlFVVjRReXh6UWtGQmMwSXNTVUZCWjBNc1JVRkJSU3hSUVVFd1FqdEpRVU5vUml4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnFRaXhKUVVGSkxFTkJRVU1zWjBKQlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVOdVJDeEpRVUZKTEVOQlFVTXNaMEpCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUlVGQlF5eFRRVUZUTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF6dFJRVVZxUkN3NFNFRkJPRWc3VVVGRE9VZ3NkMGxCUVhkSk8xRkJRM2hKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFdEJRVXNzWTBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTVRaXhKUVVGSkxFTkJRVU1zWjBKQlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVOeVJDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzU1VGQlNTeERRVUZETEdkQ1FVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdTVUZETDBJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEWkN4RFFVRkRPMEZCUlVRc2RVSkJRWFZDTEdOQlFXMURMRVZCUVVVc1lVRkJhME03U1VGRE5VWXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJUU3hQUVVGTExFbEJRVWtzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGhRVUZoTEVOQlFVTXNZMEZCWXl4RFFVRkRMRTlCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU40UXl3MlJrRkJOa1k3V1VGRE4wWXNTVUZCVFN4SFFVRkhMRWRCUVVjc1lVRkJZU3hEUVVGRExFOUJRVXNzUTBGQlF5eERRVUZETzFsQlEycERMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVTBzUlVGQlJTeEpRVUZKTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM0pDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhqUVVGakxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNelFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRkxMRWxCUVVrc1kwRkJZeXhEUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZETlVJc2VVTkJRWGxETzNkQ1FVTjZReXhqUVVGakxFTkJRVU1zVDBGQlN5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8yOUNRVU51UXl4RFFVRkRPMjlDUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzNkQ1FVTk9MR05CUVdNc1EwRkJReXhQUVVGTExFTkJRVU1zUjBGQlJ5eEZRVUZETEVWQlFVVXNSVUZCUlN4SlFVRkpMRVZCUVVNc1EwRkJRenR2UWtGRGNrTXNRMEZCUXp0blFrRkRTQ3hEUVVGRE8xbEJRMGdzUTBGQlF6dFJRVU5JTEVOQlFVTTdTVUZEU0N4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRU8wbEJRVzFETEhsRFFVRlpPMGxCU3pkRE96czdUMEZIUnp0SlFVTklMSFZDUVVGdlFpeFZRVUZ4UWl4RlFVRlZMRkZCUVhsQ08xRkJRVFZGTEZsQlEwVXNhVUpCUVU4c1UwRkRVanRSUVVadFFpeG5Ra0ZCVlN4SFFVRldMRlZCUVZVc1EwRkJWenRSUVVGVkxHTkJRVkVzUjBGQlVpeFJRVUZSTEVOQlFXbENPenRKUVVVMVJTeERRVUZETzBsQlZrMHNOa0pCUVVzc1IwRkJXanRSUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEdGQlFXRXNRMEZCUXl4aFFVRk5MRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNSVUZCUlN4blFrRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTJ4R0xFTkJRVU03U1VGVllTeHJRa0ZCU1N4SFFVRnNRaXhWUVVGdFFpeExRVUZuUWp0UlFVTnFReXhKUVVGSkxGZEJRVmNzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZEZUVJc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eFZRVUZCTEVWQlFVVTdXVUZEZEVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnBDTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNN1dVRkRja0lzUTBGQlF6dFJRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlVnc1NVRkJUU3hKUVVGSkxFZEJRVWNzUlVGQlJTeERRVUZETzFGQlEyaENMRWxCUVUwc1NVRkJTU3hIUVVGSExFVkJRVVVzUTBGQlF6dFJRVVZvUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtJc09FUkJRVGhFTzFsQlF6bEVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRFpDeERRVUZETzFGQlJVUXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhWUVVGRExGRkJRVkVzUlVGQlJTeFBRVUZQTzFsQlEzUkRMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOMlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhMUVVGTExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTI1RExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzI5Q1FVTTFRaXh6UTBGQmMwTTdiMEpCUTNSRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03YjBKQlF6RkNMSEZEUVVGeFF6dG5Ra0ZEZGtNc1EwRkJRenRuUWtGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkRUaXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRPMjlDUVVOc1JDeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNN2IwSkJSV2hFTEN0RVFVRXJSRHR2UWtGREwwUXNTVUZCVFN4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0dlFrRkRia01zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4SlFVRkpMRXRCUVVzc1EwRkJReXhOUVVGTkxFdEJRVXNzWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkROME1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdkMEpCUTI1RExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETzI5Q1FVTnlReXhEUVVGRE8yZENRVU5JTEVOQlFVTTdXVUZEU0N4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WjBKQlEwNHNXVUZCV1N4RFFVRkRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFpRVU12UWl4RFFVRkRPMUZCUTBnc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRlNDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMR0ZCUVdFc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEZGtNc1EwRkJRenRKUVVWTkxEWkNRVUZMTEVkQlFWb3NWVUZCWVN4TFFVRnZRanRSUVVNdlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMR0ZCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEZRVUZGTEV0QlFVc3NRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGREwwTXNZVUZCWVN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMWxCUXpkRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0UlFVTnFRaXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExHOURRVUZ2UXl4RFFVRkRMRU5CUVVNN1VVRkRiRVFzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGVFN4eFEwRkJZU3hIUVVGd1FpeFZRVUZ4UWl4TlFVRm5RanRSUVVGeVF5eHBRa0ZGUXp0UlFVUkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4TFFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCZWtJc1EwRkJlVUlzUTBGQlF5eERRVUZETzBsQlEycEVMRU5CUVVNN1NVRkZUU3gxUTBGQlpTeEhRVUYwUWp0UlFVTkZMRWxCUVUwc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVVZtTEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNRMEZCUXl4SlFVRkpMRTlCUVVFc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCWWl4RFFVRmhMRU5CUVVNc1EwRkJRenRSUVVOc1JDeFhRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEVOQlFVTXNTVUZCU1N4UFFVRkJMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlFXSXNRMEZCWVN4RFFVRkRMRU5CUVVNN1VVRkZhRVFzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXp0SlFVTmlMRU5CUVVNN1NVRkZUU3h6UTBGQll5eEhRVUZ5UWp0UlFVRkJMR2xDUVZWRE8xRkJWRU1zU1VGQlRTeEhRVUZITEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUldZc1YwRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJRU3hMUVVGTE8xbEJReTlDTEZkQlFVa3NRMEZCUXl4TFFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVFc1JVRkJSVHRuUWtGRGJrTXNSMEZCUnl4RFFVRkpMRVZCUVVVc1UwRkJTU3hMUVVGUExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdXVUZETDBJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFRDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03U1VGRFlpeERRVUZETzBsQlJVMHNaME5CUVZFc1IwRkJaanRSUVVGQkxHbENRV2RDUXp0UlFXWkRMRWxCUVUwc1IwRkJSeXhIUVVGaExFVkJRVVVzUTBGQlF6dFJRVU42UWl4SlFVRk5MRTFCUVUwc1IwRkJZU3hGUVVGRkxFTkJRVU03VVVGRE5VSXNWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUVN4TFFVRkxPMWxCUXk5Q0xGZEJRVWtzUTBGQlF5eExRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNSVUZCUlR0blFrRkRia01zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJRenRuUWtGRFlpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRM0pDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTB3c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRlNDeE5RVUZOTEVOQlFVTTdXVUZEVEN4SlFVRkpMRVZCUVVVc1YwRkJWenRaUVVOcVFpeFBRVUZQTEVWQlFVVXNWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU03V1VGRE9VSXNSMEZCUnl4TFFVRkJPMWxCUTBnc1RVRkJUU3hSUVVGQk8xTkJRMUFzUTBGQlF6dEpRVU5LTEVOQlFVTTdTVUZEU0N4dlFrRkJRenRCUVVGRUxFTkJRVU1zUVVFNVIwUXNRMEZCYlVNc2RVSkJRVmtzUjBFNFJ6bERPMEZCT1VkWkxITkRRVUZoSW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZGF0YV8xID0gcmVxdWlyZShcIi4uLy4uL2RhdGFcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgYWdncmVnYXRlXzEgPSByZXF1aXJlKFwiLi9hZ2dyZWdhdGVcIik7XG52YXIgYmluXzEgPSByZXF1aXJlKFwiLi9iaW5cIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIGZhY2V0XzEgPSByZXF1aXJlKFwiLi9mYWNldFwiKTtcbnZhciBmb3JtYXRwYXJzZV8xID0gcmVxdWlyZShcIi4vZm9ybWF0cGFyc2VcIik7XG52YXIgbm9ucG9zaXRpdmVmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL25vbnBvc2l0aXZlZmlsdGVyXCIpO1xudmFyIG51bGxmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL251bGxmaWx0ZXJcIik7XG52YXIgb3B0aW1pemVyc18xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyc1wiKTtcbnZhciBvcHRpbWl6ZXJzID0gcmVxdWlyZShcIi4vb3B0aW1pemVyc1wiKTtcbnZhciBwYXRob3JkZXJfMSA9IHJlcXVpcmUoXCIuL3BhdGhvcmRlclwiKTtcbnZhciBzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZVwiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4vc3RhY2tcIik7XG52YXIgdGltZXVuaXRfMSA9IHJlcXVpcmUoXCIuL3RpbWV1bml0XCIpO1xudmFyIHRyYW5zZm9ybXNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybXNcIik7XG5leHBvcnRzLkZBQ0VUX1NDQUxFX1BSRUZJWCA9ICdzY2FsZV8nO1xuLyoqXG4gKiBTdGFydCBvcHRpbWl6YXRpb24gcGF0aCBmcm9tIHRoZSByb290LiBVc2VmdWwgZm9yIHJlbW92aW5nIG5vZGVzLlxuICovXG5mdW5jdGlvbiByZW1vdmVVbm5lY2Vzc2FyeU5vZGVzKG5vZGUpIHtcbiAgICAvLyByZW1vdmUgZW1wdHkgbm9uIHBvc2l0aXZlIGZpbHRlclxuICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9ucG9zaXRpdmVmaWx0ZXJfMS5Ob25Qb3NpdGl2ZUZpbHRlck5vZGUgJiYgdXRpbF8xLmV2ZXJ5KHV0aWxfMS52YWxzKG5vZGUuZmlsdGVyKSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIgPT09IGZhbHNlOyB9KSkge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgZW1wdHkgbnVsbCBmaWx0ZXIgbm9kZXNcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG51bGxmaWx0ZXJfMS5OdWxsRmlsdGVyTm9kZSAmJiB1dGlsXzEuZXZlcnkodXRpbF8xLnZhbHMobm9kZS5maWx0ZXJlZEZpZWxkcyksIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmID09PSBudWxsOyB9KSkge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgb3V0cHV0IG5vZGVzIHRoYXQgYXJlIG5vdCByZXF1aXJlZFxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgZGF0YWZsb3dfMS5PdXRwdXROb2RlICYmICFub2RlLnJlcXVpcmVkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChyZW1vdmVVbm5lY2Vzc2FyeU5vZGVzKTtcbn1cbi8qKlxuICogQ2xvbmVzIHRoZSBzdWJ0cmVlIGFuZCBpZ25vcmVzIG91dHB1dCBub2RlcyBleGNlcHQgZm9yIHRoZSBsZWFmcywgd2hpY2ggYXJlIHJlbmFtZWQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3VidHJlZShmYWNldCkge1xuICAgIGZ1bmN0aW9uIGNsb25lKG5vZGUpIHtcbiAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIHBhdGhvcmRlcl8xLk9yZGVyTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5XzEgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAgICBpZiAoY29weV8xIGluc3RhbmNlb2YgZGF0YWZsb3dfMS5PdXRwdXROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05hbWUgPSBleHBvcnRzLkZBQ0VUX1NDQUxFX1BSRUZJWCArIGZhY2V0Lm1vZGVsLmdldE5hbWUoY29weV8xLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29weV8xLnNvdXJjZSA9IG5ld05hbWU7XG4gICAgICAgICAgICAgICAgZmFjZXQubW9kZWwuY29tcG9uZW50LmRhdGEub3V0cHV0Tm9kZXNbbmV3TmFtZV0gPSBjb3B5XzE7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmZsYXR0ZW4obm9kZS5jaGlsZHJlbi5tYXAoY2xvbmUpKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnBhcmVudCA9IGNvcHlfMTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3B5XzEgaW5zdGFuY2VvZiBhZ2dyZWdhdGVfMS5BZ2dyZWdhdGVOb2RlIHx8IGNvcHlfMSBpbnN0YW5jZW9mIHN0YWNrXzEuU3RhY2tOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29weV8xLmFkZERpbWVuc2lvbnMoZmFjZXQuZmllbGRzKTtcbiAgICAgICAgICAgICAgICB1dGlsXzEuZmxhdHRlbihub2RlLmNoaWxkcmVuLm1hcChjbG9uZSkpLmZvckVhY2goZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ucGFyZW50ID0gY29weV8xOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5mbGF0dGVuKG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lKSkuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gbi5wYXJlbnQgPSBjb3B5XzE7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtjb3B5XzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsXzEuZmxhdHRlbihub2RlLmNoaWxkcmVuLm1hcChjbG9uZSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIE1vdmUgZmFjZXQgbm9kZXMgZG93biB0byB0aGUgbmV4dCBmb3JrIG9yIG91dHB1dCBub2RlLiBBbHNvIHB1bGwgdGhlIG1haW4gb3V0cHV0IHdpdGggdGhlIGZhY2V0IG5vZGUuXG4gKiBBZnRlciBtb3ZpbmcgZG93biB0aGUgZmFjZXQgbm9kZSwgbWFrZSBhIGNvcHkgb2YgdGhlIHN1YnRyZWUgYW5kIG1ha2UgaXQgYSBjaGlsZCBvZiB0aGUgbWFpbiBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIG1vdmVGYWNldERvd24obm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgZmFjZXRfMS5GYWNldE5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubnVtQ2hpbGRyZW4oKSA9PT0gMSAmJiAhKG5vZGUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBkYXRhZmxvd18xLk91dHB1dE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBtb3ZlIGRvd24gdW50aWwgd2UgaGl0IGEgZm9yayBvciBvdXRwdXQgbm9kZVxuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIGFnZ3JlZ2F0ZV8xLkFnZ3JlZ2F0ZU5vZGUgfHwgY2hpbGQgaW5zdGFuY2VvZiBzdGFja18xLlN0YWNrTm9kZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmFkZERpbWVuc2lvbnMobm9kZS5maWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQuc3dhcFdpdGhQYXJlbnQoKTtcbiAgICAgICAgICAgIG1vdmVGYWNldERvd24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBtb3ZlIG1haW4gdG8gZmFjZXRcbiAgICAgICAgICAgIG1vdmVNYWluRG93blRvRmFjZXQobm9kZS5tb2RlbC5jb21wb25lbnQuZGF0YS5tYWluKTtcbiAgICAgICAgICAgIC8vIHJlcGxpY2F0ZSB0aGUgc3VidHJlZSBhbmQgcGxhY2UgaXQgYmVmb3JlIHRoZSBmYWNldCdzIG1haW4gbm9kZVxuICAgICAgICAgICAgdmFyIGNvcHkgPSB1dGlsXzEuZmxhdHRlbihub2RlLmNoaWxkcmVuLm1hcChjbG9uZVN1YnRyZWUobm9kZSkpKTtcbiAgICAgICAgICAgIGNvcHkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5wYXJlbnQgPSBub2RlLm1vZGVsLmNvbXBvbmVudC5kYXRhLm1haW47IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2gobW92ZUZhY2V0RG93bik7XG4gICAgfVxufVxuZnVuY3Rpb24gbW92ZU1haW5Eb3duVG9GYWNldChub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkYXRhZmxvd18xLk91dHB1dE5vZGUgJiYgbm9kZS50eXBlID09PSBkYXRhXzEuTUFJTikge1xuICAgICAgICBpZiAobm9kZS5udW1DaGlsZHJlbigpID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBmYWNldF8xLkZhY2V0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5zd2FwV2l0aFBhcmVudCgpO1xuICAgICAgICAgICAgICAgIG1vdmVNYWluRG93blRvRmFjZXQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybiBhbGwgbGVhZiBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhdmVzKHJvb3RzKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFwcGVuZChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm51bUNoaWxkcmVuKCkgPT09IDApIHtcbiAgICAgICAgICAgIGxlYXZlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGFwcGVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcm9vdHMuZm9yRWFjaChhcHBlbmQpO1xuICAgIHJldHVybiBsZWF2ZXM7XG59XG4vKipcbiAqIFByaW50IGRlYnVnIGluZm9ybWF0aW9uIGZvciBkYXRhZmxvdyB0cmVlLlxuICovXG5mdW5jdGlvbiBkZWJ1Zyhub2RlKSB7XG4gICAgY29uc29sZS5sb2coXCJcIiArIG5vZGUuY29uc3RydWN0b3IubmFtZSArIChub2RlLmRlYnVnTmFtZSA/IFwiIChcIiArIG5vZGUuZGVidWdOYW1lICsgXCIpXCIgOiAnJykgKyBcIiAtPiBcIiArIChub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJcIiArIGMuY29uc3RydWN0b3IubmFtZSArIChjLmRlYnVnTmFtZSA/IFwiIChcIiArIGMuZGVidWdOYW1lICsgXCIpXCIgOiAnJyk7XG4gICAgfSkpKTtcbiAgICBjb25zb2xlLmxvZyhub2RlKTtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZGVidWcpO1xufVxuZnVuY3Rpb24gbWFrZVdhbGtUcmVlKGRhdGEpIHtcbiAgICAvLyB0byBuYW1lIGRhdGFzb3VyY2VzXG4gICAgdmFyIGRhdGFzZXRJbmRleCA9IDA7XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2FsayBkb3duIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdhbGtUcmVlKG5vZGUsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBmb3JtYXRwYXJzZV8xLlBhcnNlTm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50IGluc3RhbmNlb2Ygc291cmNlXzEuU291cmNlTm9kZSAmJiAhZGF0YVNvdXJjZS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub2RlJ3MgcGFyZW50IGlzIGEgcm9vdCBzb3VyY2UgYW5kIHRoZSBkYXRhIHNvdXJjZSBkb2VzIG5vdCByZWZlciB0byBhbm90aGVyIGRhdGEgc291cmNlLCB1c2Ugbm9ybWFsIGZvcm1hdCBwYXJzZVxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZm9ybWF0ID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZGF0YVNvdXJjZS5mb3JtYXQgfHwge30sIHsgcGFyc2U6IG5vZGUuYXNzZW1ibGVGb3JtYXRQYXJzZSgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBWZWdhIGV4cHJlc3Npb24gdG8gcGFyc2VcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLnRyYW5zZm9ybSA9IGRhdGFTb3VyY2UudHJhbnNmb3JtLmNvbmNhdChub2RlLmFzc2VtYmxlVHJhbnNmb3JtcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGZhY2V0XzEuRmFjZXROb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGFTb3VyY2UubmFtZSkge1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UubmFtZSA9IFwiZGF0YV9cIiArIGRhdGFzZXRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhU291cmNlLnNvdXJjZSB8fCBkYXRhU291cmNlLnRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTb3VyY2UubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTb3VyY2Uuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5hc3NlbWJsZSgpLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRhdGEucHVzaChkKTsgfSk7XG4gICAgICAgICAgICAvLyBicmVhayBoZXJlIGJlY2F1c2UgdGhlIHJlc3Qgb2YgdGhlIHRyZWUgaGFzIHRvIGJlIHRha2VuIGNhcmUgb2YgYnkgdGhlIGZhY2V0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgdHJhbnNmb3Jtc18xLkZpbHRlck5vZGUgfHxcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBudWxsZmlsdGVyXzEuTnVsbEZpbHRlck5vZGUgfHxcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiB0cmFuc2Zvcm1zXzEuQ2FsY3VsYXRlTm9kZSB8fFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIGFnZ3JlZ2F0ZV8xLkFnZ3JlZ2F0ZU5vZGUgfHxcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBwYXRob3JkZXJfMS5PcmRlck5vZGUpIHtcbiAgICAgICAgICAgIGRhdGFTb3VyY2UudHJhbnNmb3JtLnB1c2gobm9kZS5hc3NlbWJsZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vbnBvc2l0aXZlZmlsdGVyXzEuTm9uUG9zaXRpdmVGaWx0ZXJOb2RlIHx8XG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgYmluXzEuQmluTm9kZSB8fFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIHRpbWV1bml0XzEuVGltZVVuaXROb2RlIHx8XG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2Ygc3RhY2tfMS5TdGFja05vZGUpIHtcbiAgICAgICAgICAgIGRhdGFTb3VyY2UudHJhbnNmb3JtID0gZGF0YVNvdXJjZS50cmFuc2Zvcm0uY29uY2F0KG5vZGUuYXNzZW1ibGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkYXRhZmxvd18xLk91dHB1dE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRhU291cmNlLnNvdXJjZSAmJiBkYXRhU291cmNlLnRyYW5zZm9ybS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBub2RlLnNvdXJjZSA9IGRhdGFTb3VyY2Uuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnQgaW5zdGFuY2VvZiBkYXRhZmxvd18xLk91dHB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgYW4gb3V0cHV0IG5vZGUgbWF5IGJlIHJlcXVpcmVkIGJ1dCB3ZSBzdGlsbCBkbyBub3QgYXNzZW1ibGUgYVxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlIGRhdGEgc291cmNlIGZvciBpdC5cbiAgICAgICAgICAgICAgICBub2RlLnNvdXJjZSA9IGRhdGFTb3VyY2UubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YVNvdXJjZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UubmFtZSA9IFwiZGF0YV9cIiArIGRhdGFzZXRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIHNldCB0aGUgbmFtZSBvZiB0aGUgZGF0YXNvdXJjZSB3ZSBnZW5lcmF0ZWQuIEZyb20gbm93IG9uXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgYXNzZW1ibGVycyBjYW4gdXNlIGl0LlxuICAgICAgICAgICAgICAgIG5vZGUuc291cmNlID0gZGF0YVNvdXJjZS5uYW1lO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm9kZSBoYXMgbW9yZSB0aGFuIG9uZSBjaGlsZCwgd2Ugd2lsbCBhZGQgYSBkYXRhc291cmNlIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5udW1DaGlsZHJlbigpID09PSAxICYmIGRhdGFTb3VyY2UudHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGRhdGFTb3VyY2UubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IG5ld0RhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobm9kZS5udW1DaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gZG9uZVxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZGF0YWZsb3dfMS5PdXRwdXROb2RlICYmICghZGF0YVNvdXJjZS5zb3VyY2UgfHwgZGF0YVNvdXJjZS50cmFuc2Zvcm0ubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHB1c2ggZW1wdHkgZGF0YXNvdXJjZXMgdGhhdCBhcmUgc2ltcGx5IHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB3YWxrVHJlZShub2RlLmNoaWxkcmVuWzBdLCBkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZV8yID0gZGF0YVNvdXJjZS5uYW1lO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YVNvdXJjZS5zb3VyY2UgfHwgZGF0YVNvdXJjZS50cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VfMiA9IGRhdGFTb3VyY2Uuc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXzIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHdhbGtUcmVlKGNoaWxkLCBuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2Fsa1RyZWU7XG59XG4vKipcbiAqIEFzc2VtYmxlIGRhdGEgc291cmNlcyB0aGF0IGFyZSBkZXJpdmVkIGZyb20gZmFjZXRlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBhc3NlbWJsZUZhY2V0RGF0YShyb290KSB7XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgd2Fsa1RyZWUgPSBtYWtlV2Fsa1RyZWUoZGF0YSk7XG4gICAgcm9vdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gd2Fsa1RyZWUoY2hpbGQsIHtcbiAgICAgICAgc291cmNlOiByb290Lm5hbWUsXG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIHRyYW5zZm9ybTogW11cbiAgICB9KTsgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmFzc2VtYmxlRmFjZXREYXRhID0gYXNzZW1ibGVGYWNldERhdGE7XG4vKipcbiAqIENyZWF0ZSBWZWdhIERhdGEgYXJyYXkgZnJvbSBhIGdpdmVuIGNvbXBpbGVkIG1vZGVsIGFuZCBhcHBlbmQgYWxsIG9mIHRoZW0gdG8gdGhlIGdpdmVuIGFycmF5XG4gKlxuICogQHBhcmFtICBtb2RlbFxuICogQHBhcmFtICBkYXRhIGFycmF5XG4gKiBAcmV0dXJuIG1vZGlmaWVkIGRhdGEgYXJyYXlcbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVEYXRhKHJvb3RzKSB7XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICByb290cy5mb3JFYWNoKHJlbW92ZVVubmVjZXNzYXJ5Tm9kZXMpO1xuICAgIC8vIHJlbW92ZSBzb3VyY2Ugbm9kZXMgdGhhdCBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgYWxzbyBkb24ndCBoYXZlIG91dHB1dCBub2Rlc1xuICAgIHJvb3RzID0gcm9vdHMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLm51bUNoaWxkcmVuKCkgPiAwOyB9KTtcbiAgICBnZXRMZWF2ZXMocm9vdHMpLmZvckVhY2gob3B0aW1pemVyc18xLml0ZXJhdGVGcm9tTGVhdmVzKG9wdGltaXplcnMucmVtb3ZlVW51c2VkU3VidHJlZXMpKTtcbiAgICByb290cyA9IHJvb3RzLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci5udW1DaGlsZHJlbigpID4gMDsgfSk7XG4gICAgZ2V0TGVhdmVzKHJvb3RzKS5mb3JFYWNoKG9wdGltaXplcnNfMS5pdGVyYXRlRnJvbUxlYXZlcyhvcHRpbWl6ZXJzLm1vdmVQYXJzZVVwKSk7XG4gICAgcm9vdHMuZm9yRWFjaChtb3ZlRmFjZXREb3duKTtcbiAgICAvLyByb290cy5mb3JFYWNoKGRlYnVnKTtcbiAgICB2YXIgd2Fsa1RyZWUgPSBtYWtlV2Fsa1RyZWUoZGF0YSk7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICByb290cy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIC8vIGFzc2lnbiBhIG5hbWUgaWYgdGhlIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgbmFtZSB5ZXRcbiAgICAgICAgaWYgKCFyb290Lmhhc05hbWUoKSkge1xuICAgICAgICAgICAgcm9vdC5kYXRhTmFtZSA9IFwic291cmNlX1wiICsgc291cmNlSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3RGF0YSA9IHJvb3QuYXNzZW1ibGUoKTtcbiAgICAgICAgd2Fsa1RyZWUocm9vdCwgbmV3RGF0YSk7XG4gICAgfSk7XG4gICAgLy8gcmVtb3ZlIGVtcHR5IHRyYW5zZm9ybSBhcnJheXMgZm9yIGNsZWFuZXIgb3V0cHV0XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlmIChkLnRyYW5zZm9ybS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkLnRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy5hc3NlbWJsZURhdGEgPSBhc3NlbWJsZURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZWE56WlcxaWJHVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlrWVhSaEwyRnpjMlZ0WW14bExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVGQkxHMURRVUZuUXp0QlFVVm9ReXh0UTBGQlowUTdRVUZIYUVRc2VVTkJRVEJETzBGQlF6RkRMRFpDUVVFNFFqdEJRVU01UWl4MVEwRkJiMFE3UVVGRGNFUXNhVU5CUVd0RE8wRkJRMnhETERaRFFVRjNRenRCUVVONFF5eDVSRUZCTUVRN1FVRkRNVVFzTWtOQlFUUkRPMEZCUXpWRExESkRRVUVyUXp0QlFVTXZReXg1UTBGQk1rTTdRVUZETTBNc2VVTkJRWE5ETzBGQlEzUkRMRzFEUVVGdlF6dEJRVU53UXl4cFEwRkJhME03UVVGRGJFTXNkVU5CUVhkRE8wRkJRM2hETERKRFFVRjFSRHRCUVVjeFF5eFJRVUZCTEd0Q1FVRnJRaXhIUVVGSExGRkJRVkVzUTBGQlF6dEJRVVV6UXpzN1IwRkZSenRCUVVOSUxHZERRVUZuUXl4SlFVRnJRanRKUVVOb1JDeHRRMEZCYlVNN1NVRkRia01zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4WlFVRlpMSGxEUVVGeFFpeEpRVUZKTEZsQlFVc3NRMEZCUXl4WFFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eEZRVUZGTEZWQlFVRXNRMEZCUXl4SlFVRkpMRTlCUVVFc1EwRkJReXhMUVVGTExFdEJRVXNzUlVGQldDeERRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRlRVlzU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRPMGxCUTJoQ0xFTkJRVU03U1VGRlJDeHBRMEZCYVVNN1NVRkRha01zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4WlFVRlpMREpDUVVGakxFbEJRVWtzV1VGQlN5eERRVUZETEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFVkJRVVVzVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4RFFVRkRMRXRCUVVzc1NVRkJTU3hGUVVGV0xFTkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjRSaXhKUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdTVUZEYUVJc1EwRkJRenRKUVVWRUxEUkRRVUUwUXp0SlFVTTFReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEZsQlFWa3NjVUpCUVZVc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwRUxFbEJRVWtzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0SlFVTm9RaXhEUVVGRE8wbEJSVVFzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNRMEZCUXp0QlFVTm9SQ3hEUVVGRE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N4elFrRkJjMElzUzBGQlowSTdTVUZEY0VNc1pVRkJaU3hKUVVGclFqdFJRVU12UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeFpRVUZaTEhGQ1FVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrTXNTVUZCVFN4TlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzFsQlJURkNMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVWtzV1VGQldTeHhRa0ZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGREwwSXNTVUZCVFN4UFFVRlBMRWRCUVVjc01FSkJRV3RDTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVOMFJTeE5RVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTlCUVU4c1EwRkJRenRuUWtGRmRFSXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhOUVVGSkxFTkJRVU03WjBKQlJYWkVMR05CUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZETEVOQlFXVXNTVUZCU3l4UFFVRkJMRU5CUVVNc1EwRkJReXhOUVVGTkxFZEJRVWNzVFVGQlNTeEZRVUZtTEVOQlFXVXNRMEZCUXl4RFFVRkRPMWxCUTJ4R0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJTU3haUVVGWkxIbENRVUZoTEVsQlFVa3NUVUZCU1N4WlFVRlpMR2xDUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjBSU3hOUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRuUWtGRmFrTXNZMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUTBGQlpTeEpRVUZMTEU5QlFVRXNRMEZCUXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGSkxFVkJRV1lzUTBGQlpTeERRVUZETEVOQlFVTTdXVUZEYkVZc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MR05CUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZETEVOQlFXVXNTVUZCU3l4UFFVRkJMRU5CUVVNc1EwRkJReXhOUVVGTkxFZEJRVWNzVFVGQlNTeEZRVUZtTEVOQlFXVXNRMEZCUXl4RFFVRkRPMWxCUTJ4R0xFTkJRVU03V1VGRlJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4TlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOb1FpeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMR05CUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRek5ETEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRVVZFT3pzN1IwRkhSenRCUVVOSUxIVkNRVUYxUWl4SlFVRnJRanRKUVVOMlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRmxCUVZrc2FVSkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VJc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3h4UWtGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpGRkxDdERRVUVyUXp0WlFVVXZReXhKUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJSUzlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1dVRkJXU3g1UWtGQllTeEpRVUZKTEV0QlFVc3NXVUZCV1N4cFFrRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYWtVc1MwRkJTeXhEUVVGRExHRkJRV0VzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF6dFpRVVZFTEV0QlFVc3NRMEZCUXl4alFVRmpMRVZCUVVVc1EwRkJRenRaUVVOMlFpeGhRVUZoTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRkRUlzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTA0c2NVSkJRWEZDTzFsQlEzSkNMRzFDUVVGdFFpeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVVndSQ3hyUlVGQmEwVTdXVUZEYkVVc1NVRkJUU3hKUVVGSkxFZEJRVzFDTEdOQlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZGTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRVZCUVhwRExFTkJRWGxETEVOQlFVTXNRMEZCUXp0UlFVTXZSQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTA0c1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1NVRkRka01zUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZGUkN3MlFrRkJOa0lzU1VGQmEwSTdTVUZETjBNc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeFpRVUZaTEhGQ1FVRlZMRWxCUVVrc1NVRkJTU3hEUVVGRExFbEJRVWtzUzBGQlN5eFhRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6ZENMRWxCUVUwc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkZMMElzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1dVRkJXU3hwUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOc1F5eExRVUZMTEVOQlFVTXNZMEZCWXl4RlFVRkZMRU5CUVVNN1owSkJRM1pDTEcxQ1FVRnRRaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlF6VkNMRU5CUVVNN1VVRkRTQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZIUkRzN1IwRkZSenRCUVVOSUxHMUNRVUZ0UWl4TFFVRnhRanRKUVVOMFF5eEpRVUZOTEUxQlFVMHNSMEZCYlVJc1JVRkJSU3hEUVVGRE8wbEJRMnhETEdkQ1FVRm5RaXhKUVVGclFqdFJRVU5vUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNM1FpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM0JDTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRMmhETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUlVRc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTjBRaXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzBGQlEyaENMRU5CUVVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEdWQlFXVXNTVUZCYTBJN1NVRkRMMElzVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkpMRWxCUVVrc1EwRkJReXhYUVVGdFFpeERRVUZETEVsQlFVa3NTVUZCUnl4SlFVRkpMRU5CUVVNc1UwRkJVeXhIUVVGSExFOUJRVXNzU1VGQlNTeERRVUZETEZOQlFWTXNUVUZCUnl4SFFVRkhMRVZCUVVVc1lVRkRNVVlzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGQkxFTkJRVU03VVVGRGJFSXNUVUZCVFN4RFFVRkRMRXRCUVVrc1EwRkJReXhEUVVGRExGZEJRVzFDTEVOQlFVTXNTVUZCU1N4SlFVRkhMRU5CUVVNc1EwRkJReXhUUVVGVExFZEJRVWNzVDBGQlN5eERRVUZETEVOQlFVTXNVMEZCVXl4TlFVRkhMRWRCUVVjc1JVRkJSU3hEUVVGRkxFTkJRVU03U1VGRGJrWXNRMEZCUXl4RFFVRkRMRU5CUTBZc1EwRkJReXhEUVVGRE8wbEJRMG9zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVOc1FpeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEJRVU12UWl4RFFVRkRPMEZCUlVRc2MwSkJRWE5DTEVsQlFXTTdTVUZEYkVNc2MwSkJRWE5DTzBsQlEzUkNMRWxCUVVrc1dVRkJXU3hIUVVGSExFTkJRVU1zUTBGQlF6dEpRVVZ5UWpzN1QwRkZSenRKUVVOSUxHdENRVUZyUWl4SlFVRnJRaXhGUVVGRkxGVkJRV3RDTzFGQlEzUkVMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzV1VGQldTeDFRa0ZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNNVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3haUVVGWkxHMUNRVUZWTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVVVzUTBGQlF6dG5Ra0ZETjBRc2RVaEJRWFZJTzJkQ1FVTjJTQ3hWUVVGVkxFTkJRVU1zVFVGQlRTeDNRa0ZEV2l4VlFVRlZMRU5CUVVNc1RVRkJUU3hKUVVGSkxFVkJRVVVzU1VGRE1VSXNTMEZCU3l4RlFVRkZMRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNSVUZCUlN4SFFVTnNReXhEUVVGRE8xbEJRMG9zUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xIbERRVUY1UXp0blFrRkRla01zVlVGQlZTeERRVUZETEZOQlFWTXNSMEZCUnl4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEyaEdMRU5CUVVNN1VVRkRTQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4WlFVRlpMR2xDUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bENMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM0pDTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1ZVRkJVU3haUVVGWkxFVkJRVWtzUTBGQlF6dFpRVU0zUXl4RFFVRkRPMWxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4SlFVRkpMRlZCUVZVc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRekZFTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03WjBKQlEzUkNMRWxCUVVrc1EwRkJReXhKUVVGSkxFZEJRVWNzVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTTVRaXhEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTA0c1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUTJoRExFTkJRVU03V1VGRlJDeEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVUVzUTBGQlF5eEpRVUZKTEU5QlFVRXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQldpeERRVUZaTEVOQlFVTXNRMEZCUXp0WlFVVXpReXhuUmtGQlowWTdXVUZEYUVZc1RVRkJUU3hEUVVGRE8xRkJRMVFzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1dVRkJXU3gxUWtGQlZUdFpRVU0xUWl4SlFVRkpMRmxCUVZrc01rSkJRV003V1VGRE9VSXNTVUZCU1N4WlFVRlpMREJDUVVGaE8xbEJRemRDTEVsQlFVa3NXVUZCV1N4NVFrRkJZVHRaUVVNM1FpeEpRVUZKTEZsQlFWa3NjVUpCUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE5VSXNWVUZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkROME1zUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1dVRkJXU3g1UTBGQmNVSTdXVUZEZGtNc1NVRkJTU3haUVVGWkxHRkJRVTg3V1VGRGRrSXNTVUZCU1N4WlFVRlpMSFZDUVVGWk8xbEJRelZDTEVsQlFVa3NXVUZCV1N4cFFrRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0xUWl4VlFVRlZMRU5CUVVNc1UwRkJVeXhIUVVGSExGVkJRVlVzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEzUkZMRU5CUVVNN1VVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEZsQlFWa3NjVUpCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGREwwSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzU1VGQlNTeFZRVUZWTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTXpSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNN1dVRkRiRU1zUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeFpRVUZaTEhGQ1FVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU0zUXl3d1JVRkJNRVU3WjBKQlF6RkZMQ3RDUVVFclFqdG5Ra0ZETDBJc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRPMWxCUTJoRExFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRUaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU55UWl4VlFVRlZMRU5CUVVNc1NVRkJTU3hIUVVGSExGVkJRVkVzV1VGQldTeEZRVUZKTEVOQlFVTTdaMEpCUXpkRExFTkJRVU03WjBKQlJVUXNiVVZCUVcxRk8yZENRVU51UlN3clFrRkJLMEk3WjBKQlF5OUNMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXp0blFrRkZPVUlzSzBWQlFTdEZPMmRDUVVNdlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEpRVUZKTEZWQlFWVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTJoRkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN2IwSkJRM1JDTEVsQlFVMHNUMEZCVHl4SFFVRlhPM2RDUVVOMFFpeEpRVUZKTEVWQlFVVXNTVUZCU1R0M1FrRkRWaXhOUVVGTkxFVkJRVVVzVlVGQlZTeERRVUZETEVsQlFVazdkMEpCUTNaQ0xGTkJRVk1zUlVGQlJTeEZRVUZGTzNGQ1FVTmtMRU5CUVVNN2IwSkJRMFlzVlVGQlZTeEhRVUZITEU5QlFVOHNRMEZCUXp0blFrRkRka0lzUTBGQlF6dFpRVU5JTEVOQlFVTTdVVUZEU0N4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNelFpeExRVUZMTEVOQlFVTTdaMEpCUTBvc1QwRkJUenRuUWtGRFVDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRmxCUVZrc2NVSkJRVlVzU1VGQlNTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1NVRkJTU3hWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlF6RkdMREpFUVVFeVJEdHZRa0ZETTBRc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0blFrRkRlRUlzUTBGQlF6dG5Ra0ZEUkN4TFFVRkxMRU5CUVVNN1dVRkRVaXhMUVVGTExFTkJRVU03WjBKQlEwb3NVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1owSkJRM1pETEV0QlFVc3NRMEZCUXp0WlFVTlNPMmRDUVVORkxFbEJRVWtzVVVGQlRTeEhRVUZITEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNN1owSkJRemRDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzU1VGQlNTeFZRVUZWTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTXhSQ3hKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRPMmRDUVVONFFpeERRVUZETzJkQ1FVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yOUNRVU5PTEZGQlFVMHNSMEZCUnl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRE8yZENRVU0zUWl4RFFVRkRPMmRDUVVWRUxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVFc1MwRkJTenR2UWtGRGVrSXNTVUZCVFN4UFFVRlBMRWRCUVZjN2QwSkJRM1JDTEVsQlFVa3NSVUZCUlN4SlFVRkpPM2RDUVVOV0xFMUJRVTBzUlVGQlJTeFJRVUZOTzNkQ1FVTmtMRk5CUVZNc1JVRkJSU3hGUVVGRk8zRkNRVU5rTEVOQlFVTTdiMEpCUTBZc1VVRkJVU3hEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0blFrRkRNMElzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTBnc1MwRkJTeXhEUVVGRE8xRkJRMVlzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRE8wRkJRMnhDTEVOQlFVTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxESkNRVUZyUXl4SlFVRmxPMGxCUXk5RExFbEJRVTBzU1VGQlNTeEhRVUZoTEVWQlFVVXNRMEZCUXp0SlFVTXhRaXhKUVVGTkxGRkJRVkVzUjBGQlJ5eFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkZjRU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJRU3hMUVVGTExFbEJRVWtzVDBGQlFTeFJRVUZSTEVOQlFVTXNTMEZCU3l4RlFVRkZPMUZCUXpkRExFMUJRVTBzUlVGQlJTeEpRVUZKTEVOQlFVTXNTVUZCU1R0UlFVTnFRaXhKUVVGSkxFVkJRVVVzU1VGQlNUdFJRVU5XTEZOQlFWTXNSVUZCUlN4RlFVRkZPMHRCUTJRc1EwRkJReXhGUVVvMlFpeERRVWszUWl4RFFVRkRMRU5CUVVNN1NVRkZTaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlEyUXNRMEZCUXp0QlFWaEVMRGhEUVZkRE8wRkJSVVE3T3pzN096dEhRVTFITzBGQlEwZ3NjMEpCUVRaQ0xFdEJRVzFDTzBsQlF6bERMRWxCUVUwc1NVRkJTU3hIUVVGaExFVkJRVVVzUTBGQlF6dEpRVVV4UWl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExITkNRVUZ6UWl4RFFVRkRMRU5CUVVNN1NVRkZkRU1zTmtaQlFUWkdPMGxCUXpkR0xFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVFc1EwRkJReXhKUVVGSkxFOUJRVUVzUTBGQlF5eERRVUZETEZkQlFWY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1JVRkJia0lzUTBGQmJVSXNRMEZCUXl4RFFVRkRPMGxCUXk5RExGTkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc09FSkJRV2xDTEVOQlFVTXNWVUZCVlN4RFFVRkRMRzlDUVVGdlFpeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTNSU3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkJMRU5CUVVNc1NVRkJTU3hQUVVGQkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNSMEZCUnl4RFFVRkRMRVZCUVc1Q0xFTkJRVzFDTEVOQlFVTXNRMEZCUXp0SlFVVXZReXhUUVVGVExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRGhDUVVGcFFpeERRVUZETEZWQlFWVXNRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJSWEJGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03U1VGRk4wSXNkMEpCUVhkQ08wbEJSWGhDTEVsQlFVMHNVVUZCVVN4SFFVRkhMRmxCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVVZ3UXl4SlFVRkpMRmRCUVZjc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRmNFSXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGQkxFbEJRVWs3VVVGRGFFSXNkVVJCUVhWRU8xRkJRM1pFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndRaXhKUVVGSkxFTkJRVU1zVVVGQlVTeEhRVUZITEZsQlFWVXNWMEZCVnl4RlFVRkpMRU5CUVVNN1VVRkROVU1zUTBGQlF6dFJRVVZFTEVsQlFVMHNUMEZCVHl4SFFVRlhMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFJRVVY0UXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlF6RkNMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJSVWdzYlVSQlFXMUVPMGxCUTI1RUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUVN4RFFVRkRPMUZCUTFvc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0zUWl4UFFVRlBMRU5CUVVNc1EwRkJReXhUUVVGVExFTkJRVU03VVVGRGNrSXNRMEZCUXp0SlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJSVWdzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRjJRMFFzYjBOQmRVTkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBiaW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9iaW5cIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgdW5pdF8xID0gcmVxdWlyZShcIi4uL3VuaXRcIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xuZnVuY3Rpb24gbnVtYmVyRm9ybWF0RXhwcihleHByLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gXCJmb3JtYXQoXCIgKyBleHByICsgXCIsICdcIiArIGZvcm1hdCArIFwiJylcIjtcbn1cbmZ1bmN0aW9uIHJhbmdlRm9ybXVsYShtb2RlbCwgZmllbGREZWYsIGNoYW5uZWwsIGNvbmZpZykge1xuICAgIHZhciBkaXNjcmV0ZURvbWFpbiA9IG1vZGVsLmhhc0Rpc2NyZXRlRG9tYWluKGNoYW5uZWwpO1xuICAgIGlmIChkaXNjcmV0ZURvbWFpbikge1xuICAgICAgICAvLyByZWFkIGZvcm1hdCBmcm9tIGF4aXMgb3IgbGVnZW5kLCBpZiB0aGVyZSBpcyBubyBmb3JtYXQgdGhlbiB1c2UgY29uZmlnLm51bWJlckZvcm1hdFxuICAgICAgICB2YXIgZ3VpZGUgPSAobW9kZWwgaW5zdGFuY2VvZiB1bml0XzEuVW5pdE1vZGVsKSA/IChtb2RlbC5heGlzKGNoYW5uZWwpIHx8IG1vZGVsLmxlZ2VuZChjaGFubmVsKSB8fCB7fSkgOiB7fTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IGNvbW1vbl8xLm51bWJlckZvcm1hdChmaWVsZERlZiwgZ3VpZGUuZm9ybWF0LCBjb25maWcsIGNoYW5uZWwpO1xuICAgICAgICB2YXIgc3RhcnRGaWVsZCA9IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgZXhwcjogJ2RhdHVtJywgYmluU3VmZml4OiAnc3RhcnQnIH0pO1xuICAgICAgICB2YXIgZW5kRmllbGQgPSBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGV4cHI6ICdkYXR1bScsIGJpblN1ZmZpeDogJ2VuZCcgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtdWxhQXM6IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAncmFuZ2UnIH0pLFxuICAgICAgICAgICAgZm9ybXVsYTogbnVtYmVyRm9ybWF0RXhwcihzdGFydEZpZWxkLCBmb3JtYXQpICsgXCIgKyAnIC0gJyArIFwiICsgbnVtYmVyRm9ybWF0RXhwcihlbmRGaWVsZCwgZm9ybWF0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG52YXIgQmluTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmluTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5Ob2RlKGJpbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmlucyA9IGJpbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmluTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluTm9kZSh1dGlsXzEuZHVwbGljYXRlKHRoaXMuYmlucykpO1xuICAgIH07XG4gICAgQmluTm9kZS5tYWtlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBiaW5zID0gbW9kZWwucmVkdWNlRmllbGREZWYoZnVuY3Rpb24gKGJpbkNvbXBvbmVudCwgZmllbGREZWYsIGNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZERlZkJpbiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpLmJpbjtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZkJpbikge1xuICAgICAgICAgICAgICAgIHZhciBiaW4gPSB1dGlsXzEuaXNCb29sZWFuKGZpZWxkRGVmQmluKSA/IHt9IDogZmllbGREZWZCaW47XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGJpbl8xLmJpblRvU3RyaW5nKGZpZWxkRGVmLmJpbikgKyBcIl9cIiArIGZpZWxkRGVmLmZpZWxkO1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBiaW5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbkNvbXBvbmVudFtrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluOiBiaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGREZWYuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhczogW2ZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pLCBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ2VuZCcgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBtb2RlbC5nZXROYW1lKGtleSArIFwiX2JpbnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRTaWduYWw6IG1vZGVsLmdldE5hbWUoa2V5ICsgJ19leHRlbnQnKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5Db21wb25lbnRba2V5XSA9IHRzbGliXzEuX19hc3NpZ24oe30sIGJpbkNvbXBvbmVudFtrZXldLCByYW5nZUZvcm11bGEobW9kZWwsIGZpZWxkRGVmLCBjaGFubmVsLCBtb2RlbC5jb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaW5Db21wb25lbnQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGJpbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCaW5Ob2RlKGJpbnMpO1xuICAgIH07XG4gICAgQmluTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5iaW5zID0gdXRpbF8xLmV4dGVuZChvdGhlci5iaW5zKTtcbiAgICAgICAgb3RoZXIucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBCaW5Ob2RlLnByb3RvdHlwZS5wcm9kdWNlZEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB1dGlsXzEudmFscyh0aGlzLmJpbnMpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGMuYXMuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gb3V0W2ZdID0gdHJ1ZTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQmluTm9kZS5wcm90b3R5cGUuZGVwZW5kZW50RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIHV0aWxfMS52YWxzKHRoaXMuYmlucykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgb3V0W2MuZmllbGRdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBCaW5Ob2RlLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5mbGF0dGVuKHV0aWxfMS52YWxzKHRoaXMuYmlucykubWFwKGZ1bmN0aW9uIChiaW4pIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBbXTtcbiAgICAgICAgICAgIHZhciBiaW5UcmFucyA9IHRzbGliXzEuX19hc3NpZ24oeyB0eXBlOiAnYmluJywgZmllbGQ6IGJpbi5maWVsZCwgYXM6IGJpbi5hcywgc2lnbmFsOiBiaW4uc2lnbmFsIH0sIGJpbi5iaW4pO1xuICAgICAgICAgICAgaWYgKCFiaW4uYmluLmV4dGVudCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2V4dGVudCcsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBiaW4uZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYmluLmV4dGVudFNpZ25hbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJpblRyYW5zLmV4dGVudCA9IHsgc2lnbmFsOiBiaW4uZXh0ZW50U2lnbmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucHVzaChiaW5UcmFucyk7XG4gICAgICAgICAgICBpZiAoYmluLmZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwcjogYmluLmZvcm11bGEsXG4gICAgICAgICAgICAgICAgICAgIGFzOiBiaW4uZm9ybXVsYUFzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluTm9kZTtcbn0oZGF0YWZsb3dfMS5EYXRhRmxvd05vZGUpKTtcbmV4cG9ydHMuQmluTm9kZSA9IEJpbk5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZbWx1TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdlpHRjBZUzlpYVc0dWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc2FVTkJRWGRFTzBGQlIzaEVMREpEUVVFclF6dEJRVVV2UXl4dFEwRkJPRVk3UVVGRk9VWXNiME5CUVhWRE8wRkJSWFpETEdkRFFVRnJRenRCUVVOc1F5eDFRMEZCZDBNN1FVRkhlRU1zTUVKQlFUQkNMRWxCUVZrc1JVRkJSU3hOUVVGak8wbEJRM0JFTEUxQlFVMHNRMEZCUXl4WlFVRlZMRWxCUVVrc1YwRkJUU3hOUVVGTkxFOUJRVWtzUTBGQlF6dEJRVU40UXl4RFFVRkRPMEZCUlVRc2MwSkJRWE5DTEV0QlFYRkNMRVZCUVVVc1VVRkJNRUlzUlVGQlJTeFBRVUZuUWl4RlFVRkZMRTFCUVdNN1NVRkRja2NzU1VGQlRTeGpRVUZqTEVkQlFVY3NTMEZCU3l4RFFVRkRMR2xDUVVGcFFpeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUlhoRUxFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRia0lzYzBaQlFYTkdPMUZCUlhSR0xFbEJRVTBzUzBGQlN5eEhRVUZITEVOQlFVTXNTMEZCU3l4WlFVRlpMR2RDUVVGVExFTkJRVU1zUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZEZGtjc1NVRkJUU3hOUVVGTkxFZEJRVWNzY1VKQlFWa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1MwRkJTeXhEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkZja1VzU1VGQlRTeFZRVUZWTEVkQlFVY3NaMEpCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUlVGQlF5eEpRVUZKTEVWQlFVVXNUMEZCVHl4RlFVRkZMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF5eERRVUZETzFGQlEzaEZMRWxCUVUwc1VVRkJVU3hIUVVGSExHZENRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUlVGQlJTeFRRVUZUTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNc1EwRkJRenRSUVVWd1JTeE5RVUZOTEVOQlFVTTdXVUZEVEN4VFFVRlRMRVZCUVVVc1owSkJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNSVUZCUXl4VFFVRlRMRVZCUVVVc1QwRkJUeXhGUVVGRExFTkJRVU03V1VGRGFFUXNUMEZCVHl4RlFVRkxMR2RDUVVGblFpeERRVUZETEZWQlFWVXNSVUZCUlN4TlFVRk5MRU5CUVVNc2JVSkJRV01zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxFMUJRVTBzUTBGQlJ6dFRRVU51Unl4RFFVRkRPMGxCUTBvc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTTdRVUZEWkN4RFFVRkRPMEZCWlVRN1NVRkJOa0lzYlVOQlFWazdTVUZMZGtNc2FVSkJRVzlDTEVsQlFYZENPMUZCUVRWRExGbEJRMFVzYVVKQlFVOHNVMEZEVWp0UlFVWnRRaXhWUVVGSkxFZEJRVW9zU1VGQlNTeERRVUZ2UWpzN1NVRkZOVU1zUTBGQlF6dEpRVTVOTEhWQ1FVRkxMRWRCUVZvN1VVRkRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeFBRVUZQTEVOQlFVTXNaMEpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXpReXhEUVVGRE8wbEJUV0VzV1VGQlNTeEhRVUZzUWl4VlFVRnRRaXhMUVVGeFFqdFJRVU4wUXl4SlFVRk5MRWxCUVVrc1IwRkJSeXhMUVVGTExFTkJRVU1zWTBGQll5eERRVUZETEZWQlFVTXNXVUZCWjBNc1JVRkJSU3hSUVVGUkxFVkJRVVVzVDBGQlR6dFpRVU53Uml4SlFVRk5MRmRCUVZjc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJRenRaUVVOb1JDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5vUWl4SlFVRk5MRWRCUVVjc1IwRkJVU3huUWtGQlV5eERRVUZETEZkQlFWY3NRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhYUVVGWExFTkJRVU03WjBKQlF6TkVMRWxCUVUwc1IwRkJSeXhIUVVGTkxHbENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhUUVVGSkxGRkJRVkVzUTBGQlF5eExRVUZQTEVOQlFVTTdaMEpCUlRkRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTXpRaXhaUVVGWkxFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVYzdkMEpCUTJ4Q0xFZEJRVWNzUlVGQlJTeEhRVUZITzNkQ1FVTlNMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUzBGQlN6dDNRa0ZEY2tJc1JVRkJSU3hGUVVGRkxFTkJRVU1zWjBKQlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTXNSVUZCUlN4blFrRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZETEZOQlFWTXNSVUZCUlN4TFFVRkxMRVZCUVVNc1EwRkJReXhEUVVGRE8zZENRVU5vUml4TlFVRk5MRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlNTeEhRVUZITEZWQlFVOHNRMEZCUXp0M1FrRkRjRU1zV1VGQldTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhIUVVGSExGTkJRVk1zUTBGQlF6dHhRa0ZETjBNc1EwRkJRenRuUWtGRFNpeERRVUZETzJkQ1FVVkVMRmxCUVZrc1EwRkJReXhIUVVGSExFTkJRVU1zZDBKQlExb3NXVUZCV1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVOcVFpeFpRVUZaTEVOQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJSU3hQUVVGUExFVkJRVVVzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVTjRSQ3hEUVVGRE8xbEJRMG9zUTBGQlF6dFpRVU5FTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNN1VVRkRkRUlzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUlZBc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhOUVVGTkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlEyUXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wbEJSVTBzZFVKQlFVc3NSMEZCV2l4VlFVRmhMRXRCUVdNN1VVRkRla0lzU1VGQlNTeERRVUZETEVsQlFVa3NSMEZCUnl4aFFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlF5OUNMRXRCUVVzc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dEpRVU5xUWl4RFFVRkRPMGxCUlUwc1owTkJRV01zUjBGQmNrSTdVVUZEUlN4SlFVRk5MRWRCUVVjc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRlppeFhRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEVOQlFVTTdXVUZEZGtJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RlFVRmlMRU5CUVdFc1EwRkJReXhEUVVGRE8xRkJRMjVETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlVnc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF6dEpRVU5pTEVOQlFVTTdTVUZGVFN4cFEwRkJaU3hIUVVGMFFqdFJRVU5GTEVsQlFVMHNSMEZCUnl4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVWbUxGZEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVUVzUTBGQlF6dFpRVU4yUWl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVTjBRaXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVZJTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNN1NVRkRZaXhEUVVGRE8wbEJSVTBzTUVKQlFWRXNSMEZCWmp0UlFVTkZMRTFCUVUwc1EwRkJReXhqUVVGUExFTkJRVU1zVjBGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlFTeEhRVUZITzFsQlEzQkRMRWxCUVUwc1UwRkJVeXhIUVVGclFpeEZRVUZGTEVOQlFVTTdXVUZGY0VNc1NVRkJUU3hSUVVGUkxITkNRVU5XTEVsQlFVa3NSVUZCUlN4TFFVRkxMRVZCUTFnc1MwRkJTeXhGUVVGRkxFZEJRVWNzUTBGQlF5eExRVUZMTEVWQlEyaENMRVZCUVVVc1JVRkJSU3hIUVVGSExFTkJRVU1zUlVGQlJTeEZRVU5XTEUxQlFVMHNSVUZCUlN4SFFVRkhMRU5CUVVNc1RVRkJUU3hKUVVObUxFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlEySXNRMEZCUXp0WlFVVkdMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU53UWl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRE8yOUNRVU5pTEVsQlFVa3NSVUZCUlN4UlFVRlJPMjlDUVVOa0xFdEJRVXNzUlVGQlJTeEhRVUZITEVOQlFVTXNTMEZCU3p0dlFrRkRhRUlzVFVGQlRTeEZRVUZGTEVkQlFVY3NRMEZCUXl4WlFVRlpPMmxDUVVONlFpeERRVUZETEVOQlFVTTdaMEpCUTBnc1VVRkJVU3hEUVVGRExFMUJRVTBzUjBGQlJ5eEZRVUZETEUxQlFVMHNSVUZCUlN4SFFVRkhMRU5CUVVNc1dVRkJXU3hGUVVGRExFTkJRVU03V1VGREwwTXNRMEZCUXp0WlFVVkVMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdXVUZGZWtJc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMmhDTEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNN2IwSkJRMklzU1VGQlNTeEZRVUZGTEZOQlFWTTdiMEpCUTJZc1NVRkJTU3hGUVVGRkxFZEJRVWNzUTBGQlF5eFBRVUZQTzI5Q1FVTnFRaXhGUVVGRkxFVkJRVVVzUjBGQlJ5eERRVUZETEZOQlFWTTdhVUpCUTJ4Q0xFTkJRVU1zUTBGQlF6dFpRVU5NTEVOQlFVTTdXVUZGUkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRE8xRkJRMjVDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUaXhEUVVGRE8wbEJRMGdzWTBGQlF6dEJRVUZFTEVOQlFVTXNRVUZ3UjBRc1EwRkJOa0lzZFVKQlFWa3NSMEZ2UjNoRE8wRkJjRWRaTERCQ1FVRlBJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKlxuICogQSBub2RlIGluIHRoZSBkYXRhZmxvdyB0cmVlLlxuICovXG52YXIgRGF0YUZsb3dOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhRmxvd05vZGUoZGVidWdOYW1lKSB7XG4gICAgICAgIHRoaXMuZGVidWdOYW1lID0gZGVidWdOYW1lO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGlzIG5vZGUgd2l0aCBhIGRlZXAgY29weSBidXQgZG9uJ3QgY2xvbmUgbGlua3MgdG8gY2hpbGRyZW4gb3IgcGFyZW50cy5cbiAgICAgKi9cbiAgICBEYXRhRmxvd05vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjbG9uZSBub2RlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgb2YgZmllbGRzIHRoYXQgYXJlIGJlaW5nIGNyZWF0ZWQgYnkgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIERhdGFGbG93Tm9kZS5wcm90b3R5cGUucHJvZHVjZWRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9O1xuICAgIERhdGFGbG93Tm9kZS5wcm90b3R5cGUuZGVwZW5kZW50RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUZsb3dOb2RlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHBhcmVudCBvZiB0aGUgbm9kZSBhbmQgYWxzbyBhZGQgdGhpcyBub3QgdG8gdGhlIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhRmxvd05vZGUucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERhdGFGbG93Tm9kZS5wcm90b3R5cGUubnVtQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgfTtcbiAgICBEYXRhRmxvd05vZGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH07XG4gICAgRGF0YUZsb3dOb2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChvbGRDaGlsZCkge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UodGhpcy5fY2hpbGRyZW4uaW5kZXhPZihvbGRDaGlsZCksIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG5vZGUgZnJvbSB0aGUgZGF0YWZsb3cuXG4gICAgICovXG4gICAgRGF0YUZsb3dOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5wYXJlbnQgPSBfdGhpcy5fcGFyZW50OyB9KTtcbiAgICAgICAgdGhpcy5fcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH07XG4gICAgRGF0YUZsb3dOb2RlLnByb3RvdHlwZS5zd2FwV2l0aFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIC8vIHJlY29ubmVjdCB0aGUgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5wYXJlbnQgPSBwYXJlbnQ7IH0pO1xuICAgICAgICAvLyByZW1vdmUgb2xkIGxpbmtzXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107IC8vIGVxdWl2YWxlbnQgdG8gcmVtb3ZpbmcgZXZlcnkgY2hpbGQgbGluayBvbmUgYnkgb25lXG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcGFyZW50LnBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICAvLyBzd2FwIHR3byBub2Rlc1xuICAgICAgICB0aGlzLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgcGFyZW50LnBhcmVudCA9IHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YUZsb3dOb2RlO1xufSgpKTtcbmV4cG9ydHMuRGF0YUZsb3dOb2RlID0gRGF0YUZsb3dOb2RlO1xudmFyIE91dHB1dE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE91dHB1dE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0cHV0Tm9kZShzb3VyY2UsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc291cmNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgX3RoaXMuX3JlZmNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPdXRwdXROb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb25lT2JqID0gbmV3IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNsb25lT2JqLl9zb3VyY2UgPSB0aGlzLl9zb3VyY2U7XG4gICAgICAgIGNsb25lT2JqLmRlYnVnTmFtZSA9ICdjbG9uZV8nICsgdGhpcy5kZWJ1Z05hbWU7XG4gICAgICAgIGNsb25lT2JqLl9yZWZjb3VudCA9IHRoaXMuX3JlZmNvdW50O1xuICAgICAgICByZXR1cm4gY2xvbmVPYmo7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3V0cHV0Tm9kZS5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcXVlc3QgdGhlIGRhdGFzb3VyY2UgbmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRHVyaW5nIHRoZSBwYXJzaW5nIHBoYXNlLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzaW1wbGUgbmFtZSBzdWNoIGFzICdtYWluJyBvciAncmF3Jy5cbiAgICAgICAgICogSXQgaXMgY3J1Y2lhbCB0byByZXF1ZXN0IHRoZSBuYW1lIGZyb20gYW4gb3V0cHV0IG5vZGUgdG8gbWFyayBpdCBhcyBhIHJlcXVpcmVkIG5vZGUuXG4gICAgICAgICAqIElmIG5vYm9keSBldmVyIHJlcXVlc3RzIHRoZSBuYW1lLCB0aGlzIGRhdGFzb3VyY2Ugd2lsbCBub3QgYmUgaW5zdGFudGlhdGVkIGluIHRoZSBhc3NlbWJsZSBwaGFzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gdGhlIGFzc2VtYmxlIHBoYXNlLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBjb3JyZWN0IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZmNvdW50Kys7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE91dHB1dE5vZGUucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVmY291bnQgPiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gT3V0cHV0Tm9kZTtcbn0oRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLk91dHB1dE5vZGUgPSBPdXRwdXROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWkdGMFlXWnNiM2N1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5a1lYUmhMMlJoZEdGbWJHOTNMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVdEJPenRIUVVWSE8wRkJRMGc3U1VGTFJTeHpRa0ZCTkVJc1UwRkJhMEk3VVVGQmJFSXNZMEZCVXl4SFFVRlVMRk5CUVZNc1EwRkJVenRSUVVwMFF5eGpRVUZUTEVkQlFXMUNMRVZCUVVVc1EwRkJRenRSUVVVdlFpeFpRVUZQTEVkQlFXbENMRWxCUVVrc1EwRkJRenRKUVVWaExFTkJRVU03U1VGRmJrUTdPMDlCUlVjN1NVRkRTU3cwUWtGQlN5eEhRVUZhTzFGQlEwVXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4RFFVRkRPMGxCUTNaRExFTkJRVU03U1VGRlJEczdUMEZGUnp0SlFVTkpMSEZEUVVGakxFZEJRWEpDTzFGQlEwVXNUVUZCVFN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVOYUxFTkJRVU03U1VGRlRTeHpRMEZCWlN4SFFVRjBRanRSUVVORkxFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTTdTVUZEV2l4RFFVRkRPMGxCUlVRc2MwSkJRVWtzWjBOQlFVMDdZVUZCVmp0WlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEzUkNMRU5CUVVNN1VVRkZSRHM3VjBGRlJ6dGhRVU5JTEZWQlFWY3NUVUZCYjBJN1dVRkROMElzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1dVRkRkRUlzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVONFFpeERRVUZET3pzN1QwRlNRVHRKUVZWRUxITkNRVUZKTEd0RFFVRlJPMkZCUVZvN1dVRkRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXp0UlFVTjRRaXhEUVVGRE96czdUMEZCUVR0SlFVVk5MR3REUVVGWExFZEJRV3hDTzFGQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETzBsQlF5OUNMRU5CUVVNN1NVRkZUU3dyUWtGQlVTeEhRVUZtTEZWQlFXZENMRXRCUVcxQ08xRkJRMnBETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzBsQlF6ZENMRU5CUVVNN1NVRkZUU3hyUTBGQlZ5eEhRVUZzUWl4VlFVRnRRaXhSUVVGelFqdFJRVU4yUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTNSQ3hEUVVGRE8wbEJSVVE3TzA5QlJVYzdTVUZEU1N3MlFrRkJUU3hIUVVGaU8xRkJRVUVzYVVKQlIwTTdVVUZHUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEV0QlFVc3NTVUZCU1N4UFFVRkJMRXRCUVVzc1EwRkJReXhOUVVGTkxFZEJRVWNzUzBGQlNTeERRVUZETEU5QlFVOHNSVUZCTTBJc1EwRkJNa0lzUTBGQlF5eERRVUZETzFGQlF6ZEVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTJwRExFTkJRVU03U1VGRlRTeHhRMEZCWXl4SFFVRnlRanRSUVVORkxFbEJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNN1VVRkROVUlzU1VGQlRTeFRRVUZUTEVkQlFVY3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVWb1F5eDVRa0ZCZVVJN1VVRkRla0lzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1JVRkJha0lzUTBGQmFVSXNRMEZCUXl4RFFVRkRPMUZCUlM5RExHMUNRVUZ0UWp0UlFVTnVRaXhKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVRkZMSEZFUVVGeFJEdFJRVU16UlN4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzcENMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUjJ4RExHbENRVUZwUWp0UlFVTnFRaXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEZOQlFWTXNRMEZCUXp0UlFVTjRRaXhOUVVGTkxFTkJRVU1zVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJRMGdzYlVKQlFVTTdRVUZCUkN4RFFVRkRMRUZCT1VWRUxFbEJPRVZETzBGQk9VVlpMRzlEUVVGWk8wRkJaMFo2UWp0SlFVRm5ReXh6UTBGQldUdEpRV014UXl4dlFrRkJXU3hOUVVGakxFVkJRV3RDTEVsQlFXOUNPMUZCUVdoRkxGbEJRMFVzYTBKQlFVMHNUVUZCVFN4RFFVRkRMRk5CUjJRN1VVRktNa01zVlVGQlNTeEhRVUZLTEVsQlFVa3NRMEZCWjBJN1VVRldlRVFzWlVGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFXRndRaXhMUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEUxQlFVMHNRMEZCUXpzN1NVRkRlRUlzUTBGQlF6dEpRVnBOTERCQ1FVRkxMRWRCUVZvN1VVRkRSU3hKUVVGTkxGRkJRVkVzUjBGQlJ5eEpRVUZWTEVsQlFVa3NRMEZCUXl4WFFVRlpMRU5CUVVNN1VVRkROME1zVVVGQlVTeERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRE8xRkJRMmhETEZGQlFWRXNRMEZCUXl4VFFVRlRMRWRCUVVjc1VVRkJVU3hIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTTdVVUZETDBNc1VVRkJVU3hEUVVGRExGTkJRVk1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTNCRExFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVdsQ1JDeHpRa0ZCU1N3NFFrRkJUVHRSUVZSV096czdPenM3T3p0WFFWRkhPMkZCUTBnN1dVRkRSU3hKUVVGSkxFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTTdXVUZEYWtJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTTdVVUZEZEVJc1EwRkJRenRoUVVWRUxGVkJRVmNzVFVGQll6dFpRVU4yUWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExFMUJRVTBzUTBGQlF6dFJRVU40UWl4RFFVRkRPenM3VDBGS1FUdEpRVTFFTEhOQ1FVRkpMR2REUVVGUk8yRkJRVm83V1VGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRE5VSXNRMEZCUXpzN08wOUJRVUU3U1VGRFNDeHBRa0ZCUXp0QlFVRkVMRU5CUVVNc1FVRjZRMFFzUTBGQlowTXNXVUZCV1N4SFFYbERNME03UVVGNlExa3NaME5CUVZVaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIGRhdGFmbG93XzEgPSByZXF1aXJlKFwiLi9kYXRhZmxvd1wiKTtcbi8qKlxuICogQSBub2RlIHRoYXQgaGVscHMgdXMgdHJhY2sgd2hhdCBmaWVsZHMgd2UgYXJlIGZhY2V0aW5nIGJ5LlxuICovXG52YXIgRmFjZXROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGYWNldE5vZGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1vZGVsIFRoZSBmYWNldCBtb2RlbC5cbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoaXMgZmFjZXQgc291cmNlIHdpbGwgaGF2ZS5cbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgc291cmNlIGRhdGEgZm9yIHRoaXMgZmFjZXQgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGYWNldE5vZGUobW9kZWwsIG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAobW9kZWwuZmFjZXQuY29sdW1uKSB7XG4gICAgICAgICAgICBfdGhpcy5jb2x1bW5GaWVsZCA9IG1vZGVsLmZpZWxkKGNoYW5uZWxfMS5DT0xVTU4pO1xuICAgICAgICAgICAgX3RoaXMuY29sdW1uTmFtZSA9IG1vZGVsLmdldE5hbWUoJ2NvbHVtbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlbC5mYWNldC5yb3cpIHtcbiAgICAgICAgICAgIF90aGlzLnJvd0ZpZWxkID0gbW9kZWwuZmllbGQoY2hhbm5lbF8xLlJPVyk7XG4gICAgICAgICAgICBfdGhpcy5yb3dOYW1lID0gbW9kZWwuZ2V0TmFtZSgncm93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZXROb2RlLnByb3RvdHlwZSwgXCJmaWVsZHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkZpZWxkKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2godGhpcy5jb2x1bW5GaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yb3dGaWVsZCkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHRoaXMucm93RmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2V0Tm9kZS5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIHRvIHJlZmVyZW5jZSB0aGlzIHNvdXJjZSBpcyBpdHMgbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGYWNldE5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5OYW1lKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwYnk6IFt0aGlzLmNvbHVtbkZpZWxkXVxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb2x1bW4gbmVlZHMgYW5vdGhlciBkYXRhIHNvdXJjZSB0byBjYWxjdWxhdGUgY2FyZGluYWxpdHkgYXMgaW5wdXQgdG8gbGF5b3V0XG4gICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuY29sdW1uTmFtZSArICdfbGF5b3V0JyxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogWydkaXN0aW5jdCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBbdGhpcy5jb2x1bW5GaWVsZF1cbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvd05hbWUpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5yb3dOYW1lLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBieTogW3RoaXMucm93RmllbGRdXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBGYWNldE5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLkZhY2V0Tm9kZSA9IEZhY2V0Tm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVptRmpaWFF1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5a1lYUmhMMlpoWTJWMExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVGQkxIbERRVUV3UXp0QlFVY3hReXgxUTBGQmIwUTdRVUZGY0VRN08wZEJSVWM3UVVGRFNEdEpRVUVyUWl4eFEwRkJXVHRKUVU5NlF6czdPenRQUVVsSE8wbEJRMGdzYlVKQlFXMURMRXRCUVdsQ0xFVkJRV3RDTEVsQlFWa3NSVUZCVXl4SlFVRlpPMUZCUVhaSExGbEJRMFVzYVVKQlFVOHNVMEZYVWp0UlFWcHJReXhYUVVGTExFZEJRVXdzUzBGQlN5eERRVUZaTzFGQlFXdENMRlZCUVVrc1IwRkJTaXhKUVVGSkxFTkJRVkU3VVVGQlV5eFZRVUZKTEVkQlFVb3NTVUZCU1N4RFFVRlJPMUZCUjNKSExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4yUWl4TFFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNaMEpCUVUwc1EwRkJReXhEUVVGRE8xbEJRM1pETEV0QlFVa3NRMEZCUXl4VlFVRlZMRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVTTFReXhEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkNMRXRCUVVrc1EwRkJReXhSUVVGUkxFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4aFFVRkhMRU5CUVVNc1EwRkJRenRaUVVOcVF5eExRVUZKTEVOQlFVTXNUMEZCVHl4SFFVRkhMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdVVUZEZEVNc1EwRkJRenM3U1VGRFNDeERRVUZETzBsQlJVUXNjMEpCUVVrc05rSkJRVTA3WVVGQlZqdFpRVU5GTEVsQlFVMHNUVUZCVFN4SFFVRmhMRVZCUVVVc1EwRkJRenRaUVVNMVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEY2tJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNN1dVRkRhRU1zUTBGQlF6dFpRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnNRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRaUVVNM1FpeERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVOb1FpeERRVUZET3pzN1QwRkJRVHRKUVV0RUxITkNRVUZKTERaQ1FVRk5PMUZCU0ZZN08xZEJSVWM3WVVGRFNEdFpRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMjVDTEVOQlFVTTdPenRQUVVGQk8wbEJSVTBzTkVKQlFWRXNSMEZCWmp0UlFVTkZMRWxCUVUwc1NVRkJTU3hIUVVGaExFVkJRVVVzUTBGQlF6dFJRVVV4UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndRaXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVTlNMRWxCUVVrc1JVRkJSU3hKUVVGSkxFTkJRVU1zVlVGQlZUdG5Ra0ZEY2tJc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTzJkQ1FVTnFRaXhUUVVGVExFVkJRVVVzUTBGQlF6dDNRa0ZEVml4SlFVRkpMRVZCUVVVc1YwRkJWenQzUWtGRGFrSXNUMEZCVHl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF6dHhRa0ZETlVJc1EwRkJRenRoUVVOSUxFTkJRVU1zUTBGQlF6dFpRVVZJTEN0RlFVRXJSVHRaUVVNdlJTeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMmRDUVVOU0xFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNWVUZCVlN4SFFVRkhMRk5CUVZNN1owSkJRMnBETEUxQlFVMHNSVUZCUlN4SlFVRkpMRU5CUVVNc1ZVRkJWVHRuUWtGRGRrSXNVMEZCVXl4RlFVRkZMRU5CUVVNN2QwSkJRMVlzU1VGQlNTeEZRVUZGTEZkQlFWYzdkMEpCUTJwQ0xFZEJRVWNzUlVGQlJTeERRVUZETEZWQlFWVXNRMEZCUXp0M1FrRkRha0lzVFVGQlRTeEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJRenR4UWtGRE0wSXNRMEZCUXp0aFFVTklMRU5CUVVNc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRE8yZENRVU5TTEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1QwRkJUenRuUWtGRGJFSXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhKUVVGSk8yZENRVU5xUWl4VFFVRlRMRVZCUVVVc1EwRkJRenQzUWtGRFZpeEpRVUZKTEVWQlFVVXNWMEZCVnp0M1FrRkRha0lzVDBGQlR5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJRenR4UWtGRGVrSXNRMEZCUXp0aFFVTklMRU5CUVVNc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVOSUxHZENRVUZETzBGQlFVUXNRMEZCUXl4QlFXeEdSQ3hEUVVFclFpeDFRa0ZCV1N4SFFXdEdNVU03UVVGc1Jsa3NPRUpCUVZNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0ZXRpbWVcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXJcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuLi8uLi90cmFuc2Zvcm1cIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbFwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oZmllbGQsIHBhcnNlKSB7XG4gICAgdmFyIGYgPSBcImRhdHVtW1wiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKGZpZWxkKSArIFwiXVwiO1xuICAgIGlmIChwYXJzZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIFwidG9OdW1iZXIoXCIgKyBmICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcnNlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFwidG9Cb29sZWFuKFwiICsgZiArIFwiKVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFwidG9TdHJpbmcoXCIgKyBmICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcnNlID09PSAnZGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIFwidG9EYXRlKFwiICsgZiArIFwiKVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZS5pbmRleE9mKCdkYXRlOicpID09PSAwKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXIgPSBwYXJzZS5zbGljZSg2LCBwYXJzZS5sZW5ndGggLSAxKTsgLy8gc3BlY2lmaWVyIGlzIGluIFwiXCIgb3IgJydcbiAgICAgICAgcmV0dXJuIFwidGltZVBhcnNlKFwiICsgZiArIFwiLFxcXCJcIiArIHNwZWNpZmllciArIFwiXFxcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLnVucmVjb2duaXplZFBhcnNlKHBhcnNlKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbnZhciBQYXJzZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnNlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJzZU5vZGUocGFyc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3BhcnNlID0ge307XG4gICAgICAgIF90aGlzLl9wYXJzZSA9IHBhcnNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBhcnNlTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5wYXJzZSkpO1xuICAgIH07XG4gICAgUGFyc2VOb2RlLm1ha2UgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIHBhcnNlID0ge307XG4gICAgICAgIHZhciBjYWxjRmllbGRNYXAgPSBtb2RlbC50cmFuc2Zvcm1zLmZpbHRlcih0cmFuc2Zvcm1fMS5pc0NhbGN1bGF0ZSkucmVkdWNlKGZ1bmN0aW9uIChmaWVsZE1hcCwgZm9ybXVsYSkge1xuICAgICAgICAgICAgZmllbGRNYXBbZm9ybXVsYS5hc10gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTWFwO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIFBhcnNlIGZpbHRlciBmaWVsZHNcbiAgICAgICAgbW9kZWwudHJhbnNmb3Jtcy5maWx0ZXIodHJhbnNmb3JtXzEuaXNGaWx0ZXIpLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRyYW5zZm9ybS5maWx0ZXI7XG4gICAgICAgICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEZvciBFcXVhbEZpbHRlciwganVzdCB1c2UgdGhlIGVxdWFsIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gRm9yIFJhbmdlRmlsdGVyIGFuZCBPbmVPZkZpbHRlciwgYWxsIGFycmF5IG1lbWJlcnMgc2hvdWxkIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIHR5cGUsIHNvIHdlIG9ubHkgdXNlIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgICAgICBpZiAoZmlsdGVyXzEuaXNFcXVhbEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZmlsdGVyLmVxdWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyXzEuaXNSYW5nZUZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZmlsdGVyLnJhbmdlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyXzEuaXNPbmVPZkZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gKGZpbHRlci5vbmVPZiB8fCBmaWx0ZXJbJ2luJ10pWzBdO1xuICAgICAgICAgICAgfSAvLyBlbHNlIC0tIGZvciBmaWx0ZXIgZXhwcmVzc2lvbiwgd2UgY2FuJ3QgaW5mZXIgYW55dGhpbmdcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXRpbWVfMS5pc0RhdGVUaW1lKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VbZmlsdGVyWydmaWVsZCddXSA9ICdkYXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VbZmlsdGVyWydmaWVsZCddXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsXzEuaXNTdHJpbmcodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVtmaWx0ZXJbJ2ZpZWxkJ11dID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgbW9kZWxfMS5Nb2RlbFdpdGhGaWVsZCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgZW5jb2RlZCBmaWVsZHNcbiAgICAgICAgICAgIG1vZGVsLmZvckVhY2hGaWVsZERlZihmdW5jdGlvbiAoZmllbGREZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLlRFTVBPUkFMKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlW2ZpZWxkRGVmLmZpZWxkXSA9ICdkYXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLlFVQU5USVRBVElWRSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0NvdW50KGZpZWxkRGVmKSB8fCBjYWxjRmllbGRNYXBbZmllbGREZWYuZmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VbZmllbGREZWYuZmllbGRdID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3VzdG9tIHBhcnNlIHNob3VsZCBvdmVycmlkZSBpbmZlcnJlZCBwYXJzZVxuICAgICAgICB2YXIgZGF0YSA9IG1vZGVsLmRhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuZm9ybWF0ICYmIGRhdGEuZm9ybWF0LnBhcnNlKSB7XG4gICAgICAgICAgICB2YXIgcF8xID0gZGF0YS5mb3JtYXQucGFyc2U7XG4gICAgICAgICAgICB1dGlsXzEua2V5cyhwXzEpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VbZmllbGRdID0gcF8xW2ZpZWxkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsXzEua2V5cyhwYXJzZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShwYXJzZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyc2VOb2RlLnByb3RvdHlwZSwgXCJwYXJzZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQYXJzZU5vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlID0gdXRpbF8xLmV4dGVuZCh0aGlzLl9wYXJzZSwgb3RoZXIucGFyc2UpO1xuICAgICAgICBvdGhlci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIFBhcnNlTm9kZS5wcm90b3R5cGUuYXNzZW1ibGVGb3JtYXRQYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlO1xuICAgIH07XG4gICAgUGFyc2VOb2RlLnByb3RvdHlwZS5hc3NlbWJsZVRyYW5zZm9ybXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9wYXJzZSkubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oZmllbGQsIF90aGlzLl9wYXJzZVtmaWVsZF0pO1xuICAgICAgICAgICAgaWYgKCFleHByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgICAgICAgICAgZXhwcjogZXhwcixcbiAgICAgICAgICAgICAgICBhczogZmllbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm9ybXVsYTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICE9PSBudWxsOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZU5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLlBhcnNlTm9kZSA9IFBhcnNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVptOXliV0YwY0dGeWMyVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlrWVhSaEwyWnZjbTFoZEhCaGNuTmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVRkJMREpEUVVGdlJEdEJRVU53UkN3eVEwRkJhVVE3UVVGRGFrUXNkVU5CUVhsRk8wRkJRM3BGTEN0Q1FVRnBRenRCUVVOcVF5dzJRMEZCTWtZN1FVRkRNMFlzYlVOQlFXdEVPMEZCUTJ4RUxHMURRVUZ0Unp0QlFVVnVSeXhyUTBGQkswTTdRVUZETDBNc2RVTkJRWGRETzBGQlIzaERMSGxDUVVGNVFpeExRVUZoTEVWQlFVVXNTMEZCWVR0SlFVTnVSQ3hKUVVGTkxFTkJRVU1zUjBGQlJ5eFhRVUZUTEd0Q1FVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVWNzUTBGQlF6dEpRVU42UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJRaXhOUVVGTkxFTkJRVU1zWTBGQldTeERRVUZETEUxQlFVY3NRMEZCUXp0SlFVTXhRaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF5OUNMRTFCUVUwc1EwRkJReXhsUVVGaExFTkJRVU1zVFVGQlJ5eERRVUZETzBsQlF6TkNMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4TFFVRkxMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VSXNUVUZCVFN4RFFVRkRMR05CUVZrc1EwRkJReXhOUVVGSExFTkJRVU03U1VGRE1VSXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEV0QlFVc3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNMVFpeE5RVUZOTEVOQlFVTXNXVUZCVlN4RFFVRkRMRTFCUVVjc1EwRkJRenRKUVVONFFpeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40UXl4SlFVRk5MRk5CUVZNc1IwRkJSeXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVVXNNa0pCUVRKQ08xRkJRMmhHTEUxQlFVMHNRMEZCUXl4bFFVRmhMRU5CUVVNc1YwRkJTeXhUUVVGVExGRkJRVWtzUTBGQlF6dEpRVU14UXl4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZGUkR0SlFVRXJRaXh4UTBGQldUdEpRVTk2UXl4dFFrRkJXU3hMUVVGdFFqdFJRVUV2UWl4WlFVTkZMR2xDUVVGUExGTkJSMUk3VVVGV1R5eFpRVUZOTEVkQlFXbENMRVZCUVVVc1EwRkJRenRSUVZOb1F5eExRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJRenM3U1VGRGRFSXNRMEZCUXp0SlFWSk5MSGxDUVVGTExFZEJRVm83VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4VFFVRlRMRU5CUVVNc1owSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNNVF5eERRVUZETzBsQlVXRXNZMEZCU1N4SFFVRnNRaXhWUVVGdFFpeExRVUZaTzFGQlF6ZENMRWxCUVUwc1MwRkJTeXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVVZxUWl4SlFVRk5MRmxCUVZrc1IwRkJSeXhMUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4MVFrRkJWeXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFVTXNVVUZCVVN4RlFVRkZMRTlCUVRKQ08xbEJRM0pITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETzFsQlF6VkNMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03VVVGRGJFSXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJSVkFzYzBKQlFYTkNPMUZCUTNSQ0xFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMRzlDUVVGUkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUXl4VFFVRXdRanRaUVVOdVJTeEpRVUZOTEUxQlFVMHNSMEZCUnl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRE8xbEJRMmhETEVsQlFVa3NSMEZCUnl4SFFVRjVReXhKUVVGSkxFTkJRVU03V1VGRGNrUXNaMFJCUVdkRU8xbEJRMmhFTEdsRlFVRnBSVHRaUVVOcVJTd3JRMEZCSzBNN1dVRkRMME1zUlVGQlJTeERRVUZETEVOQlFVTXNjMEpCUVdFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpGQ0xFZEJRVWNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMWxCUTNKQ0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2MwSkJRV0VzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnBETEVkQlFVY3NSMEZCUnl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaENMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNjMEpCUVdFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJwRExFZEJRVWNzUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRWxCUVVrc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUTBGQlF5eERRVUZETEhsRVFVRjVSRHRaUVVVelJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5TTEVWQlFVVXNRMEZCUXl4RFFVRkRMSEZDUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOd1FpeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETzJkQ1FVTnNReXhEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVONlFpeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFZEJRVWNzVVVGQlVTeERRVUZETzJkQ1FVTndReXhEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVONlFpeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFZEJRVWNzVVVGQlVTeERRVUZETzJkQ1FVTndReXhEUVVGRE8xbEJRMGdzUTBGQlF6dFJRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlVnc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eFpRVUZaTEhOQ1FVRmpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEhWQ1FVRjFRanRaUVVOMlFpeExRVUZMTEVOQlFVTXNaVUZCWlN4RFFVRkRMRlZCUVVFc1VVRkJVVHRuUWtGRE5VSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUzBGQlN5eGxRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNdlFpeExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF6dG5Ra0ZEYWtNc1EwRkJRenRuUWtGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUzBGQlN5eHRRa0ZCV1N4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRE1VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2EwSkJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRkRVFzVFVGQlRTeERRVUZETzI5Q1FVTlVMRU5CUVVNN2IwSkJRMFFzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhSUVVGUkxFTkJRVU03WjBKQlEyNURMRU5CUVVNN1dVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZGUkN3NFEwRkJPRU03VVVGRE9VTXNTVUZCVFN4SlFVRkpMRWRCUVVjc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU40UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzU1VGQlNTeERRVUZETEUxQlFVMHNTVUZCU1N4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBNc1NVRkJUU3hIUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1dVRkROVUlzVjBGQlNTeERRVUZETEVkQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGRExFdEJRVXM3WjBKQlEzQkNMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eEhRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkRNVUlzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVjBGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6ZENMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRFpDeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzBsQlF6bENMRU5CUVVNN1NVRkZSQ3h6UWtGQlZ5dzBRa0ZCU3p0aFFVRm9RanRaUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTNKQ0xFTkJRVU03T3p0UFFVRkJPMGxCUjAwc2VVSkJRVXNzUjBGQldpeFZRVUZoTEV0QlFXZENPMUZCUXpOQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NZVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUXk5RExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0SlFVTnFRaXhEUVVGRE8wbEJSVTBzZFVOQlFXMUNMRWRCUVRGQ08xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRja0lzUTBGQlF6dEpRVVZOTEhORFFVRnJRaXhIUVVGNlFqdFJRVUZCTEdsQ1FXTkRPMUZCWWtNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZCTEV0QlFVczdXVUZEZGtNc1NVRkJUU3hKUVVGSkxFZEJRVWNzWlVGQlpTeERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOV0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdXVUZEWkN4RFFVRkRPMWxCUlVRc1NVRkJUU3hQUVVGUExFZEJRWFZDTzJkQ1FVTnNReXhKUVVGSkxFVkJRVVVzVTBGQlV6dG5Ra0ZEWml4SlFVRkpMRTFCUVVFN1owSkJRMG9zUlVGQlJTeEZRVUZGTEV0QlFVczdZVUZEVml4RFFVRkRPMWxCUTBZc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dFJRVU5xUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4RFFVRkRMRXRCUVVzc1NVRkJTU3hGUVVGV0xFTkJRVlVzUTBGQlF5eERRVUZETzBsQlF6ZENMRU5CUVVNN1NVRkRTQ3huUWtGQlF6dEJRVUZFTEVOQlFVTXNRVUV4UjBRc1EwRkJLMElzZFVKQlFWa3NSMEV3UnpGRE8wRkJNVWRaTERoQ1FVRlRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGRhdGFmbG93XzEgPSByZXF1aXJlKFwiLi9kYXRhZmxvd1wiKTtcbnZhciBOb25Qb3NpdGl2ZUZpbHRlck5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vblBvc2l0aXZlRmlsdGVyTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb25Qb3NpdGl2ZUZpbHRlck5vZGUoZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTm9uUG9zaXRpdmVGaWx0ZXJOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25Qb3NpdGl2ZUZpbHRlck5vZGUodXRpbF8xLmV4dGVuZCh7fSwgdGhpcy5fZmlsdGVyKSk7XG4gICAgfTtcbiAgICBOb25Qb3NpdGl2ZUZpbHRlck5vZGUubWFrZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgZmlsdGVyID0gbW9kZWwuY2hhbm5lbHMoKS5yZWR1Y2UoZnVuY3Rpb24gKG5vblBvc2l0aXZlQ29tcG9uZW50LCBjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsKTtcbiAgICAgICAgICAgIGlmICghc2NhbGUgfHwgIW1vZGVsLmZpZWxkKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vblBvc2l0aXZlQ29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9uUG9zaXRpdmVDb21wb25lbnRbbW9kZWwuZmllbGQoY2hhbm5lbCldID0gc2NhbGUudHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuTE9HO1xuICAgICAgICAgICAgcmV0dXJuIG5vblBvc2l0aXZlQ29tcG9uZW50O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoZmlsdGVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9uUG9zaXRpdmVGaWx0ZXJOb2RlKGZpbHRlcik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uUG9zaXRpdmVGaWx0ZXJOb2RlLnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5vblBvc2l0aXZlRmlsdGVyTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB1dGlsXzEua2V5cyh0aGlzLl9maWx0ZXIpLmZpbHRlcihmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZmlsdGVyIGZpZWxkcyAoa2V5cykgd2l0aCB2YWx1ZSA9IHRydWVcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmlsdGVyW2ZpZWxkXTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgICAgICAgICAgICBleHByOiAnZGF0dW1bXCInICsgZmllbGQgKyAnXCJdID4gMCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE5vblBvc2l0aXZlRmlsdGVyTm9kZTtcbn0oZGF0YWZsb3dfMS5EYXRhRmxvd05vZGUpKTtcbmV4cG9ydHMuTm9uUG9zaXRpdmVGaWx0ZXJOb2RlID0gTm9uUG9zaXRpdmVGaWx0ZXJOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm05dWNHOXphWFJwZG1WbWFXeDBaWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5a1lYUmhMMjV2Ym5CdmMybDBhWFpsWm1sc2RHVnlMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVRkJMSEZEUVVGelF6dEJRVU4wUXl4dFEwRkJlVVE3UVVGSGVrUXNkVU5CUVhkRE8wRkJSWGhETzBsQlFUSkRMR2xFUVVGWk8wbEJUM0pFTEN0Q1FVRlpMRTFCUVhGQ08xRkJRV3BETEZsQlEwVXNhVUpCUVU4c1UwRkhVanRSUVVSRExFdEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NUVUZCVFN4RFFVRkRPenRKUVVONFFpeERRVUZETzBsQlVrMHNjVU5CUVVzc1IwRkJXanRSUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEhGQ1FVRnhRaXhEUVVGRExHRkJRVTBzUTBGQlF5eEZRVUZGTEVWQlFVVXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE4wUXNRMEZCUXp0SlFWRmhMREJDUVVGSkxFZEJRV3hDTEZWQlFXMUNMRXRCUVdkQ08xRkJRMnBETEVsQlFVMHNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVXl4dlFrRkJiMElzUlVGQlJTeFBRVUZQTzFsQlF6TkZMRWxCUVUwc1MwRkJTeXhIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRia01zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNFTXNjVUpCUVhGQ08yZENRVU55UWl4TlFVRk5MRU5CUVVNc2IwSkJRVzlDTEVOQlFVTTdXVUZET1VJc1EwRkJRenRaUVVORUxHOUNRVUZ2UWl4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExHbENRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRPMWxCUXpGRkxFMUJRVTBzUTBGQlF5eHZRa0ZCYjBJc1EwRkJRenRSUVVNNVFpeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkZVQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm9ReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlEyUXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhKUVVGSkxIRkNRVUZ4UWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8wbEJRek5ETEVOQlFVTTdTVUZGUkN4elFrRkJTU3g1UTBGQlRUdGhRVUZXTzFsQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU03VVVGRGRFSXNRMEZCUXpzN08wOUJRVUU3U1VGRlRTeDNRMEZCVVN4SFFVRm1PMUZCUVVFc2FVSkJWVU03VVVGVVF5eE5RVUZOTEVOQlFVTXNWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4TFFVRkxPMWxCUTNKRExEaERRVUU0UXp0WlFVTTVReXhOUVVGTkxFTkJRVU1zUzBGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVNM1FpeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJVeXhMUVVGTE8xbEJRMjVDTEUxQlFVMHNRMEZCUXp0blFrRkRUQ3hKUVVGSkxFVkJRVVVzVVVGQlVUdG5Ra0ZEWkN4SlFVRkpMRVZCUVVVc1UwRkJVeXhIUVVGSExFdEJRVXNzUjBGQlJ5eFJRVUZSTzJGQlEyUXNRMEZCUXp0UlFVTjZRaXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZEU0N3MFFrRkJRenRCUVVGRUxFTkJRVU1zUVVFNVEwUXNRMEZCTWtNc2RVSkJRVmtzUjBFNFEzUkVPMEZCT1VOWkxITkVRVUZ4UWlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIERFRkFVTFRfTlVMTF9GSUxURVJTID0ge1xuICAgIG5vbWluYWw6IGZhbHNlLFxuICAgIG9yZGluYWw6IGZhbHNlLFxuICAgIHF1YW50aXRhdGl2ZTogdHJ1ZSxcbiAgICB0ZW1wb3JhbDogdHJ1ZVxufTtcbnZhciBOdWxsRmlsdGVyTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTnVsbEZpbHRlck5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVsbEZpbHRlck5vZGUoZmllbGRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9maWx0ZXJlZEZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOdWxsRmlsdGVyTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVsbEZpbHRlck5vZGUodXRpbF8xLmR1cGxpY2F0ZSh0aGlzLl9maWx0ZXJlZEZpZWxkcykpO1xuICAgIH07XG4gICAgTnVsbEZpbHRlck5vZGUubWFrZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgZmllbGRzID0gbW9kZWwucmVkdWNlRmllbGREZWYoZnVuY3Rpb24gKGFnZ3JlZ2F0b3IsIGZpZWxkRGVmKSB7XG4gICAgICAgICAgICBpZiAoZmllbGREZWYuYWdncmVnYXRlICE9PSAnY291bnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmNvbmZpZy5maWx0ZXJJbnZhbGlkIHx8XG4gICAgICAgICAgICAgICAgICAgIChtb2RlbC5jb25maWcuZmlsdGVySW52YWxpZCA9PT0gdW5kZWZpbmVkICYmIChmaWVsZERlZi5maWVsZCAmJiBERUZBVUxUX05VTExfRklMVEVSU1tmaWVsZERlZi50eXBlXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0b3JbZmllbGREZWYuZmllbGRdID0gZmllbGREZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbmUgdGhpcyBzbyB3ZSBrbm93IHRoYXQgd2UgZG9uJ3QgZmlsdGVyIG51bGxzIGZvciB0aGlzIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIG1lcmdlIGludG8gcGFyZW50c1xuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdG9yW2ZpZWxkRGVmLmZpZWxkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0b3I7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZpZWxkcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE51bGxGaWx0ZXJOb2RlKGZpZWxkcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTnVsbEZpbHRlck5vZGUucHJvdG90eXBlLCBcImZpbHRlcmVkRmllbGRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWRGaWVsZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE51bGxGaWx0ZXJOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdCA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpbHRlcmVkRmllbGRzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyAnICcgKyB1dGlsXzEuaGFzaChfdGhpcy5fZmlsdGVyZWRGaWVsZHNba10pOyB9KTtcbiAgICAgICAgdmFyIG8gPSBPYmplY3Qua2V5cyhvdGhlci5maWx0ZXJlZEZpZWxkcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgJyAnICsgdXRpbF8xLmhhc2gob3RoZXIuZmlsdGVyZWRGaWVsZHNba10pOyB9KTtcbiAgICAgICAgaWYgKCF1dGlsXzEuZGlmZmVyQXJyYXkodCwgbykpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcmVkRmllbGRzID0gdXRpbF8xLmV4dGVuZCh0aGlzLl9maWx0ZXJlZEZpZWxkcywgb3RoZXIuX2ZpbHRlcmVkRmllbGRzKTtcbiAgICAgICAgICAgIG90aGVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOdWxsRmlsdGVyTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gdXRpbF8xLmtleXModGhpcy5fZmlsdGVyZWRGaWVsZHMpLnJlZHVjZShmdW5jdGlvbiAoX2ZpbHRlcnMsIGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgZmllbGREZWYgPSBfdGhpcy5fZmlsdGVyZWRGaWVsZHNbZmllbGRdO1xuICAgICAgICAgICAgaWYgKGZpZWxkRGVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2ZpbHRlcnMucHVzaChcImRhdHVtW1wiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKGZpZWxkRGVmLmZpZWxkKSArIFwiXSAhPT0gbnVsbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodXRpbF8xLmNvbnRhaW5zKFt0eXBlXzEuUVVBTlRJVEFUSVZFLCB0eXBlXzEuVEVNUE9SQUxdLCBmaWVsZERlZi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtbGl0ZS9pc3N1ZXMvMTQzNik6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBiZSBldmVuIHNtYXJ0ZXIgYW5kIGFkZCBOYU4gZmlsdGVyIGZvciBOLE8gdGhhdCBhcmUgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAvLyBiYXNlZCBvbiB0aGUgYHBhcnNlYCBwcm9wZXJ0eSBvbmNlIHdlIGhhdmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIF9maWx0ZXJzLnB1c2goXCIhaXNOYU4oZGF0dW1bXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUoZmllbGREZWYuZmllbGQpICsgXCJdKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2ZpbHRlcnM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICAgICAgZXhwcjogZmlsdGVycy5qb2luKCcgJiYgJylcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE51bGxGaWx0ZXJOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5OdWxsRmlsdGVyTm9kZSA9IE51bGxGaWx0ZXJOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm5Wc2JHWnBiSFJsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyUmhkR0V2Ym5Wc2JHWnBiSFJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZEUVN4dFEwRkJhMFE3UVVGRGJFUXNiVU5CUVRKSE8wRkJTVE5ITEhWRFFVRjNRenRCUVVkNFF5eEpRVUZOTEc5Q1FVRnZRaXhIUVVGSE8wbEJRek5DTEU5QlFVOHNSVUZCUlN4TFFVRkxPMGxCUTJRc1QwRkJUeXhGUVVGRkxFdEJRVXM3U1VGRFpDeFpRVUZaTEVWQlFVVXNTVUZCU1R0SlFVTnNRaXhSUVVGUkxFVkJRVVVzU1VGQlNUdERRVU5tTEVOQlFVTTdRVUZGUmp0SlFVRnZReXd3UTBGQldUdEpRVTg1UXl4M1FrRkJXU3hOUVVFNFFqdFJRVUV4UXl4WlFVTkZMR2xDUVVGUExGTkJSMUk3VVVGRVF5eExRVUZKTEVOQlFVTXNaVUZCWlN4SFFVRkhMRTFCUVUwc1EwRkJRenM3U1VGRGFFTXNRMEZCUXp0SlFWSk5MRGhDUVVGTExFZEJRVm83VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4alFVRmpMRU5CUVVNc1owSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNM1JDeERRVUZETzBsQlVXRXNiVUpCUVVrc1IwRkJiRUlzVlVGQmJVSXNTMEZCY1VJN1VVRkRkRU1zU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMR05CUVdNc1EwRkJReXhWUVVGRExGVkJRV3RETEVWQlFVVXNVVUZCVVR0WlFVTXZSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4TFFVRkxMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyNURMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNZVUZCWVR0dlFrRkROVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1MwRkJTeXhUUVVGVExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4SlFVRkpMRzlDUVVGdlFpeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTjRSeXhWUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRkZCUVZFc1EwRkJRenRuUWtGRGVFTXNRMEZCUXp0blFrRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dHZRa0ZEVGl4dFJVRkJiVVU3YjBKQlEyNUZMRFpEUVVFMlF6dHZRa0ZETjBNc1ZVRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRM0JETEVOQlFVTTdXVUZEU0N4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF6dFJRVU53UWl4RFFVRkRMRVZCUVVVc1JVRkJORUlzUTBGQlF5eERRVUZETzFGQlJXcERMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU5rTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hqUVVGakxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEY0VNc1EwRkJRenRKUVVWRUxITkNRVUZKTERCRFFVRmpPMkZCUVd4Q08xbEJRMGtzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNN1VVRkRhRU1zUTBGQlF6czdPMDlCUVVFN1NVRkZUU3c0UWtGQlN5eEhRVUZhTEZWQlFXRXNTMEZCY1VJN1VVRkJiRU1zYVVKQlVVTTdVVUZRUXl4SlFVRk5MRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExGZEJRVWtzUTBGQlF5eExRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRWFpETEVOQlFYVkRMRU5CUVVNc1EwRkJRenRSUVVNNVJpeEpRVUZOTEVOQlFVTXNSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRmRCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVhaRExFTkJRWFZETEVOQlFVTXNRMEZCUXp0UlFVVTVSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEd0Q1FVRlhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhKUVVGSkxFTkJRVU1zWlVGQlpTeEhRVUZITEdGQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hGUVVGRkxFdEJRVXNzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0WlFVTXpSU3hMUVVGTExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdVVUZEYWtJc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRlRTeHBRMEZCVVN4SFFVRm1PMUZCUVVFc2FVSkJiMEpETzFGQmJrSkRMRWxCUVUwc1QwRkJUeXhIUVVGSExGZEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVczdXVUZEYUVVc1NVRkJUU3hSUVVGUkxFZEJRVWNzUzBGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRaUVVNM1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVJc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZUTEd0Q1FVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eGxRVUZaTEVOQlFVTXNRMEZCUXp0blFrRkRhRVVzUlVGQlJTeERRVUZETEVOQlFVTXNaVUZCVVN4RFFVRkRMRU5CUVVNc2JVSkJRVmtzUlVGQlJTeGxRVUZSTEVOQlFVTXNSVUZCUlN4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTjBSQ3gxUkVGQmRVUTdiMEpCUTNaRUxIRkZRVUZ4UlR0dlFrRkRja1VzYVVSQlFXbEVPMjlDUVVOcVJDeFJRVUZSTEVOQlFVTXNTVUZCU1N4RFFVRkRMR3RDUVVGblFpeHJRa0ZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlNTeERRVUZETEVOQlFVTTdaMEpCUTJwRkxFTkJRVU03V1VGRFNDeERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRSUVVOc1FpeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkZVQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRPMWxCUTNaQ08yZENRVU5GTEVsQlFVa3NSVUZCUlN4UlFVRlJPMmRDUVVOa0xFbEJRVWtzUlVGQlJTeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRoUVVNelFpeEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTmlMRU5CUVVNN1NVRkRTQ3h4UWtGQlF6dEJRVUZFTEVOQlFVTXNRVUYwUlVRc1EwRkJiME1zZFVKQlFWa3NSMEZ6UlM5RE8wRkJkRVZaTEhkRFFVRmpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIGZvcm1hdHBhcnNlXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRwYXJzZVwiKTtcbnZhciBzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZVwiKTtcbi8qKlxuICogU3RhcnQgb3B0aW1pemF0aW9uIHBhdGggYXQgdGhlIGxlYXZlcy4gVXNlZnVsIGZvciBtZXJnaW5nIHVwIG9yIHJlbW92aW5nIHRoaW5ncy5cbiAqXG4gKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVlLCB0aGUgcmVjdXJzaW9uIGNvbnRpbnVlcy5cbiAqL1xuZnVuY3Rpb24gaXRlcmF0ZUZyb21MZWF2ZXMoZikge1xuICAgIGZ1bmN0aW9uIG9wdGltaXplTmV4dEZyb21MZWF2ZXMobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIHNvdXJjZV8xLlNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dCA9IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoZihub2RlKSkge1xuICAgICAgICAgICAgb3B0aW1pemVOZXh0RnJvbUxlYXZlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW1pemVOZXh0RnJvbUxlYXZlcztcbn1cbmV4cG9ydHMuaXRlcmF0ZUZyb21MZWF2ZXMgPSBpdGVyYXRlRnJvbUxlYXZlcztcbi8qKlxuICogTW92ZSBwYXJzZSBub2RlcyB1cCB0byBmb3Jrcy5cbiAqL1xuZnVuY3Rpb24gbW92ZVBhcnNlVXAobm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAvLyBtb3ZlIHBhcnNlIHVwIGJ5IG1lcmdpbmcgb3Igc3dhcHBpbmdcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGZvcm1hdHBhcnNlXzEuUGFyc2VOb2RlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBzb3VyY2VfMS5Tb3VyY2VOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5udW1DaGlsZHJlbigpID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIGZvcm1hdHBhcnNlXzEuUGFyc2VOb2RlKSB7XG4gICAgICAgICAgICBwYXJlbnQubWVyZ2Uobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnN3YXBXaXRoUGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLm1vdmVQYXJzZVVwID0gbW92ZVBhcnNlVXA7XG4vKipcbiAqIFJlcGVhdGVkbHkgcmVtb3ZlIGxlYWYgbm9kZXMgdGhhdCBhcmUgbm90IG91dHB1dCBub2Rlcy5cbiAqIFRoZSByZWFzb24gaXMgdGhhdCB3ZSBkb24ndCBuZWVkIHN1YnRyZWVzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgb3V0cHV0IG5vZGVzLlxuICovXG5mdW5jdGlvbiByZW1vdmVVbnVzZWRTdWJ0cmVlcyhub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgZGF0YWZsb3dfMS5PdXRwdXROb2RlIHx8IG5vZGUubnVtQ2hpbGRyZW4oKSA+IDApIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBjb250aW51ZSB3aXRoIHBhcmVudCBiZWNhdXNlIGl0IGlzIG91dHB1dCBub2RlIG9yIHdpbGwgaGF2ZSBjaGlsZHJlbiAodGhlcmUgd2FzIGEgZm9yaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnJlbW92ZVVudXNlZFN1YnRyZWVzID0gcmVtb3ZlVW51c2VkU3VidHJlZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liM0IwYVcxcGVtVnljeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDJSaGRHRXZiM0IwYVcxcGVtVnljeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVZEJMSFZEUVVGdlJEdEJRVVZ3UkN3MlEwRkJkME03UVVGRmVFTXNiVU5CUVc5RE8wRkJTM0JET3pzN08wZEJTVWM3UVVGRFNDd3lRa0ZCYTBNc1EwRkJhME03U1VGRGJFVXNaME5CUVdkRExFbEJRV3RDTzFGQlEyaEVMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzV1VGQldTeHRRa0ZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlFpeE5RVUZOTEVOQlFVTTdVVUZEVkN4RFFVRkRPMUZCUlVRc1NVRkJUU3hKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTjZRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMW9zYzBKQlFYTkNMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGREwwSXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zYzBKQlFYTkNMRU5CUVVNN1FVRkRhRU1zUTBGQlF6dEJRV0pFTERoRFFXRkRPMEZCUlVRN08wZEJSVWM3UVVGRFNDeHhRa0ZCTkVJc1NVRkJhMEk3U1VGRE5VTXNTVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dEpRVVV6UWl4MVEwRkJkVU03U1VGRGRrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3haUVVGWkxIVkNRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpsQ0xFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNXVUZCV1N4dFFrRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRMllzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhYUVVGWExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeFpRVUZaTEhWQ1FVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGNrSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzU1VGQlNTeERRVUZETEdOQlFXTXNSVUZCUlN4RFFVRkRPMUZCUTNoQ0xFTkJRVU03U1VGRFNDeERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOa0xFTkJRVU03UVVGeVFrUXNhME5CY1VKRE8wRkJSVVE3T3p0SFFVZEhPMEZCUTBnc09FSkJRWEZETEVsQlFXdENPMGxCUTNKRUxFbEJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkZNMElzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4WlFVRlpMSEZDUVVGVkxFbEJRVWtzU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVrUXNjVWRCUVhGSE8xRkJRM0pITEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1NVRkRaaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU03U1VGRGFFSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlZrUXNiMFJCVlVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbnZhciBmYWNldF8xID0gcmVxdWlyZShcIi4uL2ZhY2V0XCIpO1xudmFyIGxheWVyXzEgPSByZXF1aXJlKFwiLi4vbGF5ZXJcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi9tb2RlbFwiKTtcbnZhciB1bml0XzEgPSByZXF1aXJlKFwiLi4vdW5pdFwiKTtcbnZhciBhZ2dyZWdhdGVfMSA9IHJlcXVpcmUoXCIuL2FnZ3JlZ2F0ZVwiKTtcbnZhciBiaW5fMSA9IHJlcXVpcmUoXCIuL2JpblwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG52YXIgZmFjZXRfMiA9IHJlcXVpcmUoXCIuL2ZhY2V0XCIpO1xudmFyIGZvcm1hdHBhcnNlXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRwYXJzZVwiKTtcbnZhciBub25wb3NpdGl2ZWZpbHRlcl8xID0gcmVxdWlyZShcIi4vbm9ucG9zaXRpdmVmaWx0ZXJcIik7XG52YXIgbnVsbGZpbHRlcl8xID0gcmVxdWlyZShcIi4vbnVsbGZpbHRlclwiKTtcbnZhciBwYXRob3JkZXJfMSA9IHJlcXVpcmUoXCIuL3BhdGhvcmRlclwiKTtcbnZhciBzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZVwiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4vc3RhY2tcIik7XG52YXIgdGltZXVuaXRfMSA9IHJlcXVpcmUoXCIuL3RpbWV1bml0XCIpO1xudmFyIHRyYW5zZm9ybXNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybXNcIik7XG5mdW5jdGlvbiBwYXJzZVJvb3QobW9kZWwsIHNvdXJjZXMpIHtcbiAgICBpZiAobW9kZWwuZGF0YSB8fCAhbW9kZWwucGFyZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBtb2RlbCBkZWZpbmVzIGEgZGF0YSBzb3VyY2Ugb3IgaXMgdGhlIHJvb3QsIGNyZWF0ZSBhIHNvdXJjZSBub2RlXG4gICAgICAgIHZhciBzb3VyY2UgPSBuZXcgc291cmNlXzEuU291cmNlTm9kZShtb2RlbCk7XG4gICAgICAgIHZhciBoYXNoID0gc291cmNlLmhhc2goKTtcbiAgICAgICAgaWYgKGhhc2ggaW4gc291cmNlcykge1xuICAgICAgICAgICAgLy8gdXNlIGEgcmVmZXJlbmNlIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNvdXJjZVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZXNbaGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWRkIGEgbmV3IG9uZVxuICAgICAgICAgICAgc291cmNlc1toYXNoXSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBzb3VyY2UgZGVmaW5lZCAob3ZlcnJpZGluZyBwYXJlbnQncyBkYXRhKSwgdXNlIHRoZSBwYXJlbnQncyBmYWNldCByb290IG9yIG1haW4uXG4gICAgICAgIHJldHVybiBtb2RlbC5wYXJlbnQuY29tcG9uZW50LmRhdGEuZmFjZXRSb290ID8gbW9kZWwucGFyZW50LmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdCA6IG1vZGVsLnBhcmVudC5jb21wb25lbnQuZGF0YS5tYWluO1xuICAgIH1cbn1cbi8qXG5EZXNjcmlwdGlvbiBvZiB0aGUgZGF0YWZsb3cgKGh0dHA6Ly9hc2NpaWZsb3cuY29tLyk6XG5cbiAgICAgKy0tLS0tLS0tK1xuICAgICB8IFNvdXJjZSB8XG4gICAgICstLS0rLS0tLStcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICAgICBQYXJzZVxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICBUcmFuc2Zvcm1zXG4oRmlsdGVyLCBDb21wdXRlLCAuLi4pXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgIE51bGwgRmlsdGVyXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgICBCaW5uaW5nXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgIFRpbWV1bml0XG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgICArLS0rLS0rXG4gICAgICB8IFJhdyB8XG4gICAgICArLS0tLS0rXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgIEFnZ3JlZ2F0ZVxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICAgIFN0YWNrXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgICA+MCBGaWx0ZXJcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICAgUGF0aCBPcmRlclxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgKy0tLS0tLS0tLS0rXG4gICB8ICAgTWFpbiAgIHxcbiAgICstLS0tLS0tLS0tK1xuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICArLS0tLS0tLStcbiAgICAgfCBGYWNldCB8LS0tLT4gXCJjb2x1bW5cIiwgXCJjb2x1bW4tbGF5b3V0XCIsIGFuZCBcInJvd1wiXG4gICAgICstLS0tLS0tK1xuICAgICAgICAgfFxuICAgICAgICAgdlxuICAuLi5DaGlsZCBkYXRhLi4uXG5cbiovXG5mdW5jdGlvbiBwYXJzZURhdGEobW9kZWwpIHtcbiAgICB2YXIgcm9vdCA9IHBhcnNlUm9vdChtb2RlbCwgbW9kZWwuY29tcG9uZW50LmRhdGEuc291cmNlcyk7XG4gICAgdmFyIG91dHB1dE5vZGVzID0gbW9kZWwuY29tcG9uZW50LmRhdGEub3V0cHV0Tm9kZXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgdHJlZSB0aGF0IHdlIGFyZSBhcHBlbmRpbmcgdG9cbiAgICB2YXIgaGVhZCA9IHJvb3Q7XG4gICAgdmFyIHBhcnNlID0gZm9ybWF0cGFyc2VfMS5QYXJzZU5vZGUubWFrZShtb2RlbCk7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICAgIHBhcnNlLnBhcmVudCA9IHJvb3Q7XG4gICAgICAgIGhlYWQgPSBwYXJzZTtcbiAgICB9XG4gICAgLy8gSEFDSzogVGhpcyBpcyBlcXVpdmFsZW50IGZvciBtZXJnaW5nIGJpbiBleHRlbnQgZm9yIHVuaW9uIHNjYWxlLlxuICAgIC8vIEZJWE1FKGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtbGl0ZS9pc3N1ZXMvMjI3MCk6IENvcnJlY3RseSBtZXJnZSBleHRlbnQgLyBiaW4gbm9kZSBmb3Igc2hhcmVkIGJpbiBzY2FsZVxuICAgIHZhciBwYXJlbnRJc0xheWVyID0gbW9kZWwucGFyZW50ICYmIChtb2RlbC5wYXJlbnQgaW5zdGFuY2VvZiBsYXllcl8xLkxheWVyTW9kZWwpO1xuICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIG1vZGVsXzEuTW9kZWxXaXRoRmllbGQpIHtcbiAgICAgICAgaWYgKHBhcmVudElzTGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBiaW4gPSBiaW5fMS5CaW5Ob2RlLm1ha2UobW9kZWwpO1xuICAgICAgICAgICAgaWYgKGJpbikge1xuICAgICAgICAgICAgICAgIGJpbi5wYXJlbnQgPSBoZWFkO1xuICAgICAgICAgICAgICAgIGhlYWQgPSBiaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGVsLnRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX2EgPSB0cmFuc2Zvcm1zXzEucGFyc2VUcmFuc2Zvcm1BcnJheShtb2RlbCksIGZpcnN0ID0gX2EuZmlyc3QsIGxhc3QgPSBfYS5sYXN0O1xuICAgICAgICBmaXJzdC5wYXJlbnQgPSBoZWFkO1xuICAgICAgICBoZWFkID0gbGFzdDtcbiAgICB9XG4gICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgbW9kZWxfMS5Nb2RlbFdpdGhGaWVsZCkge1xuICAgICAgICB2YXIgbnVsbEZpbHRlciA9IG51bGxmaWx0ZXJfMS5OdWxsRmlsdGVyTm9kZS5tYWtlKG1vZGVsKTtcbiAgICAgICAgaWYgKG51bGxGaWx0ZXIpIHtcbiAgICAgICAgICAgIG51bGxGaWx0ZXIucGFyZW50ID0gaGVhZDtcbiAgICAgICAgICAgIGhlYWQgPSBudWxsRmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50SXNMYXllcikge1xuICAgICAgICAgICAgdmFyIGJpbiA9IGJpbl8xLkJpbk5vZGUubWFrZShtb2RlbCk7XG4gICAgICAgICAgICBpZiAoYmluKSB7XG4gICAgICAgICAgICAgICAgYmluLnBhcmVudCA9IGhlYWQ7XG4gICAgICAgICAgICAgICAgaGVhZCA9IGJpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHUgPSB0aW1ldW5pdF8xLlRpbWVVbml0Tm9kZS5tYWtlKG1vZGVsKTtcbiAgICAgICAgaWYgKHR1KSB7XG4gICAgICAgICAgICB0dS5wYXJlbnQgPSBoZWFkO1xuICAgICAgICAgICAgaGVhZCA9IHR1O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBhbiBvdXRwdXQgbm9kZSBwcmUgYWdncmVnYXRpb25cbiAgICB2YXIgcmF3TmFtZSA9IG1vZGVsLmdldE5hbWUoZGF0YV8xLlJBVyk7XG4gICAgdmFyIHJhdyA9IG5ldyBkYXRhZmxvd18xLk91dHB1dE5vZGUocmF3TmFtZSwgZGF0YV8xLlJBVyk7XG4gICAgb3V0cHV0Tm9kZXNbcmF3TmFtZV0gPSByYXc7XG4gICAgcmF3LnBhcmVudCA9IGhlYWQ7XG4gICAgaGVhZCA9IHJhdztcbiAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiB1bml0XzEuVW5pdE1vZGVsKSB7XG4gICAgICAgIHZhciBhZ2cgPSBhZ2dyZWdhdGVfMS5BZ2dyZWdhdGVOb2RlLm1ha2UobW9kZWwpO1xuICAgICAgICBpZiAoYWdnKSB7XG4gICAgICAgICAgICBhZ2cucGFyZW50ID0gaGVhZDtcbiAgICAgICAgICAgIGhlYWQgPSBhZ2c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YWNrID0gc3RhY2tfMS5TdGFja05vZGUubWFrZShtb2RlbCk7XG4gICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgc3RhY2sucGFyZW50ID0gaGVhZDtcbiAgICAgICAgICAgIGhlYWQgPSBzdGFjaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9uUG9zRmlsdGVyID0gbm9ucG9zaXRpdmVmaWx0ZXJfMS5Ob25Qb3NpdGl2ZUZpbHRlck5vZGUubWFrZShtb2RlbCk7XG4gICAgICAgIGlmIChub25Qb3NGaWx0ZXIpIHtcbiAgICAgICAgICAgIG5vblBvc0ZpbHRlci5wYXJlbnQgPSBoZWFkO1xuICAgICAgICAgICAgaGVhZCA9IG5vblBvc0ZpbHRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiB1bml0XzEuVW5pdE1vZGVsKSB7XG4gICAgICAgIHZhciBvcmRlciA9IHBhdGhvcmRlcl8xLk9yZGVyTm9kZS5tYWtlKG1vZGVsKTtcbiAgICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgICAgICBvcmRlci5wYXJlbnQgPSBoZWFkO1xuICAgICAgICAgICAgaGVhZCA9IG9yZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG91dHB1dCBub2RlIGZvciBtYXJrc1xuICAgIHZhciBtYWluTmFtZSA9IG1vZGVsLmdldE5hbWUoZGF0YV8xLk1BSU4pO1xuICAgIHZhciBtYWluID0gbmV3IGRhdGFmbG93XzEuT3V0cHV0Tm9kZShtYWluTmFtZSwgZGF0YV8xLk1BSU4pO1xuICAgIG91dHB1dE5vZGVzW21haW5OYW1lXSA9IG1haW47XG4gICAgbWFpbi5wYXJlbnQgPSBoZWFkO1xuICAgIGhlYWQgPSBtYWluO1xuICAgIC8vIGFkZCBmYWNldCBtYXJrZXJcbiAgICB2YXIgZmFjZXRSb290ID0gbnVsbDtcbiAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBmYWNldF8xLkZhY2V0TW9kZWwpIHtcbiAgICAgICAgdmFyIGZhY2V0TmFtZSA9IG1vZGVsLmdldE5hbWUoJ2ZhY2V0Jyk7XG4gICAgICAgIGZhY2V0Um9vdCA9IG5ldyBmYWNldF8yLkZhY2V0Tm9kZShtb2RlbCwgZmFjZXROYW1lLCBtYWluLnNvdXJjZSk7XG4gICAgICAgIG91dHB1dE5vZGVzW2ZhY2V0TmFtZV0gPSBmYWNldFJvb3Q7XG4gICAgICAgIGZhY2V0Um9vdC5wYXJlbnQgPSBoZWFkO1xuICAgICAgICBoZWFkID0gZmFjZXRSb290O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VzOiBtb2RlbC5jb21wb25lbnQuZGF0YS5zb3VyY2VzLFxuICAgICAgICBvdXRwdXROb2Rlczogb3V0cHV0Tm9kZXMsXG4gICAgICAgIG1haW46IG1haW4sXG4gICAgICAgIGZhY2V0Um9vdDogZmFjZXRSb290XG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VEYXRhID0gcGFyc2VEYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0dGeWMyVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlrWVhSaEwzQmhjbk5sTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzYlVOQlFYRkRPMEZCUlhKRExHdERRVUZ2UXp0QlFVTndReXhyUTBGQmIwTTdRVUZEY0VNc2EwTkJRU3RETzBGQlF5OURMR2REUVVGclF6dEJRVU5zUXl4NVEwRkJNRU03UVVGRE1VTXNOa0pCUVRoQ08wRkJRemxDTEhWRFFVRnZSRHRCUVVOd1JDeHBRMEZCYTBNN1FVRkRiRU1zTmtOQlFYZERPMEZCUlhoRExIbEVRVUV3UkR0QlFVTXhSQ3d5UTBGQk5FTTdRVUZETlVNc2VVTkJRWE5ETzBGQlEzUkRMRzFEUVVGdlF6dEJRVU53UXl4cFEwRkJhME03UVVGRGJFTXNkVU5CUVhkRE8wRkJRM2hETERKRFFVRnBSRHRCUVVWcVJDeHRRa0ZCYlVJc1MwRkJXU3hGUVVGRkxFOUJRWGxDTzBsQlEzaEVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5vUXl3d1JVRkJNRVU3VVVGRE1VVXNTVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3h0UWtGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUTNKRExFbEJRVTBzU1VGQlNTeEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRSUVVNelFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRWxCUVVrc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UWl3NFEwRkJPRU03V1VGRE9VTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU4yUWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpd3dRa0ZCTUVJN1dVRkRNVUlzVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRTFCUVUwc1EwRkJRenRaUVVOMlFpeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTJoQ0xFTkJRVU03U1VGRFNDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXh4UjBGQmNVYzdVVUZEY2tjc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzBsQlF6RklMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJSVVE3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPMFZCY1VSRk8wRkJSVVlzYlVKQlFUQkNMRXRCUVZrN1NVRkRjRU1zU1VGQlRTeEpRVUZKTEVkQlFVY3NVMEZCVXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVVMVJDeEpRVUZOTEZkQlFWY3NSMEZCUnl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdTVUZGY2tRc2QwUkJRWGRFTzBsQlEzaEVMRWxCUVVrc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dEpRVVZvUWl4SlFVRk5MRXRCUVVzc1IwRkJSeXgxUWtGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVOd1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMVlzUzBGQlN5eERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkRjRUlzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXp0SlFVTm1MRU5CUVVNN1NVRkZSQ3h0UlVGQmJVVTdTVUZEYmtVc0swZEJRU3RITzBsQlF5OUhMRWxCUVUwc1lVRkJZU3hIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3haUVVGWkxHdENRVUZWTEVOQlFVTXNRMEZCUXp0SlFVTXpSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEZsQlFWa3NjMEpCUVdNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUWl4SlFVRk5MRWRCUVVjc1IwRkJSeXhoUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMWxCUTJoRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMUlzUjBGQlJ5eERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRMnhDTEVsQlFVa3NSMEZCUnl4SFFVRkhMRU5CUVVNN1dVRkRZaXhEUVVGRE8xRkJRMGdzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRekZDTEVsQlFVRXNORU5CUVRCRExFVkJRWHBETEdkQ1FVRkxMRVZCUVVVc1kwRkJTU3hEUVVFclFqdFJRVU5xUkN4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF6dFJRVU53UWl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1dVRkJXU3h6UWtGQll5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndReXhKUVVGTkxGVkJRVlVzUjBGQlJ5d3lRa0ZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU01UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyWXNWVUZCVlN4RFFVRkRMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU03V1VGRGVrSXNTVUZCU1N4SFFVRkhMRlZCUVZVc1EwRkJRenRSUVVOd1FpeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNUNMRWxCUVUwc1IwRkJSeXhIUVVGSExHRkJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkRhRU1zUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRFVpeEhRVUZITEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJRenRuUWtGRGJFSXNTVUZCU1N4SFFVRkhMRWRCUVVjc1EwRkJRenRaUVVOaUxFTkJRVU03VVVGRFNDeERRVUZETzFGQlJVUXNTVUZCVFN4RlFVRkZMRWRCUVVjc2RVSkJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRjRU1zUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOUUxFVkJRVVVzUTBGQlF5eE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRPMWxCUTJwQ0xFbEJRVWtzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZEV2l4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxIRkRRVUZ4UXp0SlFVTnlReXhKUVVGTkxFOUJRVThzUjBGQlJ5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVjc1EwRkJReXhEUVVGRE8wbEJRMjVETEVsQlFVMHNSMEZCUnl4SFFVRkhMRWxCUVVrc2NVSkJRVlVzUTBGQlF5eFBRVUZQTEVWQlFVVXNWVUZCUnl4RFFVRkRMRU5CUVVNN1NVRkRla01zVjBGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJRenRKUVVNelFpeEhRVUZITEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJRenRKUVVOc1FpeEpRVUZKTEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUlZnc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eFpRVUZaTEdkQ1FVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlDTEVsQlFVMHNSMEZCUnl4SFFVRkhMSGxDUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUTNSRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRVaXhIUVVGSExFTkJRVU1zVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXp0WlFVTnNRaXhKUVVGSkxFZEJRVWNzUjBGQlJ5eERRVUZETzFGQlEySXNRMEZCUXp0UlFVVkVMRWxCUVUwc1MwRkJTeXhIUVVGSExHbENRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRM0JETEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFZpeExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJRenRaUVVOd1FpeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRPMUZCUTJZc1EwRkJRenRSUVVWRUxFbEJRVTBzV1VGQldTeEhRVUZITEhsRFFVRnhRaXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xGbEJRVmtzUTBGQlF5eE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRPMWxCUXpOQ0xFbEJRVWtzUjBGQlJ5eFpRVUZaTEVOQlFVTTdVVUZEZEVJc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRmxCUVZrc1owSkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETDBJc1NVRkJUU3hMUVVGTExFZEJRVWNzY1VKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGNFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5XTEV0QlFVc3NRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE8xbEJRM0JDTEVsQlFVa3NSMEZCUnl4TFFVRkxMRU5CUVVNN1VVRkRaaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZFTEhkQ1FVRjNRanRKUVVONFFpeEpRVUZOTEZGQlFWRXNSMEZCUnl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExGZEJRVWtzUTBGQlF5eERRVUZETzBsQlEzSkRMRWxCUVUwc1NVRkJTU3hIUVVGSExFbEJRVWtzY1VKQlFWVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1YwRkJTU3hEUVVGRExFTkJRVU03U1VGRE5VTXNWMEZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF6dEpRVU0zUWl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF6dEpRVU51UWl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRE8wbEJSVm9zYlVKQlFXMUNPMGxCUTI1Q0xFbEJRVWtzVTBGQlV5eEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTnlRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEZsQlFWa3NhMEpCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFTXNTVUZCVFN4VFFVRlRMRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTjZReXhUUVVGVExFZEJRVWNzU1VGQlNTeHBRa0ZCVXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hUUVVGVExFVkJRVVVzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTNwRUxGZEJRVmNzUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVNN1VVRkRia01zVTBGQlV5eERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkRlRUlzU1VGQlNTeEhRVUZITEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETzFGQlEwd3NUMEZCVHl4RlFVRkZMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVODdVVUZEY2tNc1YwRkJWeXhoUVVGQk8xRkJRMWdzU1VGQlNTeE5RVUZCTzFGQlEwb3NVMEZCVXl4WFFVRkJPMHRCUTFZc1EwRkJRenRCUVVOS0xFTkJRVU03UVVGcVNFUXNPRUpCYVVoREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vZW5jb2RpbmdcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBzb3J0XzEgPSByZXF1aXJlKFwiLi4vLi4vc29ydFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIE9yZGVyTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3JkZXJOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9yZGVyTm9kZShzb3J0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvcnQgPSBzb3J0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9yZGVyTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3JkZXJOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5zb3J0KSk7XG4gICAgfTtcbiAgICBPcmRlck5vZGUubWFrZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgc29ydCA9IG51bGw7XG4gICAgICAgIGlmICh1dGlsXzEuY29udGFpbnMoWydsaW5lJywgJ2FyZWEnXSwgbW9kZWwubWFyaygpKSkge1xuICAgICAgICAgICAgaWYgKG1vZGVsLm1hcmsoKSA9PT0gJ2xpbmUnICYmIG1vZGVsLmNoYW5uZWxIYXNGaWVsZCgnb3JkZXInKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBvbmx5IGxpbmUsIHNvcnQgYnkgdGhlIG9yZGVyIGZpZWxkIGlmIGl0IGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBzb3J0ID0gY29tbW9uXzEuc29ydFBhcmFtcyhtb2RlbC5lbmNvZGluZy5vcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYm90aCBsaW5lIGFuZCBhcmVhLCB3ZSBzb3J0IHZhbHVlcyBiYXNlZCBvbiBkaW1lbnNpb24gYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb25DaGFubmVsID0gbW9kZWwubWFya0RlZi5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG1vZGVsLnNvcnQoZGltZW5zaW9uQ2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRGaWVsZCA9IHNvcnRfMS5pc1NvcnRGaWVsZChzKSA/XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkZGVmXzEuZmllbGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgb3AgbWlnaHQgbm90IGFscmVhZHkgZXhpc3Q/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogd2hhdCBpZiBkaW1lbnNpb25DaGFubmVsICh4IG9yIHkpIGNvbnRhaW5zIGN1c3RvbSBkb21haW4/XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGU6IGVuY29kaW5nXzEuaXNBZ2dyZWdhdGUobW9kZWwuZW5jb2RpbmcpID8gcy5vcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzLmZpZWxkXG4gICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZmllbGQoZGltZW5zaW9uQ2hhbm5lbCwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSk7XG4gICAgICAgICAgICAgICAgc29ydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNvcnRGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICdkZXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9yZGVyTm9kZShzb3J0KTtcbiAgICB9O1xuICAgIE9yZGVyTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY29sbGVjdCcsXG4gICAgICAgICAgICBzb3J0OiB0aGlzLnNvcnRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBPcmRlck5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLk9yZGVyTm9kZSA9IE9yZGVyTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNHRjBhRzl5WkdWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZaR0YwWVM5d1lYUm9iM0prWlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc01rTkJRVEpETzBGQlF6TkRMREpEUVVGeFF6dEJRVU55UXl4dFEwRkJkVU03UVVGRGRrTXNiVU5CUVN0RE8wRkJSeTlETEc5RFFVRnhRenRCUVVWeVF5eDFRMEZCZDBNN1FVRkZlRU03U1VGQkswSXNjVU5CUVZrN1NVRkxla01zYlVKQlFXOUNMRWxCUVZrN1VVRkJhRU1zV1VGRFJTeHBRa0ZCVHl4VFFVTlNPMUZCUm0xQ0xGVkJRVWtzUjBGQlNpeEpRVUZKTEVOQlFWRTdPMGxCUldoRExFTkJRVU03U1VGT1RTeDVRa0ZCU3l4SFFVRmFPMUZCUTBVc1RVRkJUU3hEUVVGRExFbEJRVWtzVTBGQlV5eERRVUZETEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETjBNc1EwRkJRenRKUVUxaExHTkJRVWtzUjBGQmJFSXNWVUZCYlVJc1MwRkJaMEk3VVVGRGFrTXNTVUZCU1N4SlFVRkpMRWRCUVZjc1NVRkJTU3hEUVVGRE8xRkJSWGhDTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVZFc1EwRkJReXhEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4TFFVRkxMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE9VUXNOa1JCUVRaRU8yZENRVU0zUkN4SlFVRkpMRWRCUVVjc2JVSkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRekZETEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeDFSVUZCZFVVN1owSkJRM1pGTEVsQlFVMHNaMEpCUVdkQ0xFZEJRV01zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRXRCUVVzc1dVRkJXU3hIUVVGSExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTTdaMEpCUTNSR0xFbEJRVTBzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXp0blFrRkRka01zU1VGQlRTeFRRVUZUTEVkQlFVY3NhMEpCUVZjc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlF6bENMR2RDUVVGTExFTkJRVU03ZDBKQlEwb3NNRU5CUVRCRE8zZENRVU14UXl4dFJVRkJiVVU3ZDBKQlEyNUZMRk5CUVZNc1JVRkJSU3h6UWtGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEZOQlFWTTdkMEpCUTNwRUxFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3p0eFFrRkRaaXhEUVVGRE8yOUNRVU5HTEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1owSkJRV2RDTEVWQlFVVXNSVUZCUXl4VFFVRlRMRVZCUVVVc1QwRkJUeXhGUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZGZEVRc1NVRkJTU3hIUVVGSE8yOUNRVU5NTEV0QlFVc3NSVUZCUlN4VFFVRlRPMjlDUVVOb1FpeExRVUZMTEVWQlFVVXNXVUZCV1R0cFFrRkRjRUlzUTBGQlF6dFpRVU5LTEVOQlFVTTdVVUZEU0N4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJRc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNM1FpeERRVUZETzBsQlJVMHNORUpCUVZFc1IwRkJaanRSUVVORkxFMUJRVTBzUTBGQlF6dFpRVU5NTEVsQlFVa3NSVUZCUlN4VFFVRlRPMWxCUTJZc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTzFOQlEyaENMRU5CUVVNN1NVRkRTaXhEUVVGRE8wbEJRMGdzWjBKQlFVTTdRVUZCUkN4RFFVRkRMRUZCTDBORUxFTkJRU3RDTEhWQ1FVRlpMRWRCSzBNeFF6dEJRUzlEV1N3NFFrRkJVeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG52YXIgU291cmNlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU291cmNlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlKG1vZGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gbW9kZWwuZGF0YSB8fCB7IG5hbWU6ICdzb3VyY2UnIH07XG4gICAgICAgIGlmIChkYXRhXzEuaXNJbmxpbmVEYXRhKGRhdGEpKSB7XG4gICAgICAgICAgICBfdGhpcy5fZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGEudmFsdWVzLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogeyB0eXBlOiAnanNvbicgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhXzEuaXNVcmxEYXRhKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGV4dGVuc2lvbiBmcm9tIFVSTCB1c2luZyBzbmlwcGV0IGZyb21cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjgwOTI5L2hvdy10by1leHRyYWN0LWV4dGVuc2lvbi1mcm9tLWZpbGVuYW1lLXN0cmluZy1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEV4dGVuc2lvbiA9IC8oPzpcXC4oW14uXSspKT8kLy5leGVjKGRhdGEudXJsKVsxXTtcbiAgICAgICAgICAgIGlmICghdXRpbF8xLmNvbnRhaW5zKFsnanNvbicsICdjc3YnLCAndHN2JywgJ3RvcG9qc29uJ10sIGRlZmF1bHRFeHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEV4dGVuc2lvbiA9ICdqc29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhRm9ybWF0ID0gZGF0YS5mb3JtYXQgfHwge307XG4gICAgICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3IgZm9ybWVyIGBkYXRhLmZvcm1hdFR5cGVgIHByb3BlcnR5XG4gICAgICAgICAgICB2YXIgZm9ybWF0VHlwZSA9IGRhdGFGb3JtYXQudHlwZSB8fCBkYXRhWydmb3JtYXRUeXBlJ107XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBkYXRhRm9ybWF0LnByb3BlcnR5LCBmZWF0dXJlID0gZGF0YUZvcm1hdC5mZWF0dXJlLCBtZXNoID0gZGF0YUZvcm1hdC5tZXNoO1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRzbGliXzEuX19hc3NpZ24oeyB0eXBlOiBmb3JtYXRUeXBlID8gZm9ybWF0VHlwZSA6IGRlZmF1bHRFeHRlbnNpb24gfSwgKHByb3BlcnR5ID8geyBwcm9wZXJ0eTogcHJvcGVydHkgfSA6IHt9KSwgKGZlYXR1cmUgPyB7IGZlYXR1cmU6IGZlYXR1cmUgfSA6IHt9KSwgKG1lc2ggPyB7IG1lc2g6IG1lc2ggfSA6IHt9KSk7XG4gICAgICAgICAgICBfdGhpcy5fZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFfMS5pc05hbWVkRGF0YShkYXRhKSkge1xuICAgICAgICAgICAgX3RoaXMuX25hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgICBfdGhpcy5fZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU5vZGUucHJvdG90eXBlLCBcImRhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS5oYXNOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9uYW1lO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU5vZGUucHJvdG90eXBlLCBcImRhdGFOYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VOb2RlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIG5vZGVzIGhhdmUgdG8gYmUgcm9vdHMuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2Ugbm9kZXMgYXJlIHJvb3RzIGFuZCBjYW5ub3QgYmUgcmVtb3ZlZC4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHVuaXF1ZSBpZGVudGlmaXIgZm9yIHRoaXMgZGF0YSBzb3VyY2UuXG4gICAgICovXG4gICAgU291cmNlTm9kZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRhdGFfMS5pc0lubGluZURhdGEodGhpcy5fZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuaGFzaCh0aGlzLl9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhXzEuaXNVcmxEYXRhKHRoaXMuX2RhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS51cmwgKyBcIiBcIiArIHV0aWxfMS5oYXNoKHRoaXMuX2RhdGEuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oeyBuYW1lOiB0aGlzLl9uYW1lIH0sIHRoaXMuX2RhdGEsIHsgdHJhbnNmb3JtOiBbXSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTb3VyY2VOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMyOTFjbU5sTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdlpHRjBZUzl6YjNWeVkyVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlFVRXNiVU5CUVRSRk8wRkJRelZGTEcxRFFVRXdRenRCUVVjeFF5eDFRMEZCZDBNN1FVRkZlRU03U1VGQlowTXNjME5CUVZrN1NVRkxNVU1zYjBKQlFWa3NTMEZCV1R0UlFVRjRRaXhaUVVORkxHbENRVUZQTEZOQmNVTlNPMUZCYmtORExFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRWxCUVVrc1JVRkJReXhKUVVGSkxFVkJRVVVzVVVGQlVTeEZRVUZETEVOQlFVTTdVVUZGTlVNc1JVRkJSU3hEUVVGRExFTkJRVU1zYlVKQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrSXNTMEZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSenRuUWtGRFdDeE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRMRTFCUVUwN1owSkJRMjVDTEUxQlFVMHNSVUZCUlN4RlFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFVkJRVU03WVVGRGRrSXNRMEZCUXp0UlFVTktMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETTBJc1owUkJRV2RFTzFsQlEyaEVMSGRIUVVGM1J6dFpRVU40Unl4SlFVRkpMR2RDUVVGblFpeEhRVUZITEdsQ1FVRnBRaXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE0wUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hWUVVGVkxFTkJRVU1zUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEY0VVc1owSkJRV2RDTEVkQlFVY3NUVUZCVFN4RFFVRkRPMWxCUXpWQ0xFTkJRVU03V1VGRFJDeEpRVUZOTEZWQlFWVXNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hKUVVGSkxFVkJRVVVzUTBGQlF6dFpRVVZ5UXl4dFJVRkJiVVU3V1VGRGJrVXNTVUZCVFN4VlFVRlZMRWRCUVdVc1ZVRkJWU3hEUVVGRExFbEJRVWtzU1VGQlNTeEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1dVRkRPVVFzU1VGQlFTdzRRa0ZCVVN4RlFVRkZMRFJDUVVGUExFVkJRVVVzYzBKQlFVa3NRMEZCWlR0WlFVVTNReXhKUVVGTkxFMUJRVTBzYzBKQlExWXNTVUZCU1N4RlFVRkZMRlZCUVZVc1IwRkJSeXhWUVVGVkxFZEJRVWNzWjBKQlFXZENMRWxCUXpkRExFTkJRVU1zVVVGQlVTeEhRVUZITEVWQlFVTXNVVUZCVVN4VlFVRkJMRVZCUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zUlVGRE5VSXNRMEZCUXl4UFFVRlBMRWRCUVVjc1JVRkJReXhQUVVGUExGTkJRVUVzUlVGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RlFVTXhRaXhEUVVGRExFbEJRVWtzUjBGQlJ5eEZRVUZETEVsQlFVa3NUVUZCUVN4RlFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRM2hDTEVOQlFVTTdXVUZGUml4TFFVRkpMRU5CUVVNc1MwRkJTeXhIUVVGSE8yZENRVU5ZTEVkQlFVY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1IwRkJSenRuUWtGRFlpeE5RVUZOTEZGQlFVRTdZVUZEVUN4RFFVRkRPMUZCUTBvc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4clFrRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTNRaXhMUVVGSkxFTkJRVU1zUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRka0lzUzBGQlNTeERRVUZETEV0QlFVc3NSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRiRUlzUTBGQlF6czdTVUZEU0N4RFFVRkRPMGxCUlVRc2MwSkJRVWtzTkVKQlFVazdZVUZCVWp0WlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlEzQkNMRU5CUVVNN096dFBRVUZCTzBsQlJVMHNORUpCUVU4c1IwRkJaRHRSUVVORkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVOMFFpeERRVUZETzBsQlJVUXNjMEpCUVVrc1owTkJRVkU3WVVGQldqdFpRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRM0JDTEVOQlFVTTdZVUZGUkN4VlFVRmhMRWxCUVZrN1dVRkRka0lzU1VGQlNTeERRVUZETEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkRjRUlzUTBGQlF6czdPMDlCU2tFN1NVRk5SQ3h6UWtGQlNTdzRRa0ZCVFR0aFFVRldMRlZCUVZjc1RVRkJiMEk3V1VGRE4wSXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhuUTBGQlowTXNRMEZCUXl4RFFVRkRPMUZCUTNCRUxFTkJRVU03T3p0UFFVRkJPMGxCUlUwc01rSkJRVTBzUjBGQllqdFJRVU5GTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc0swTkJRU3RETEVOQlFVTXNRMEZCUXp0SlFVTnVSU3hEUVVGRE8wbEJSVVE3TzA5QlJVYzdTVUZEU1N4NVFrRkJTU3hIUVVGWU8xRkJRMFVzUlVGQlJTeERRVUZETEVOQlFVTXNiVUpCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFMUJRVTBzUTBGQlF5eFhRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRekZDTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycERMRTFCUVUwc1EwRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NVMEZCU1N4WFFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVY3NRMEZCUXp0UlFVTjRSQ3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU53UWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWTkxEWkNRVUZSTEVkQlFXWTdVVUZEUlN4TlFVRk5MRzlDUVVOS0xFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNTMEZCU3l4SlFVTmlMRWxCUVVrc1EwRkJReXhMUVVGTExFbEJRMklzVTBGQlV5eEZRVUZGTEVWQlFVVXNTVUZEWWp0SlFVTktMRU5CUVVNN1NVRkRTQ3hwUWtGQlF6dEJRVUZFTEVOQlFVTXNRVUY2UmtRc1EwRkJaME1zZFVKQlFWa3NSMEY1UmpORE8wRkJla1paTEdkRFFVRlZJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB2ZWdhX3V0aWxfMSA9IHJlcXVpcmUoXCJ2ZWdhLXV0aWxcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG5mdW5jdGlvbiBnZXRTdGFja0J5RmllbGRzKG1vZGVsKSB7XG4gICAgcmV0dXJuIG1vZGVsLnN0YWNrLnN0YWNrQnkucmVkdWNlKGZ1bmN0aW9uIChmaWVsZHMsIGJ5KSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gYnkuY2hhbm5lbDtcbiAgICAgICAgdmFyIGZpZWxkRGVmID0gYnkuZmllbGREZWY7XG4gICAgICAgIHZhciBzY2FsZSA9IG1vZGVsLnNjYWxlKGNoYW5uZWwpO1xuICAgICAgICB2YXIgX2ZpZWxkID0gZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwge1xuICAgICAgICAgICAgYmluU3VmZml4OiBzY2FsZSAmJiBzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHNjYWxlLnR5cGUpID8gJ3JhbmdlJyA6ICdzdGFydCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfZmllbGQpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKF9maWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9LCBbXSk7XG59XG52YXIgU3RhY2tOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGFja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2tOb2RlKHN0YWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0YWNrTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5fc3RhY2spKTtcbiAgICB9O1xuICAgIFN0YWNrTm9kZS5tYWtlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBzdGFja1Byb3BlcnRpZXMgPSBtb2RlbC5zdGFjaztcbiAgICAgICAgaWYgKCFzdGFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cGJ5ID0gW107XG4gICAgICAgIGlmIChzdGFja1Byb3BlcnRpZXMuZ3JvdXBieUNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBncm91cGJ5RmllbGREZWYgPSBtb2RlbC5maWVsZERlZihzdGFja1Byb3BlcnRpZXMuZ3JvdXBieUNoYW5uZWwpO1xuICAgICAgICAgICAgaWYgKGdyb3VwYnlGaWVsZERlZi5iaW4pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgQmluLCB3ZSBuZWVkIHRvIGFkZCBib3RoIHN0YXJ0IGFuZCBlbmQgdG8gZW5zdXJlIHRoYXQgYm90aCBnZXQgaW1wdXRlZFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpbmNsdWRlZCBpbiB0aGUgc3RhY2sgb3V0cHV0IChodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzLzE4MDUpLlxuICAgICAgICAgICAgICAgIGdyb3VwYnkucHVzaChtb2RlbC5maWVsZChzdGFja1Byb3BlcnRpZXMuZ3JvdXBieUNoYW5uZWwsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pKTtcbiAgICAgICAgICAgICAgICBncm91cGJ5LnB1c2gobW9kZWwuZmllbGQoc3RhY2tQcm9wZXJ0aWVzLmdyb3VwYnlDaGFubmVsLCB7IGJpblN1ZmZpeDogJ2VuZCcgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBieS5wdXNoKG1vZGVsLmZpZWxkKHN0YWNrUHJvcGVydGllcy5ncm91cGJ5Q2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFja2J5ID0gZ2V0U3RhY2tCeUZpZWxkcyhtb2RlbCk7XG4gICAgICAgIHZhciBvcmRlckRlZiA9IG1vZGVsLmVuY29kaW5nLm9yZGVyO1xuICAgICAgICB2YXIgc29ydDtcbiAgICAgICAgaWYgKG9yZGVyRGVmKSB7XG4gICAgICAgICAgICBzb3J0ID0gY29tbW9uXzEuc29ydFBhcmFtcyhvcmRlckRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0ID0gZGVzY2VuZGluZyBieSBzdGFja0ZpZWxkc1xuICAgICAgICAgICAgLy8gRklYTUUgaXMgdGhlIGRlZmF1bHQgaGVyZSBjb3JyZWN0IGZvciBiaW5uZWQgZmllbGRzP1xuICAgICAgICAgICAgc29ydCA9IHN0YWNrYnkucmVkdWNlKGZ1bmN0aW9uIChzLCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHMuZmllbGQucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgcy5vcmRlci5wdXNoKCdkZXNjZW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9LCB7IGZpZWxkOiBbXSwgb3JkZXI6IFtdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tOb2RlKHtcbiAgICAgICAgICAgIGdyb3VwYnk6IGdyb3VwYnksXG4gICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoc3RhY2tQcm9wZXJ0aWVzLmZpZWxkQ2hhbm5lbCksXG4gICAgICAgICAgICBzdGFja2J5OiBzdGFja2J5LFxuICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgIG9mZnNldDogc3RhY2tQcm9wZXJ0aWVzLm9mZnNldCxcbiAgICAgICAgICAgIGltcHV0ZTogdXRpbF8xLmNvbnRhaW5zKFsnYXJlYScsICdsaW5lJ10sIG1vZGVsLm1hcmsoKSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrTm9kZS5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RhY2tOb2RlLnByb3RvdHlwZS5hZGREaW1lbnNpb25zID0gZnVuY3Rpb24gKGZpZWxkcykge1xuICAgICAgICB0aGlzLl9zdGFjay5ncm91cGJ5ID0gdGhpcy5fc3RhY2suZ3JvdXBieS5jb25jYXQoZmllbGRzKTtcbiAgICB9O1xuICAgIFN0YWNrTm9kZS5wcm90b3R5cGUuZGVwZW5kZW50RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIG91dFt0aGlzLl9zdGFjay5maWVsZF0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGFjay5ncm91cGJ5LmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG91dFtmXSA9IHRydWU7IH0pO1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLl9zdGFjay5zb3J0LmZpZWxkO1xuICAgICAgICB2ZWdhX3V0aWxfMS5pc0FycmF5KGZpZWxkKSA/IGZpZWxkLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG91dFtmXSA9IHRydWU7IH0pIDogb3V0W2ZpZWxkXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBTdGFja05vZGUucHJvdG90eXBlLnByb2R1Y2VkRmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIG91dFt0aGlzLl9zdGFjay5maWVsZCArICdfc3RhcnQnXSA9IHRydWU7XG4gICAgICAgIG91dFt0aGlzLl9zdGFjay5maWVsZCArICdfZW5kJ10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgU3RhY2tOb2RlLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFtdO1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICAgICAgLy8gSW1wdXRlXG4gICAgICAgIGlmIChzdGFjay5pbXB1dGUpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaW1wdXRlJyxcbiAgICAgICAgICAgICAgICBmaWVsZDogc3RhY2suZmllbGQsXG4gICAgICAgICAgICAgICAgZ3JvdXBieTogc3RhY2suc3RhY2tieSxcbiAgICAgICAgICAgICAgICBvcmRlcmJ5OiBzdGFjay5ncm91cGJ5LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhY2tcbiAgICAgICAgdHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3N0YWNrJyxcbiAgICAgICAgICAgIGdyb3VwYnk6IHN0YWNrLmdyb3VwYnksXG4gICAgICAgICAgICBmaWVsZDogc3RhY2suZmllbGQsXG4gICAgICAgICAgICBzb3J0OiBzdGFjay5zb3J0LFxuICAgICAgICAgICAgYXM6IFtcbiAgICAgICAgICAgICAgICBzdGFjay5maWVsZCArICdfc3RhcnQnLFxuICAgICAgICAgICAgICAgIHN0YWNrLmZpZWxkICsgJ19lbmQnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFjay5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2tOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5TdGFja05vZGUgPSBTdGFja05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1JoWTJzdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDNOMFlXTnJMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVRkJMSFZEUVVGclF6dEJRVU5zUXl3eVEwRkJjVU03UVVGRGNrTXNjVU5CUVRoRE8wRkJSVGxETEcxRFFVRXJRenRCUVVVdlF5eHZRMEZCY1VNN1FVRkZja01zZFVOQlFYZERPMEZCUlhoRExEQkNRVUV3UWl4TFFVRm5RanRKUVVONFF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFVTXNUVUZCVFN4RlFVRkZMRVZCUVVVN1VVRkRNME1zU1VGQlRTeFBRVUZQTEVkQlFVY3NSVUZCUlN4RFFVRkRMRTlCUVU4c1EwRkJRenRSUVVNelFpeEpRVUZOTEZGQlFWRXNSMEZCUnl4RlFVRkZMRU5CUVVNc1VVRkJVU3hEUVVGRE8xRkJSVGRDTEVsQlFVMHNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEYmtNc1NVRkJUU3hOUVVGTkxFZEJRVWNzWjBKQlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVN1dVRkROMElzVTBGQlV5eEZRVUZGTEV0QlFVc3NTVUZCU1N4NVFrRkJhVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1QwRkJUeXhIUVVGSExFOUJRVTg3VTBGRGRFVXNRMEZCUXl4RFFVRkRPMUZCUTBnc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEZEVJc1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZEYUVJc1EwRkJReXhGUVVGRkxFVkJRV01zUTBGQlF5eERRVUZETzBGQlEzSkNMRU5CUVVNN1FVRm5RMFE3U1VGQkswSXNjVU5CUVZrN1NVRlBla01zYlVKQlFWa3NTMEZCY1VJN1VVRkJha01zV1VGRFJTeHBRa0ZCVHl4VFFVZFNPMUZCUkVNc1MwRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTTdPMGxCUTNSQ0xFTkJRVU03U1VGU1RTeDVRa0ZCU3l4SFFVRmFPMUZCUTBVc1RVRkJUU3hEUVVGRExFbEJRVWtzVTBGQlV5eERRVUZETEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETDBNc1EwRkJRenRKUVZGaExHTkJRVWtzUjBGQmJFSXNWVUZCYlVJc1MwRkJaMEk3VVVGRmFrTXNTVUZCVFN4bFFVRmxMRWRCUVVjc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF6dFJRVVZ3UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU5rTEVOQlFVTTdVVUZGUkN4SlFVRk5MRTlCUVU4c1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRGJrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1NVRkJUU3hsUVVGbExFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4bFFVRmxMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU03V1VGRGRrVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoQ0xEWkZRVUUyUlR0blFrRkROMFVzYjBaQlFXOUdPMmRDUVVOd1JpeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEdOQlFXTXNSVUZCUlN4RlFVRkRMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJoR0xFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zWTBGQll5eEZRVUZGTEVWQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1JVRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUml4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WjBKQlEwNHNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZFTEVOQlFVTTdVVUZEU0N4RFFVRkRPMUZCUlVRc1NVRkJUU3hQUVVGUExFZEJRVWNzWjBKQlFXZENMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGVFTXNTVUZCVFN4UlFVRlJMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZGZEVNc1NVRkJTU3hKUVVGWkxFTkJRVU03VVVGRGFrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5pTEVsQlFVa3NSMEZCUnl4dFFrRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzFGQlF6bENMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEhORFFVRnpRenRaUVVOMFF5eDFSRUZCZFVRN1dVRkRka1FzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJReXhEUVVGRExFVkJRVVVzUzBGQlN6dG5Ra0ZETjBJc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1owSkJRM0JDTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETzJkQ1FVTXpRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRExFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVXNSVUZCUlN4RlFVRkRMRU5CUVVNc1EwRkJRenRSUVVNMVFpeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRE8xbEJRMjVDTEU5QlFVOHNVMEZCUVR0WlFVTlFMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4WlFVRlpMRU5CUVVNN1dVRkRhRVFzVDBGQlR5eFRRVUZCTzFsQlExQXNTVUZCU1N4TlFVRkJPMWxCUTBvc1RVRkJUU3hGUVVGRkxHVkJRV1VzUTBGQlF5eE5RVUZOTzFsQlF6bENMRTFCUVUwc1JVRkJSU3hsUVVGUkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVWQlFVVXNUVUZCVFN4RFFVRkRMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETzFOQlEycEVMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJDeHpRa0ZCU1N3MFFrRkJTenRoUVVGVU8xbEJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1VVRkRja0lzUTBGQlF6czdPMDlCUVVFN1NVRkZUU3hwUTBGQllTeEhRVUZ3UWl4VlFVRnhRaXhOUVVGblFqdFJRVU51UXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZETTBRc1EwRkJRenRKUVVWTkxHMURRVUZsTEVkQlFYUkNPMUZCUTBVc1NVRkJUU3hIUVVGSExFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJXWXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUXpsQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGQkxFTkJRVU1zU1VGQlNTeFBRVUZCTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFVkJRV0lzUTBGQllTeERRVUZETEVOQlFVTTdVVUZEYUVRc1NVRkJUU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRM0pETEcxQ1FVRlBMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRU5CUVVNc1NVRkJTU3hQUVVGQkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4SlFVRkpMRVZCUVdJc1EwRkJZU3hEUVVGRExFZEJRVWNzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVWMlJTeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRPMGxCUTJJc1EwRkJRenRKUVVWTkxHdERRVUZqTEVkQlFYSkNPMUZCUTBVc1NVRkJUU3hIUVVGSExFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJXWXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEhRVUZITEZGQlFWRXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVONlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFZEJRVWNzVFVGQlRTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUlhaRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTTdTVUZEWWl4RFFVRkRPMGxCUlUwc05FSkJRVkVzUjBGQlpqdFJRVU5GTEVsQlFVMHNVMEZCVXl4SFFVRnJRaXhGUVVGRkxFTkJRVU03VVVGRmNFTXNTVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVVV4UWl4VFFVRlRPMUZCUTFRc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha0lzVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXp0blFrRkRZaXhKUVVGSkxFVkJRVVVzVVVGQlVUdG5Ra0ZEWkN4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXM3WjBKQlEyeENMRTlCUVU4c1JVRkJSU3hMUVVGTExFTkJRVU1zVDBGQlR6dG5Ra0ZEZEVJc1QwRkJUeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTzJkQ1FVTjBRaXhOUVVGTkxFVkJRVVVzVDBGQlR6dG5Ra0ZEWml4TFFVRkxMRVZCUVVVc1EwRkJRenRoUVVOVUxFTkJRVU1zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZGUkN4UlFVRlJPMUZCUTFJc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF6dFpRVU5pTEVsQlFVa3NSVUZCUlN4UFFVRlBPMWxCUTJJc1QwRkJUeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTzFsQlEzUkNMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zUzBGQlN6dFpRVU5zUWl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWs3V1VGRGFFSXNSVUZCUlN4RlFVRkZPMmRDUVVOR0xFdEJRVXNzUTBGQlF5eExRVUZMTEVkQlFVY3NVVUZCVVR0blFrRkRkRUlzUzBGQlN5eERRVUZETEV0QlFVc3NSMEZCUnl4TlFVRk5PMkZCUTNKQ08xbEJRMFFzVFVGQlRTeEZRVUZGTEV0QlFVc3NRMEZCUXl4TlFVRk5PMU5CUTNKQ0xFTkJRVU1zUTBGQlF6dFJRVVZJTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVU5JTEdkQ1FVRkRPMEZCUVVRc1EwRkJReXhCUVhoSVJDeERRVUVyUWl4MVFrRkJXU3hIUVhkSU1VTTdRVUY0U0Zrc09FSkJRVk1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciB0aW1ldW5pdF8xID0gcmVxdWlyZShcIi4uLy4uL3RpbWV1bml0XCIpO1xudmFyIHR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGRhdGFmbG93XzEgPSByZXF1aXJlKFwiLi9kYXRhZmxvd1wiKTtcbnZhciBUaW1lVW5pdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVVbml0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lVW5pdE5vZGUoZm9ybXVsYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mb3JtdWxhID0gZm9ybXVsYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lVW5pdE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVVbml0Tm9kZSh1dGlsXzEuZHVwbGljYXRlKHRoaXMuZm9ybXVsYSkpO1xuICAgIH07XG4gICAgVGltZVVuaXROb2RlLm1ha2UgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGZvcm11bGEgPSBtb2RlbC5yZWR1Y2VGaWVsZERlZihmdW5jdGlvbiAodGltZVVuaXRDb21wb25lbnQsIGZpZWxkRGVmKSB7XG4gICAgICAgICAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLlRFTVBPUkFMICYmIGZpZWxkRGVmLnRpbWVVbml0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmKTtcbiAgICAgICAgICAgICAgICB0aW1lVW5pdENvbXBvbmVudFtmXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYXM6IGYsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVVbml0OiBmaWVsZERlZi50aW1lVW5pdCxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkRGVmLmZpZWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aW1lVW5pdENvbXBvbmVudDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZm9ybXVsYSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVVbml0Tm9kZShmb3JtdWxhKTtcbiAgICB9O1xuICAgIFRpbWVVbml0Tm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5mb3JtdWxhID0gdXRpbF8xLmV4dGVuZCh0aGlzLmZvcm11bGEsIG90aGVyLmZvcm11bGEpO1xuICAgICAgICBvdGhlci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIFRpbWVVbml0Tm9kZS5wcm90b3R5cGUucHJvZHVjZWRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgdXRpbF8xLnZhbHModGhpcy5mb3JtdWxhKS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBvdXRbZi5hc10gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFRpbWVVbml0Tm9kZS5wcm90b3R5cGUuZGVwZW5kZW50RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIHV0aWxfMS52YWxzKHRoaXMuZm9ybXVsYSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgb3V0W2YuZmllbGRdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBUaW1lVW5pdE5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLnZhbHModGhpcy5mb3JtdWxhKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvcm11bGEnLFxuICAgICAgICAgICAgICAgIGFzOiBjLmFzLFxuICAgICAgICAgICAgICAgIGV4cHI6IHRpbWV1bml0XzEuZmllbGRFeHByKGMudGltZVVuaXQsIGMuZmllbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lVW5pdE5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLlRpbWVVbml0Tm9kZSA9IFRpbWVVbml0Tm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHbHRaWFZ1YVhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDNScGJXVjFibWwwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096dEJRVU5CTERKRFFVRXJRenRCUVVNdlF5d3lRMEZCYlVRN1FVRkRia1FzYlVOQlFXOURPMEZCUTNCRExHMURRVUZ2UlR0QlFVbHdSU3gxUTBGQmQwTTdRVUZUZUVNN1NVRkJhME1zZDBOQlFWazdTVUZMTlVNc2MwSkJRVzlDTEU5QlFXZERPMUZCUVhCRUxGbEJRMFVzYVVKQlFVOHNVMEZEVWp0UlFVWnRRaXhoUVVGUExFZEJRVkFzVDBGQlR5eERRVUY1UWpzN1NVRkZjRVFzUTBGQlF6dEpRVTVOTERSQ1FVRkxMRWRCUVZvN1VVRkRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeFpRVUZaTEVOQlFVTXNaMEpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTnVSQ3hEUVVGRE8wbEJUV0VzYVVKQlFVa3NSMEZCYkVJc1ZVRkJiVUlzUzBGQmNVSTdVVUZEZEVNc1NVRkJUU3hQUVVGUExFZEJRVWNzUzBGQlN5eERRVUZETEdOQlFXTXNRMEZCUXl4VlFVRkRMR2xDUVVGdlF5eEZRVUZGTEZGQlFWRTdXVUZEYkVZc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NTMEZCU3l4bFFVRlJMRWxCUVVrc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNCRUxFbEJRVTBzUTBGQlF5eEhRVUZITEdkQ1FVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03WjBKQlF6RkNMR2xDUVVGcFFpeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhPMjlDUVVOeVFpeEZRVUZGTEVWQlFVVXNRMEZCUXp0dlFrRkRUQ3hSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEZGQlFWRTdiMEpCUXpOQ0xFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNTMEZCU3p0cFFrRkRkRUlzUTBGQlF6dFpRVU5LTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc2FVSkJRV2xDTEVOQlFVTTdVVUZETTBJc1EwRkJReXhGUVVGRkxFVkJRVFpDTEVOQlFVTXNRMEZCUXp0UlFVVnNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFbEJRVWtzV1VGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUTI1RExFTkJRVU03U1VGRlRTdzBRa0ZCU3l4SFFVRmFMRlZCUVdFc1MwRkJiVUk3VVVGRE9VSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhoUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRGJrUXNTMEZCU3l4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8wbEJRMnBDTEVOQlFVTTdTVUZGVFN4eFEwRkJZeXhIUVVGeVFqdFJRVU5GTEVsQlFVMHNSMEZCUnl4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVWbUxGZEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVUVzUTBGQlF6dFpRVU14UWl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVTnVRaXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVZJTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNN1NVRkRZaXhEUVVGRE8wbEJSVTBzYzBOQlFXVXNSMEZCZEVJN1VVRkRSU3hKUVVGTkxFZEJRVWNzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZGWml4WFFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRU5CUVVNN1dVRkRNVUlzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRGRFSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkZTQ3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETzBsQlEySXNRMEZCUXp0SlFVVk5MQ3RDUVVGUkxFZEJRV1k3VVVGRFJTeE5RVUZOTEVOQlFVTXNWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRPMWxCUXpkQ0xFMUJRVTBzUTBGQlF6dG5Ra0ZEVEN4SlFVRkpMRVZCUVVVc1UwRkJVenRuUWtGRFppeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVN1owSkJRMUlzU1VGQlNTeEZRVUZGTEc5Q1FVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRPMkZCUTJZc1EwRkJRenRSUVVNeFFpeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkRTQ3h0UWtGQlF6dEJRVUZFTEVOQlFVTXNRVUV2UkVRc1EwRkJhME1zZFVKQlFWa3NSMEVyUkRkRE8wRkJMMFJaTEc5RFFVRlpJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXJcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuLi8uLi90cmFuc2Zvcm1cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIEZpbHRlck5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZpbHRlck5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyTm9kZShtb2RlbCwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIF90aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaWx0ZXJOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJOb2RlKHRoaXMubW9kZWwsIHV0aWxfMS5kdXBsaWNhdGUodGhpcy5maWx0ZXIpKTtcbiAgICB9O1xuICAgIEZpbHRlck5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICBleHByOiBmaWx0ZXJfMS5leHByZXNzaW9uKHRoaXMubW9kZWwsIHRoaXMuZmlsdGVyKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLkZpbHRlck5vZGUgPSBGaWx0ZXJOb2RlO1xuLyoqXG4gKiBXZSBkb24ndCBrbm93IHdoYXQgYSBjYWxjdWxhdGUgbm9kZSBkZXBlbmRzIG9uIHNvIHdlIHNob3VsZCBuZXZlciBtb3ZlIGl0IGJleW9uZCBhbnl0aGluZyB0aGF0IHByb2R1Y2VzIGZpZWxkcy5cbiAqL1xudmFyIENhbGN1bGF0ZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENhbGN1bGF0ZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsY3VsYXRlTm9kZSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhbGN1bGF0ZU5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENhbGN1bGF0ZU5vZGUodXRpbF8xLmR1cGxpY2F0ZSh0aGlzLnRyYW5zZm9ybSkpO1xuICAgIH07XG4gICAgQ2FsY3VsYXRlTm9kZS5wcm90b3R5cGUucHJvZHVjZWRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgb3V0W3RoaXMudHJhbnNmb3JtLmFzXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBDYWxjdWxhdGVOb2RlLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICAgICAgICAgIGV4cHI6IHRoaXMudHJhbnNmb3JtLmNhbGN1bGF0ZSxcbiAgICAgICAgICAgIGFzOiB0aGlzLnRyYW5zZm9ybS5hc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENhbGN1bGF0ZU5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLkNhbGN1bGF0ZU5vZGUgPSBDYWxjdWxhdGVOb2RlO1xuLyoqXG4gKiBQYXJzZXMgYSB0cmFuc2Zvcm1zIGFycmF5IGludG8gYSBjaGFpbiBvZiBjb25uZWN0ZWQgZGF0YWZsb3cgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtQXJyYXkobW9kZWwpIHtcbiAgICB2YXIgZmlyc3Q7XG4gICAgdmFyIGxhc3Q7XG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIHByZXZpb3VzO1xuICAgIG1vZGVsLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICBpZiAodHJhbnNmb3JtXzEuaXNDYWxjdWxhdGUodCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQ2FsY3VsYXRlTm9kZSh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm1fMS5pc0ZpbHRlcih0KSkge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBGaWx0ZXJOb2RlKG1vZGVsLCB0LmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5pbnZhbGlkVHJhbnNmb3JtSWdub3JlZCh0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGZpcnN0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub2RlO1xuICAgIH0pO1xuICAgIGxhc3QgPSBub2RlO1xuICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogbGFzdCB9O1xufVxuZXhwb3J0cy5wYXJzZVRyYW5zZm9ybUFycmF5ID0gcGFyc2VUcmFuc2Zvcm1BcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmhibk5tYjNKdGN5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMlJoZEdFdmRISmhibk5tYjNKdGN5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGRFFTeDFRMEZCWjBRN1FVRkRhRVFzSzBKQlFXbERPMEZCUTJwRExEWkRRVUV5Ump0QlFVTXpSaXh0UTBGQmNVTTdRVUZIY2tNc2RVTkJRWGRETzBGQlJYaERPMGxCUVdkRExITkRRVUZaTzBsQlN6RkRMRzlDUVVFMlFpeExRVUZaTEVWQlFWVXNUVUZCWXp0UlFVRnFSU3haUVVORkxHbENRVUZQTEZOQlExSTdVVUZHTkVJc1YwRkJTeXhIUVVGTUxFdEJRVXNzUTBGQlR6dFJRVUZWTEZsQlFVMHNSMEZCVGl4TlFVRk5MRU5CUVZFN08wbEJSV3BGTEVOQlFVTTdTVUZPVFN3d1FrRkJTeXhIUVVGYU8xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzWjBKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU0xUkN4RFFVRkRPMGxCVFUwc05rSkJRVkVzUjBGQlpqdFJRVU5GTEUxQlFVMHNRMEZCUXp0WlFVTk1MRWxCUVVrc1JVRkJSU3hSUVVGUk8xbEJRMlFzU1VGQlNTeEZRVUZGTEcxQ1FVRlZMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRPMU5CUXpGRExFTkJRVU03U1VGRFNpeERRVUZETzBsQlEwZ3NhVUpCUVVNN1FVRkJSQ3hEUVVGRExFRkJaa1FzUTBGQlowTXNkVUpCUVZrc1IwRmxNME03UVVGbVdTeG5RMEZCVlR0QlFXbENka0k3TzBkQlJVYzdRVUZEU0R0SlFVRnRReXg1UTBGQldUdEpRVXMzUXl4MVFrRkJiMElzVTBGQk5rSTdVVUZCYWtRc1dVRkRSU3hwUWtGQlR5eFRRVU5TTzFGQlJtMUNMR1ZCUVZNc1IwRkJWQ3hUUVVGVExFTkJRVzlDT3p0SlFVVnFSQ3hEUVVGRE8wbEJUazBzTmtKQlFVc3NSMEZCV2p0UlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxHRkJRV0VzUTBGQlF5eG5Ra0ZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzUkVMRU5CUVVNN1NVRk5UU3h6UTBGQll5eEhRVUZ5UWp0UlFVTkZMRWxCUVUwc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVU5tTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVTTVRaXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETzBsQlEySXNRMEZCUXp0SlFVVk5MR2REUVVGUkxFZEJRV1k3VVVGRFJTeE5RVUZOTEVOQlFVTTdXVUZEVEN4SlFVRkpMRVZCUVVVc1UwRkJVenRaUVVObUxFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNN1dVRkRPVUlzUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1JVRkJSVHRUUVVOMFFpeERRVUZETzBsQlEwb3NRMEZCUXp0SlFVTklMRzlDUVVGRE8wRkJRVVFzUTBGQlF5eEJRWFJDUkN4RFFVRnRReXgxUWtGQldTeEhRWE5DT1VNN1FVRjBRbGtzYzBOQlFXRTdRVUYzUWpGQ096dEhRVVZITzBGQlEwZ3NOa0pCUVc5RExFdEJRVms3U1VGRE9VTXNTVUZCU1N4TFFVRnRRaXhEUVVGRE8wbEJRM2hDTEVsQlFVa3NTVUZCYTBJc1EwRkJRenRKUVVOMlFpeEpRVUZKTEVsQlFXdENMRU5CUVVNN1NVRkRka0lzU1VGQlNTeFJRVUZ6UWl4RFFVRkRPMGxCUlROQ0xFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVNc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRE5VSXNSVUZCUlN4RFFVRkRMRU5CUVVNc2RVSkJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia0lzU1VGQlNTeEhRVUZITEVsQlFVa3NZVUZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemxDTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zYjBKQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrSXNTVUZCU1N4SFFVRkhMRWxCUVVrc1ZVRkJWU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRla01zUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTA0c1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMSFZDUVVGMVFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha1FzVFVGQlRTeERRVUZETzFGQlExUXNRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTFvc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF6dFJRVU5tTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NVVUZCVVN4RFFVRkRPMUZCUTNwQ0xFTkJRVU03VVVGRFJDeFJRVUZSTEVkQlFVY3NTVUZCU1N4RFFVRkRPMGxCUTJ4Q0xFTkJRVU1zUTBGQlF5eERRVUZETzBsQlJVZ3NTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJRenRKUVVWYUxFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NUMEZCUVN4RlFVRkZMRWxCUVVrc1RVRkJRU3hGUVVGRExFTkJRVU03UVVGRGRrSXNRMEZCUXp0QlFUTkNSQ3hyUkVFeVFrTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL2VuY29kaW5nXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vZmllbGRkZWZcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ1wiKTtcbnZhciBtYXJrXzEgPSByZXF1aXJlKFwiLi4vbWFya1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciB2ZWdhX3NjaGVtYV8xID0gcmVxdWlyZShcIi4uL3ZlZ2Euc2NoZW1hXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGFzc2VtYmxlXzEgPSByZXF1aXJlKFwiLi9kYXRhL2Fzc2VtYmxlXCIpO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi9kYXRhL3BhcnNlXCIpO1xudmFyIGhlYWRlcl8xID0gcmVxdWlyZShcIi4vbGF5b3V0L2hlYWRlclwiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgcmVwZWF0XzEgPSByZXF1aXJlKFwiLi9yZXBlYXRcIik7XG52YXIgRmFjZXRNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRmFjZXRNb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGYWNldE1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCByZXBlYXRlciwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNoaWxkID0gY29tbW9uXzEuYnVpbGRNb2RlbChzcGVjLnNwZWMsIF90aGlzLCBfdGhpcy5nZXROYW1lKCdjaGlsZCcpLCB1bmRlZmluZWQsIHJlcGVhdGVyLCBjb25maWcpO1xuICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IFtfdGhpcy5jaGlsZF07XG4gICAgICAgIHZhciBmYWNldCA9IHJlcGVhdF8xLnJlcGxhY2VSZXBlYXRlckluRmFjZXQoc3BlYy5mYWNldCwgcmVwZWF0ZXIpO1xuICAgICAgICBfdGhpcy5mYWNldCA9IF90aGlzLmluaXRGYWNldChmYWNldCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuaW5pdEZhY2V0ID0gZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgICAgIC8vIGNsb25lIHRvIHByZXZlbnQgc2lkZSBlZmZlY3QgdG8gdGhlIG9yaWdpbmFsIHNwZWNcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nXzEucmVkdWNlKGZhY2V0LCBmdW5jdGlvbiAobm9ybWFsaXplZEZhY2V0LCBmaWVsZERlZiwgY2hhbm5lbCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoW2NoYW5uZWxfMS5ST1csIGNoYW5uZWxfMS5DT0xVTU5dLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgIC8vIERyb3AgdW5zdXBwb3J0ZWQgY2hhbm5lbFxuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmluY29tcGF0aWJsZUNoYW5uZWwoY2hhbm5lbCwgJ2ZhY2V0JykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRmFjZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGREZWYuZmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmVtcHR5RmllbGREZWYoZmllbGREZWYsIGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZhY2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udmVydCB0eXBlIHRvIGZ1bGwsIGxvd2VyY2FzZSB0eXBlLCBvciBhdWdtZW50IHRoZSBmaWVsZERlZiB3aXRoIGEgZGVmYXVsdCB0eXBlIGlmIG1pc3NpbmcuXG4gICAgICAgICAgICBub3JtYWxpemVkRmFjZXRbY2hhbm5lbF0gPSBmaWVsZGRlZl8xLm5vcm1hbGl6ZShmaWVsZERlZiwgY2hhbm5lbCk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZhY2V0O1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5jaGFubmVsSGFzRmllbGQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmZhY2V0W2NoYW5uZWxdO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuaGFzRGlzY3JldGVEb21haW4gPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmZpZWxkRGVmID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXRbY2hhbm5lbF07XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5wYXJzZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmRhdGEgPSBwYXJzZV8xLnBhcnNlRGF0YSh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZC5wYXJzZURhdGEoKTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBcyBhIGZhY2V0IGhhcyBhIHNpbmdsZSBjaGlsZCwgdGhlIHNlbGVjdGlvbiBjb21wb25lbnRzIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgLy8gVGhlIGNoaWxkIG1haW50YWlucyBpdHMgc2VsZWN0aW9ucyB0byBhc3NlbWJsZSBzaWduYWxzLCB3aGljaCByZW1haW5cbiAgICAgICAgLy8gd2l0aGluIGl0cyB1bml0LlxuICAgICAgICB0aGlzLmNoaWxkLnBhcnNlU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnNlbGVjdGlvbiA9IHRoaXMuY2hpbGQuY29tcG9uZW50LnNlbGVjdGlvbjtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGQ7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgIGNoaWxkLnBhcnNlU2NhbGUoKTtcbiAgICAgICAgdmFyIHNjYWxlQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQuc2NhbGVzID0ge307XG4gICAgICAgIC8vIFRoZW4sIG1vdmUgc2hhcmVkL3VuaW9uIGZyb20gaXRzIGNoaWxkIHNwZWMuXG4gICAgICAgIHV0aWxfMS5rZXlzKGNoaWxkLmNvbXBvbmVudC5zY2FsZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvcnJlY3RseSBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgc2NhbGVcbiAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZC5jb21wb25lbnQuc2NhbGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZU5hbWVXaXRob3V0UHJlZml4ID0gc2NhbGUubmFtZS5zdWJzdHIoY2hpbGQuZ2V0TmFtZSgnJykubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG1vZGVsLnNjYWxlTmFtZShzY2FsZU5hbWVXaXRob3V0UHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW5hbWVTY2FsZShzY2FsZS5uYW1lLCBuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICBzY2FsZS5uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBzY2FsZSBkb21haW4gd2l0aCBkYXRhIG91dHB1dCBmcm9tIGEgY2xvbmVkIHN1YnRyZWUgYWZ0ZXIgdGhlIGZhY2V0LlxuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG4gICAgICAgICAgICAgICAgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmRG9tYWluKGRvbWFpbikgfHwgdmVnYV9zY2hlbWFfMS5pc0ZpZWxkUmVmVW5pb25Eb21haW4oZG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZGF0YSA9IGFzc2VtYmxlXzEuRkFDRVRfU0NBTEVfUFJFRklYICsgX3RoaXMuZ2V0TmFtZShkb21haW4uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmVW5pb25lZERvbWFpbihkb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5maWVsZHMgPSBkb21haW4uZmllbGRzLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIGYsIHsgZGF0YTogYXNzZW1ibGVfMS5GQUNFVF9TQ0FMRV9QUkVGSVggKyBfdGhpcy5nZXROYW1lKGYuZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbmNlIHB1dCBpbiBwYXJlbnQsIGp1c3QgcmVtb3ZlIHRoZSBjaGlsZCdzIHNjYWxlLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5jb21wb25lbnQuc2NhbGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlTWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5wYXJzZU1hcmsoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQubWFyayA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lKCdjZWxsJyksXG4gICAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb21wb25lbnQuZGF0YS5mYWNldFJvb3QuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwYnk6IFtdLmNvbmNhdCh0aGlzLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsXzEuUk9XKSA/IFt0aGlzLmZpZWxkKGNoYW5uZWxfMS5ST1cpXSA6IFtdLCB0aGlzLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsXzEuQ09MVU1OKSA/IFt0aGlzLmZpZWxkKGNoYW5uZWxfMS5DT0xVTU4pXSA6IFtdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBnZXRGYWNldEdyb3VwUHJvcGVydGllcyh0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzQW5kSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnBhcnNlQXhpc0FuZEhlYWRlcigpO1xuICAgICAgICB0aGlzLnBhcnNlSGVhZGVyKCdjb2x1bW4nKTtcbiAgICAgICAgdGhpcy5wYXJzZUhlYWRlcigncm93Jyk7XG4gICAgICAgIHRoaXMubWVyZ2VDaGlsZEF4aXMoJ3gnKTtcbiAgICAgICAgdGhpcy5tZXJnZUNoaWxkQXhpcygneScpO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUucGFyc2VIZWFkZXIgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsSGFzRmllbGQoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZERlZiA9IHRoaXMuZmFjZXRbY2hhbm5lbF07XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZmllbGREZWYuaGVhZGVyIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gaGVhZGVyLnRpdGxlICE9PSB1bmRlZmluZWQgPyBoZWFkZXIudGl0bGUgOiBmaWVsZGRlZl8xLnRpdGxlKGZpZWxkRGVmLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZC5jb21wb25lbnQubGF5b3V0SGVhZGVyc1tjaGFubmVsXS50aXRsZSkge1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRpdGxlIHdpdGggY2hpbGQgdG8gcHJvZHVjZSBcIlRpdGxlIC8gU3VidGl0bGUgLyBTdWItc3VidGl0bGVcIlxuICAgICAgICAgICAgICAgIHRpdGxlICs9ICcgLyAnICsgdGhpcy5jaGlsZC5jb21wb25lbnQubGF5b3V0SGVhZGVyc1tjaGFubmVsXS50aXRsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLmNvbXBvbmVudC5sYXlvdXRIZWFkZXJzW2NoYW5uZWxdLnRpdGxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxheW91dEhlYWRlcnNbY2hhbm5lbF0gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGZpZWxkUmVmOiBjb21tb25fMS5mb3JtYXRTaWduYWxSZWYoZmllbGREZWYsIGhlYWRlci5mb3JtYXQsICdwYXJlbnQnLCB0aGlzLmNvbmZpZywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhZGRpbmcgbGFiZWwgdG8gZm9vdGVyIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IFt0aGlzLm1ha2VIZWFkZXJDb21wb25lbnQoY2hhbm5lbCwgdHJ1ZSldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5tYWtlSGVhZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNoYW5uZWwsIGxhYmVscykge1xuICAgICAgICB2YXIgc2l6ZUNoYW5uZWwgPSBjaGFubmVsID09PSAncm93JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICAgICAgc2l6ZVNpZ25hbDogdGhpcy5jaGlsZC5nZXRTaXplU2lnbmFsUmVmKHNpemVDaGFubmVsKSxcbiAgICAgICAgICAgIGF4ZXM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5tZXJnZUNoaWxkQXhpcyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVhZCB0aGVzZSBmcm9tIHRoZSByZXNvbHZlIHN5bnRheFxuICAgICAgICAgICAgdmFyIHNjYWxlUmVzb2x2ZSA9ICdzaGFyZWQnO1xuICAgICAgICAgICAgdmFyIGF4aXNSZXNvbHZlID0gJ3NoYXJlZCc7XG4gICAgICAgICAgICBpZiAoc2NhbGVSZXNvbHZlID09PSAnc2hhcmVkJyAmJiBheGlzUmVzb2x2ZSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igc2hhcmVkIGF4aXMsIG1vdmUgdGhlIGF4ZXMgdG8gZmFjZXQncyBoZWFkZXIgb3IgZm9vdGVyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlckNoYW5uZWwgPSBjaGFubmVsID09PSAneCcgPyAnY29sdW1uJyA6ICdyb3cnO1xuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRIZWFkZXIgPSB0aGlzLmNvbXBvbmVudC5sYXlvdXRIZWFkZXJzW2hlYWRlckNoYW5uZWxdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXS5heGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlclR5cGUgPSBoZWFkZXJfMS5nZXRIZWFkZXJUeXBlKGF4aXMub3JpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0SGVhZGVyW2hlYWRlclR5cGVdID0gbGF5b3V0SGVhZGVyW2hlYWRlclR5cGVdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5tYWtlSGVhZGVyQ29tcG9uZW50KGhlYWRlckNoYW5uZWwsIGZhbHNlKV07XG4gICAgICAgICAgICAgICAgICAgIGxheW91dEhlYWRlcltoZWFkZXJUeXBlXVswXS5heGVzLnB1c2goYXhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLmNvbXBvbmVudC5heGVzW2NoYW5uZWxdLmF4ZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3RoaW5nIGZvciBpbmRlcGVuZGVudCBheGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlTGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnBhcnNlTGVnZW5kKCk7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgbGVnZW5kIGZvciBpbmRlcGVuZGVudCBub24tcG9zaXRpb24gc2NhbGUgYWNyb3NzIGZhY2V0c1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGxlZ2VuZCBmb3IgZmllbGQgcmVmZXJlbmNlIG9mIHBhcmVudCBkYXRhIChlLmcuLCBmb3IgU1BMT00pXG4gICAgICAgIC8vIEZvciBub3csIGFzc3VtaW5nIHRoYXQgbm9uLXBvc2l0aW9uYWwgc2NhbGVzIGFyZSBhbHdheXMgc2hhcmVkIGFjcm9zcyBmYWNldHNcbiAgICAgICAgLy8gVGh1cywganVzdCBtb3ZlIGFsbCBsZWdlbmRzIGZyb20gaXRzIGNoaWxkXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmxlZ2VuZHMgPSB0aGlzLmNoaWxkLmNvbXBvbmVudC5sZWdlbmRzO1xuICAgICAgICB0aGlzLmNoaWxkLmNvbXBvbmVudC5sZWdlbmRzID0ge307XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgYXNzZW1ibGUgZGF0YSBpbiB0aGUgcm9vdFxuICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlXzEuYXNzZW1ibGVEYXRhKHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmRhdGEuc291cmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlUGFyZW50R3JvdXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uVG9wTGV2ZWxTaWduYWxzID0gZnVuY3Rpb24gKHNpZ25hbHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuYXNzZW1ibGVTZWxlY3Rpb25Ub3BMZXZlbFNpZ25hbHMoc2lnbmFscyk7XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNlbGVjdGlvblNpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuYXNzZW1ibGVTZWxlY3Rpb25TaWduYWxzKCk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmFzc2VtYmxlU2VsZWN0aW9uRGF0YShkYXRhKTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuY2hhbm5lbEhhc0ZpZWxkKCdjb2x1bW4nKSA/IHtcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5jb2x1bW5EaXN0aW5jdFNpZ25hbCgpXG4gICAgICAgIH0gOiAxO1xuICAgICAgICAvLyBUT0RPOiBkZXRlcm1pbmUgZGVmYXVsdCBhbGlnbiBiYXNlZCBvbiBzaGFyZWQgLyBpbmRlcGVuZGVudCBzY2FsZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHsgcm93OiAxMCwgY29sdW1uOiAxMCB9LFxuICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvZmZzZXQgZm9yIHJvd0hlYWRlci9yb3dGb290ZXIvcm93VGl0bGUvY29sdW1uSGVhZGVyL2NvbHVtbkZvb3Rlci9jb2x1bW5UaXRsZVxuICAgICAgICAgICAgb2Zmc2V0OiAxMCxcbiAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICAgICAgICBib3VuZHM6ICdmdWxsJ1xuICAgICAgICB9O1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVMYXlvdXRTaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGSVhNRShodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzLzExOTMpOiB0aGlzIGNhbiBiZSBpbmNvcnJlY3QgaWYgd2UgaGF2ZSBpbmRlcGVuZGVudCBzY2FsZXMuXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmFzc2VtYmxlTGF5b3V0U2lnbmFscygpO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuY29sdW1uRGlzdGluY3RTaWduYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEluIGZhY2V0Tm9kZS5hc3NlbWJsZSgpLCB0aGUgbmFtZSBpcyBhbHdheXMgdGhpcy5nZXROYW1lKCdjb2x1bW4nKSArICdfbGF5b3V0Jy5cbiAgICAgICAgdmFyIGZhY2V0TGF5b3V0RGF0YU5hbWUgPSB0aGlzLmdldE5hbWUoJ2NvbHVtbicpICsgJ19sYXlvdXQnO1xuICAgICAgICB2YXIgY29sdW1uRGlzdGluY3QgPSB0aGlzLmZpZWxkKCdjb2x1bW4nLCB7IHByZWZpeDogJ2Rpc3RpbmN0JyB9KTtcbiAgICAgICAgcmV0dXJuIFwiZGF0YSgnXCIgKyBmYWNldExheW91dERhdGFOYW1lICsgXCInKVswXVtcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShjb2x1bW5EaXN0aW5jdCkgKyBcIl1cIjtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmYWNldFJvb3QgPSB0aGlzLmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdDtcbiAgICAgICAgdmFyIGRhdGEgPSBhc3NlbWJsZV8xLmFzc2VtYmxlRmFjZXREYXRhKGZhY2V0Um9vdCk7XG4gICAgICAgIHZhciBtYXJrID0gdGhpcy5jb21wb25lbnQubWFya1swXTtcbiAgICAgICAgLy8gY29ycmVjdCB0aGUgbmFtZSBvZiB0aGUgZmFjZXRlZCBkYXRhIHNvdXJjZVxuICAgICAgICBtYXJrLmZyb20uZmFjZXQgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBtYXJrLmZyb20uZmFjZXQsIHsgbmFtZTogZmFjZXRSb290Lm5hbWUsIGRhdGE6IGZhY2V0Um9vdC5kYXRhIH0pO1xuICAgICAgICB2YXIgbWFya3MgPSBbdHNsaWJfMS5fX2Fzc2lnbih7fSwgKGRhdGEubGVuZ3RoID4gMCA/IHsgZGF0YTogZGF0YSB9IDoge30pLCBtYXJrLCB0aGlzLmNoaWxkLmFzc2VtYmxlR3JvdXAoKSldO1xuICAgICAgICByZXR1cm4gbWFya3MubWFwKHRoaXMuY29ycmVjdERhdGFOYW1lcyk7XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5jaGFubmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtjaGFubmVsXzEuUk9XLCBjaGFubmVsXzEuQ09MVU1OXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmdldE1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0O1xuICAgIH07XG4gICAgcmV0dXJuIEZhY2V0TW9kZWw7XG59KG1vZGVsXzEuTW9kZWxXaXRoRmllbGQpKTtcbmV4cG9ydHMuRmFjZXRNb2RlbCA9IEZhY2V0TW9kZWw7XG4vLyBGSVhNRShodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzLzIwNDEpOiByZXZpc2UgdGhpcy5cbmZ1bmN0aW9uIGdldEZhY2V0R3JvdXBQcm9wZXJ0aWVzKG1vZGVsKSB7XG4gICAgdmFyIGVuY29kZUVudHJ5ID0gbW9kZWwuY2hpbGQuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMoKTtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgKGVuY29kZUVudHJ5ID8gZW5jb2RlRW50cnkgOiB7fSksIGNvbW1vbl8xLmFwcGx5Q29uZmlnKHt9LCBtb2RlbC5jb25maWcuZmFjZXQuY2VsbCwgbWFya18xLkZJTExfU1RST0tFX0NPTkZJRy5jb25jYXQoWydjbGlwJ10pKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqWlhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5bVlXTmxkQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkJRU3h6UTBGQmMwUTdRVUZIZEVRc2QwTkJRVzFETzBGQlJXNURMSGREUVVGM1JUdEJRVU40UlN3MFFrRkJPRUk3UVVGRE9VSXNaME5CUVRKRE8wRkJSek5ETEdkRFFVRnBSanRCUVVWcVJpdzRRMEZSZDBJN1FVRkhlRUlzYlVOQlFXdEZPMEZCUTJ4RkxEUkRRVUZ2Ump0QlFVTndSaXh6UTBGQmRVTTdRVUZEZGtNc01FTkJRWEZITzBGQlJYSkhMR2xEUVVFNFF6dEJRVU01UXl4dFEwRkJLMFE3UVVGSkwwUTdTVUZCWjBNc2MwTkJRV003U1VGUE5VTXNiMEpCUVZrc1NVRkJaU3hGUVVGRkxFMUJRV0VzUlVGQlJTeGxRVUYxUWl4RlFVRkZMRkZCUVhWQ0xFVkJRVVVzVFVGQll6dFJRVUUxUnl4WlFVTkZMR3RDUVVGTkxFbEJRVWtzUlVGQlJTeE5RVUZOTEVWQlFVVXNaVUZCWlN4RlFVRkZMRTFCUVUwc1EwRkJReXhUUVZFM1F6dFJRVTVETEV0QlFVa3NRMEZCUXl4TFFVRkxMRWRCUVVjc2JVSkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RlFVRkZMRXRCUVVrc1JVRkJSU3hMUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRk5CUVZNc1JVRkJSU3hSUVVGUkxFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdVVUZETjBZc1MwRkJTU3hEUVVGRExGRkJRVkVzUjBGQlJ5eERRVUZETEV0QlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVVM1FpeEpRVUZOTEV0QlFVc3NSMEZCYTBJc0swSkJRWE5DTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVVV4UlN4TFFVRkpMRU5CUVVNc1MwRkJTeXhIUVVGSExFdEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN08wbEJRM0pETEVOQlFVTTdTVUZGVHl3NFFrRkJVeXhIUVVGcVFpeFZRVUZyUWl4TFFVRnZRanRSUVVOd1F5eHZSRUZCYjBRN1VVRkRjRVFzVFVGQlRTeERRVUZETEdsQ1FVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxGVkJRVk1zWlVGQlpTeEZRVUZGTEZGQlFUQkNMRVZCUVVVc1QwRkJaMEk3V1VGRGVrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eGhRVUZITEVWQlFVVXNaMEpCUVUwc1EwRkJReXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRU1zTWtKQlFUSkNPMmRDUVVNelFpeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1QwRkJUeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpWRUxFMUJRVTBzUTBGQlF5eGxRVUZsTEVOQlFVTTdXVUZEZWtJc1EwRkJRenRaUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYWtNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR0ZCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRka1FzVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXp0WlFVTjZRaXhEUVVGRE8xbEJSVVFzWjBkQlFXZEhPMWxCUTJoSExHVkJRV1VzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4dlFrRkJVeXhEUVVGRExGRkJRVkVzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTjRSQ3hOUVVGTkxFTkJRVU1zWlVGQlpTeERRVUZETzFGQlEzcENMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZGVFN4dlEwRkJaU3hIUVVGMFFpeFZRVUYxUWl4UFFVRm5RanRSUVVOeVF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZETDBJc1EwRkJRenRKUVVWTkxITkRRVUZwUWl4SFFVRjRRaXhWUVVGNVFpeFBRVUZuUWp0UlFVTjJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVk5MRFpDUVVGUkxFZEJRV1lzVlVGQlowSXNUMEZCWjBJN1VVRkRPVUlzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRE4wSXNRMEZCUXp0SlFVVk5MRGhDUVVGVExFZEJRV2hDTzFGQlEwVXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFZEJRVWNzYVVKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOMFF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1JVRkJSU3hEUVVGRE8wbEJRM3BDTEVOQlFVTTdTVUZGVFN4dFEwRkJZeXhIUVVGeVFqdFJRVU5GTEhkRlFVRjNSVHRSUVVONFJTeDFSVUZCZFVVN1VVRkRka1VzYlVKQlFXMUNPMUZCUTI1Q0xFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNZMEZCWXl4RlFVRkZMRU5CUVVNN1VVRkROVUlzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4VFFVRlRMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNVMEZCVXl4RFFVRkRPMGxCUXpWRUxFTkJRVU03U1VGRlRTd3JRa0ZCVlN4SFFVRnFRanRSUVVGQkxHbENRWEZEUXp0UlFYQkRReXhKUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTNwQ0xFbEJRVTBzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVVnVRaXhMUVVGTExFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTTdVVUZGYmtJc1NVRkJUU3hqUVVGakxFZEJRVWNzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJSV3hFTEN0RFFVRXJRenRSUVVNdlF5eFhRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUVN4UFFVRlBPMWxCUXpGRExEaERRVUU0UXp0WlFVTTVReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOVUxFbEJRVTBzUzBGQlN5eEhRVUZITEdOQlFXTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRuUWtGRmVFVXNTVUZCVFN4elFrRkJjMElzUjBGQlJ5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVU16UlN4SlFVRk5MRTlCUVU4c1IwRkJSeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEhOQ1FVRnpRaXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTTVSQ3hMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03WjBKQlEzWkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETzJkQ1FVVnlRaXh0UmtGQmJVWTdaMEpCUTI1R0xFbEJRVTBzVFVGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNN1owSkJSVFZDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRFpDUVVGbExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NiVU5CUVhGQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNM1JDeE5RVUZOTEVOQlFVTXNTVUZCU1N4SFFVRkhMRFpDUVVGclFpeEhRVUZITEV0QlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTXZSQ3hEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXh2UTBGQmMwSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlF6RkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJReXhEUVVGWk8zZENRVU0zUXl4TlFVRk5MSE5DUVVORUxFTkJRVU1zU1VGRFNpeEpRVUZKTEVWQlFVVXNOa0pCUVd0Q0xFZEJRVWNzUzBGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJReTlETzI5Q1FVTktMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5NTEVOQlFVTTdaMEpCUlVRc2NVUkJRWEZFTzJkQ1FVTnlSQ3hQUVVGUExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xbEJRM3BETEVOQlFVTTdVVUZEU0N4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlRTdzRRa0ZCVXl4SFFVRm9RanRSUVVORkxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1VVRkZka0lzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRWRCUVVjc1EwRkJRenRuUWtGRGNrSXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETzJkQ1FVTXhRaXhKUVVGSkxFVkJRVVVzVDBGQlR6dG5Ra0ZEWWl4SlFVRkpMRVZCUVVVN2IwSkJRMG9zUzBGQlN5eEZRVUZGTzNkQ1FVTk1MRWxCUVVrc1JVRkJSU3hKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTVHQzUWtGRGVFTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpPM2RDUVVONFF5eFBRVUZQTEVWQlFVVXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkRhRUlzU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4aFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNZVUZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRMnhFTEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1owSkJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhuUWtGQlRTeERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRU5CUTNwRU8zRkNRVU5HTzJsQ1FVTkdPMmRDUVVORUxFMUJRVTBzUlVGQlJUdHZRa0ZEVGl4TlFVRk5MRVZCUVVVc2RVSkJRWFZDTEVOQlFVTXNTVUZCU1N4RFFVRkRPMmxDUVVOMFF6dGhRVU5HTEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkZUU3gxUTBGQmEwSXNSMEZCZWtJN1VVRkRSU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEd0Q1FVRnJRaXhGUVVGRkxFTkJRVU03VVVGRmFFTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU16UWl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlJYaENMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wbEJSVThzWjBOQlFWY3NSMEZCYmtJc1ZVRkJiMElzVDBGQmMwSTdVVUZGZUVNc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNTVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTnlReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4SlFVRkpMRVZCUVVVc1EwRkJRenRaUVVOeVF5eEpRVUZKTEV0QlFVc3NSMEZCUnl4TlFVRk5MRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUjBGQlNTeE5RVUZOTEVOQlFVTXNTMEZCU3l4SFFVRkhMR2RDUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRaUVVVNVJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eGhRVUZoTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVRc2MwVkJRWE5GTzJkQ1FVTjBSU3hMUVVGTExFbEJRVWtzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHRkJRV0VzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNN1owSkJRMjVGTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHRkJRV0VzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRE8xbEJRek5FTEVOQlFVTTdXVUZGUkN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExHRkJRV0VzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnp0blFrRkRkRU1zUzBGQlN5eFBRVUZCTzJkQ1FVTk1MRkZCUVZFc1JVRkJSU3gzUWtGQlpTeERRVUZETEZGQlFWRXNSVUZCUlN4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxGRkJRVkVzUlVGQlJTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJRenRuUWtGREwwVXNLME5CUVN0RE8yZENRVU12UXl4TlFVRk5MRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1QwRkJUeXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzJGQlEyeEVMRU5CUVVNN1VVRkRTaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZQTEhkRFFVRnRRaXhIUVVFelFpeFZRVUUwUWl4UFFVRnpRaXhGUVVGRkxFMUJRV1U3VVVGRGFrVXNTVUZCVFN4WFFVRlhMRWRCUVVjc1QwRkJUeXhMUVVGTExFdEJRVXNzUjBGQlJ5eFJRVUZSTEVkQlFVY3NUMEZCVHl4RFFVRkRPMUZCUlRORUxFMUJRVTBzUTBGQlF6dFpRVU5NTEUxQlFVMHNVVUZCUVR0WlFVTk9MRlZCUVZVc1JVRkJSU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGZEJRVmNzUTBGQlF6dFpRVU53UkN4SlFVRkpMRVZCUVVVc1JVRkJSVHRUUVVOVUxFTkJRVU03U1VGRFNpeERRVUZETzBsQlJVOHNiVU5CUVdNc1IwRkJkRUlzVlVGQmRVSXNUMEZCYTBJN1VVRkRhRU1zU1VGQlFTeHJRa0ZCU3l4RFFVRlRPMUZCUTNKQ0xFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNReXd5UTBGQk1rTTdXVUZETTBNc1NVRkJUU3haUVVGWkxFZEJRVWNzVVVGQlVTeERRVUZETzFsQlF6bENMRWxCUVUwc1YwRkJWeXhIUVVGSExGRkJRVkVzUTBGQlF6dFpRVVUzUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFdEJRVXNzVVVGQlVTeEpRVUZKTEZkQlFWY3NTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU14UkN3MlJFRkJOa1E3WjBKQlF6ZEVMRWxCUVUwc1lVRkJZU3hIUVVGSExFOUJRVThzUzBGQlN5eEhRVUZITEVkQlFVY3NVVUZCVVN4SFFVRkhMRXRCUVVzc1EwRkJRenRuUWtGRmVrUXNTVUZCVFN4WlFVRlpMRWRCUVVjc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eGhRVUZoTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1owSkJRMnBGTEVkQlFVY3NRMEZCUXl4RFFVRmxMRlZCUVd0RExFVkJRV3hETEV0QlFVRXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNTVUZCU1N4RlFVRnNReXhqUVVGclF5eEZRVUZzUXl4SlFVRnJRenR2UWtGQmFFUXNTVUZCVFN4SlFVRkpMRk5CUVVFN2IwSkJRMklzU1VGQlRTeFZRVUZWTEVkQlFVY3NjMEpCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdiMEpCUXpsRExGbEJRVmtzUTBGQlF5eFZRVUZWTEVOQlFVTXNSMEZCUnl4WlFVRlpMRU5CUVVNc1ZVRkJWU3hEUVVGRE8zZENRVU5xUkN4RFFVRkRMRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4aFFVRmhMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEYmtRc1dVRkJXU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdhVUpCUXpkRE8yZENRVU5FTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVsQlFVa3NSMEZCUnl4RlFVRkZMRU5CUVVNN1dVRkRNVU1zUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xEUkRRVUUwUXp0WlFVTTVReXhEUVVGRE8xRkJRMGdzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGVFN4blEwRkJWeXhIUVVGc1FqdFJRVU5GTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU03VVVGRmVrSXNkMFZCUVhkRk8xRkJRM2hGTERSRlFVRTBSVHRSUVVVMVJTd3JSVUZCSzBVN1VVRkRMMFVzTmtOQlFUWkRPMUZCUXpkRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNRMEZCUXp0UlFVTjBSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRWRCUVVjc1JVRkJSU3hEUVVGRE8wbEJRM0JETEVOQlFVTTdTVUZGVFN4cFEwRkJXU3hIUVVGdVFqdFJRVU5GTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtJc2FVTkJRV2xETzFsQlEycERMRTFCUVUwc1EwRkJReXgxUWtGQldTeERRVUZETEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNwRUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFvc1EwRkJRenRKUVVWTkxHdEVRVUUyUWl4SFFVRndRenRSUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlUwc2NVUkJRV2RETEVkQlFYWkRMRlZCUVhkRExFOUJRV003VVVGRGNFUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zWjBOQlFXZERMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRE9VUXNRMEZCUXp0SlFVVk5MRFpEUVVGM1FpeEhRVUV2UWp0UlFVTkZMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zZDBKQlFYZENMRVZCUVVVc1EwRkJRenRSUVVOMFF5eE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFvc1EwRkJRenRKUVVWTkxEQkRRVUZ4UWl4SFFVRTFRaXhWUVVFMlFpeEpRVUZqTzFGQlEzcERMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEhGQ1FVRnhRaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlEyaEVMRU5CUVVNN1NVRkZUU3h0UTBGQll5eEhRVUZ5UWp0UlFVTkZMRWxCUVUwc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjN1dVRkRMME1zVFVGQlRTeEZRVUZGTEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUlVGQlJUdFRRVU53UXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVWT0xIRkZRVUZ4UlR0UlFVVnlSU3hOUVVGTkxFTkJRVU03V1VGRFRDeFBRVUZQTEVWQlFVVXNSVUZCUXl4SFFVRkhMRVZCUVVVc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeEZRVUZGTEVWQlFVTTdXVUZGT1VJc09FWkJRVGhHTzFsQlF6bEdMRTFCUVUwc1JVRkJSU3hGUVVGRk8xbEJRMVlzVDBGQlR5eFRRVUZCTzFsQlExQXNUVUZCVFN4RlFVRkZMRTFCUVUwN1UwRkRaaXhEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVVZOTERCRFFVRnhRaXhIUVVFMVFqdFJRVU5GTERaSFFVRTJSenRSUVVNM1J5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXh4UWtGQmNVSXNSVUZCUlN4RFFVRkRPMGxCUXpWRExFTkJRVU03U1VGRlR5eDVRMEZCYjBJc1IwRkJOVUk3VVVGRFJTeHJSa0ZCYTBZN1VVRkRiRVlzU1VGQlRTeHRRa0ZCYlVJc1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRk5CUVZNc1EwRkJRenRSUVVNdlJDeEpRVUZOTEdOQlFXTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJ5eEZRVUZETEUxQlFVMHNSVUZCUlN4VlFVRlZMRVZCUVVNc1EwRkJReXhEUVVGRE8xRkJRMjVGTEUxQlFVMHNRMEZCUXl4WFFVRlRMRzFDUVVGdFFpeGpRVUZUTEd0Q1FVRlhMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVWNzUTBGQlF6dEpRVU0zUlN4RFFVRkRPMGxCUlUwc2EwTkJRV0VzUjBGQmNFSTdVVUZEUlN4SlFVRk5MRk5CUVZNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNN1VVRkRhRVFzU1VGQlRTeEpRVUZKTEVkQlFVY3NORUpCUVdsQ0xFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdVVUZGTVVNc1NVRkJUU3hKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRmNFTXNPRU5CUVRoRE8xRkJRemxETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXgzUWtGRFZpeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1NVRkRiRUlzU1VGQlNTeEZRVUZGTEZOQlFWTXNRMEZCUXl4SlFVRkpMRVZCUTNCQ0xFbEJRVWtzUlVGQlJTeFRRVUZUTEVOQlFVTXNTVUZCU1N4SFFVTnlRaXhEUVVGRE8xRkJSVVlzU1VGQlRTeExRVUZMTEVkQlFVY3NjMEpCUTFRc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNSMEZCUnl4RlFVRkRMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNSVUZEY2tNc1NVRkJTU3hGUVVOS0xFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNZVUZCWVN4RlFVRkZMRVZCUXpkQ0xFTkJRVU03VVVGRlNDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1EwRkJRenRKUVVNeFF5eERRVUZETzBsQlJVMHNOa0pCUVZFc1IwRkJaanRSUVVORkxFMUJRVTBzUTBGQlF5eERRVUZETEdGQlFVY3NSVUZCUlN4blFrRkJUU3hEUVVGRExFTkJRVU03U1VGRGRrSXNRMEZCUXp0SlFVVlRMQ3RDUVVGVkxFZEJRWEJDTzFGQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRGNFSXNRMEZCUXp0SlFVTklMR2xDUVVGRE8wRkJRVVFzUTBGQlF5eEJRUzlTUkN4RFFVRm5ReXh6UWtGQll5eEhRU3RTTjBNN1FVRXZVbGtzWjBOQlFWVTdRVUZwVTNaQ0xIRkZRVUZ4UlR0QlFVTnlSU3hwUTBGQmFVTXNTMEZCYVVJN1NVRkRhRVFzU1VGQlRTeFhRVUZYTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXcyUWtGQk5rSXNSVUZCUlN4RFFVRkRPMGxCUldoRkxFMUJRVTBzYzBKQlEwUXNRMEZCUXl4WFFVRlhMRWRCUVVjc1YwRkJWeXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVU5vUXl4dlFrRkJWeXhEUVVGRExFVkJRVVVzUlVGQlJTeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzZVVKQlFXdENMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVTm9SanRCUVVOS0xFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4uL21hcmtcIik7XG52YXIgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgdmVnYV9zY2hlbWFfMSA9IHJlcXVpcmUoXCIuLi92ZWdhLnNjaGVtYVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBhc3NlbWJsZV8xID0gcmVxdWlyZShcIi4vZGF0YS9hc3NlbWJsZVwiKTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4vZGF0YS9wYXJzZVwiKTtcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4vbGF5b3V0L2luZGV4XCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBkb21haW5fMSA9IHJlcXVpcmUoXCIuL3NjYWxlL2RvbWFpblwiKTtcbnZhciBzZWxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvbi9zZWxlY3Rpb25cIik7XG52YXIgTGF5ZXJNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGF5ZXJNb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXllck1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCBwYXJlbnRVbml0U2l6ZSwgcmVwZWF0ZXIsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXNvbHZlID0gcmVzb2x2ZV8xLmluaXRMYXllclJlc29sdmUoc3BlYy5yZXNvbHZlIHx8IHt9KTtcbiAgICAgICAgdmFyIHVuaXRTaXplID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgcGFyZW50VW5pdFNpemUsIChzcGVjLndpZHRoID8geyB3aWR0aDogc3BlYy53aWR0aCB9IDoge30pLCAoc3BlYy5oZWlnaHQgPyB7IGhlaWdodDogc3BlYy5oZWlnaHQgfSA6IHt9KSk7XG4gICAgICAgIF90aGlzLmNoaWxkcmVuID0gc3BlYy5sYXllci5tYXAoZnVuY3Rpb24gKGxheWVyLCBpKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBub3QgYWx3YXlzIHRoZSBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIG1vZGVsIGhhcyB0byBiZSBhIHVuaXQgbW9kZWwgYmVjYXVzZSB3ZSBwYXNzIGluIGEgdW5pdCBzcGVjXG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuYnVpbGRNb2RlbChsYXllciwgX3RoaXMsIF90aGlzLmdldE5hbWUoJ2xheWVyXycgKyBpKSwgdW5pdFNpemUsIHJlcGVhdGVyLCBjb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5wYXJzZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmRhdGEgPSBwYXJzZV8xLnBhcnNlRGF0YSh0aGlzKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBjaGlsZC5wYXJzZURhdGEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUucGFyc2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE1lcmdlIHNlbGVjdGlvbnMgdXAgdGhlIGhpZXJhcmNoeSBzbyB0aGF0IHRoZXkgbWF5IGJlIHJlZmVyZW5jZWRcbiAgICAgICAgLy8gYWNyb3NzIHVuaXQgc3BlY3MuIFBlcnNpc3QgdGhlaXIgZGVmaW5pdGlvbnMgd2l0aGluIGVhY2ggY2hpbGRcbiAgICAgICAgLy8gdG8gYXNzZW1ibGUgc2lnbmFscyB3aGljaCByZW1haW4gd2l0aGluIG91dHB1dCBWZWdhIHVuaXQgZ3JvdXBzLlxuICAgICAgICB0aGlzLmNvbXBvbmVudC5zZWxlY3Rpb24gPSB7fTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB1dGlsXzEua2V5cyhjaGlsZC5jb21wb25lbnQuc2VsZWN0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnQuc2VsZWN0aW9uW2tleV0gPSBjaGlsZC5jb21wb25lbnQuc2VsZWN0aW9uW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBfbG9vcF8xKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUucGFyc2VTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgICAgdmFyIHNjYWxlQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQuc2NhbGVzID0ge307XG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZVNjYWxlKCk7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBzY2FsZXMgYXJlIGFjdHVhbGx5IGNvbXBhdGlibGUsIGUuZy4gdXNlIHRoZSBzYW1lIHNvcnQgb3IgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIHV0aWxfMS5rZXlzKGNoaWxkLmNvbXBvbmVudC5zY2FsZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzb2x2ZVtjaGFubmVsXS5zY2FsZSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkU2NhbGUgPSBjaGlsZC5jb21wb25lbnQuc2NhbGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxTY2FsZSA9IHNjYWxlQ29tcG9uZW50W2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkU2NhbGUgfHwgdmVnYV9zY2hlbWFfMS5pc1NpZ25hbFJlZkRvbWFpbihjaGlsZFNjYWxlLmRvbWFpbikgfHwgKG1vZGVsU2NhbGUgJiYgdmVnYV9zY2hlbWFfMS5pc1NpZ25hbFJlZkRvbWFpbihtb2RlbFNjYWxlLmRvbWFpbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtZXJnZSBzaWduYWwgcmVmIGRvbWFpbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxTY2FsZS5kb21haW4gPSBkb21haW5fMS51bmlvbkRvbWFpbnMobW9kZWxTY2FsZS5kb21haW4sIGNoaWxkU2NhbGUuZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlQ29tcG9uZW50W2NoYW5uZWxdID0gY2hpbGRTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZW5hbWUgY2hpbGQgc2NhbGUgdG8gcGFyZW50IHNjYWxlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVOYW1lV2l0aG91dFByZWZpeCA9IGNoaWxkU2NhbGUubmFtZS5zdWJzdHIoY2hpbGQuZ2V0TmFtZSgnJykubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05hbWUgPSBtb2RlbC5zY2FsZU5hbWUoc2NhbGVOYW1lV2l0aG91dFByZWZpeCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlbmFtZVNjYWxlKGNoaWxkU2NhbGUubmFtZSwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkU2NhbGUubmFtZSA9IG5ld05hbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBtZXJnZWQgc2NhbGVzIGZyb20gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5zY2FsZXNbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgX2xvb3BfMihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlTWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBjaGlsZC5wYXJzZU1hcmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzQW5kSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXhpc0NvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50LmF4ZXMgPSB7fTtcbiAgICAgICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlQXhpc0FuZEhlYWRlcigpO1xuICAgICAgICAgICAgdXRpbF8xLmtleXMoY2hpbGQuY29tcG9uZW50LmF4ZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzb2x2ZVtjaGFubmVsXS5heGlzID09PSAnc2hhcmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzaGFyZWQvdW5pb24gYXhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHVzZSB0aGUgZmlyc3QgYXhlcyBkZWZpbml0aW9uIGZvciBlYWNoIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBpZiB0aGUgYXhlcyBmcm9tIGRpZmZlcmVudCBjaGlsZHJlbiBhcmUgbm90IGNvbXBhdGlibGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGlzQ29tcG9uZW50W2NoYW5uZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzQ29tcG9uZW50W2NoYW5uZWxdID0gY2hpbGQuY29tcG9uZW50LmF4ZXNbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGF4ZXMgYXJlIGluZGVwZW5kZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oIzIyNTEpOiBjb3JyZWN0bHkgbWVyZ2UgYXhpc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXNDb21wb25lbnRbY2hhbm5lbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGZpcnN0IGF4aXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCBldmVyeSBvZGQgbnVtYmVyZWQgYXhpcyBvbiB0aGUgcmlnaHQvdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzQ29tcG9uZW50W2NoYW5uZWxdLmF4ZXMucHVzaCh0c2xpYl8xLl9fYXNzaWduKHt9LCBjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXS5heGVzWzBdLCAoYXhpc0NvbXBvbmVudFtjaGFubmVsXS5heGVzLmxlbmd0aCAlIDIgPT09IDEgPyB7IG9yaWVudDogY2hhbm5lbCA9PT0gJ3knID8gJ3JpZ2h0JyA6ICd0b3AnIH0gOiB7fSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXS5ncmlkQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0NvbXBvbmVudFtjaGFubmVsXS5ncmlkQXhlcy5wdXNoKHRzbGliXzEuX19hc3NpZ24oe30sIGNoaWxkLmNvbXBvbmVudC5heGVzW2NoYW5uZWxdLmdyaWRBeGVzWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5heGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgX2xvb3BfMyhjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlTGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGVnZW5kQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQubGVnZW5kcyA9IHt9O1xuICAgICAgICB2YXIgX2xvb3BfNCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyc2VMZWdlbmQoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvcnJlY3RseSBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgYXhlc1xuICAgICAgICAgICAgdXRpbF8xLmtleXMoY2hpbGQuY29tcG9uZW50LmxlZ2VuZHMpLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzb2x2ZVtjaGFubmVsXS5sZWdlbmQgPT09ICdzaGFyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgdXNlIHRoZSBmaXJzdCBsZWdlbmQgZGVmaW5pdGlvbiBmb3IgZWFjaCBjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kQ29tcG9uZW50W2NoYW5uZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZC5jb21wb25lbnQubGVnZW5kc1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBpbmRlcGVuZGVudCBsZWdlbmRzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xuICAgICAgICAgICAgX2xvb3BfNChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlUGFyZW50R3JvdXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7IHdpZHRoOiB0aGlzLmdldFNpemVTaWduYWxSZWYoJ3dpZHRoJyksIGhlaWdodDogdGhpcy5nZXRTaXplU2lnbmFsUmVmKCdoZWlnaHQnKSB9LCBjb21tb25fMS5hcHBseUNvbmZpZyh7fSwgdGhpcy5jb25maWcuY2VsbCwgbWFya18xLkZJTExfU1RST0tFX0NPTkZJRy5jb25jYXQoWydjbGlwJ10pKSk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNlbGVjdGlvblRvcExldmVsU2lnbmFscyA9IGZ1bmN0aW9uIChzaWduYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoc2csIGNoaWxkKSB7IHJldHVybiBjaGlsZC5hc3NlbWJsZVNlbGVjdGlvblRvcExldmVsU2lnbmFscyhzZyk7IH0sIHNpZ25hbHMpO1xuICAgIH07XG4gICAgLy8gVE9ETzogU3VwcG9ydCBzYW1lIG5hbWVkIHNlbGVjdGlvbnMgYWNyb3NzIGNoaWxkcmVuLlxuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uU2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChzaWduYWxzLCBjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25hbHMuY29uY2F0KGNoaWxkLmFzc2VtYmxlU2VsZWN0aW9uU2lnbmFscygpKTtcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVMYXlvdXRTaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKHNpZ25hbHMsIGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmFscy5jb25jYXQoY2hpbGQuYXNzZW1ibGVMYXlvdXRTaWduYWxzKCkpO1xuICAgICAgICB9LCBpbmRleF8xLmFzc2VtYmxlTGF5b3V0TGF5ZXJTaWduYWxzKHRoaXMpKTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoZGIsIGNoaWxkKSB7IHJldHVybiBjaGlsZC5hc3NlbWJsZVNlbGVjdGlvbkRhdGEoZGIpOyB9LCBbXSk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgYXNzZW1ibGUgZGF0YSBpbiB0aGUgcm9vdFxuICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlXzEuYXNzZW1ibGVEYXRhKHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmRhdGEuc291cmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2NhbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb21iaW5lIHdpdGggc2NhbGVzIGZyb20gY2hpbGRyZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChzY2FsZXMsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZXMuY29uY2F0KGMuYXNzZW1ibGVTY2FsZXMoKSk7XG4gICAgICAgIH0sIF9zdXBlci5wcm90b3R5cGUuYXNzZW1ibGVTY2FsZXMuY2FsbCh0aGlzKSk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZU1hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uXzEuYXNzZW1ibGVMYXllclNlbGVjdGlvbk1hcmtzKHRoaXMsIHV0aWxfMS5mbGF0dGVuKHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmFzc2VtYmxlTWFya3MoKTtcbiAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXllck1vZGVsO1xufShtb2RlbF8xLk1vZGVsKSk7XG5leHBvcnRzLkxheWVyTW9kZWwgPSBMYXllck1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYkdGNVpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXNZWGxsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZGUVN4blEwRkJNa003UVVGRE0wTXNjME5CUVN0R08wRkJSUzlHTEdkRFFVRnJSRHRCUVVOc1JDdzRRMEZCY1VjN1FVRkZja2NzYlVOQlFXbEVPMEZCUTJwRUxEUkRRVUUyUXp0QlFVTTNReXh6UTBGQmRVTTdRVUZEZGtNc2QwTkJRVEJFTzBGQlF6RkVMR2xEUVVFNFFqdEJRVVU1UWl4NVEwRkJORU03UVVGRE5VTXNiVVJCUVd0Rk8wRkJTV3hGTzBsQlFXZERMSE5EUVVGTE8wbEJTMjVETEc5Q1FVRlpMRWxCUVdVc1JVRkJSU3hOUVVGaExFVkJRVVVzWlVGQmRVSXNSVUZEYWtVc1kwRkJkMElzUlVGQlJTeFJRVUYxUWl4RlFVRkZMRTFCUVdNN1VVRkVia1VzV1VGSFJTeHJRa0ZCVFN4SlFVRkpMRVZCUVVVc1RVRkJUU3hGUVVGRkxHVkJRV1VzUlVGQlJTeE5RVUZOTEVOQlFVTXNVMEZsTjBNN1VVRmlReXhMUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITERCQ1FVRm5RaXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkZjRVFzU1VGQlRTeFJRVUZSTEhkQ1FVTlVMR05CUVdNc1JVRkRaQ3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RlFVTjJReXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NSVUZCUXl4TlFVRk5MRVZCUVVVc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVTTVReXhEUVVGRE8xRkJSVVlzUzBGQlNTeERRVUZETEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMWxCUTNSRExIRkRRVUZ4UXp0WlFVTnlReXdyUlVGQkswVTdXVUZETDBVc1RVRkJUU3hEUVVGRExHMUNRVUZWTEVOQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVrc1JVRkJSU3hMUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hSUVVGUkxFVkJRVVVzVVVGQlVTeEZRVUZGTEUxQlFVMHNRMEZCWXl4RFFVRkRPMUZCUTNSSExFTkJRVU1zUTBGQlF5eERRVUZET3p0SlFVTk1MRU5CUVVNN1NVRkZUU3c0UWtGQlV5eEhRVUZvUWp0UlFVTkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeEhRVUZITEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGRFTXNSMEZCUnl4RFFVRkRMRU5CUVdkQ0xGVkJRV0VzUlVGQllpeExRVUZCTEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVdJc1kwRkJZU3hGUVVGaUxFbEJRV0U3V1VGQk5VSXNTVUZCVFN4TFFVRkxMRk5CUVVFN1dVRkRaQ3hMUVVGTExFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTTdVMEZEYmtJN1NVRkRTQ3hEUVVGRE8wbEJSVTBzYlVOQlFXTXNSMEZCY2tJN1VVRkJRU3hwUWtGWFF6dFJRVlpETEcxRlFVRnRSVHRSUVVOdVJTeHBSVUZCYVVVN1VVRkRha1VzYlVWQlFXMUZPMUZCUTI1RkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNVMEZCVXl4SFFVRkhMRVZCUVVVc1EwRkJRenRuUTBGRGJrSXNTMEZCU3p0WlFVTmtMRXRCUVVzc1EwRkJReXhqUVVGakxFVkJRVVVzUTBGQlF6dFpRVU4yUWl4WFFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJReXhIUVVGSE8yZENRVU14UXl4TFFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTnFSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZNUkN4SFFVRkhMRU5CUVVNc1EwRkJaMElzVlVGQllTeEZRVUZpTEV0QlFVRXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJZaXhqUVVGaExFVkJRV0lzU1VGQllUdFpRVUUxUWl4SlFVRk5MRXRCUVVzc1UwRkJRVHR2UWtGQlRDeExRVUZMTzFOQlMyWTdTVUZEU0N4RFFVRkRPMGxCUlUwc0swSkJRVlVzUjBGQmFrSTdVVUZCUVN4cFFrRnZRME03VVVGdVEwTXNTVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJSVzVDTEVsQlFVMHNZMEZCWXl4SFFVRnJRaXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNSMEZCUnl4RlFVRkZMRU5CUVVNN1owTkJSWFJFTEV0QlFVczdXVUZEWkN4TFFVRkxMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU03V1VGRmJrSXNNRVpCUVRCR08xbEJRekZHTEZkQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkRMRTlCUVhGQ08yZENRVU42UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTNReXhKUVVGTkxGVkJRVlVzUjBGQlJ5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dHZRa0ZEYmtRc1NVRkJUU3hWUVVGVkxFZEJRVWNzWTBGQll5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMjlDUVVVelF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRlZCUVZVc1NVRkJTU3dyUWtGQmFVSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVsQlFVa3NLMEpCUVdsQ0xFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU5vU0N4cFEwRkJhVU03ZDBKQlEycERMRTFCUVUwc1EwRkJRenR2UWtGRFZDeERRVUZETzI5Q1FVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdkMEpCUTJZc1ZVRkJWU3hEUVVGRExFMUJRVTBzUjBGQlJ5eHhRa0ZCV1N4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFVkJRVVVzVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMjlDUVVONlJTeERRVUZETzI5Q1FVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8zZENRVU5PTEdOQlFXTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU03YjBKQlEzWkRMRU5CUVVNN2IwSkJSVVFzYzBOQlFYTkRPMjlDUVVOMFF5eEpRVUZOTEhOQ1FVRnpRaXhIUVVGSExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN2IwSkJRMmhHTEVsQlFVMHNUMEZCVHl4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zYzBKQlFYTkNMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlF6bEVMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenR2UWtGRE5VTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU03YjBKQlJURkNMSEZEUVVGeFF6dHZRa0ZEY2tNc1QwRkJUeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRuUWtGRGVrTXNRMEZCUXp0WlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMHdzUTBGQlF6dFJRVGxDUkN4SFFVRkhMRU5CUVVNc1EwRkJaMElzVlVGQllTeEZRVUZpTEV0QlFVRXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJZaXhqUVVGaExFVkJRV0lzU1VGQllUdFpRVUUxUWl4SlFVRk5MRXRCUVVzc1UwRkJRVHR2UWtGQlRDeExRVUZMTzFOQk9FSm1PMGxCUTBnc1EwRkJRenRKUVVWTkxEaENRVUZUTEVkQlFXaENPMUZCUTBVc1IwRkJSeXhEUVVGRExFTkJRV2RDTEZWQlFXRXNSVUZCWWl4TFFVRkJMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRV0lzWTBGQllTeEZRVUZpTEVsQlFXRTdXVUZCTlVJc1NVRkJUU3hMUVVGTExGTkJRVUU3V1VGRFpDeExRVUZMTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1UwRkRia0k3U1VGRFNDeERRVUZETzBsQlJVMHNkVU5CUVd0Q0xFZEJRWHBDTzFGQlFVRXNhVUpCYjBORE8xRkJia05ETEVsQlFVMHNZVUZCWVN4SFFVRnJRaXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NSMEZCUnl4RlFVRkZMRU5CUVVNN1owTkJSVzVFTEV0QlFVczdXVUZEWkN4TFFVRkxMRU5CUVVNc2EwSkJRV3RDTEVWQlFVVXNRMEZCUXp0WlFVTXpRaXhYUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlF5eFBRVUUwUWp0blFrRkRPVVFzUlVGQlJTeERRVUZETEVOQlFVVXNTMEZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVzlDTEVOQlFVTXNTVUZCU1N4TFFVRkxMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEyaEZMSFZDUVVGMVFqdHZRa0ZGZGtJc2MwUkJRWE5FTzI5Q1FVTjBSQ3h2UlVGQmIwVTdiMEpCUTNCRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZETlVJc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzI5Q1FVTjZSQ3hEUVVGRE8yZENRVU5JTEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlEwNHNNRUpCUVRCQ08yOUNRVU14UWl4dlEwRkJiME03YjBKQlEzQkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWVVGQllTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenQzUWtGRE5VSXNjMEpCUVhOQ08zZENRVU4wUWl4aFFVRmhMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03YjBKQlEzcEVMRU5CUVVNN2IwSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdkMEpCUTA0c0swTkJRU3RETzNkQ1FVTXZReXhoUVVGaExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc2MwSkJRek5DTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkRja01zUTBGQlF5eGhRVUZoTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRVZCUVVNc1RVRkJUU3hGUVVGRkxFOUJRVThzUzBGQlN5eEhRVUZITEVkQlFVY3NUMEZCVHl4SFFVRkhMRXRCUVVzc1JVRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVU53Unl4RFFVRkRPM2RDUVVOSUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6czBRa0ZEZEVRc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMSE5DUVVNdlFpeExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUXpWRExFTkJRVU03ZDBKQlEwd3NRMEZCUXp0dlFrRkRTQ3hEUVVGRE8yZENRVU5JTEVOQlFVTTdaMEpCUTBRc2QwTkJRWGRETzFsQlF6RkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMHdzUTBGQlF6dFJRV2hEUkN4SFFVRkhMRU5CUVVNc1EwRkJaMElzVlVGQllTeEZRVUZpTEV0QlFVRXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJZaXhqUVVGaExFVkJRV0lzU1VGQllUdFpRVUUxUWl4SlFVRk5MRXRCUVVzc1UwRkJRVHR2UWtGQlRDeExRVUZMTzFOQlowTm1PMGxCUTBnc1EwRkJRenRKUVVWTkxHZERRVUZYTEVkQlFXeENPMUZCUVVFc2FVSkJhMEpETzFGQmFrSkRMRWxCUVUwc1pVRkJaU3hIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4SFFVRkhMRVZCUVVVc1EwRkJRenRuUTBGRmVrTXNTMEZCU3p0WlFVTmtMRXRCUVVzc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF6dFpRVVZ3UWl3MlEwRkJOa003V1VGRE4wTXNWMEZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVNc1QwRkJLMEk3WjBKQlEzQkZMRVZCUVVVc1EwRkJReXhEUVVGRkxFdEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRjFRaXhEUVVGRExFMUJRVTBzUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOeVJTeDNSRUZCZDBRN2IwSkJRM2hFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRPVUlzWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMjlDUVVNNVJDeERRVUZETzJkQ1FVTklMRU5CUVVNN1owSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdiMEpCUTA0c2IwTkJRVzlETzJkQ1FVTjBReXhEUVVGRE8xbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCWkVRc1IwRkJSeXhEUVVGRExFTkJRV2RDTEZWQlFXRXNSVUZCWWl4TFFVRkJMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRV0lzWTBGQllTeEZRVUZpTEVsQlFXRTdXVUZCTlVJc1NVRkJUU3hMUVVGTExGTkJRVUU3YjBKQlFVd3NTMEZCU3p0VFFXTm1PMGxCUTBnc1EwRkJRenRKUVVWTkxHdEVRVUUyUWl4SFFVRndRenRSUVVORkxFMUJRVTBzYjBKQlEwb3NTMEZCU3l4RlFVRkZMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkRja01zVFVGQlRTeEZRVUZGTEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZEY0VNc2IwSkJRVmNzUTBGQlF5eEZRVUZGTEVWQlFVVXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFVkJRVVVzZVVKQlFXdENMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVTjZSVHRKUVVOS0xFTkJRVU03U1VGRlRTeHhSRUZCWjBNc1IwRkJka01zVlVGQmQwTXNUMEZCWXp0UlFVTndSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJReXhGUVVGRkxFVkJRVVVzUzBGQlN5eEpRVUZMTEU5QlFVRXNTMEZCU3l4RFFVRkRMR2REUVVGblF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRXhReXhEUVVFd1F5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUTJ4SExFTkJRVU03U1VGRlJDeDFSRUZCZFVRN1NVRkRhRVFzTmtOQlFYZENMRWRCUVM5Q08xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zVDBGQlR5eEZRVUZGTEV0QlFVczdXVUZEZWtNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMSGRDUVVGM1FpeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTXhSQ3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEVkN4RFFVRkRPMGxCUjAwc01FTkJRWEZDTEVkQlFUVkNPMUZCUTBVc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1QwRkJUeXhGUVVGRkxFdEJRVXM3V1VGRGVrTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEhGQ1FVRnhRaXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU4yUkN4RFFVRkRMRVZCUVVVc2EwTkJRVEJDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOMlF5eERRVUZETzBsQlJVMHNNRU5CUVhGQ0xFZEJRVFZDTEZWQlFUWkNMRWxCUVdNN1VVRkRla01zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUlVGQlJTeEZRVUZGTEV0QlFVc3NTVUZCU3l4UFFVRkJMRXRCUVVzc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJMMElzUTBGQkswSXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOc1JpeERRVUZETzBsQlJVMHNhVU5CUVZrc1IwRkJia0k3VVVGRFJ5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyeENMR2xEUVVGcFF6dFpRVU5xUXl4TlFVRk5MRU5CUVVNc2RVSkJRVmtzUTBGQlF5eFhRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZSQ3hEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXp0SlFVTmFMRU5CUVVNN1NVRkZUU3h0UTBGQll5eEhRVUZ5UWp0UlFVTkZMRzlEUVVGdlF6dFJRVU53UXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4TlFVRk5MRVZCUVVVc1EwRkJRenRaUVVOd1F5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zWTBGQll5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTXpReXhEUVVGRExFVkJRVVVzYVVKQlFVMHNZMEZCWXl4WFFVRkZMRU5CUVVNc1EwRkJRenRKUVVNM1FpeERRVUZETzBsQlJVMHNiVU5CUVdNc1IwRkJja0k3VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWTkxHdERRVUZoTEVkQlFYQkNPMUZCUTBVc1RVRkJUU3hEUVVGRExIVkRRVUV5UWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hqUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJReXhMUVVGTE8xbEJRM1pGTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1lVRkJZU3hGUVVGRkxFTkJRVU03VVVGREwwSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMUFzUTBGQlF6dEpRVU5JTEdsQ1FVRkRPMEZCUVVRc1EwRkJReXhCUVhwTlJDeERRVUZuUXl4aFFVRkxMRWRCZVUxd1F6dEJRWHBOV1N4blEwRkJWU0o5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmV4cG9ydHMuSEVBREVSX0NIQU5ORUxTID0gWydyb3cnLCAnY29sdW1uJ107XG5leHBvcnRzLkhFQURFUl9UWVBFUyA9IFsnaGVhZGVyJywgJ2Zvb3RlciddO1xuZnVuY3Rpb24gZ2V0SGVhZGVyVHlwZShvcmllbnQpIHtcbiAgICBpZiAob3JpZW50ID09PSAndG9wJyB8fCBvcmllbnQgPT09ICdsZWZ0Jykge1xuICAgICAgICByZXR1cm4gJ2hlYWRlcic7XG4gICAgfVxuICAgIHJldHVybiAnZm9vdGVyJztcbn1cbmV4cG9ydHMuZ2V0SGVhZGVyVHlwZSA9IGdldEhlYWRlclR5cGU7XG5mdW5jdGlvbiBnZXRUaXRsZUdyb3VwKG1vZGVsLCBjaGFubmVsKSB7XG4gICAgdmFyIHNpemVDaGFubmVsID0gY2hhbm5lbCA9PT0gJ3JvdycgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIHRpdGxlID0gbW9kZWwuY29tcG9uZW50LmxheW91dEhlYWRlcnNbY2hhbm5lbF0udGl0bGU7XG4gICAgdmFyIHBvc2l0aW9uQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICdyb3cnID8gJ3knIDogJ3gnO1xuICAgIHZhciBhbGlnbiA9IGNoYW5uZWwgPT09ICdyb3cnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuICAgIHZhciB0ZXh0T3JpZW50ID0gY2hhbm5lbCA9PT0gJ3JvdycgPyAndmVydGljYWwnIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG1vZGVsLmdldE5hbWUoY2hhbm5lbCArIFwiX3RpdGxlXCIpLFxuICAgICAgICByb2xlOiBjaGFubmVsICsgXCItdGl0bGVcIixcbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJvbGU6IGNoYW5uZWwgKyBcIi10aXRsZS10ZXh0XCIsXG4gICAgICAgICAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdHNsaWJfMS5fX2Fzc2lnbigoX2EgPSB7fSwgX2FbcG9zaXRpb25DaGFubmVsXSA9IHsgc2lnbmFsOiBcIjAuNSAqIFwiICsgc2l6ZUNoYW5uZWwgfSwgX2EuYWxpZ24gPSB7IHZhbHVlOiBhbGlnbiB9LCBfYS50ZXh0ID0geyB2YWx1ZTogdGl0bGUgfSwgX2EuZmlsbCA9IHsgdmFsdWU6ICdibGFjaycgfSwgX2EuZm9udFdlaWdodCA9IHsgdmFsdWU6ICdib2xkJyB9LCBfYSksICh0ZXh0T3JpZW50ID09PSAndmVydGljYWwnID8geyBhbmdsZTogeyB2YWx1ZTogMjcwIH0gfSA6IHt9KSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgIH07XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy5nZXRUaXRsZUdyb3VwID0gZ2V0VGl0bGVHcm91cDtcbmZ1bmN0aW9uIGdldEhlYWRlckdyb3VwKG1vZGVsLCBjaGFubmVsLCBoZWFkZXJUeXBlLCBsYXlvdXRIZWFkZXIsIGhlYWRlcikge1xuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICAgICAgaWYgKGxheW91dEhlYWRlci5maWVsZFJlZiAmJiBoZWFkZXIubGFiZWxzKSB7XG4gICAgICAgICAgICB0aXRsZSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYXlvdXRIZWFkZXIuZmllbGRSZWYsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxMCxcbiAgICAgICAgICAgICAgICBvcmllbnQ6IGNoYW5uZWwgPT09ICdyb3cnID8gJ2xlZnQnIDogJ3RvcCcsXG4gICAgICAgICAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdHNsaWJfMS5fX2Fzc2lnbih7IGZvbnRXZWlnaHQ6IHsgdmFsdWU6ICdub3JtYWwnIH0sIGFuZ2xlOiB7IHZhbHVlOiAwIH0sIGZvbnRTaXplOiB7IHZhbHVlOiAxMCB9IH0sIChjaGFubmVsID09PSAncm93JyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiB7IHZhbHVlOiAncmlnaHQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlbGluZTogeyB2YWx1ZTogJ21pZGRsZScgfVxuICAgICAgICAgICAgICAgICAgICB9IDoge30pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSBoZWFkZXIuYXhlcztcbiAgICAgICAgdmFyIGhhc0F4ZXMgPSBheGVzICYmIGF4ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHRpdGxlIHx8IGhhc0F4ZXMpIHtcbiAgICAgICAgICAgIHZhciBzaXplQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICdyb3cnID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oeyBuYW1lOiBtb2RlbC5nZXROYW1lKGNoYW5uZWwgKyBcIl9cIiArIGhlYWRlclR5cGUpLCB0eXBlOiAnZ3JvdXAnLCByb2xlOiBjaGFubmVsICsgXCItXCIgKyBoZWFkZXJUeXBlIH0sIChsYXlvdXRIZWFkZXIuZmllbGRSZWYgPyB7IGZyb206IHsgZGF0YTogbW9kZWwuZ2V0TmFtZShjaGFubmVsKSB9IH0gOiB7fSksICh0aXRsZSA/IHsgdGl0bGU6IHRpdGxlIH0gOiB7fSksIHsgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBfYVtzaXplQ2hhbm5lbF0gPSBoZWFkZXIuc2l6ZVNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hKVxuICAgICAgICAgICAgICAgIH0gfSwgKGhhc0F4ZXMgPyB7IGF4ZXM6IGF4ZXMgfSA6IHt9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy5nZXRIZWFkZXJHcm91cCA9IGdldEhlYWRlckdyb3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYUdWaFpHVnlMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YkdGNWIzVjBMMmhsWVdSbGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGWFlTeFJRVUZCTEdWQlFXVXNSMEZCYjBJc1EwRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdRVUZIY2tRc1VVRkJRU3haUVVGWkxFZEJRV2xDTEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8wRkJNa012UkN4MVFrRkJPRUlzVFVGQmEwSTdTVUZET1VNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeExRVUZMTEV0QlFVc3NTVUZCU1N4TlFVRk5MRXRCUVVzc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14UXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRE8wbEJRMnhDTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRE8wRkJRMnhDTEVOQlFVTTdRVUZNUkN4elEwRkxRenRCUVVWRUxIVkNRVUU0UWl4TFFVRlpMRVZCUVVVc1QwRkJjMEk3U1VGRGFFVXNTVUZCVFN4WFFVRlhMRWRCUVVjc1QwRkJUeXhMUVVGTExFdEJRVXNzUjBGQlJ5eFJRVUZSTEVkQlFVY3NUMEZCVHl4RFFVRkRPMGxCUXpORUxFbEJRVTBzUzBGQlN5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXp0SlFVTXpSQ3hKUVVGTkxHVkJRV1VzUjBGQlJ5eFBRVUZQTEV0QlFVc3NTMEZCU3l4SFFVRkhMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU03U1VGRGRFUXNTVUZCVFN4TFFVRkxMRWRCUVVjc1QwRkJUeXhMUVVGTExFdEJRVXNzUjBGQlJ5eFBRVUZQTEVkQlFVY3NVVUZCVVN4RFFVRkRPMGxCUTNKRUxFbEJRVTBzVlVGQlZTeEhRVUZITEU5QlFVOHNTMEZCU3l4TFFVRkxMRWRCUVVjc1ZVRkJWU3hIUVVGSExGTkJRVk1zUTBGQlF6dEpRVVU1UkN4TlFVRk5MRU5CUVVNN1VVRkRUQ3hKUVVGSkxFVkJRVWNzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCU1N4UFFVRlBMRmRCUVZFc1EwRkJRenRSUVVONFF5eEpRVUZKTEVWQlFVc3NUMEZCVHl4WFFVRlJPMUZCUTNoQ0xFbEJRVWtzUlVGQlJTeFBRVUZQTzFGQlEySXNTMEZCU3l4RlFVRkZMRU5CUVVNN1owSkJRMDRzU1VGQlNTeEZRVUZGTEUxQlFVMDdaMEpCUTFvc1NVRkJTU3hGUVVGTExFOUJRVThzWjBKQlFXRTdaMEpCUXpkQ0xFMUJRVTBzUlVGQlJUdHZRa0ZEVGl4TlFVRk5MR2REUVVWSUxHVkJRV1VzU1VGQlJ5eEZRVUZETEUxQlFVMHNSVUZCUlN4WFFVRlRMRmRCUVdFc1JVRkJReXhGUVVOdVJDeFJRVUZMTEVkQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhGUVVGRExFVkJRM0pDTEU5QlFVa3NSMEZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVU1zUlVGRGNFSXNUMEZCU1N4SFFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlF5eEZRVU4wUWl4aFFVRlZMRWRCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzVFVGQlRTeEZRVUZETEU5QlEzaENMRU5CUVVNc1ZVRkJWU3hMUVVGTExGVkJRVlVzUjBGQlJ5eEZRVUZETEV0QlFVc3NSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hIUVVGSExFVkJRVU1zUlVGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVTTFSRHRwUWtGRFJqdGhRVU5HTEVOQlFVTTdTMEZEU0N4RFFVRkRPenRCUVVOS0xFTkJRVU03UVVFelFrUXNjME5CTWtKRE8wRkJSVVFzZDBKQlFTdENMRXRCUVZrc1JVRkJSU3hQUVVGelFpeEZRVUZGTEZWQlFYTkNMRVZCUVVVc1dVRkJiVU1zUlVGQlJTeE5RVUYxUWp0SlFVTjJTaXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTFnc1NVRkJTU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEycENMRVZCUVVVc1EwRkJReXhEUVVGRExGbEJRVmtzUTBGQlF5eFJRVUZSTEVsQlFVa3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE0wTXNTMEZCU3l4SFFVRkhPMmRDUVVOT0xFbEJRVWtzUlVGQlJTeFpRVUZaTEVOQlFVTXNVVUZCVVR0blFrRkRNMElzVFVGQlRTeEZRVUZGTEVWQlFVVTdaMEpCUTFZc1RVRkJUU3hGUVVGRkxFOUJRVThzUzBGQlN5eExRVUZMTEVkQlFVY3NUVUZCVFN4SFFVRkhMRXRCUVVzN1owSkJRekZETEUxQlFVMHNSVUZCUlR0dlFrRkRUaXhOUVVGTkxIRkNRVU5LTEZWQlFWVXNSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hSUVVGUkxFVkJRVU1zUlVGRE4wSXNTMEZCU3l4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUlVGQlF5eEZRVU5xUWl4UlFVRlJMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlJTeEZRVUZETEVsQlEycENMRU5CUVVNc1QwRkJUeXhMUVVGTExFdEJRVXNzUjBGQlJ6dDNRa0ZEZGtJc1MwRkJTeXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUXp0M1FrRkRka0lzVVVGQlVTeEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJRenR4UWtGRE5VSXNSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkRVanRwUWtGRFJqdGhRVU5HTEVOQlFVTTdVVUZEU2l4RFFVRkRPMUZCUlVRc1NVRkJUU3hKUVVGSkxFZEJRVWNzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0UlFVVjZRaXhKUVVGTkxFOUJRVThzUjBGQlJ5eEpRVUZKTEVsQlFVa3NTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGVFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhKUVVGSkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tJc1NVRkJUU3hYUVVGWExFZEJRVWNzVDBGQlR5eExRVUZMTEV0QlFVc3NSMEZCUnl4UlFVRlJMRWRCUVVjc1QwRkJUeXhEUVVGRE8xbEJSVE5FTEUxQlFVMHNiMEpCUTBvc1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVa3NUMEZCVHl4VFFVRkpMRlZCUVZrc1EwRkJReXhGUVVNdlF5eEpRVUZKTEVWQlFVVXNUMEZCVHl4RlFVTmlMRWxCUVVrc1JVRkJTeXhQUVVGUExGTkJRVWtzVlVGQldTeEpRVU0zUWl4RFFVRkRMRmxCUVZrc1EwRkJReXhSUVVGUkxFZEJRVWNzUlVGQlF5eEpRVUZKTEVWQlFVVXNSVUZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUXl4RlFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFVkJRM0pGTEVOQlFVTXNTMEZCU3l4SFFVRkhMRVZCUVVNc1MwRkJTeXhQUVVGQkxFVkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZEZWtJc1RVRkJUU3hGUVVGRk8yOUNRVU5PTEUxQlFVMDdkMEpCUTBvc1IwRkJReXhYUVVGWExFbEJRVWNzVFVGQlRTeERRVUZETEZWQlFWVTdNa0pCUTJwRE8ybENRVU5HTEVsQlEwVXNRMEZCUXl4UFFVRlBMRWRCUVVjc1JVRkJReXhKUVVGSkxFMUJRVUVzUlVGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RlFVTXhRanRSUVVOS0xFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenM3UVVGRFpDeERRVUZETzBGQk5VTkVMSGREUVRSRFF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xuLy8gVE9ETzogcmV3cml0ZSB0aGlzIHN1Y2ggdGhhdCB3ZSBtZXJnZSByZWR1bmRhbnQgc2lnbmFsc1xuZnVuY3Rpb24gYXNzZW1ibGVMYXlvdXRMYXllclNpZ25hbHMobW9kZWwpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7IG5hbWU6IG1vZGVsLmdldE5hbWUoJ3dpZHRoJyksIHVwZGF0ZTogbGF5ZXJTaXplRXhwcihtb2RlbCwgJ3dpZHRoJykgfSxcbiAgICAgICAgeyBuYW1lOiBtb2RlbC5nZXROYW1lKCdoZWlnaHQnKSwgdXBkYXRlOiBsYXllclNpemVFeHByKG1vZGVsLCAnaGVpZ2h0JykgfVxuICAgIF07XG59XG5leHBvcnRzLmFzc2VtYmxlTGF5b3V0TGF5ZXJTaWduYWxzID0gYXNzZW1ibGVMYXlvdXRMYXllclNpZ25hbHM7XG5mdW5jdGlvbiBsYXllclNpemVFeHByKG1vZGVsLCBzaXplVHlwZSkge1xuICAgIHZhciBjaGlsZHJlblNpemVTaWduYWxzID0gbW9kZWwuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQuZ2V0TmFtZShzaXplVHlwZSk7IH0pLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIFwibWF4KFwiICsgY2hpbGRyZW5TaXplU2lnbmFscyArIFwiKVwiO1xufVxuZXhwb3J0cy5sYXllclNpemVFeHByID0gbGF5ZXJTaXplRXhwcjtcbmZ1bmN0aW9uIGFzc2VtYmxlTGF5b3V0VW5pdFNpZ25hbHMobW9kZWwpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7IG5hbWU6IG1vZGVsLmdldE5hbWUoJ3dpZHRoJyksIHVwZGF0ZTogdW5pdFNpemVFeHByKG1vZGVsLCAnd2lkdGgnKSB9LFxuICAgICAgICB7IG5hbWU6IG1vZGVsLmdldE5hbWUoJ2hlaWdodCcpLCB1cGRhdGU6IHVuaXRTaXplRXhwcihtb2RlbCwgJ2hlaWdodCcpIH1cbiAgICBdO1xufVxuZXhwb3J0cy5hc3NlbWJsZUxheW91dFVuaXRTaWduYWxzID0gYXNzZW1ibGVMYXlvdXRVbml0U2lnbmFscztcbmZ1bmN0aW9uIHVuaXRTaXplRXhwcihtb2RlbCwgc2l6ZVR5cGUpIHtcbiAgICB2YXIgY2hhbm5lbCA9IHNpemVUeXBlID09PSAnd2lkdGgnID8gJ3gnIDogJ3knO1xuICAgIHZhciBzY2FsZSA9IG1vZGVsLnNjYWxlKGNoYW5uZWwpO1xuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZS50eXBlKSAmJiBzY2FsZS5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgIHZhciBzY2FsZU5hbWUgPSBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbCk7XG4gICAgICAgICAgICB2YXIgY2FyZGluYWxpdHkgPSBcImRvbWFpbignXCIgKyBzY2FsZU5hbWUgKyBcIicpLmxlbmd0aFwiO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdPdXRlciA9IHNjYWxlLnBhZGRpbmdPdXRlciAhPT0gdW5kZWZpbmVkID8gc2NhbGUucGFkZGluZ091dGVyIDogc2NhbGUucGFkZGluZztcbiAgICAgICAgICAgIHZhciBwYWRkaW5nSW5uZXIgPSBzY2FsZS50eXBlID09PSAnYmFuZCcgP1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYmFuZCBoYXMgcmVhbCBwYWRkaW5nSW5uZXJcbiAgICAgICAgICAgICAgICAoc2NhbGUucGFkZGluZ0lubmVyICE9PSB1bmRlZmluZWQgPyBzY2FsZS5wYWRkaW5nSW5uZXIgOiBzY2FsZS5wYWRkaW5nKSA6XG4gICAgICAgICAgICAgICAgLy8gRm9yIHBvaW50LCBhcyBjYWxjdWxhdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2Etc2NhbGUvYmxvYi9tYXN0ZXIvc3JjL2JhbmQuanMjTDEyOCxcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGVxdWl2YWxlbnQgdG8gaGF2ZSBwYWRkaW5nSW5uZXIgPSAxIHNpbmNlIHRoZXJlIGlzIG9ubHkgbi0xIHN0ZXBzIGJldHdlZW4gbiBwb2ludHMuXG4gICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgIHJldHVybiBcImJhbmRzcGFjZShcIiArIGNhcmRpbmFsaXR5ICsgXCIsIFwiICsgcGFkZGluZ0lubmVyICsgXCIsIFwiICsgcGFkZGluZ091dGVyICsgXCIpICogXCIgKyBzY2FsZS5yYW5nZVN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBtb2RlbFtzaXplVHlwZV07XG59XG5leHBvcnRzLnVuaXRTaXplRXhwciA9IHVuaXRTaXplRXhwcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5c1lYbHZkWFF2YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGSFFTeHhRMEZCT0VNN1FVRlZPVU1zTUVSQlFUQkVPMEZCUXpGRUxHOURRVUV5UXl4TFFVRnBRanRKUVVNeFJDeE5RVUZOTEVOQlFVTTdVVUZEVEN4RlFVRkRMRWxCUVVrc1JVRkJSU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRTFCUVUwc1JVRkJSU3hoUVVGaExFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RlFVRkRPMUZCUTNKRkxFVkJRVU1zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFVkJRVVVzVFVGQlRTeEZRVUZGTEdGQlFXRXNRMEZCUXl4TFFVRkxMRVZCUVVVc1VVRkJVU3hEUVVGRExFVkJRVU03UzBGRGVFVXNRMEZCUXp0QlFVTktMRU5CUVVNN1FVRk1SQ3huUlVGTFF6dEJRVVZFTEhWQ1FVRTRRaXhMUVVGcFFpeEZRVUZGTEZGQlFUUkNPMGxCUXpORkxFbEJRVTBzYlVKQlFXMUNMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4TFFVRkxMRWxCUVVrc1QwRkJRU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRjJRaXhEUVVGMVFpeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRelZHTEUxQlFVMHNRMEZCUXl4VFFVRlBMRzFDUVVGdFFpeE5RVUZITEVOQlFVTTdRVUZEZGtNc1EwRkJRenRCUVVoRUxITkRRVWRETzBGQlJVUXNiVU5CUVRCRExFdEJRV2RDTzBsQlEzaEVMRTFCUVUwc1EwRkJRenRSUVVOTUxFVkJRVU1zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVVzVFVGQlRTeEZRVUZGTEZsQlFWa3NRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRExFVkJRVU03VVVGRGNFVXNSVUZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlN4TlFVRk5MRVZCUVVVc1dVRkJXU3hEUVVGRExFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNSVUZCUXp0TFFVTjJSU3hEUVVGRE8wRkJRMG9zUTBGQlF6dEJRVXhFTERoRVFVdERPMEZCUlVRc2MwSkJRVFpDTEV0QlFXZENMRVZCUVVVc1VVRkJORUk3U1VGRGVrVXNTVUZCVFN4UFFVRlBMRWRCUVVjc1VVRkJVU3hMUVVGSExFOUJRVThzUjBGQlJ5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUXk5RExFbEJRVTBzUzBGQlN5eEhRVUZITEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGJrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5XTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGxDUVVGcFFpeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnlSQ3hKUVVGTkxGTkJRVk1zUjBGQlJ5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xbEJSVE5ETEVsQlFVMHNWMEZCVnl4SFFVRkhMR0ZCUVZjc1UwRkJVeXhqUVVGWExFTkJRVU03V1VGRGNFUXNTVUZCVFN4WlFVRlpMRWRCUVVjc1MwRkJTeXhEUVVGRExGbEJRVmtzUzBGQlN5eFRRVUZUTEVkQlFVY3NTMEZCU3l4RFFVRkRMRmxCUVZrc1IwRkJSeXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETzFsQlF6TkdMRWxCUVUwc1dVRkJXU3hIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NUVUZCVFR0blFrRkRlRU1zYTBOQlFXdERPMmRDUVVOc1F5eERRVUZETEV0QlFVc3NRMEZCUXl4WlFVRlpMRXRCUVVzc1UwRkJVeXhIUVVGSExFdEJRVXNzUTBGQlF5eFpRVUZaTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJRenRuUWtGRGRrVXNLMFpCUVN0R08yZENRVU12Uml3eVJrRkJNa1k3WjBKQlF6TkdMRU5CUVVNc1EwRkJRenRaUVVWS0xFMUJRVTBzUTBGQlF5eGxRVUZoTEZkQlFWY3NWVUZCU3l4WlFVRlpMRlZCUVVzc1dVRkJXU3haUVVGUExFdEJRVXNzUTBGQlF5eFRRVUZYTEVOQlFVTTdVVUZETlVZc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNTMEZCUnl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGSExFTkJRVU03UVVGRE9VSXNRMEZCUXp0QlFYQkNSQ3h2UTBGdlFrTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBtYXJrXzEgPSByZXF1aXJlKFwiLi4vLi4vbWFya1wiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4uL21hcmsvbWl4aW5zXCIpO1xuZnVuY3Rpb24gc3ltYm9scyhmaWVsZERlZiwgc3ltYm9sc1NwZWMsIG1vZGVsLCBjaGFubmVsKSB7XG4gICAgdmFyIHN5bWJvbHMgPSB7fTtcbiAgICB2YXIgbWFyayA9IG1vZGVsLm1hcmsoKTtcbiAgICBzd2l0Y2ggKG1hcmspIHtcbiAgICAgICAgY2FzZSBtYXJrXzEuQkFSOlxuICAgICAgICBjYXNlIG1hcmtfMS5USUNLOlxuICAgICAgICBjYXNlIG1hcmtfMS5URVhUOlxuICAgICAgICAgICAgc3ltYm9scy5zaGFwZSA9IHsgdmFsdWU6ICdzcXVhcmUnIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXJrXzEuQ0lSQ0xFOlxuICAgICAgICBjYXNlIG1hcmtfMS5TUVVBUkU6XG4gICAgICAgICAgICBzeW1ib2xzLnNoYXBlID0geyB2YWx1ZTogbWFyayB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWFya18xLlBPSU5UOlxuICAgICAgICBjYXNlIG1hcmtfMS5MSU5FOlxuICAgICAgICBjYXNlIG1hcmtfMS5BUkVBOlxuICAgICAgICAgICAgLy8gdXNlIGRlZmF1bHQgY2lyY2xlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGNmZyA9IG1vZGVsLmNvbmZpZztcbiAgICB2YXIgZmlsbGVkID0gbW9kZWwubWFya0RlZi5maWxsZWQ7XG4gICAgdmFyIGNvbmZpZyA9IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5DT0xPUiA/XG4gICAgICAgIC8qIEZvciBjb2xvcidzIGxlZ2VuZCwgZG8gbm90IHNldCBmaWxsICh3aGVuIGZpbGxlZCkgb3Igc3Ryb2tlICh3aGVuIHVuZmlsbGVkKSBwcm9wZXJ0eSBmcm9tIGNvbmZpZyBiZWNhdXNlIHRoZSBsZWdlbmQncyBgZmlsbGAgb3IgYHN0cm9rZWAgc2NhbGUgc2hvdWxkIGhhdmUgcHJlY2VkZW5jZSAqL1xuICAgICAgICB1dGlsXzEud2l0aG91dChtYXJrXzEuRklMTF9TVFJPS0VfQ09ORklHLCBbZmlsbGVkID8gJ2ZpbGwnIDogJ3N0cm9rZScsICdzdHJva2VEYXNoJywgJ3N0cm9rZURhc2hPZmZzZXQnXSkgOlxuICAgICAgICAvKiBGb3Igb3RoZXIgbGVnZW5kLCBubyBuZWVkIHRvIG9taXQuICovXG4gICAgICAgIG1hcmtfMS5GSUxMX1NUUk9LRV9DT05GSUc7XG4gICAgY29uZmlnID0gdXRpbF8xLndpdGhvdXQoY29uZmlnLCBbJ3N0cm9rZURhc2gnLCAnc3Ryb2tlRGFzaE9mZnNldCddKTtcbiAgICBjb21tb25fMS5hcHBseU1hcmtDb25maWcoc3ltYm9scywgbW9kZWwsIGNvbmZpZyk7XG4gICAgaWYgKGNoYW5uZWwgIT09IGNoYW5uZWxfMS5DT0xPUikge1xuICAgICAgICB2YXIgY29sb3JNaXhpbnMgPSBtaXhpbnMuY29sb3IobW9kZWwpO1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZmllbGQgZm9yIGZpbGwgb3Igc3Ryb2tlLCByZW1vdmUgdGhlbSBhcyB3ZSBhbHJlYWR5IGFwcGx5IGNoYW5uZWxzLlxuICAgICAgICBpZiAoY29sb3JNaXhpbnMuZmlsbCAmJiBmaWVsZGRlZl8xLmlzRmllbGREZWYoY29sb3JNaXhpbnMuZmlsbCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb2xvck1peGlucy5maWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvck1peGlucy5zdHJva2UgJiYgZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNvbG9yTWl4aW5zLnN0cm9rZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb2xvck1peGlucy5zdHJva2U7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLmV4dGVuZChzeW1ib2xzLCBjb2xvck1peGlucyk7XG4gICAgfVxuICAgIGlmIChjaGFubmVsICE9PSBjaGFubmVsXzEuU0hBUEUpIHtcbiAgICAgICAgdmFyIHNoYXBlRGVmID0gbW9kZWwuZW5jb2Rpbmcuc2hhcGU7XG4gICAgICAgIGlmIChmaWVsZGRlZl8xLmlzVmFsdWVEZWYoc2hhcGVEZWYpKSB7XG4gICAgICAgICAgICBzeW1ib2xzLnNoYXBlID0geyB2YWx1ZTogc2hhcGVEZWYudmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW1ib2xzID0gdXRpbF8xLmV4dGVuZChzeW1ib2xzLCBzeW1ib2xzU3BlYyB8fCB7fSk7XG4gICAgcmV0dXJuIHV0aWxfMS5rZXlzKHN5bWJvbHMpLmxlbmd0aCA+IDAgPyBzeW1ib2xzIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9scztcbmZ1bmN0aW9uIGxhYmVscyhmaWVsZERlZiwgbGFiZWxzU3BlYywgbW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgbGVnZW5kID0gbW9kZWwubGVnZW5kKGNoYW5uZWwpO1xuICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWc7XG4gICAgdmFyIGxhYmVscyA9IHt9O1xuICAgIGlmIChmaWVsZERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUwpIHtcbiAgICAgICAgbGFiZWxzU3BlYyA9IHV0aWxfMS5leHRlbmQoe1xuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIHNpZ25hbDogY29tbW9uXzEudGltZUZvcm1hdEV4cHJlc3Npb24oJ2RhdHVtLnZhbHVlJywgZmllbGREZWYudGltZVVuaXQsIGxlZ2VuZC5mb3JtYXQsIGNvbmZpZy5sZWdlbmQuc2hvcnRUaW1lTGFiZWxzLCBjb25maWcudGltZUZvcm1hdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbGFiZWxzU3BlYyB8fCB7fSk7XG4gICAgfVxuICAgIGxhYmVscyA9IHV0aWxfMS5leHRlbmQobGFiZWxzLCBsYWJlbHNTcGVjIHx8IHt9KTtcbiAgICByZXR1cm4gdXRpbF8xLmtleXMobGFiZWxzKS5sZW5ndGggPiAwID8gbGFiZWxzIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5sYWJlbHMgPSBsYWJlbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laVzVqYjJSbExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZiR1ZuWlc1a0wyVnVZMjlrWlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEhsRFFVRnZSRHRCUVVOd1JDd3lRMEZCWjBVN1FVRkRhRVVzYlVOQlFXdEhPMEZCUTJ4SExHMURRVUZ2UXp0QlFVTndReXh0UTBGQmFVUTdRVUZKYWtRc2IwTkJRV2RGTzBGQlEyaEZMSFZEUVVGNVF6dEJRVWQ2UXl4cFFrRkJkMElzVVVGQk1FSXNSVUZCUlN4WFFVRm5RaXhGUVVGRkxFdEJRV2RDTEVWQlFVVXNUMEZCWjBJN1NVRkRkRWNzU1VGQlNTeFBRVUZQTEVkQlFVOHNSVUZCUlN4RFFVRkRPMGxCUTNKQ0xFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRKUVVVeFFpeE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMklzUzBGQlN5eFZRVUZITEVOQlFVTTdVVUZEVkN4TFFVRkxMRmRCUVVrc1EwRkJRenRSUVVOV0xFdEJRVXNzVjBGQlNUdFpRVU5RTEU5QlFVOHNRMEZCUXl4TFFVRkxMRWRCUVVjc1JVRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeEZRVUZETEVOQlFVTTdXVUZEYkVNc1MwRkJTeXhEUVVGRE8xRkJRMUlzUzBGQlN5eGhRVUZOTEVOQlFVTTdVVUZEV2l4TFFVRkxMR0ZCUVUwN1dVRkRWQ3hQUVVGUExFTkJRVU1zUzBGQlN5eEhRVUZITEVWQlFVTXNTMEZCU3l4RlFVRkZMRWxCUVVrc1JVRkJReXhEUVVGRE8xbEJRemxDTEV0QlFVc3NRMEZCUXp0UlFVTlNMRXRCUVVzc1dVRkJTeXhEUVVGRE8xRkJRMWdzUzBGQlN5eFhRVUZKTEVOQlFVTTdVVUZEVml4TFFVRkxMRmRCUVVrN1dVRkRVQ3h4UWtGQmNVSTdXVUZEY2tJc1MwRkJTeXhEUVVGRE8wbEJRMVlzUTBGQlF6dEpRVVZFTEVsQlFVMHNSMEZCUnl4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGVrSXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZGY0VNc1NVRkJTU3hOUVVGTkxFZEJRVWNzVDBGQlR5eExRVUZMTEdWQlFVczdVVUZETVVJc01rdEJRVEpMTzFGQlF6TkxMR05CUVU4c1EwRkJReXg1UWtGQmEwSXNSVUZCUlN4RFFVRkZMRTFCUVUwc1IwRkJSeXhOUVVGTkxFZEJRVWNzVVVGQlVTeEZRVUZGTEZsQlFWa3NSVUZCUlN4clFrRkJhMElzUTBGQlF5eERRVUZETzFGQlF6VkdMSGREUVVGM1F6dFJRVU40UXl4NVFrRkJhMElzUTBGQlF6dEpRVVYyUWl4TlFVRk5MRWRCUVVjc1kwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEZsQlFWa3NSVUZCUlN4clFrRkJhMElzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGTjBRc2QwSkJRV1VzUTBGQlF5eFBRVUZQTEVWQlFVVXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8wbEJSWGhETEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhsUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRWxCUVUwc1YwRkJWeXhIUVVGSExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkZlRU1zYlVaQlFXMUdPMUZCUTI1R0xFVkJRVVVzUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRWxCUVVrc2NVSkJRVlVzUTBGQlF5eFhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pFTEU5QlFVOHNWMEZCVnl4RFFVRkRMRWxCUVVrc1EwRkJRenRSUVVNeFFpeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1YwRkJWeXhEUVVGRExFMUJRVTBzU1VGQlNTeHhRa0ZCVlN4RFFVRkRMRmRCUVZjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtRc1QwRkJUeXhYUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETzFGQlF6VkNMRU5CUVVNN1VVRkRSQ3hoUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEZkQlFWY3NRMEZCUXl4RFFVRkRPMGxCUXk5Q0xFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1pVRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUWl4SlFVRk5MRkZCUVZFc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTjBReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UWl4UFFVRlBMRU5CUVVNc1MwRkJTeXhIUVVGSExFVkJRVU1zUzBGQlN5eEZRVUZGTEZGQlFWRXNRMEZCUXl4TFFVRkxMRVZCUVVNc1EwRkJRenRSUVVNeFF5eERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVkVMRTlCUVU4c1IwRkJSeXhoUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEZkQlFWY3NTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVVM1F5eE5RVUZOTEVOQlFVTXNWMEZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVkQlFVY3NUMEZCVHl4SFFVRkhMRk5CUVZNc1EwRkJRenRCUVVONFJDeERRVUZETzBGQmVrUkVMREJDUVhsRVF6dEJRVVZFTEdkQ1FVRjFRaXhSUVVFd1FpeEZRVUZGTEZWQlFXVXNSVUZCUlN4TFFVRm5RaXhGUVVGRkxFOUJRV2RDTzBsQlEzQkhMRWxCUVUwc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRja01zU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVVMVFpeEpRVUZKTEUxQlFVMHNSMEZCVHl4RlFVRkZMRU5CUVVNN1NVRkZjRUlzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1MwRkJTeXhsUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF5OUNMRlZCUVZVc1IwRkJSeXhoUVVGTkxFTkJRVU03V1VGRGJFSXNTVUZCU1N4RlFVRkZPMmRDUVVOS0xFMUJRVTBzUlVGQlJTdzJRa0ZCYjBJc1EwRkJReXhoUVVGaExFVkJRVVVzVVVGQlVTeERRVUZETEZGQlFWRXNSVUZCUlN4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNaVUZCWlN4RlFVRkZMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU03WVVGRGFFazdVMEZEUml4RlFVRkZMRlZCUVZVc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU4yUWl4RFFVRkRPMGxCUlVRc1RVRkJUU3hIUVVGSExHRkJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNWVUZCVlN4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJSVEZETEUxQlFVMHNRMEZCUXl4WFFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNSMEZCUnl4TlFVRk5MRWRCUVVjc1UwRkJVeXhEUVVGRE8wRkJRM1JFTEVOQlFVTTdRVUZxUWtRc2QwSkJhVUpESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIGxlZ2VuZF8xID0gcmVxdWlyZShcIi4uLy4uL2xlZ2VuZFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgZW5jb2RlID0gcmVxdWlyZShcIi4vZW5jb2RlXCIpO1xudmFyIHJ1bGVzID0gcmVxdWlyZShcIi4vcnVsZXNcIik7XG5mdW5jdGlvbiBwYXJzZUxlZ2VuZENvbXBvbmVudChtb2RlbCkge1xuICAgIHJldHVybiBbY2hhbm5lbF8xLkNPTE9SLCBjaGFubmVsXzEuU0laRSwgY2hhbm5lbF8xLlNIQVBFLCBjaGFubmVsXzEuT1BBQ0lUWV0ucmVkdWNlKGZ1bmN0aW9uIChsZWdlbmRDb21wb25lbnQsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKG1vZGVsLmxlZ2VuZChjaGFubmVsKSkge1xuICAgICAgICAgICAgbGVnZW5kQ29tcG9uZW50W2NoYW5uZWxdID0gcGFyc2VMZWdlbmQobW9kZWwsIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWdlbmRDb21wb25lbnQ7XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5wYXJzZUxlZ2VuZENvbXBvbmVudCA9IHBhcnNlTGVnZW5kQ29tcG9uZW50O1xuZnVuY3Rpb24gZ2V0TGVnZW5kRGVmV2l0aFNjYWxlKG1vZGVsLCBjaGFubmVsKSB7XG4gICAgLy8gRm9yIGJpbm5lZCBmaWVsZCB3aXRoIGNvbnRpbnVvdXMgc2NhbGUsIHVzZSBhIHNwZWNpYWwgc2NhbGUgc28gd2UgY2FuIG92ZXJycmlkZSB0aGUgbWFyayBwcm9wcyBhbmQgbGFiZWxzXG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLkNPTE9SOlxuICAgICAgICAgICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5DT0xPUik7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwubWFya0RlZi5maWxsZWQgPyB7IGZpbGw6IHNjYWxlIH0gOiB7IHN0cm9rZTogc2NhbGUgfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0laRTpcbiAgICAgICAgICAgIHJldHVybiB7IHNpemU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuU0laRSkgfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4geyBzaGFwZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5TSEFQRSkgfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuT1BBQ0lUWTpcbiAgICAgICAgICAgIHJldHVybiB7IG9wYWNpdHk6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuT1BBQ0lUWSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUxlZ2VuZChtb2RlbCwgY2hhbm5lbCkge1xuICAgIHZhciBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgIHZhciBsZWdlbmQgPSBtb2RlbC5sZWdlbmQoY2hhbm5lbCk7XG4gICAgdmFyIGRlZiA9IGdldExlZ2VuZERlZldpdGhTY2FsZShtb2RlbCwgY2hhbm5lbCk7XG4gICAgbGVnZW5kXzEuTEVHRU5EX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUocHJvcGVydHksIGxlZ2VuZCwgY2hhbm5lbCwgbW9kZWwpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gMikgQWRkIG1hcmsgcHJvcGVydHkgZGVmaW5pdGlvbiBncm91cHNcbiAgICB2YXIgZW5jb2RlU3BlYyA9IGxlZ2VuZC5lbmNvZGUgfHwge307XG4gICAgWydsYWJlbHMnLCAnbGVnZW5kJywgJ3RpdGxlJywgJ3N5bWJvbHMnXS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGVuY29kZVtwYXJ0XSA/XG4gICAgICAgICAgICBlbmNvZGVbcGFydF0oZmllbGREZWYsIGVuY29kZVNwZWNbcGFydF0sIG1vZGVsLCBjaGFubmVsKSA6XG4gICAgICAgICAgICBlbmNvZGVTcGVjW3BhcnRdOyAvLyBubyBydWxlIC0tIGp1c3QgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdXRpbF8xLmtleXModmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlZi5lbmNvZGUgPSBkZWYuZW5jb2RlIHx8IHt9O1xuICAgICAgICAgICAgZGVmLmVuY29kZVtwYXJ0XSA9IHsgdXBkYXRlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmV4cG9ydHMucGFyc2VMZWdlbmQgPSBwYXJzZUxlZ2VuZDtcbmZ1bmN0aW9uIGdldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlKHByb3BlcnR5LCBzcGVjaWZpZWRMZWdlbmQsIGNoYW5uZWwsIG1vZGVsKSB7XG4gICAgdmFyIGZpZWxkRGVmID0gbW9kZWwuZmllbGREZWYoY2hhbm5lbCk7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlICdmb3JtYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm51bWJlckZvcm1hdChmaWVsZERlZiwgc3BlY2lmaWVkTGVnZW5kLmZvcm1hdCwgbW9kZWwuY29uZmlnLCBjaGFubmVsKTtcbiAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnRpdGxlKHNwZWNpZmllZExlZ2VuZCwgZmllbGREZWYsIG1vZGVsLmNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ3ZhbHVlcyc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMudmFsdWVzKHNwZWNpZmllZExlZ2VuZCk7XG4gICAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnR5cGUoc3BlY2lmaWVkTGVnZW5kLCBmaWVsZERlZi50eXBlLCBjaGFubmVsLCBtb2RlbC5zY2FsZShjaGFubmVsKS50eXBlKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gc3BlY2lmaWVkIHByb3BlcnR5LlxuICAgIHJldHVybiBzcGVjaWZpZWRMZWdlbmRbcHJvcGVydHldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0dGeWMyVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlzWldkbGJtUXZjR0Z5YzJVdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4NVEwRkJiVVU3UVVGRGJrVXNkVU5CUVhWRU8wRkJRM1pFTEcxRFFVRnpRenRCUVVkMFF5eHZRMEZCZFVNN1FVRkhka01zYVVOQlFXMURPMEZCUTI1RExDdENRVUZwUXp0QlFVVnFReXc0UWtGQmNVTXNTMEZCWjBJN1NVRkRia1FzVFVGQlRTeERRVUZETEVOQlFVTXNaVUZCU3l4RlFVRkZMR05CUVVrc1JVRkJSU3hsUVVGTExFVkJRVVVzYVVKQlFVOHNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVExHVkJRV1VzUlVGQlJTeFBRVUZQTzFGQlF6TkZMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZDTEdWQlFXVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhYUVVGWExFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUTNwRUxFTkJRVU03VVVGRFJDeE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRPMGxCUTNwQ0xFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0QlFVTlVMRU5CUVVNN1FVRlFSQ3h2UkVGUFF6dEJRVVZFTEN0Q1FVRXJRaXhMUVVGblFpeEZRVUZGTEU5QlFXZENPMGxCUXk5RUxEUkhRVUUwUnp0SlFVTTFSeXhOUVVGTkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFdEJRVXNzWlVGQlN6dFpRVU5TTEVsQlFVMHNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zWlVGQlN5eERRVUZETEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4SFFVRkhMRVZCUVVNc1NVRkJTU3hGUVVGRkxFdEJRVXNzUlVGQlF5eEhRVUZITEVWQlFVTXNUVUZCVFN4RlFVRkZMRXRCUVVzc1JVRkJReXhEUVVGRE8xRkJRMmhGTEV0QlFVc3NZMEZCU1R0WlFVTlFMRTFCUVUwc1EwRkJReXhGUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMR05CUVVrc1EwRkJReXhGUVVGRExFTkJRVU03VVVGRGRrTXNTMEZCU3l4bFFVRkxPMWxCUTFJc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1pVRkJTeXhEUVVGRExFVkJRVU1zUTBGQlF6dFJRVU42UXl4TFFVRkxMR2xDUVVGUE8xbEJRMVlzVFVGQlRTeERRVUZETEVWQlFVTXNUMEZCVHl4RlFVRkZMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zYVVKQlFVOHNRMEZCUXl4RlFVRkRMRU5CUVVNN1NVRkRMME1zUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJSVVFzY1VKQlFUUkNMRXRCUVdkQ0xFVkJRVVVzVDBGQlowSTdTVUZETlVRc1NVRkJUU3hSUVVGUkxFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVONlF5eEpRVUZOTEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlJYSkRMRWxCUVUwc1IwRkJSeXhIUVVGaExIRkNRVUZ4UWl4RFFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVVUxUkN3d1FrRkJhVUlzUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCVXl4UlFVRlJPMUZCUTNwRExFbEJRVTBzUzBGQlN5eEhRVUZITERCQ1FVRXdRaXhEUVVGRExGRkJRVkVzUlVGQlJTeE5RVUZOTEVWQlFVVXNUMEZCVHl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRek5GTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaENMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZEZUVJc1EwRkJRenRKUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlJVZ3NlVU5CUVhsRE8wbEJRM3BETEVsQlFVMHNWVUZCVlN4SFFVRkhMRTFCUVUwc1EwRkJReXhOUVVGTkxFbEJRVWtzUlVGQlJTeERRVUZETzBsQlEzWkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFBRVUZQTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVk1zU1VGQlNUdFJRVU0xUkN4SlFVRk5MRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFsQlEzaENMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFdEJRVXNzUlVGQlJTeFBRVUZQTEVOQlFVTTdXVUZEZUVRc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNhVU5CUVdsRE8xRkJRM0pFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhUUVVGVExFbEJRVWtzVjBGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyeEVMRWRCUVVjc1EwRkJReXhOUVVGTkxFZEJRVWNzUjBGQlJ5eERRVUZETEUxQlFVMHNTVUZCU1N4RlFVRkZMRU5CUVVNN1dVRkRPVUlzUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhGUVVGRExFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVTXNRMEZCUXp0UlFVTnlReXhEUVVGRE8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGU0N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRE8wRkJRMklzUTBGQlF6dEJRVEZDUkN4clEwRXdRa003UVVGRlJDeHZRMEZCYjBNc1VVRkJkMElzUlVGQlJTeGxRVUYxUWl4RlFVRkZMRTlCUVdkQ0xFVkJRVVVzUzBGQlowSTdTVUZEZGtnc1NVRkJUU3hSUVVGUkxFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVWNlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBDTEV0QlFVc3NVVUZCVVR0WlFVTllMRTFCUVUwc1EwRkJReXh4UWtGQldTeERRVUZETEZGQlFWRXNSVUZCUlN4bFFVRmxMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRMMFVzUzBGQlN5eFBRVUZQTzFsQlExWXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zWlVGQlpTeEZRVUZGTEZGQlFWRXNSVUZCUlN4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRE9VUXNTMEZCU3l4UlFVRlJPMWxCUTFnc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNN1VVRkRka01zUzBGQlN5eE5RVUZOTzFsQlExUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlpTeEZRVUZGTEZGQlFWRXNRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE1VWXNRMEZCUXp0SlFVVkVMSGREUVVGM1F6dEpRVU40UXl4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzBGQlEyNURMRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBkYXRldGltZV8xID0gcmVxdWlyZShcIi4uLy4uL2RhdGV0aW1lXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIHRpdGxlKGxlZ2VuZCwgZmllbGREZWYsIGNvbmZpZykge1xuICAgIGlmIChsZWdlbmQudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVnZW5kLnRpdGxlO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRkZWZfMS50aXRsZShmaWVsZERlZiwgY29uZmlnKTtcbn1cbmV4cG9ydHMudGl0bGUgPSB0aXRsZTtcbmZ1bmN0aW9uIHZhbHVlcyhsZWdlbmQpIHtcbiAgICB2YXIgdmFscyA9IGxlZ2VuZC52YWx1ZXM7XG4gICAgaWYgKHZhbHMgJiYgZGF0ZXRpbWVfMS5pc0RhdGVUaW1lKHZhbHNbMF0pKSB7XG4gICAgICAgIHJldHVybiB2YWxzLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSA9IHRydWUgYXMgZW5kIHVzZXIgd29uJ3QgcHV0IDAgPSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVfMS50aW1lc3RhbXAoZHQsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG59XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmZ1bmN0aW9uIHR5cGUobGVnZW5kLCB0eXBlLCBjaGFubmVsLCBzY2FsZVR5cGUpIHtcbiAgICBpZiAobGVnZW5kLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZC50eXBlO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLkNPTE9SICYmICgodHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScgJiYgIXNjYWxlXzEuaXNCaW5TY2FsZShzY2FsZVR5cGUpKSB8fCAodHlwZSA9PT0gJ3RlbXBvcmFsJyAmJiB1dGlsXzEuY29udGFpbnMoWyd0aW1lJywgJ3V0YyddLCBzY2FsZVR5cGUpKSkpIHtcbiAgICAgICAgcmV0dXJuICdncmFkaWVudCc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnR5cGUgPSB0eXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY25Wc1pYTXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlzWldkbGJtUXZjblZzWlhNdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4NVEwRkJOa003UVVGRk4wTXNNa05CUVN0RU8wRkJSUzlFTERKRFFVRnRSRHRCUVVWdVJDeHhRMEZCYTBRN1FVRkZiRVFzYlVOQlFXOURPMEZCUlhCRExHVkJRWE5DTEUxQlFXTXNSVUZCUlN4UlFVRXdRaXhGUVVGRkxFMUJRV003U1VGRE9VVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTNSQ0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNaMEpCUVZVc1EwRkJReXhSUVVGUkxFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdRVUZEZEVNc1EwRkJRenRCUVU1RUxITkNRVTFETzBGQlJVUXNaMEpCUVhWQ0xFMUJRV003U1VGRGJrTXNTVUZCVFN4SlFVRkpMRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU16UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzY1VKQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYUVNc1RVRkJUU3hEUVVGRkxFbEJRVzFDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1JVRkJSVHRaUVVOcVF5eHhSRUZCY1VRN1dVRkRja1FzVFVGQlRTeERRVUZETEc5Q1FVRlRMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlF6ZENMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJWRVFzZDBKQlUwTTdRVUZGUkN4alFVRnhRaXhOUVVGakxFVkJRVVVzU1VGQlZTeEZRVUZGTEU5QlFXZENMRVZCUVVVc1UwRkJiMEk3U1VGRGNrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYUVJc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEY2tJc1EwRkJRenRKUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4bFFVRkxMRWxCUVVrc1EwRkJReXhEUVVGRExFbEJRVWtzUzBGQlN5eGpRVUZqTEVsQlFVa3NRMEZCUXl4clFrRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRXRCUVVzc1ZVRkJWU3hKUVVGSkxHVkJRVkVzUTBGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpOS0xFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdTVUZEY0VJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVZKRUxHOUNRVkZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xuZXhwb3J0cy5hcmVhID0ge1xuICAgIHZnTWFyazogJ2FyZWEnLFxuICAgIGRlZmF1bHRSb2xlOiB1bmRlZmluZWQsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCAnemVyb09yTWluJyksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMudGV4dChtb2RlbCwgJ3Rvb2x0aXAnKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpLCBtaXhpbnMubWFya0RlZlByb3BlcnRpZXMobW9kZWwubWFya0RlZiwgWydvcmllbnQnLCAnaW50ZXJwb2xhdGUnLCAndGVuc2lvbiddKSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlYSmxZUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDIxaGNtc3ZZWEpsWVM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZEUVN4cFEwRkJiVU03UVVGSmRFSXNVVUZCUVN4SlFVRkpMRWRCUVdsQ08wbEJRMmhETEUxQlFVMHNSVUZCUlN4TlFVRk5PMGxCUTJRc1YwRkJWeXhGUVVGRkxGTkJRVk03U1VGRGRFSXNWMEZCVnl4RlFVRkZMRlZCUVVNc1MwRkJaMEk3VVVGRE5VSXNUVUZCVFN4elFrRkRSQ3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRVZCUVVVc1YwRkJWeXhEUVVGRExFVkJRemRETEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZETjBNc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGQlF5eExRVUZMTEVWQlFVVXNWMEZCVnl4RFFVRkRMRVZCUlhwRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUTI1Q0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRk5CUVZNc1EwRkJReXhGUVVNM1FpeE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRk5CUVZNc1JVRkJSU3hMUVVGTExFTkJRVU1zUlVGRGNFTXNUVUZCVFN4RFFVRkRMR2xDUVVGcFFpeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzWVVGQllTeEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRMRVZCUTJoR08wbEJRMG9zUTBGQlF6dERRVU5HTEVOQlFVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpZWxkZGVmXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciBtaXhpbnMgPSByZXF1aXJlKFwiLi9taXhpbnNcIik7XG52YXIgcmVmID0gcmVxdWlyZShcIi4vdmFsdWVyZWZcIik7XG5leHBvcnRzLmJhciA9IHtcbiAgICB2Z01hcms6ICdyZWN0JyxcbiAgICBkZWZhdWx0Um9sZTogJ2JhcicsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBtb2RlbC5zdGFjaztcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIHgobW9kZWwsIHN0YWNrKSwgeShtb2RlbCwgc3RhY2spLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMudGV4dChtb2RlbCwgJ3Rvb2x0aXAnKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpKTtcbiAgICB9XG59O1xuZnVuY3Rpb24geChtb2RlbCwgc3RhY2spIHtcbiAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnLCB3aWR0aCA9IG1vZGVsLndpZHRoO1xuICAgIHZhciBvcmllbnQgPSBtb2RlbC5tYXJrRGVmLm9yaWVudDtcbiAgICB2YXIgc2l6ZURlZiA9IG1vZGVsLmVuY29kaW5nLnNpemU7XG4gICAgdmFyIHhEZWYgPSBtb2RlbC5lbmNvZGluZy54O1xuICAgIHZhciB4U2NhbGVOYW1lID0gbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5YKTtcbiAgICB2YXIgeFNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8xLlgpO1xuICAgIC8vIHgsIHgyLCBhbmQgd2lkdGggLS0gd2UgbXVzdCBzcGVjaWZ5IHR3byBvZiB0aGVzZSBpbiBhbGwgY29uZGl0aW9uc1xuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMucG9pbnRQb3NpdGlvbjIobW9kZWwsICd6ZXJvT3JNaW4nKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKHhEZWYpKSB7XG4gICAgICAgICAgICBpZiAoIXNpemVEZWYgJiYgc2NhbGVfMS5pc0JpblNjYWxlKHhTY2FsZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbnMuYmlubmVkUG9zaXRpb24oJ3gnLCBtb2RlbCwgY29uZmlnLmJhci5iaW5TcGFjaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhTY2FsZS50eXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peGlucy5iYW5kUG9zaXRpb24oJ3gnLCBtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2l6ZWQgYmluLCBub3JtYWwgcG9pbnQtb3JkaW5hbCBheGlzLCBxdWFudGl0YXRpdmUgeC1heGlzLCBvciBubyB4XG4gICAgICAgIHJldHVybiBtaXhpbnMuY2VudGVyZWRCYW5kUG9zaXRpb24oJ3gnLCBtb2RlbCwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVmLm1pZFgod2lkdGgsIGNvbmZpZykpLCBkZWZhdWx0U2l6ZVJlZih4U2NhbGVOYW1lLCBtb2RlbC5zY2FsZShjaGFubmVsXzEuWCksIGNvbmZpZykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHkobW9kZWwsIHN0YWNrKSB7XG4gICAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZywgZW5jb2RpbmcgPSBtb2RlbC5lbmNvZGluZywgaGVpZ2h0ID0gbW9kZWwuaGVpZ2h0O1xuICAgIHZhciBvcmllbnQgPSBtb2RlbC5tYXJrRGVmLm9yaWVudDtcbiAgICB2YXIgc2l6ZURlZiA9IGVuY29kaW5nLnNpemU7XG4gICAgdmFyIHlEZWYgPSBlbmNvZGluZy55O1xuICAgIHZhciB5U2NhbGVOYW1lID0gbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ZKTtcbiAgICB2YXIgeVNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8xLlkpO1xuICAgIC8vIHksIHkyICYgaGVpZ2h0IC0tIHdlIG11c3Qgc3BlY2lmeSB0d28gb2YgdGhlc2UgaW4gYWxsIGNvbmRpdGlvbnNcbiAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCAnemVyb09yTWluJyksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1pbicpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoeURlZikpIHtcbiAgICAgICAgICAgIGlmICh5RGVmLmJpbiAmJiAhc2l6ZURlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbnMuYmlubmVkUG9zaXRpb24oJ3knLCBtb2RlbCwgY29uZmlnLmJhci5iaW5TcGFjaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHlTY2FsZS50eXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peGlucy5iYW5kUG9zaXRpb24oJ3knLCBtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1peGlucy5jZW50ZXJlZEJhbmRQb3NpdGlvbigneScsIG1vZGVsLCByZWYubWlkWShoZWlnaHQsIGNvbmZpZyksIGRlZmF1bHRTaXplUmVmKHlTY2FsZU5hbWUsIG1vZGVsLnNjYWxlKGNoYW5uZWxfMS5ZKSwgY29uZmlnKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdFNpemVSZWYoc2NhbGVOYW1lLCBzY2FsZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5iYXIuZGlzY3JldGVCYW5kU2l6ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY29uZmlnLmJhci5kaXNjcmV0ZUJhbmRTaXplIH07XG4gICAgfVxuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuUE9JTlQpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZS5yYW5nZVN0ZXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc2NhbGUucmFuZ2VTdGVwIC0gMSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuQkFSX1dJVEhfUE9JTlRfU0NBTEVfQU5EX1JBTkdFU1RFUF9OVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2FsZS50eXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmLmJhbmQoc2NhbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjb25maWcuYmFyLmNvbnRpbnVvdXNCYW5kU2l6ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcuc2NhbGUucmFuZ2VTdGVwICYmIGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgLSAxIH07XG4gICAgfVxuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGRlcGVuZHMgb24gY2VsbCdzIHdpZHRoIC8gaGVpZ2h0P1xuICAgIHJldHVybiB7IHZhbHVlOiAyMCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWW1GeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZiV0Z5YXk5aVlYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlFVRXNlVU5CUVcxRE8wRkJSVzVETERKRFFVRXdRenRCUVVNeFF5d3JRa0ZCYVVNN1FVRkRha01zY1VOQlFYbEVPMEZCVFhwRUxHbERRVUZ0UXp0QlFVZHVReXhuUTBGQmEwTTdRVUZGY2tJc1VVRkJRU3hIUVVGSExFZEJRV2xDTzBsQlF5OUNMRTFCUVUwc1JVRkJSU3hOUVVGTk8wbEJRMlFzVjBGQlZ5eEZRVUZGTEV0QlFVczdTVUZEYkVJc1YwRkJWeXhGUVVGRkxGVkJRVU1zUzBGQlowSTdVVUZETlVJc1NVRkJUU3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTXhRaXhOUVVGTkxITkNRVU5FTEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRMllzUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkRaaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RlFVTnVRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4VFFVRlRMRU5CUVVNc1JVRkROMElzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4VFFVRlRMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRM1pETzBsQlEwb3NRMEZCUXp0RFFVTkdMRU5CUVVNN1FVRkZSaXhYUVVGWExFdEJRV2RDTEVWQlFVVXNTMEZCYzBJN1NVRkRNVU1zU1VGQlFTeHhRa0ZCVFN4RlFVRkZMRzFDUVVGTExFTkJRVlU3U1VGRE9VSXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZEY0VNc1NVRkJUU3hQUVVGUExFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkZjRU1zU1VGQlRTeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE9VSXNTVUZCVFN4VlFVRlZMRWRCUVVjc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFhRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjBReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRmRCUVVNc1EwRkJReXhEUVVGRE8wbEJRemxDTEhGRlFVRnhSVHRKUVVOeVJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRXRCUVVzc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0xUWl4TlFVRk5MSE5DUVVORUxFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hYUVVGWExFTkJRVU1zUlVGRE4wTXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJReXhMUVVGTExFVkJRVVVzVjBGQlZ5eERRVUZETEVWQlF6VkRPMGxCUTBvc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNSVUZCUlN4RFFVRkRMRU5CUVVNc2NVSkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRja0lzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRWxCUVVrc2EwSkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU40UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdXVUZEYkVVc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hMUVVGTExHbENRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE1VTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMWxCUTNwRExFTkJRVU03VVVGRFNDeERRVUZETzFGQlEwUXNjVVZCUVhGRk8xRkJSWEpGTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc2RVSkJRM1pETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEhRVU16UWl4alFVRmpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRMjVFTEVOQlFVTTdTVUZEU2l4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxGZEJRVmNzUzBGQlowSXNSVUZCUlN4TFFVRnpRanRKUVVNeFF5eEpRVUZCTEhGQ1FVRk5MRVZCUVVVc2VVSkJRVkVzUlVGQlJTeHhRa0ZCVFN4RFFVRlZPMGxCUTNwRExFbEJRVTBzVFVGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRM0JETEVsQlFVMHNUMEZCVHl4SFFVRkhMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU03U1VGRk9VSXNTVUZCVFN4SlFVRkpMRWRCUVVjc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU40UWl4SlFVRk5MRlZCUVZVc1IwRkJSeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEZkQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNSRExFbEJRVTBzVFVGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJReXhEUVVGRExFTkJRVU03U1VGRE9VSXNiVVZCUVcxRk8wbEJRMjVGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1MwRkJTeXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6RkNMRTFCUVUwc2MwSkJRMFFzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhGUVVGRkxGZEJRVmNzUTBGQlF5eEZRVU0zUXl4TlFVRk5MRU5CUVVNc1kwRkJZeXhEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZETlVNN1NVRkRTaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4RlFVRkZMRU5CUVVNc1EwRkJReXh4UWtGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOeVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRla0lzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xbEJRMnhGTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NTMEZCU3l4cFFrRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF6dFpRVU42UXl4RFFVRkRPMUZCUTBnc1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zUjBGQlJ5eEZRVUZGTEV0QlFVc3NSVUZCUlN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4alFVRmpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU12U0N4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxIZENRVUYzUWl4VFFVRnBRaXhGUVVGRkxFdEJRVmtzUlVGQlJTeE5RVUZqTzBsQlEzSkZMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaERMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMR2RDUVVGblFpeEZRVUZETEVOQlFVTTdTVUZET1VNc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRWaXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMR2xDUVVGVExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4TFFVRkxMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6ZENMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeExRVUZMTEVOQlFVTXNVMEZCVXl4SFFVRkhMRU5CUVVNc1JVRkJReXhEUVVGRE8xbEJRM1JETEVOQlFVTTdXVUZEUkN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNkVU5CUVhWRExFTkJRVU1zUTBGQlF6dFJRVU5vUlN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc2FVSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJRemRDTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExHdENRVUZyUWl4RlFVRkRMRU5CUVVNN1VVRkRhRVFzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUzBGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpsRUxFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUjBGQlJ5eERRVUZETEVWQlFVTXNRMEZCUXp0SlFVTTNReXhEUVVGRE8wbEJRMFFzYzBSQlFYTkVPMGxCUTNSRUxFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4RlFVRkZMRVZCUVVNc1EwRkJRenRCUVVOeVFpeERRVUZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbmNvZGluZ1wiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpZWxkZGVmXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4uLy4uL21hcmtcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBpbml0TWFya0RlZihtYXJrLCBlbmNvZGluZywgc2NhbGUsIGNvbmZpZykge1xuICAgIHZhciBtYXJrRGVmID0gbWFya18xLmlzTWFya0RlZihtYXJrKSA/IHRzbGliXzEuX19hc3NpZ24oe30sIG1hcmspIDogeyB0eXBlOiBtYXJrIH07XG4gICAgdmFyIHNwZWNpZmllZE9yaWVudCA9IG1hcmtEZWYub3JpZW50IHx8IGNvbW1vbl8xLmdldE1hcmtDb25maWcoJ29yaWVudCcsIG1hcmtEZWYudHlwZSwgY29uZmlnKTtcbiAgICBtYXJrRGVmLm9yaWVudCA9IG9yaWVudChtYXJrRGVmLnR5cGUsIGVuY29kaW5nLCBzY2FsZSwgc3BlY2lmaWVkT3JpZW50KTtcbiAgICBpZiAoc3BlY2lmaWVkT3JpZW50ICE9PSB1bmRlZmluZWQgJiYgc3BlY2lmaWVkT3JpZW50ICE9PSBtYXJrRGVmLm9yaWVudCkge1xuICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5vcmllbnRPdmVycmlkZGVuKG1hcmtEZWYub3JpZW50LCBzcGVjaWZpZWRPcmllbnQpKTtcbiAgICB9XG4gICAgdmFyIHNwZWNpZmllZEZpbGxlZCA9IG1hcmtEZWYuZmlsbGVkO1xuICAgIGlmIChzcGVjaWZpZWRGaWxsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXJrRGVmLmZpbGxlZCA9IGZpbGxlZChtYXJrRGVmLnR5cGUsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrRGVmO1xufVxuZXhwb3J0cy5pbml0TWFya0RlZiA9IGluaXRNYXJrRGVmO1xuLyoqXG4gKiBJbml0aWFsaXplIGVuY29kaW5nJ3MgdmFsdWUgd2l0aCBzb21lIHNwZWNpYWwgZGVmYXVsdCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gaW5pdEVuY29kaW5nKG1hcmssIGVuY29kaW5nLCBzdGFja2VkLCBjb25maWcpIHtcbiAgICB2YXIgb3BhY2l0eUNvbmZpZyA9IGNvbW1vbl8xLmdldE1hcmtDb25maWcoJ29wYWNpdHknLCBtYXJrLCBjb25maWcpO1xuICAgIGlmICghZW5jb2Rpbmcub3BhY2l0eSAmJiBvcGFjaXR5Q29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkZWZhdWx0T3BhY2l0eShtYXJrLCBlbmNvZGluZywgc3RhY2tlZCk7XG4gICAgICAgIGlmIChvcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kaW5nLm9wYWNpdHkgPSB7IHZhbHVlOiBvcGFjaXR5IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5nO1xufVxuZXhwb3J0cy5pbml0RW5jb2RpbmcgPSBpbml0RW5jb2Rpbmc7XG5mdW5jdGlvbiBkZWZhdWx0T3BhY2l0eShtYXJrLCBlbmNvZGluZywgc3RhY2tlZCkge1xuICAgIGlmICh1dGlsXzEuY29udGFpbnMoW21hcmtfMS5QT0lOVCwgbWFya18xLlRJQ0ssIG1hcmtfMS5DSVJDTEUsIG1hcmtfMS5TUVVBUkVdLCBtYXJrKSkge1xuICAgICAgICAvLyBwb2ludC1iYXNlZCBtYXJrc1xuICAgICAgICBpZiAoIWVuY29kaW5nXzEuaXNBZ2dyZWdhdGUoZW5jb2RpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gMC43O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBmaWxsZWQobWFyaywgY29uZmlnKSB7XG4gICAgdmFyIGZpbGxlZENvbmZpZyA9IGNvbW1vbl8xLmdldE1hcmtDb25maWcoJ2ZpbGxlZCcsIG1hcmssIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZpbGxlZENvbmZpZyAhPT0gdW5kZWZpbmVkID8gZmlsbGVkQ29uZmlnIDogbWFyayAhPT0gbWFya18xLlBPSU5UICYmIG1hcmsgIT09IG1hcmtfMS5MSU5FICYmIG1hcmsgIT09IG1hcmtfMS5SVUxFO1xufVxuZnVuY3Rpb24gb3JpZW50KG1hcmssIGVuY29kaW5nLCBzY2FsZSwgc3BlY2lmaWVkT3JpZW50KSB7XG4gICAgc3dpdGNoIChtYXJrKSB7XG4gICAgICAgIGNhc2UgbWFya18xLlBPSU5UOlxuICAgICAgICBjYXNlIG1hcmtfMS5DSVJDTEU6XG4gICAgICAgIGNhc2UgbWFya18xLlNRVUFSRTpcbiAgICAgICAgY2FzZSBtYXJrXzEuVEVYVDpcbiAgICAgICAgY2FzZSBtYXJrXzEuUkVDVDpcbiAgICAgICAgICAgIC8vIG9yaWVudCBpcyBtZWFuaW5nbGVzcyBmb3IgdGhlc2UgbWFya3MuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgeUlzUmFuZ2UgPSBlbmNvZGluZy55ICYmIGVuY29kaW5nLnkyO1xuICAgIHZhciB4SXNSYW5nZSA9IGVuY29kaW5nLnggJiYgZW5jb2RpbmcueDI7XG4gICAgc3dpdGNoIChtYXJrKSB7XG4gICAgICAgIGNhc2UgbWFya18xLlRJQ0s6XG4gICAgICAgICAgICB2YXIgeFNjYWxlVHlwZSA9IHNjYWxlWyd4J10gPyBzY2FsZVsneCddLnR5cGUgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHlTY2FsZVR5cGUgPSBzY2FsZVsneSddID8gc2NhbGVbJ3knXS50eXBlIDogbnVsbDtcbiAgICAgICAgICAgIC8vIFRpY2sgaXMgb3Bwb3NpdGUgdG8gYmFyLCBsaW5lLCBhcmVhIGFuZCBuZXZlciBoYXZlIHJhbmdlZCBtYXJrLlxuICAgICAgICAgICAgaWYgKCFzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHhTY2FsZVR5cGUpICYmICghZW5jb2RpbmcueSB8fFxuICAgICAgICAgICAgICAgIHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oeVNjYWxlVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLnkpICYmIGVuY29kaW5nLnkuYmluKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHk6USBvciBBbWJpZ3VvdXMgY2FzZSwgcmV0dXJuIGhvcml6b250YWxcbiAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XG4gICAgICAgIGNhc2UgbWFya18xLlJVTEU6XG4gICAgICAgIGNhc2UgbWFya18xLkJBUjpcbiAgICAgICAgY2FzZSBtYXJrXzEuQVJFQTpcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSByYW5nZSBmb3IgYm90aCB4IGFuZCB5LCB5ICh2ZXJ0aWNhbCkgaGFzIGhpZ2hlciBwcmVjZWRlbmNlLlxuICAgICAgICAgICAgaWYgKHlJc1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4SXNSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXJrID09PSBtYXJrXzEuUlVMRSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy54ICYmICFlbmNvZGluZy55KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZy55ICYmICFlbmNvZGluZy54KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgICAgICBjYXNlIG1hcmtfMS5MSU5FOlxuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICAgICAgdmFyIHhJc0NvbnRpbnVvdXMgPSBmaWVsZGRlZl8xLmlzRmllbGREZWYoZW5jb2RpbmcueCkgJiYgZmllbGRkZWZfMS5pc0NvbnRpbnVvdXMoZW5jb2RpbmcueCk7XG4gICAgICAgICAgICB2YXIgeUlzQ29udGludW91cyA9IGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy55KSAmJiBmaWVsZGRlZl8xLmlzQ29udGludW91cyhlbmNvZGluZy55KTtcbiAgICAgICAgICAgIGlmICh4SXNDb250aW51b3VzICYmICF5SXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF4SXNDb250aW51b3VzICYmIHlJc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhJc0NvbnRpbnVvdXMgJiYgeUlzQ29udGludW91cykge1xuICAgICAgICAgICAgICAgIHZhciB4RGVmID0gZW5jb2RpbmcueDsgLy8gd2UgY2FuIGNhc3QgaGVyZSBzaW5jZSB0aGV5IGFyZSBzdXJlbHkgZmllbGREZWZcbiAgICAgICAgICAgICAgICB2YXIgeURlZiA9IGVuY29kaW5nLnk7XG4gICAgICAgICAgICAgICAgdmFyIHhJc1RlbXBvcmFsID0geERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUw7XG4gICAgICAgICAgICAgICAgdmFyIHlJc1RlbXBvcmFsID0geURlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUw7XG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYWwgd2l0aG91dCB0aW1lVW5pdCBpcyBjb25zaWRlcmVkIGNvbnRpbnVvdXMsIGJ1dCBiZXR0ZXIgc2VydmVzIGFzIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgIGlmICh4SXNUZW1wb3JhbCAmJiAheUlzVGVtcG9yYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF4SXNUZW1wb3JhbCAmJiB5SXNUZW1wb3JhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXhEZWYuYWdncmVnYXRlICYmIHlEZWYuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4RGVmLmFnZ3JlZ2F0ZSAmJiAheURlZi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpZmllZE9yaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGFtYmlndW91cywgdXNlIHVzZXIgc3BlY2lmaWVkIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmllZE9yaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEobWFyayA9PT0gbWFya18xLkxJTkUgJiYgZW5jb2Rpbmcub3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCBmb3IgY29ubmVjdGVkIHNjYXR0ZXJwbG90LCB3ZSBzaG91bGQgbG9nIHdhcm5pbmcgZm9yIHVuY2xlYXIgb3JpZW50YXRpb24gb2YgUXhRIHBsb3RzLlxuICAgICAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS51bmNsZWFyT3JpZW50Q29udGludW91cyhtYXJrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIERpc2NyZXRlIHggRGlzY3JldGUgY2FzZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS51bmNsZWFyT3JpZW50RGlzY3JldGVPckVtcHR5KG1hcmspKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3ZlcnRpY2FsJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNXBkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDIxaGNtc3ZhVzVwZEM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZEUVN3eVEwRkJjVVE3UVVGRGNrUXNNa05CUVd0Rk8wRkJRMnhGTEN0Q1FVRnBRenRCUVVOcVF5eHRRMEZCTkVnN1FVRkROVWdzY1VOQlFYRkVPMEZCUlhKRUxHMURRVUZ2UXp0QlFVTndReXh0UTBGQk1FTTdRVUZETVVNc2IwTkJRWGRETzBGQlJYaERMSEZDUVVFMFFpeEpRVUZ2UWl4RlFVRkZMRkZCUVRCQ0xFVkJRVVVzUzBGQmEwSXNSVUZCUlN4TlFVRmpPMGxCUXpsSExFbEJRVTBzVDBGQlR5eEhRVUZITEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExIZENRVUZQTEVsQlFVa3NTVUZCU1N4RlFVRkRMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVU1zUTBGQlF6dEpRVVV6UkN4SlFVRk5MR1ZCUVdVc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeEpRVUZKTEhOQ1FVRmhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRlRVlzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeFJRVUZSTEVWQlFVVXNTMEZCU3l4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8wbEJRM2hGTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1MwRkJTeXhUUVVGVExFbEJRVWtzWlVGQlpTeExRVUZMTEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM2hGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla1VzUTBGQlF6dEpRVVZFTEVsQlFVMHNaVUZCWlN4SFFVRkhMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGRrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJaU3hMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCUlVRc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dEJRVU5xUWl4RFFVRkRPMEZCWmtRc2EwTkJaVU03UVVGRlJEczdSMEZGUnp0QlFVTklMSE5DUVVFMlFpeEpRVUZWTEVWQlFVVXNVVUZCTUVJc1JVRkJSU3hQUVVGM1FpeEZRVUZGTEUxQlFXTTdTVUZETTBjc1NVRkJUU3hoUVVGaExFZEJRVWNzYzBKQlFXRXNRMEZCUXl4VFFVRlRMRVZCUVVVc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF6ZEVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNTVUZCU1N4aFFVRmhMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55UkN4SlFVRk5MRTlCUVU4c1IwRkJSeXhqUVVGakxFTkJRVU1zU1VGQlNTeEZRVUZGTEZGQlFWRXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVONFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU14UWl4UlFVRlJMRU5CUVVNc1QwRkJUeXhIUVVGSExFVkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUXl4RFFVRkRPMUZCUTNSRExFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRCUVVOc1FpeERRVUZETzBGQlZFUXNiME5CVTBNN1FVRkhSQ3gzUWtGQmQwSXNTVUZCVlN4RlFVRkZMRkZCUVRCQ0xFVkJRVVVzVDBGQmQwSTdTVUZEZEVZc1JVRkJSU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNXVUZCU3l4RlFVRkZMRmRCUVVrc1JVRkJSU3hoUVVGTkxFVkJRVVVzWVVGQlRTeERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhFTEc5Q1FVRnZRanRSUVVOd1FpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSE5DUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTTdVVUZEWWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVVWRUxHZENRVUZuUWl4SlFVRlZMRVZCUVVVc1RVRkJZenRKUVVONFF5eEpRVUZOTEZsQlFWa3NSMEZCUnl4elFrRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRNMFFzVFVGQlRTeERRVUZETEZsQlFWa3NTMEZCU3l4VFFVRlRMRWRCUVVjc1dVRkJXU3hIUVVGSExFbEJRVWtzUzBGQlN5eFpRVUZMTEVsQlFVa3NTVUZCU1N4TFFVRkxMRmRCUVVrc1NVRkJTU3hKUVVGSkxFdEJRVXNzVjBGQlNTeERRVUZETzBGQlEzUkhMRU5CUVVNN1FVRkZSQ3huUWtGQlowSXNTVUZCVlN4RlFVRkZMRkZCUVRCQ0xFVkJRVVVzUzBGQmEwSXNSVUZCUlN4bFFVRjFRanRKUVVOcVJ5eE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMklzUzBGQlN5eFpRVUZMTEVOQlFVTTdVVUZEV0N4TFFVRkxMR0ZCUVUwc1EwRkJRenRSUVVOYUxFdEJRVXNzWVVGQlRTeERRVUZETzFGQlExb3NTMEZCU3l4WFFVRkpMRU5CUVVNN1VVRkRWaXhMUVVGTExGZEJRVWs3V1VGRFVDeDVRMEZCZVVNN1dVRkRla01zVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnlRaXhEUVVGRE8wbEJSVVFzU1VGQlRTeFJRVUZSTEVkQlFVY3NVVUZCVVN4RFFVRkRMRU5CUVVNc1NVRkJTU3hSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlF6TkRMRWxCUVUwc1VVRkJVU3hIUVVGSExGRkJRVkVzUTBGQlF5eERRVUZETEVsQlFVa3NVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVVelF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMklzUzBGQlN5eFhRVUZKTzFsQlExQXNTVUZCVFN4VlFVRlZMRWRCUVVjc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETzFsQlEzWkVMRWxCUVUwc1ZVRkJWU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXp0WlFVVjJSQ3hyUlVGQmEwVTdXVUZEYkVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eDVRa0ZCYVVJc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVU5vUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8yZENRVU5ZTEhsQ1FVRnBRaXhEUVVGRExGVkJRVlVzUTBGQlF6dG5Ra0ZETjBJc1EwRkJReXh4UWtGQlZTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVTTNReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEU2l4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8xbEJRM0JDTEVOQlFVTTdXVUZEUkN3eVEwRkJNa003V1VGRE0wTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJRenRSUVVWMFFpeExRVUZMTEZkQlFVa3NRMEZCUXp0UlFVTldMRXRCUVVzc1ZVRkJSeXhEUVVGRE8xRkJRMVFzUzBGQlN5eFhRVUZKTzFsQlExQXNNa1ZCUVRKRk8xbEJRek5GTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEySXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJRenRaUVVOd1FpeERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNCQ0xFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTTdXVUZEZEVJc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1YwRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZWtJc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTVRaXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETzJkQ1FVTndRaXhEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEzSkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU03WjBKQlEzUkNMRU5CUVVNN1dVRkRTQ3hEUVVGRE8xRkJSVVFzYjBKQlFXOUNPMUZCUTNSQ0xFdEJRVXNzVjBGQlNUdFpRVU5RTEcxQ1FVRnRRanRaUVVOdVFpeEpRVUZOTEdGQlFXRXNSMEZCUnl4eFFrRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4MVFrRkJXU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSU3hKUVVGTkxHRkJRV0VzUjBGQlJ5eHhRa0ZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeDFRa0ZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhoUVVGaExFbEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOd1F5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRPMWxCUTNSQ0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhoUVVGaExFbEJRVWtzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRNME1zVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0WlFVTndRaXhEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMR0ZCUVdFc1NVRkJTU3hoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTXhReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCY1VJc1EwRkJReXhEUVVGRExHdEVRVUZyUkR0blFrRkRMMFlzU1VGQlRTeEpRVUZKTEVkQlFVY3NVVUZCVVN4RFFVRkRMRU5CUVhGQ0xFTkJRVU03WjBKQlJUVkRMRWxCUVUwc1YwRkJWeXhIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEV0QlFVc3NaVUZCVVN4RFFVRkRPMmRDUVVNelF5eEpRVUZOTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hMUVVGTExHVkJRVkVzUTBGQlF6dG5Ra0ZGTTBNc2NVWkJRWEZHTzJkQ1FVTnlSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU5vUXl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8yZENRVU53UWl4RFFVRkRPMmRDUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRmRCUVZjc1NVRkJTU3hYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTjJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETzJkQ1FVTjBRaXhEUVVGRE8yZENRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zU1VGQlNTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGRFTXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJRenRuUWtGRGNFSXNRMEZCUXp0blFrRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNM1F5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRPMmRDUVVOMFFpeERRVUZETzJkQ1FVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNCQ0xEQkRRVUV3UXp0dlFrRkRNVU1zVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXp0blFrRkRla0lzUTBGQlF6dG5Ra0ZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEZkQlFVa3NTVUZCU1N4UlFVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTjJReXhuUjBGQlowYzdiMEpCUTJoSExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXgxUWtGQmRVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU4wUkN4RFFVRkRPMmRDUVVORUxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdXVUZEY0VJc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MR3RFUVVGclJEdG5Ra0ZEYkVRc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRFJDUVVFMFFpeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM3BFTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRia0lzUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8wRkJRM0JDTEVOQlFVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtaXhpbnMgPSByZXF1aXJlKFwiLi9taXhpbnNcIik7XG5leHBvcnRzLmxpbmUgPSB7XG4gICAgdmdNYXJrOiAnbGluZScsXG4gICAgZGVmYXVsdFJvbGU6IHVuZGVmaW5lZCxcbiAgICBlbmNvZGVFbnRyeTogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneCcsIG1vZGVsLCAnemVyb09yTWluJyksIG1peGlucy5wb2ludFBvc2l0aW9uKCd5JywgbW9kZWwsICd6ZXJvT3JNaW4nKSwgbWl4aW5zLmNvbG9yKG1vZGVsKSwgbWl4aW5zLnRleHQobW9kZWwsICd0b29sdGlwJyksIG1peGlucy5ub25Qb3NpdGlvbignb3BhY2l0eScsIG1vZGVsKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdzaXplJywgbW9kZWwsIHtcbiAgICAgICAgICAgIHZnQ2hhbm5lbDogJ3N0cm9rZVdpZHRoJyAvLyBWTCdzIGxpbmUgc2l6ZSBpcyBzdHJva2VXaWR0aFxuICAgICAgICB9KSwgbWl4aW5zLm1hcmtEZWZQcm9wZXJ0aWVzKG1vZGVsLm1hcmtEZWYsIFsnaW50ZXJwb2xhdGUnLCAndGVuc2lvbiddKSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJHbHVaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDIxaGNtc3ZiR2x1WlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZEUVN4cFEwRkJiVU03UVVGSmRFSXNVVUZCUVN4SlFVRkpMRWRCUVdsQ08wbEJRMmhETEUxQlFVMHNSVUZCUlN4TlFVRk5PMGxCUTJRc1YwRkJWeXhGUVVGRkxGTkJRVk03U1VGRGRFSXNWMEZCVnl4RlFVRkZMRlZCUVVNc1MwRkJaMEk3VVVGRE5VSXNUVUZCVFN4elFrRkRSQ3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRVZCUVVVc1YwRkJWeXhEUVVGRExFVkJRemRETEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZETjBNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNSVUZEYmtJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4RFFVRkRMRVZCUXpkQ0xFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1EwRkJReXhGUVVOd1F5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVVU3V1VGRGJrTXNVMEZCVXl4RlFVRkZMR0ZCUVdFc1EwRkJSU3huUTBGQlowTTdVMEZETTBRc1EwRkJReXhGUVVORExFMUJRVTBzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNZVUZCWVN4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRExFVkJRM1JGTzBsQlEwb3NRMEZCUXp0RFFVTkdMRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXJrXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGFyZWFfMSA9IHJlcXVpcmUoXCIuL2FyZWFcIik7XG52YXIgYmFyXzEgPSByZXF1aXJlKFwiLi9iYXJcIik7XG52YXIgbGluZV8xID0gcmVxdWlyZShcIi4vbGluZVwiKTtcbnZhciBwb2ludF8xID0gcmVxdWlyZShcIi4vcG9pbnRcIik7XG52YXIgcmVjdF8xID0gcmVxdWlyZShcIi4vcmVjdFwiKTtcbnZhciBydWxlXzEgPSByZXF1aXJlKFwiLi9ydWxlXCIpO1xudmFyIHRleHRfMSA9IHJlcXVpcmUoXCIuL3RleHRcIik7XG52YXIgdGlja18xID0gcmVxdWlyZShcIi4vdGlja1wiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbnZhciBjaGFubmVsXzIgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIG1hcmtDb21waWxlciA9IHtcbiAgICBhcmVhOiBhcmVhXzEuYXJlYSxcbiAgICBiYXI6IGJhcl8xLmJhcixcbiAgICBsaW5lOiBsaW5lXzEubGluZSxcbiAgICBwb2ludDogcG9pbnRfMS5wb2ludCxcbiAgICB0ZXh0OiB0ZXh0XzEudGV4dCxcbiAgICB0aWNrOiB0aWNrXzEudGljayxcbiAgICByZWN0OiByZWN0XzEucmVjdCxcbiAgICBydWxlOiBydWxlXzEucnVsZSxcbiAgICBjaXJjbGU6IHBvaW50XzEuY2lyY2xlLFxuICAgIHNxdWFyZTogcG9pbnRfMS5zcXVhcmVcbn07XG5mdW5jdGlvbiBwYXJzZU1hcmsobW9kZWwpIHtcbiAgICBpZiAodXRpbF8xLmNvbnRhaW5zKFttYXJrXzEuTElORSwgbWFya18xLkFSRUFdLCBtb2RlbC5tYXJrKCkpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVBhdGhNYXJrKG1vZGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZU5vblBhdGhNYXJrKG1vZGVsKTtcbiAgICB9XG59XG5leHBvcnRzLnBhcnNlTWFyayA9IHBhcnNlTWFyaztcbnZhciBGQUNFVEVEX1BBVEhfUFJFRklYID0gJ2ZhY2V0ZWRfcGF0aF8nO1xuZnVuY3Rpb24gcGFyc2VQYXRoTWFyayhtb2RlbCkge1xuICAgIHZhciBtYXJrID0gbW9kZWwubWFyaygpO1xuICAgIC8vIEZJWE1FOiByZXBsYWNlIHRoaXMgd2l0aCBtb3JlIGdlbmVyYWwgY2FzZSBmb3IgY29tcG9zaXRpb25cbiAgICB2YXIgZGV0YWlscyA9IGRldGFpbEZpZWxkcyhtb2RlbCk7XG4gICAgdmFyIHBhdGhNYXJrcyA9IFtcbiAgICAgICAgdHNsaWJfMS5fX2Fzc2lnbih7IG5hbWU6IG1vZGVsLmdldE5hbWUoJ21hcmtzJyksIHR5cGU6IG1hcmtDb21waWxlclttYXJrXS52Z01hcmsgfSwgKGNsaXAobW9kZWwpKSwgeyBcbiAgICAgICAgICAgIC8vIElmIGhhcyBzdWJmYWNldCBmb3IgbGluZS9hcmVhIGdyb3VwLCBuZWVkIHRvIHVzZSBmYWNldGVkIGRhdGEgZnJvbSBiZWxvdy5cbiAgICAgICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IHNvcnRpbmcgcGF0aCBvcmRlciAoaW4gY29ubmVjdGVkIHNjYXR0ZXJwbG90KVxuICAgICAgICAgICAgZnJvbTogeyBkYXRhOiAoZGV0YWlscy5sZW5ndGggPiAwID8gRkFDRVRFRF9QQVRIX1BSRUZJWCA6ICcnKSArIG1vZGVsLnJlcXVlc3REYXRhTmFtZShkYXRhXzEuTUFJTikgfSwgZW5jb2RlOiB7IHVwZGF0ZTogbWFya0NvbXBpbGVyW21hcmtdLmVuY29kZUVudHJ5KG1vZGVsKSB9IH0pXG4gICAgXTtcbiAgICBpZiAoZGV0YWlscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFRPRE86IGZvciBub24tc3RhY2tlZCBwbG90LCBtYXAgb3JkZXIgdG8gemluZGV4LiAoTWF5YmUgcmVuYW1lIG9yZGVyIGZvciBsYXllciB0byB6aW5kZXg/KVxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiBtb2RlbC5nZXROYW1lKCdwYXRoZ3JvdXAnKSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IEZBQ0VURURfUEFUSF9QUkVGSVggKyBtb2RlbC5yZXF1ZXN0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9kZWwucmVxdWVzdERhdGFOYW1lKGRhdGFfMS5NQUlOKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwYnk6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB7IGZpZWxkOiB7IGdyb3VwOiAnd2lkdGgnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogeyBmaWVsZDogeyBncm91cDogJ2hlaWdodCcgfSB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1hcmtzOiBwYXRoTWFya3NcbiAgICAgICAgICAgIH1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGhNYXJrcztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZU5vblBhdGhNYXJrKG1vZGVsKSB7XG4gICAgdmFyIG1hcmsgPSBtb2RlbC5tYXJrKCk7XG4gICAgdmFyIHJvbGUgPSBtb2RlbC5tYXJrRGVmLnJvbGUgfHwgbWFya0NvbXBpbGVyW21hcmtdLmRlZmF1bHRSb2xlO1xuICAgIHZhciBtYXJrcyA9IFtdOyAvLyBUT0RPOiB2Z01hcmtzXG4gICAgLy8gVE9ETzogZm9yIG5vbi1zdGFja2VkIHBsb3QsIG1hcCBvcmRlciB0byB6aW5kZXguIChNYXliZSByZW5hbWUgb3JkZXIgZm9yIGxheWVyIHRvIHppbmRleD8pXG4gICAgbWFya3MucHVzaCh0c2xpYl8xLl9fYXNzaWduKHsgbmFtZTogbW9kZWwuZ2V0TmFtZSgnbWFya3MnKSwgdHlwZTogbWFya0NvbXBpbGVyW21hcmtdLnZnTWFyayB9LCAoY2xpcChtb2RlbCkpLCAocm9sZSA/IHsgcm9sZTogcm9sZSB9IDoge30pLCB7IGZyb206IHsgZGF0YTogbW9kZWwucmVxdWVzdERhdGFOYW1lKGRhdGFfMS5NQUlOKSB9LCBlbmNvZGU6IHsgdXBkYXRlOiBtYXJrQ29tcGlsZXJbbWFya10uZW5jb2RlRW50cnkobW9kZWwpIH0gfSkpO1xuICAgIHJldHVybiBtYXJrcztcbn1cbi8qKlxuICogUmV0dXJucyBsaXN0IG9mIGRldGFpbCAoZ3JvdXAtYnkpIGZpZWxkc1xuICogdGhhdCB0aGUgbW9kZWwncyBzcGVjIGNvbnRhaW5zLlxuICovXG5mdW5jdGlvbiBkZXRhaWxGaWVsZHMobW9kZWwpIHtcbiAgICByZXR1cm4gY2hhbm5lbF8xLkxFVkVMX09GX0RFVEFJTF9DSEFOTkVMUy5yZWR1Y2UoZnVuY3Rpb24gKGRldGFpbHMsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKG1vZGVsLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsKSAmJiAhbW9kZWwuZmllbGREZWYoY2hhbm5lbCkuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICBkZXRhaWxzLnB1c2gobW9kZWwuZmllbGQoY2hhbm5lbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGNsaXAobW9kZWwpIHtcbiAgICB2YXIgeHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8yLlgpLCB5c2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsXzIuWSk7XG4gICAgcmV0dXJuICh4c2NhbGUgJiYgc2NhbGVfMS5pc1NlbGVjdGlvbkRvbWFpbih4c2NhbGUuZG9tYWluKSkgfHxcbiAgICAgICAgKHlzY2FsZSAmJiBzY2FsZV8xLmlzU2VsZWN0aW9uRG9tYWluKHlzY2FsZS5kb21haW4pKSA/IHsgY2xpcDogdHJ1ZSB9IDoge307XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liV0Z5YXk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyMWhjbXN2YldGeWF5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDVRMEZCZFVRN1FVRkRka1FzYlVOQlFYTkRPMEZCUTNSRExHMURRVUZ2UXp0QlFVVndReXdyUWtGQk5FSTdRVUZETlVJc05rSkJRVEJDTzBGQlJURkNMQ3RDUVVFMFFqdEJRVU0xUWl4cFEwRkJPRU03UVVGRE9VTXNLMEpCUVRSQ08wRkJRelZDTEN0Q1FVRTBRanRCUVVNMVFpd3JRa0ZCTkVJN1FVRkROVUlzSzBKQlFUUkNPMEZCUlRWQ0xHMURRVUZuUXp0QlFVbG9ReXg1UTBGQmJVTTdRVUZEYmtNc2NVTkJRVGhETzBGQlJUbERMRWxCUVUwc1dVRkJXU3hIUVVGdFF6dEpRVU51UkN4SlFVRkpMRVZCUVVVc1YwRkJTVHRKUVVOV0xFZEJRVWNzUlVGQlJTeFRRVUZITzBsQlExSXNTVUZCU1N4RlFVRkZMRmRCUVVrN1NVRkRWaXhMUVVGTExFVkJRVVVzWVVGQlN6dEpRVU5hTEVsQlFVa3NSVUZCUlN4WFFVRkpPMGxCUTFZc1NVRkJTU3hGUVVGRkxGZEJRVWs3U1VGRFZpeEpRVUZKTEVWQlFVVXNWMEZCU1R0SlFVTldMRWxCUVVrc1JVRkJSU3hYUVVGSk8wbEJRMVlzVFVGQlRTeEZRVUZGTEdOQlFVMDdTVUZEWkN4TlFVRk5MRVZCUVVVc1kwRkJUVHREUVVObUxFTkJRVU03UVVGRlJpeHRRa0ZCTUVJc1MwRkJaMEk3U1VGRGVFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJVU3hEUVVGRExFTkJRVU1zVjBGQlNTeEZRVUZGTEZkQlFVa3NRMEZCUXl4RlFVRkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZReXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVOcVF5eERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVNUVMRGhDUVUxRE8wRkJSVVFzU1VGQlRTeHRRa0ZCYlVJc1IwRkJSeXhsUVVGbExFTkJRVU03UVVGRk5VTXNkVUpCUVhWQ0xFdEJRV2RDTzBsQlEzSkRMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXp0SlFVTXhRaXcyUkVGQk5rUTdTVUZETjBRc1NVRkJUU3hQUVVGUExFZEJRVWNzV1VGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUlhCRExFbEJRVTBzVTBGQlV5eEhRVUZST3pKQ1FVVnVRaXhKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkROVUlzU1VGQlNTeEZRVUZGTEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhOUVVGTkxFbEJRelZDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRMmhDTERSRlFVRTBSVHRaUVVNMVJTd3JSRUZCSzBRN1dVRkRMMFFzU1VGQlNTeEZRVUZGTEVWQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVkQlFVY3NiVUpCUVcxQ0xFZEJRVWNzUlVGQlJTeERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhYUVVGSkxFTkJRVU1zUlVGQlF5eEZRVU16Uml4TlFVRk5MRVZCUVVVc1JVRkJReXhOUVVGTkxFVkJRVVVzV1VGQldTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGQlF6dExRVVV4UkN4RFFVRkRPMGxCUlVZc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1pDTERaR1FVRTJSanRSUVVVM1JpeE5RVUZOTEVOQlFVTXNRMEZCUXp0blFrRkRUaXhKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4WFFVRlhMRU5CUVVNN1owSkJRMmhETEVsQlFVa3NSVUZCUlN4UFFVRlBPMmRDUVVOaUxFbEJRVWtzUlVGQlJUdHZRa0ZEU2l4TFFVRkxMRVZCUVVVN2QwSkJRMHdzU1VGQlNTeEZRVUZGTEcxQ1FVRnRRaXhIUVVGSExFdEJRVXNzUTBGQlF5eGxRVUZsTEVOQlFVTXNWMEZCU1N4RFFVRkRPM2RDUVVOMlJDeEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhYUVVGSkxFTkJRVU03ZDBKQlEycERMRTlCUVU4c1JVRkJSU3hQUVVGUE8zRkNRVU5xUWp0cFFrRkRSanRuUWtGRFJDeE5RVUZOTEVWQlFVVTdiMEpCUTA0c1RVRkJUU3hGUVVGRk8zZENRVU5PTEV0QlFVc3NSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVTXNSVUZCUXp0M1FrRkRhRU1zVFVGQlRTeEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlF5eEZRVUZETzNGQ1FVTnVRenRwUWtGRFJqdG5Ra0ZEUkN4TFFVRkxMRVZCUVVVc1UwRkJVenRoUVVOcVFpeERRVUZETEVOQlFVTTdTVUZEVEN4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMGxCUTI1Q0xFTkJRVU03UVVGRFNDeERRVUZETzBGQlJVUXNNRUpCUVRCQ0xFdEJRV2RDTzBsQlEzaERMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXp0SlFVVXhRaXhKUVVGTkxFbEJRVWtzUjBGQlJ5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1NVRkJTU3haUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRPMGxCUld4RkxFbEJRVTBzUzBGQlN5eEhRVUZWTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGblFqdEpRVVY2UXl3MlJrRkJOa1k3U1VGRk4wWXNTMEZCU3l4RFFVRkRMRWxCUVVrc2IwSkJRMUlzU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRelZDTEVsQlFVa3NSVUZCUlN4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zVFVGQlRTeEpRVU0xUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVU5pTEVOQlFVTXNTVUZCU1N4SFFVRkZMRVZCUVVNc1NVRkJTU3hOUVVGQkxFVkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNTVUZEZEVJc1NVRkJTU3hGUVVGRkxFVkJRVU1zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNc1YwRkJTU3hEUVVGRExFVkJRVU1zUlVGRGVrTXNUVUZCVFN4RlFVRkZMRVZCUVVNc1RVRkJUU3hGUVVGRkxGbEJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVU1zU1VGRGRrUXNRMEZCUXp0SlFVVklMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQlNVUTdPenRIUVVkSE8wRkJRMGdzYzBKQlFYTkNMRXRCUVdkQ08wbEJRM0JETEUxQlFVMHNRMEZCUXl4clEwRkJkMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVXl4UFFVRlBMRVZCUVVVc1QwRkJUenRSUVVNNVJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1pVRkJaU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwRkxFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkRMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzBsQlEycENMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZGUkN4alFVRmpMRXRCUVdkQ08wbEJRelZDTEVsQlFVMHNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlF5eERRVUZETEVWQlFVVXNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlF5eERRVUZETEVOQlFVTTdTVUZEZGtRc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeEpRVUZKTEhsQ1FVRnBRaXhEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTnFSQ3hEUVVGRExFMUJRVTBzU1VGQlNTeDVRa0ZCYVVJc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkRMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdRVUZEY2tVc1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIHJlZiA9IHJlcXVpcmUoXCIuL3ZhbHVlcmVmXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvbi9zZWxlY3Rpb25cIik7XG5mdW5jdGlvbiBjb2xvcihtb2RlbCkge1xuICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWc7XG4gICAgdmFyIGZpbGxlZCA9IG1vZGVsLm1hcmtEZWYuZmlsbGVkO1xuICAgIHZhciBlID0gbm9uUG9zaXRpb24oJ2NvbG9yJywgbW9kZWwsIHtcbiAgICAgICAgdmdDaGFubmVsOiBmaWxsZWQgPyAnZmlsbCcgOiAnc3Ryb2tlJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBjb21tb25fMS5nZXRNYXJrQ29uZmlnKCdjb2xvcicsIG1vZGVsLm1hcmsoKSwgY29uZmlnKVxuICAgIH0pO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGZpbGwsIGFsd2F5cyBmaWxsIHN5bWJvbHNcbiAgICAvLyB3aXRoIHRyYW5zcGFyZW50IGZpbGxzIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtbGl0ZS9pc3N1ZXMvMTMxNlxuICAgIGlmICghZS5maWxsICYmIHV0aWwuY29udGFpbnMoWydiYXInLCAncG9pbnQnLCAnY2lyY2xlJywgJ3NxdWFyZSddLCBtb2RlbC5tYXJrKCkpKSB7XG4gICAgICAgIGUuZmlsbCA9IHsgdmFsdWU6ICd0cmFuc3BhcmVudCcgfTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG59XG5leHBvcnRzLmNvbG9yID0gY29sb3I7XG5mdW5jdGlvbiBtYXJrRGVmUHJvcGVydGllcyhtYXJrLCBwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5yZWR1Y2UoZnVuY3Rpb24gKG0sIHByb3ApIHtcbiAgICAgICAgaWYgKG1hcmtbcHJvcF0pIHtcbiAgICAgICAgICAgIG1bcHJvcF0gPSB7IHZhbHVlOiBtYXJrW3Byb3BdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5tYXJrRGVmUHJvcGVydGllcyA9IG1hcmtEZWZQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gdmFsdWVJZkRlZmluZWQocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX2EgPSB7fSwgX2FbcHJvcF0gPSB7IHZhbHVlOiB2YWx1ZSB9LCBfYTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgX2E7XG59XG5leHBvcnRzLnZhbHVlSWZEZWZpbmVkID0gdmFsdWVJZkRlZmluZWQ7XG4vKipcbiAqIFJldHVybiBtaXhpbnMgZm9yIG5vbi1wb3NpdGlvbmFsIGNoYW5uZWxzIHdpdGggc2NhbGVzLiAgKFRleHQgZG9lc24ndCBoYXZlIHNjYWxlLilcbiAqL1xuZnVuY3Rpb24gbm9uUG9zaXRpb24oY2hhbm5lbCwgbW9kZWwsIG9wdCkge1xuICAgIC8vIFRPRE86IHJlZmFjdG9yIGhvdyByZWZlciB0byBzY2FsZSBhcyBkaXNjdXNzZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL3B1bGwvMTYxM1xuICAgIGlmIChvcHQgPT09IHZvaWQgMCkgeyBvcHQgPSB7fTsgfVxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdFZhbHVlLCB2Z0NoYW5uZWwgPSBvcHQudmdDaGFubmVsO1xuICAgIHZhciBkZWZhdWx0UmVmID0gb3B0LmRlZmF1bHRSZWYgfHwgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8geyB2YWx1ZTogZGVmYXVsdFZhbHVlIH0gOiB1bmRlZmluZWQpO1xuICAgIHZhciBjaGFubmVsRGVmID0gbW9kZWwuZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgdmFyIHZhbHVlUmVmID0gcmVmLm1pZFBvaW50KGNoYW5uZWwsIGNoYW5uZWxEZWYsIG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKSwgbW9kZWwuc2NhbGUoY2hhbm5lbCksIGRlZmF1bHRSZWYpO1xuICAgIHJldHVybiB3cmFwQ29uZGl0aW9uKG1vZGVsLCBjaGFubmVsRGVmICYmIGNoYW5uZWxEZWYuY29uZGl0aW9uLCB2Z0NoYW5uZWwgfHwgY2hhbm5lbCwgdmFsdWVSZWYpO1xufVxuZXhwb3J0cy5ub25Qb3NpdGlvbiA9IG5vblBvc2l0aW9uO1xuLyoqXG4gKiBSZXR1cm4gYSBtaXhpbiB0aGF0IGluY2x1ZGUgYSBWZWdhIHByb2R1Y3Rpb24gcnVsZSBmb3IgYSBWZWdhLUxpdGUgY29uZGl0aW9uYWwgY2hhbm5lbCBkZWZpbml0aW9uLlxuICogb3IgYSBzaW1wbGUgbWl4aW4gaWYgY2hhbm5lbCBkZWYgaGFzIG5vIGNvbmRpdGlvbi5cbiAqL1xuZnVuY3Rpb24gd3JhcENvbmRpdGlvbihtb2RlbCwgY29uZGl0aW9uLCB2Z0NoYW5uZWwsIHZhbHVlUmVmKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gY29uZGl0aW9uLnNlbGVjdGlvbiwgdmFsdWUgPSBjb25kaXRpb24udmFsdWU7XG4gICAgICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICAgICAgX2FbdmdDaGFubmVsXSA9IFtcbiAgICAgICAgICAgICAgICB7IHRlc3Q6IHNlbGVjdGlvblRlc3QobW9kZWwsIHNlbGVjdGlvbiksIHZhbHVlOiB2YWx1ZSB9XG4gICAgICAgICAgICBdLmNvbmNhdCgodmFsdWVSZWYgIT09IHVuZGVmaW5lZCA/IFt2YWx1ZVJlZl0gOiBbXSkpLFxuICAgICAgICAgICAgX2E7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWVSZWYgIT09IHVuZGVmaW5lZCA/IChfYiA9IHt9LCBfYlt2Z0NoYW5uZWxdID0gdmFsdWVSZWYsIF9iKSA6IHt9O1xuICAgIH1cbiAgICB2YXIgX2EsIF9iO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVGVzdChtb2RlbCwgc2VsZWN0aW9uTmFtZSkge1xuICAgIHZhciBuZWdhdGUgPSBzZWxlY3Rpb25OYW1lLmNoYXJBdCgwKSA9PT0gJyEnLCBuYW1lID0gbmVnYXRlID8gc2VsZWN0aW9uTmFtZS5zbGljZSgxKSA6IHNlbGVjdGlvbk5hbWUsIHNlbGVjdGlvbiA9IG1vZGVsLmdldENvbXBvbmVudCgnc2VsZWN0aW9uJywgbmFtZSk7XG4gICAgcmV0dXJuIChuZWdhdGUgPyAnIScgOiAnJykgK1xuICAgICAgICBzZWxlY3Rpb25fMS5wcmVkaWNhdGUoc2VsZWN0aW9uLm5hbWUsIHNlbGVjdGlvbi50eXBlLCBzZWxlY3Rpb24ucmVzb2x2ZSk7XG59XG5mdW5jdGlvbiB0ZXh0KG1vZGVsLCB2Z0NoYW5uZWwpIHtcbiAgICBpZiAodmdDaGFubmVsID09PSB2b2lkIDApIHsgdmdDaGFubmVsID0gJ3RleHQnOyB9XG4gICAgdmFyIGNoYW5uZWxEZWYgPSBtb2RlbC5lbmNvZGluZ1t2Z0NoYW5uZWxdO1xuICAgIHZhciB2YWx1ZVJlZiA9ICh2Z0NoYW5uZWwgPT09ICd0b29sdGlwJyAmJiAhY2hhbm5lbERlZikgPyB1bmRlZmluZWQgOiByZWYudGV4dChjaGFubmVsRGVmLCBtb2RlbC5jb25maWcpO1xuICAgIHJldHVybiB3cmFwQ29uZGl0aW9uKG1vZGVsLCBjaGFubmVsRGVmICYmIGNoYW5uZWxEZWYuY29uZGl0aW9uLCB2Z0NoYW5uZWwsIHZhbHVlUmVmKTtcbn1cbmV4cG9ydHMudGV4dCA9IHRleHQ7XG5mdW5jdGlvbiBiYW5kUG9zaXRpb24oY2hhbm5lbCwgbW9kZWwpIHtcbiAgICAvLyBUT0RPOiBiYW5kIHNjYWxlIGRvZXNuJ3Qgc3VwcG9ydCBzaXplIHlldFxuICAgIHZhciBmaWVsZERlZiA9IG1vZGVsLmVuY29kaW5nW2NoYW5uZWxdO1xuICAgIHZhciBzY2FsZU5hbWUgPSBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbCk7XG4gICAgdmFyIHNpemVDaGFubmVsID0gY2hhbm5lbCA9PT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICBfYVtjaGFubmVsXSA9IHJlZi5maWVsZFJlZihmaWVsZERlZiwgc2NhbGVOYW1lLCB7fSksXG4gICAgICAgIF9hW3NpemVDaGFubmVsXSA9IHJlZi5iYW5kKHNjYWxlTmFtZSksXG4gICAgICAgIF9hO1xuICAgIHZhciBfYTtcbn1cbmV4cG9ydHMuYmFuZFBvc2l0aW9uID0gYmFuZFBvc2l0aW9uO1xuZnVuY3Rpb24gY2VudGVyZWRCYW5kUG9zaXRpb24oY2hhbm5lbCwgbW9kZWwsIGRlZmF1bHRQb3NSZWYsIGRlZmF1bHRTaXplUmVmKSB7XG4gICAgdmFyIGNlbnRlckNoYW5uZWwgPSBjaGFubmVsID09PSAneCcgPyAneGMnIDogJ3ljJztcbiAgICB2YXIgc2l6ZUNoYW5uZWwgPSBjaGFubmVsID09PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIHBvaW50UG9zaXRpb24oY2hhbm5lbCwgbW9kZWwsIGRlZmF1bHRQb3NSZWYsIGNlbnRlckNoYW5uZWwpLCBub25Qb3NpdGlvbignc2l6ZScsIG1vZGVsLCB7IGRlZmF1bHRSZWY6IGRlZmF1bHRTaXplUmVmLCB2Z0NoYW5uZWw6IHNpemVDaGFubmVsIH0pKTtcbn1cbmV4cG9ydHMuY2VudGVyZWRCYW5kUG9zaXRpb24gPSBjZW50ZXJlZEJhbmRQb3NpdGlvbjtcbmZ1bmN0aW9uIGJpbm5lZFBvc2l0aW9uKGNoYW5uZWwsIG1vZGVsLCBzcGFjaW5nKSB7XG4gICAgdmFyIGZpZWxkRGVmID0gbW9kZWwuZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgdmFyIHNjYWxlTmFtZSA9IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKTtcbiAgICBpZiAoY2hhbm5lbCA9PT0gJ3gnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MjogcmVmLmJpbihmaWVsZERlZiwgc2NhbGVOYW1lLCAnc3RhcnQnLCBzcGFjaW5nKSxcbiAgICAgICAgICAgIHg6IHJlZi5iaW4oZmllbGREZWYsIHNjYWxlTmFtZSwgJ2VuZCcpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeTI6IHJlZi5iaW4oZmllbGREZWYsIHNjYWxlTmFtZSwgJ3N0YXJ0JyksXG4gICAgICAgICAgICB5OiByZWYuYmluKGZpZWxkRGVmLCBzY2FsZU5hbWUsICdlbmQnLCBzcGFjaW5nKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuYmlubmVkUG9zaXRpb24gPSBiaW5uZWRQb3NpdGlvbjtcbi8qKlxuICogUmV0dXJuIG1peGlucyBmb3IgcG9pbnQgKG5vbi1iYW5kKSBwb3NpdGlvbiBjaGFubmVscy5cbiAqL1xuZnVuY3Rpb24gcG9pbnRQb3NpdGlvbihjaGFubmVsLCBtb2RlbCwgZGVmYXVsdFJlZiwgdmdDaGFubmVsKSB7XG4gICAgLy8gVE9ETzogcmVmYWN0b3IgaG93IHJlZmVyIHRvIHNjYWxlIGFzIGRpc2N1c3NlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvcHVsbC8xNjEzXG4gICAgdmFyIGVuY29kaW5nID0gbW9kZWwuZW5jb2RpbmcsIHN0YWNrID0gbW9kZWwuc3RhY2s7XG4gICAgdmFyIHZhbHVlUmVmID0gcmVmLnN0YWNrYWJsZShjaGFubmVsLCBlbmNvZGluZ1tjaGFubmVsXSwgbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpLCBtb2RlbC5zY2FsZShjaGFubmVsKSwgc3RhY2ssIGRlZmF1bHRSZWYpO1xuICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICBfYVt2Z0NoYW5uZWwgfHwgY2hhbm5lbF0gPSB2YWx1ZVJlZixcbiAgICAgICAgX2E7XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy5wb2ludFBvc2l0aW9uID0gcG9pbnRQb3NpdGlvbjtcbi8qKlxuICogUmV0dXJuIG1peGlucyBmb3IgeDIsIHkyLlxuICogSWYgY2hhbm5lbCBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm4gb25lIGNoYW5uZWwgYmFzZWQgb24gb3JpZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHBvaW50UG9zaXRpb24yKG1vZGVsLCBkZWZhdWx0UmVmLCBjaGFubmVsKSB7XG4gICAgdmFyIGVuY29kaW5nID0gbW9kZWwuZW5jb2RpbmcsIG1hcmtEZWYgPSBtb2RlbC5tYXJrRGVmLCBzdGFjayA9IG1vZGVsLnN0YWNrO1xuICAgIGNoYW5uZWwgPSBjaGFubmVsIHx8IChtYXJrRGVmLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ3gyJyA6ICd5MicpO1xuICAgIHZhciBiYXNlQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICd4MicgPyAneCcgOiAneSc7XG4gICAgdmFyIHZhbHVlUmVmID0gcmVmLnN0YWNrYWJsZTIoY2hhbm5lbCwgZW5jb2RpbmdbYmFzZUNoYW5uZWxdLCBlbmNvZGluZ1tjaGFubmVsXSwgbW9kZWwuc2NhbGVOYW1lKGJhc2VDaGFubmVsKSwgbW9kZWwuc2NhbGUoYmFzZUNoYW5uZWwpLCBzdGFjaywgZGVmYXVsdFJlZik7XG4gICAgcmV0dXJuIF9hID0ge30sIF9hW2NoYW5uZWxdID0gdmFsdWVSZWYsIF9hO1xuICAgIHZhciBfYTtcbn1cbmV4cG9ydHMucG9pbnRQb3NpdGlvbjIgPSBwb2ludFBvc2l0aW9uMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJXbDRhVzV6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdmJXRnlheTl0YVhocGJuTXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlEwRXNhVU5CUVcxRE8wRkJSVzVETEc5RFFVRjNRenRCUVVkNFF5eG5RMEZCYTBNN1FVRkpiRU1zYjBSQlFXbEVPMEZCUldwRUxHVkJRWE5DTEV0QlFXZENPMGxCUTNCRExFbEJRVTBzVFVGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkROVUlzU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRmNFTXNTVUZCVFN4RFFVRkRMRWRCUVVjc1YwRkJWeXhEUVVGRExFOUJRVThzUlVGQlJTeExRVUZMTEVWQlFVVTdVVUZEY0VNc1UwRkJVeXhGUVVGRkxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVkQlFVY3NVVUZCVVR0UlFVTnlReXhaUVVGWkxFVkJRVVVzYzBKQlFXRXNRMEZCUXl4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeEZRVUZGTEUxQlFVMHNRMEZCVnp0TFFVTnlSU3hEUVVGRExFTkJRVU03U1VGRlNDd3lRMEZCTWtNN1NVRkRNME1zZFVWQlFYVkZPMGxCUTNaRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEVWQlFVVXNTMEZCU3l4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycEdMRU5CUVVNc1EwRkJReXhKUVVGSkxFZEJRVWNzUlVGQlF5eExRVUZMTEVWQlFVVXNZVUZCWVN4RlFVRkRMRU5CUVVNN1NVRkRiRU1zUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkRXQ3hEUVVGRE8wRkJaa1FzYzBKQlpVTTdRVUZGUkN3eVFrRkJhME1zU1VGQllTeEZRVUZGTEV0QlFYZENPMGxCUTNaRkxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJReXhGUVVGRkxFbEJRVWs3VVVGRE1VSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm1MRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEZRVUZETEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVU1zUTBGQlF6dFJRVU5vUXl4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5ZTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRCUVVOVUxFTkJRVU03UVVGUVJDdzRRMEZQUXp0QlFVVkVMSGRDUVVFclFpeEpRVUZaTEVWQlFVVXNTMEZCYVVJN1NVRkROVVFzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFSXNUVUZCVFN4VlFVRkZMRWRCUVVNc1NVRkJTU3hKUVVGSExFVkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUXl4TFFVRkZPMGxCUTJ4RExFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPenRCUVVOdVFpeERRVUZETzBGQlRFUXNkME5CUzBNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEhGQ1FVRTBRaXhQUVVFMFF5eEZRVUZGTEV0QlFXZENMRVZCUVVVc1IwRkJhVWM3U1VGRE0wd3NaMGRCUVdkSE8wbEJSRTRzYjBKQlFVRXNSVUZCUVN4UlFVRnBSenRKUVVkd1RDeEpRVUZCTEN0Q1FVRlpMRVZCUVVVc2VVSkJRVk1zUTBGQlVUdEpRVU4wUXl4SlFVRk5MRlZCUVZVc1IwRkJSeXhIUVVGSExFTkJRVU1zVlVGQlZTeEpRVUZKTEVOQlFVTXNXVUZCV1N4TFFVRkxMRk5CUVZNc1IwRkJSeXhGUVVGRExFdEJRVXNzUlVGQlJTeFpRVUZaTEVWQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVNc1EwRkJRenRKUVVWMFJ5eEpRVUZOTEZWQlFWVXNSMEZCUnl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlF6TkRMRWxCUVUwc1VVRkJVU3hIUVVGSExFZEJRVWNzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RlFVRkZMRlZCUVZVc1JVRkJSU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1NVRkZMMGNzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4TFFVRkxMRVZCUVVVc1ZVRkJWU3hKUVVGSkxGVkJRVlVzUTBGQlF5eFRRVUZUTEVWQlFVVXNVMEZCVXl4SlFVRkpMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU5zUnl4RFFVRkRPMEZCVmtRc2EwTkJWVU03UVVGRlJEczdPMGRCUjBjN1FVRkRTQ3gxUWtGQmRVSXNTMEZCWjBJc1JVRkJSU3hUUVVGNVFpeEZRVUZGTEZOQlFXbENMRVZCUVVVc1VVRkJiMEk3U1VGRGVrY3NSVUZCUlN4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5RTEVsQlFVRXNLMEpCUVZNc1JVRkJSU3gxUWtGQlN5eERRVUZqTzFGQlEzSkRMRTFCUVUwN1dVRkRTaXhIUVVGRExGTkJRVk03WjBKQlExSXNSVUZCUXl4SlFVRkpMRVZCUVVVc1lVRkJZU3hEUVVGRExFdEJRVXNzUlVGQlJTeFRRVUZUTEVOQlFVTXNSVUZCUlN4TFFVRkxMRTlCUVVFc1JVRkJRenR4UWtGRE0wTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1UwRkJVeXhIUVVGSExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUXpsRE8yVkJRMFE3U1VGRFNpeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFTkJRVU1zVVVGQlVTeExRVUZMTEZOQlFWTXNZVUZCU1N4SFFVRkRMRk5CUVZNc1NVRkJSeXhSUVVGUkxGRkJRVWtzUlVGQlJTeERRVUZETzBsQlF5OUVMRU5CUVVNN08wRkJRMGdzUTBGQlF6dEJRVVZFTEhWQ1FVRjFRaXhMUVVGblFpeEZRVUZGTEdGQlFYRkNPMGxCUXpWRUxFbEJRVTBzVFVGQlRTeEhRVUZITEdGQlFXRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUjBGQlJ5eEZRVU0xUXl4SlFVRkpMRWRCUVVjc1RVRkJUU3hIUVVGSExHRkJRV0VzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1lVRkJZU3hGUVVOMFJDeFRRVUZUTEVkQlFVY3NTMEZCU3l4RFFVRkRMRmxCUVZrc1EwRkJReXhYUVVGWExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEY0VRc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVkQlFVY3NSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkRlRUlzY1VKQlFWTXNRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxGTkJRVk1zUTBGQlF5eEpRVUZKTEVWQlFVVXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wRkJRMnBGTEVOQlFVTTdRVUZGUkN4alFVRnhRaXhMUVVGblFpeEZRVUZGTEZOQlFYTkRPMGxCUVhSRExEQkNRVUZCTEVWQlFVRXNhMEpCUVhORE8wbEJRek5GTEVsQlFVMHNWVUZCVlN4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdTVUZETjBNc1NVRkJUU3hSUVVGUkxFZEJRVWNzUTBGQlF5eFRRVUZUTEV0QlFVc3NVMEZCVXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFZEJRVWNzVTBGQlV5eEhRVUZITEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTXpSeXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEV0QlFVc3NSVUZCUlN4VlFVRlZMRWxCUVVrc1ZVRkJWU3hEUVVGRExGTkJRVk1zUlVGQlJTeFRRVUZUTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRka1lzUTBGQlF6dEJRVXBFTEc5Q1FVbERPMEZCUlVRc2MwSkJRVFpDTEU5QlFXZENMRVZCUVVVc1MwRkJaMEk3U1VGRE4wUXNORU5CUVRSRE8wbEJRelZETEVsQlFVMHNVVUZCVVN4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZEZWtNc1NVRkJUU3hUUVVGVExFZEJRVWNzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNelF5eEpRVUZOTEZkQlFWY3NSMEZCUnl4UFFVRlBMRXRCUVVzc1IwRkJSeXhIUVVGSExFOUJRVThzUjBGQlJ5eFJRVUZSTEVOQlFVTTdTVUZEZWtRc1RVRkJUVHRSUVVOS0xFZEJRVU1zVDBGQlR5eEpRVUZITEVkQlFVY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1VVRkJVU3hGUVVGRkxGTkJRVk1zUlVGQlJTeEZRVUZGTEVOQlFVTTdVVUZEYUVRc1IwRkJReXhYUVVGWExFbEJRVWNzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNN1YwRkRiRU03TzBGQlEwb3NRMEZCUXp0QlFWUkVMRzlEUVZORE8wRkJSVVFzT0VKQlFYRkRMRTlCUVd0Q0xFVkJRVVVzUzBGQlowSXNSVUZCUlN4aFFVRjVRaXhGUVVGRkxHTkJRVEJDTzBsQlF6bElMRWxCUVUwc1lVRkJZU3hIUVVGblFpeFBRVUZQTEV0QlFVc3NSMEZCUnl4SFFVRkhMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU03U1VGRGFrVXNTVUZCVFN4WFFVRlhMRWRCUVVjc1QwRkJUeXhMUVVGTExFZEJRVWNzUjBGQlJ5eFBRVUZQTEVkQlFVY3NVVUZCVVN4RFFVRkRPMGxCUTNwRUxFMUJRVTBzYzBKQlEwUXNZVUZCWVN4RFFVRkRMRTlCUVU4c1JVRkJSU3hMUVVGTExFVkJRVVVzWVVGQllTeEZRVUZGTEdGQlFXRXNRMEZCUXl4RlFVTXpSQ3hYUVVGWExFTkJRVU1zVFVGQlRTeEZRVUZGTEV0QlFVc3NSVUZCUlN4RlFVRkRMRlZCUVZVc1JVRkJSU3hqUVVGakxFVkJRVVVzVTBGQlV5eEZRVUZGTEZkQlFWY3NSVUZCUXl4RFFVRkRMRVZCUTI1R08wRkJRMG9zUTBGQlF6dEJRVkJFTEc5RVFVOURPMEZCUlVRc2QwSkJRU3RDTEU5QlFXZENMRVZCUVVVc1MwRkJaMElzUlVGQlJTeFBRVUZsTzBsQlEyaEdMRWxCUVUwc1VVRkJVU3hIUVVGSExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRla01zU1VGQlRTeFRRVUZUTEVkQlFVY3NTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndRaXhOUVVGTkxFTkJRVU03V1VGRFRDeEZRVUZGTEVWQlFVVXNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFVkJRVVVzVTBGQlV5eEZRVUZGTEU5QlFVOHNSVUZCUlN4UFFVRlBMRU5CUVVNN1dVRkRiRVFzUTBGQlF5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxGTkJRVk1zUlVGQlJTeExRVUZMTEVOQlFVTTdVMEZEZGtNc1EwRkJRenRKUVVOS0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRTFCUVUwc1EwRkJRenRaUVVOTUxFVkJRVVVzUlVGQlJTeEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hUUVVGVExFVkJRVVVzVDBGQlR5eERRVUZETzFsQlEzcERMRU5CUVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4VFFVRlRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFOUJRVThzUTBGQlF6dFRRVU5vUkN4RFFVRkRPMGxCUTBvc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGa1JDeDNRMEZqUXp0QlFVVkVPenRIUVVWSE8wRkJRMGdzZFVKQlFUaENMRTlCUVdkQ0xFVkJRVVVzUzBGQlowSXNSVUZCUlN4VlFVRnJSQ3hGUVVGRkxGTkJRVFpDTzBsQlEycEtMR2RIUVVGblJ6dEpRVVY2Uml4SlFVRkJMSGxDUVVGUkxFVkJRVVVzYlVKQlFVc3NRMEZCVlR0SlFVTm9ReXhKUVVGTkxGRkJRVkVzUjBGQlJ5eEhRVUZITEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRkxFdEJRVXNzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0SlFVVTVTQ3hOUVVGTk8xRkJRMG9zUjBGQlF5eFRRVUZUTEVsQlFVa3NUMEZCVHl4SlFVRkhMRkZCUVZFN1YwRkRhRU03TzBGQlEwb3NRMEZCUXp0QlFWUkVMSE5EUVZORE8wRkJSVVE3T3p0SFFVZEhPMEZCUTBnc2QwSkJRU3RDTEV0QlFXZENMRVZCUVVVc1ZVRkJjVU1zUlVGQlJTeFBRVUZ4UWp0SlFVTndSeXhKUVVGQkxIbENRVUZSTEVWQlFVVXNkVUpCUVU4c1JVRkJSU3h0UWtGQlN5eERRVUZWTzBsQlEzcERMRTlCUVU4c1IwRkJSeXhQUVVGUExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4TFFVRkxMRmxCUVZrc1IwRkJSeXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEY2tVc1NVRkJUU3hYUVVGWExFZEJRVWNzVDBGQlR5eExRVUZMTEVsQlFVa3NSMEZCUnl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRE8wbEJSV3BFTEVsQlFVMHNVVUZCVVN4SFFVRkhMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zVDBGQlR5eEZRVUZGTEZGQlFWRXNRMEZCUXl4WFFVRlhMRU5CUVVNc1JVRkJSU3hSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhYUVVGWExFTkJRVU1zUlVGQlJTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRmRCUVZjc1EwRkJReXhGUVVGRkxFdEJRVXNzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0SlFVTTVTaXhOUVVGTkxGVkJRVVVzUjBGQlF5eFBRVUZQTEVsQlFVY3NVVUZCVVN4TFFVRkZPenRCUVVNdlFpeERRVUZETzBGQlVFUXNkME5CVDBNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1peGlucyA9IHJlcXVpcmUoXCIuL21peGluc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgcmVmID0gcmVxdWlyZShcIi4vdmFsdWVyZWZcIik7XG5mdW5jdGlvbiBlbmNvZGVFbnRyeShtb2RlbCwgZml4ZWRTaGFwZSkge1xuICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWcsIHdpZHRoID0gbW9kZWwud2lkdGgsIGhlaWdodCA9IG1vZGVsLmhlaWdodDtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgcmVmLm1pZFgod2lkdGgsIGNvbmZpZykpLCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCByZWYubWlkWShoZWlnaHQsIGNvbmZpZykpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMudGV4dChtb2RlbCwgJ3Rvb2x0aXAnKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdzaXplJywgbW9kZWwpLCBzaGFwZU1peGlucyhtb2RlbCwgY29uZmlnLCBmaXhlZFNoYXBlKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpKTtcbn1cbmZ1bmN0aW9uIHNoYXBlTWl4aW5zKG1vZGVsLCBjb25maWcsIGZpeGVkU2hhcGUpIHtcbiAgICBpZiAoZml4ZWRTaGFwZSkge1xuICAgICAgICByZXR1cm4geyBzaGFwZTogeyB2YWx1ZTogZml4ZWRTaGFwZSB9IH07XG4gICAgfVxuICAgIHJldHVybiBtaXhpbnMubm9uUG9zaXRpb24oJ3NoYXBlJywgbW9kZWwsIHsgZGVmYXVsdFZhbHVlOiBjb21tb25fMS5nZXRNYXJrQ29uZmlnKCdzaGFwZScsICdwb2ludCcsIGNvbmZpZykgfSk7XG59XG5leHBvcnRzLnNoYXBlTWl4aW5zID0gc2hhcGVNaXhpbnM7XG5leHBvcnRzLnBvaW50ID0ge1xuICAgIHZnTWFyazogJ3N5bWJvbCcsXG4gICAgZGVmYXVsdFJvbGU6ICdwb2ludCcsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlRW50cnkobW9kZWwpO1xuICAgIH1cbn07XG5leHBvcnRzLmNpcmNsZSA9IHtcbiAgICB2Z01hcms6ICdzeW1ib2wnLFxuICAgIGRlZmF1bHRSb2xlOiAnY2lyY2xlJyxcbiAgICBlbmNvZGVFbnRyeTogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVFbnRyeShtb2RlbCwgJ2NpcmNsZScpO1xuICAgIH1cbn07XG5leHBvcnRzLnNxdWFyZSA9IHtcbiAgICB2Z01hcms6ICdzeW1ib2wnLFxuICAgIGRlZmF1bHRSb2xlOiAnc3F1YXJlJyxcbiAgICBlbmNvZGVFbnRyeTogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVFbnRyeShtb2RlbCwgJ3NxdWFyZScpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljRzlwYm5RdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXRZWEpyTDNCdmFXNTBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVZEJMR2xEUVVGdFF6dEJRVWR1UXl4dlEwRkJkME03UVVGRmVFTXNaME5CUVd0RE8wRkJSV3hETEhGQ1FVRnhRaXhMUVVGblFpeEZRVUZGTEZWQlFXZERPMGxCUXpsRUxFbEJRVUVzY1VKQlFVMHNSVUZCUlN4dFFrRkJTeXhGUVVGRkxIRkNRVUZOTEVOQlFWVTdTVUZGZEVNc1RVRkJUU3h6UWtGRFJDeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFVkJRVVVzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUlVGRGVrUXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETEVWQlJURkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEVWQlEyNUNMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RlFVTTNRaXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkRha01zVjBGQlZ5eERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRVZCUVVVc1ZVRkJWU3hEUVVGRExFVkJRM1JETEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1UwRkJVeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEZRVU4yUXp0QlFVTktMRU5CUVVNN1FVRkZSQ3h4UWtGQk5FSXNTMEZCWjBJc1JVRkJSU3hOUVVGakxFVkJRVVVzVlVGQlowTTdTVUZETlVZc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm1MRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4VlFVRlZMRVZCUVVNc1JVRkJReXhEUVVGRE8wbEJRM1JETEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eFBRVUZQTEVWQlFVVXNTMEZCU3l4RlFVRkZMRVZCUVVNc1dVRkJXU3hGUVVGRkxITkNRVUZoTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTlCUVU4c1JVRkJSU3hOUVVGTkxFTkJRVmNzUlVGQlF5eERRVUZETEVOQlFVTTdRVUZETDBjc1EwRkJRenRCUVV4RUxHdERRVXRETzBGQlJWa3NVVUZCUVN4TFFVRkxMRWRCUVdsQ08wbEJRMnBETEUxQlFVMHNSVUZCUlN4UlFVRlJPMGxCUTJoQ0xGZEJRVmNzUlVGQlJTeFBRVUZQTzBsQlEzQkNMRmRCUVZjc1JVRkJSU3hWUVVGRExFdEJRV2RDTzFGQlF6VkNMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZETlVJc1EwRkJRenREUVVOR0xFTkJRVU03UVVGRlZ5eFJRVUZCTEUxQlFVMHNSMEZCYVVJN1NVRkRiRU1zVFVGQlRTeEZRVUZGTEZGQlFWRTdTVUZEYUVJc1YwRkJWeXhGUVVGRkxGRkJRVkU3U1VGRGNrSXNWMEZCVnl4RlFVRkZMRlZCUVVNc1MwRkJaMEk3VVVGRE5VSXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdTVUZEZEVNc1EwRkJRenREUVVOR0xFTkJRVU03UVVGRlZ5eFJRVUZCTEUxQlFVMHNSMEZCYVVJN1NVRkRiRU1zVFVGQlRTeEZRVUZGTEZGQlFWRTdTVUZEYUVJc1YwRkJWeXhGUVVGRkxGRkJRVkU3U1VGRGNrSXNWMEZCVnl4RlFVRkZMRlZCUVVNc1MwRkJaMEk3VVVGRE5VSXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdTVUZEZEVNc1EwRkJRenREUVVOR0xFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vLi4vbG9nXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXJrXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xuZXhwb3J0cy5yZWN0ID0ge1xuICAgIHZnTWFyazogJ3JlY3QnLFxuICAgIGRlZmF1bHRSb2xlOiB1bmRlZmluZWQsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgeChtb2RlbCksIHkobW9kZWwpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMudGV4dChtb2RlbCwgJ3Rvb2x0aXAnKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpKTtcbiAgICB9XG59O1xuZnVuY3Rpb24geChtb2RlbCkge1xuICAgIHZhciB4RGVmID0gbW9kZWwuZW5jb2RpbmcueDtcbiAgICB2YXIgeDJEZWYgPSBtb2RlbC5lbmNvZGluZy54MjtcbiAgICB2YXIgeFNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8xLlgpO1xuICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoeERlZikgJiYgeERlZi5iaW4gJiYgIXgyRGVmKSB7XG4gICAgICAgIHJldHVybiBtaXhpbnMuYmlubmVkUG9zaXRpb24oJ3gnLCBtb2RlbCwgMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHhTY2FsZSAmJiBzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHhTY2FsZS50eXBlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoeFNjYWxlLnR5cGUgPT09IHNjYWxlXzEuU2NhbGVUeXBlLkJBTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhpbnMuYmFuZFBvc2l0aW9uKCd4JywgbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZWN0IG1hcmsgd2l0aCBwb2ludC9vcmRpbmFsIHNjYWxlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2Uuc2NhbGVUeXBlTm90V29ya1dpdGhNYXJrKG1hcmtfMS5SRUNULCB4U2NhbGUudHlwZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgJ3plcm9Pck1heCcpLCBtaXhpbnMucG9pbnRQb3NpdGlvbjIobW9kZWwsICd6ZXJvT3JNaW4nLCAneDInKSk7XG4gICAgfVxufVxuZnVuY3Rpb24geShtb2RlbCkge1xuICAgIHZhciB5RGVmID0gbW9kZWwuZW5jb2RpbmcueTtcbiAgICB2YXIgeTJEZWYgPSBtb2RlbC5lbmNvZGluZy55MjtcbiAgICB2YXIgeVNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8xLlkpO1xuICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoeURlZikgJiYgeURlZi5iaW4gJiYgIXkyRGVmKSB7XG4gICAgICAgIHJldHVybiBtaXhpbnMuYmlubmVkUG9zaXRpb24oJ3knLCBtb2RlbCwgMCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHlTY2FsZSAmJiBzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHlTY2FsZS50eXBlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoeVNjYWxlLnR5cGUgPT09IHNjYWxlXzEuU2NhbGVUeXBlLkJBTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhpbnMuYmFuZFBvc2l0aW9uKCd5JywgbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZWN0IG1hcmsgd2l0aCBwb2ludC9vcmRpbmFsIHNjYWxlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2Uuc2NhbGVUeXBlTm90V29ya1dpdGhNYXJrKG1hcmtfMS5SRUNULCB5U2NhbGUudHlwZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3knLCBtb2RlbCwgJ3plcm9Pck1heCcpLCBtaXhpbnMucG9pbnRQb3NpdGlvbjIobW9kZWwsICd6ZXJvT3JNaW4nLCAneTInKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY21WamRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMjFoY21zdmNtVmpkQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkJRU3g1UTBGQmJVTTdRVUZEYmtNc01rTkJRVEJETzBGQlF6RkRMQ3RDUVVGcFF6dEJRVU5xUXl4dFEwRkJaME03UVVGRGFFTXNjVU5CUVhsRU8wRkJSM3BFTEdsRFFVRnRRenRCUVVsMFFpeFJRVUZCTEVsQlFVa3NSMEZCYVVJN1NVRkRhRU1zVFVGQlRTeEZRVUZGTEUxQlFVMDdTVUZEWkN4WFFVRlhMRVZCUVVVc1UwRkJVenRKUVVOMFFpeFhRVUZYTEVWQlFVVXNWVUZCUXl4TFFVRm5RanRSUVVNMVFpeE5RVUZOTEhOQ1FVTkVMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGRFVpeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUTFJc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNSVUZEYmtJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4RFFVRkRMRVZCUXpkQ0xFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1EwRkJReXhGUVVOMlF6dEpRVU5LTEVOQlFVTTdRMEZEUml4RFFVRkRPMEZCUlVZc1YwRkJWeXhMUVVGblFqdEpRVU42UWl4SlFVRk5MRWxCUVVrc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTVRaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVOb1F5eEpRVUZOTEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExGZEJRVU1zUTBGQlF5eERRVUZETzBsQlJUbENMRVZCUVVVc1EwRkJReXhEUVVGRExIRkNRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRNME1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTVReXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1NVRkJTU3g1UWtGQmFVSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzQkVMREJDUVVFd1FqdFJRVU14UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeExRVUZMTEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRla01zUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTA0c2MwUkJRWE5FTzFsQlEzUkVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eFhRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE0wVXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEUxQlFVMHNjMEpCUTBRc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRmRCUVZjc1EwRkJReXhGUVVNM1F5eE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hYUVVGWExFVkJRVVVzU1VGQlNTeERRVUZETEVWQlEyeEVPMGxCUTBvc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGRlJDeFhRVUZYTEV0QlFXZENPMGxCUTNwQ0xFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRemxDTEVsQlFVMHNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlEyaERMRWxCUVUwc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZPVUlzUlVGQlJTeERRVUZETEVOQlFVTXNjVUpCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU16UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRemxETEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeEpRVUZKTEhsQ1FVRnBRaXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRjRVFzTUVKQlFUQkNPMUZCUXpGQ0xFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRXRCUVVzc2FVSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU42UXl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeHpSRUZCYzBRN1dVRkRkRVFzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExIZENRVUYzUWl4RFFVRkRMRmRCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXpSU3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTA0c1RVRkJUU3h6UWtGRFJDeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFVkJRVVVzVjBGQlZ5eERRVUZETEVWQlF6ZERMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU1zUzBGQlN5eEZRVUZGTEZkQlFWY3NSVUZCUlN4SlFVRkpMRU5CUVVNc1JVRkRiRVE3U1VGRFNpeERRVUZETzBGQlEwZ3NRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xudmFyIHJlZiA9IHJlcXVpcmUoXCIuL3ZhbHVlcmVmXCIpO1xuZXhwb3J0cy5ydWxlID0ge1xuICAgIHZnTWFyazogJ3J1bGUnLFxuICAgIGRlZmF1bHRSb2xlOiB1bmRlZmluZWQsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnLCBtYXJrRGVmID0gbW9kZWwubWFya0RlZiwgd2lkdGggPSBtb2RlbC53aWR0aCwgaGVpZ2h0ID0gbW9kZWwuaGVpZ2h0O1xuICAgICAgICB2YXIgb3JpZW50ID0gbWFya0RlZi5vcmllbnQ7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneCcsIG1vZGVsLCBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICd6ZXJvT3JNaW4nIDogcmVmLm1pZFgod2lkdGgsIGNvbmZpZykpLCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCBvcmllbnQgPT09ICd2ZXJ0aWNhbCcgPyAnemVyb09yTWluJyA6IHJlZi5taWRZKGhlaWdodCwgY29uZmlnKSksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1heCcpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMudGV4dChtb2RlbCwgJ3Rvb2x0aXAnKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpLCBtaXhpbnMubm9uUG9zaXRpb24oJ3NpemUnLCBtb2RlbCwge1xuICAgICAgICAgICAgdmdDaGFubmVsOiAnc3Ryb2tlV2lkdGgnIC8vIFZMJ3MgcnVsZSBzaXplIGlzIHN0cm9rZVdpZHRoXG4gICAgICAgIH0pKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY25Wc1pTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMjFoY21zdmNuVnNaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkZRU3hwUTBGQmJVTTdRVUZEYmtNc1owTkJRV3RETzBGQlJYSkNMRkZCUVVFc1NVRkJTU3hIUVVGcFFqdEpRVU5vUXl4TlFVRk5MRVZCUVVVc1RVRkJUVHRKUVVOa0xGZEJRVmNzUlVGQlJTeFRRVUZUTzBsQlEzUkNMRmRCUVZjc1JVRkJSU3hWUVVGRExFdEJRV2RDTzFGQlEzSkNMRWxCUVVFc2NVSkJRVTBzUlVGQlJTeDFRa0ZCVHl4RlFVRkZMRzFDUVVGTExFVkJRVVVzY1VKQlFVMHNRMEZCVlR0UlFVTXZReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUlRsQ0xFMUJRVTBzYzBKQlEwUXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTEUxQlFVMHNTMEZCU3l4WlFVRlpMRWRCUVVjc1YwRkJWeXhIUVVGSExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRExFVkJRMnBITEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeE5RVUZOTEV0QlFVc3NWVUZCVlN4SFFVRkhMRmRCUVZjc1IwRkJSeXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhGUVVOb1J5eE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hYUVVGWExFTkJRVU1zUlVGRmVrTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGRGJrSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFVkJRVVVzVTBGQlV5eERRVUZETEVWQlF6ZENMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zVTBGQlV5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RlFVTndReXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVVN1dVRkRia01zVTBGQlV5eEZRVUZGTEdGQlFXRXNRMEZCUlN4blEwRkJaME03VTBGRE0wUXNRMEZCUXl4RlFVTkdPMGxCUTBvc1EwRkJRenREUVVOR0xFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vZW5jb2RpbmdcIik7XG52YXIgcmVmID0gcmVxdWlyZShcIi4vdmFsdWVyZWZcIik7XG5leHBvcnRzLnRleHQgPSB7XG4gICAgdmdNYXJrOiAndGV4dCcsXG4gICAgZGVmYXVsdFJvbGU6IHVuZGVmaW5lZCxcbiAgICBlbmNvZGVFbnRyeTogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWcsIGVuY29kaW5nID0gbW9kZWwuZW5jb2RpbmcsIGhlaWdodCA9IG1vZGVsLmhlaWdodDtcbiAgICAgICAgdmFyIHRleHREZWYgPSBlbmNvZGluZy50ZXh0O1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgeERlZmF1bHQoY29uZmlnLCB0ZXh0RGVmKSksIG1peGlucy5wb2ludFBvc2l0aW9uKCd5JywgbW9kZWwsIHJlZi5taWRZKGhlaWdodCwgY29uZmlnKSksIG1peGlucy50ZXh0KG1vZGVsKSwgbWl4aW5zLmNvbG9yKG1vZGVsKSwgbWl4aW5zLnRleHQobW9kZWwsICd0b29sdGlwJyksIG1peGlucy5ub25Qb3NpdGlvbignb3BhY2l0eScsIG1vZGVsKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdzaXplJywgbW9kZWwsIHtcbiAgICAgICAgICAgIHZnQ2hhbm5lbDogJ2ZvbnRTaXplJyAvLyBWTCdzIHRleHQgc2l6ZSBpcyBmb250U2l6ZVxuICAgICAgICB9KSwgbWl4aW5zLnZhbHVlSWZEZWZpbmVkKCdhbGlnbicsIGFsaWduKGVuY29kaW5nLCBjb25maWcpKSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHhEZWZhdWx0KGNvbmZpZywgdGV4dERlZikge1xuICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYodGV4dERlZikgJiYgdGV4dERlZi50eXBlID09PSB0eXBlXzEuUVVBTlRJVEFUSVZFKSB7XG4gICAgICAgIHJldHVybiB7IGZpZWxkOiB7IGdyb3VwOiAnd2lkdGgnIH0sIG9mZnNldDogLTUgfTtcbiAgICB9XG4gICAgLy8gVE9ETzogYWxsb3cgdGhpcyB0byBmaXQgKEJlIGNvbnNpc3RlbnQgd2l0aCByZWYubWlkWCgpKVxuICAgIHJldHVybiB7IHZhbHVlOiBjb25maWcuc2NhbGUudGV4dFhSYW5nZVN0ZXAgLyAyIH07XG59XG5mdW5jdGlvbiBhbGlnbihlbmNvZGluZywgY29uZmlnKSB7XG4gICAgdmFyIGFsaWduQ29uZmlnID0gY29tbW9uXzEuZ2V0TWFya0NvbmZpZygnYWxpZ24nLCAndGV4dCcsIGNvbmZpZyk7XG4gICAgaWYgKGFsaWduQ29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nXzEuY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBjaGFubmVsXzEuWCkgPyAnY2VudGVyJyA6ICdyaWdodCc7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIGEgY29uZmlnLCBWZWdhLXBhcnNlciB3aWxsIHByb2Nlc3MgdGhpcyBhbHJlYWR5LlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkR1Y0ZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyMWhjbXN2ZEdWNGRDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDVRMEZCWjBNN1FVRkRhRU1zYjBOQlFYZERPMEZCUjNoRExESkRRVUZ6UkR0QlFVTjBSQ3h0UTBGQmQwTTdRVUZIZUVNc2FVTkJRVzFETzBGQlJXNURMREpEUVVGNVJEdEJRVVY2UkN4blEwRkJhME03UVVGRmNrSXNVVUZCUVN4SlFVRkpMRWRCUVdsQ08wbEJRMmhETEUxQlFVMHNSVUZCUlN4TlFVRk5PMGxCUTJRc1YwRkJWeXhGUVVGRkxGTkJRVk03U1VGRmRFSXNWMEZCVnl4RlFVRkZMRlZCUVVNc1MwRkJaMEk3VVVGRGNrSXNTVUZCUVN4eFFrRkJUU3hGUVVGRkxIbENRVUZSTEVWQlFVVXNjVUpCUVUwc1EwRkJWVHRSUVVONlF5eEpRVUZOTEU5QlFVOHNSMEZCUnl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJSVGxDTEUxQlFVMHNjMEpCUTBRc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRkZCUVZFc1EwRkJReXhOUVVGTkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNSVUZETTBRc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUXpGRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUTJ4Q0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUTI1Q0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRk5CUVZNc1EwRkJReXhGUVVNM1FpeE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRk5CUVZNc1JVRkJSU3hMUVVGTExFTkJRVU1zUlVGRGNFTXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eEZRVUZGTzFsQlEyNURMRk5CUVZNc1JVRkJSU3hWUVVGVkxFTkJRVVVzTmtKQlFUWkNPMU5CUTNKRUxFTkJRVU1zUlVGRFF5eE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hMUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUXpGRU8wbEJRMG9zUTBGQlF6dERRVU5HTEVOQlFVTTdRVUZGUml4clFrRkJhMElzVFVGQll5eEZRVUZGTEU5QlFUSkNPMGxCUXpORUxFVkJRVVVzUTBGQlF5eERRVUZETEhGQ1FVRlZMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzVDBGQlR5eERRVUZETEVsQlFVa3NTMEZCU3l4dFFrRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU42UkN4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZETEVOQlFVTTdTVUZETDBNc1EwRkJRenRKUVVORUxEQkVRVUV3UkR0SlFVTXhSQ3hOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhqUVVGakxFZEJRVWNzUTBGQlF5eEZRVUZETEVOQlFVTTdRVUZEYkVRc1EwRkJRenRCUVVWRUxHVkJRV1VzVVVGQk1FSXNSVUZCUlN4TlFVRmpPMGxCUTNaRUxFbEJRVTBzVjBGQlZ5eEhRVUZITEhOQ1FVRmhMRU5CUVVNc1QwRkJUeXhGUVVGRkxFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZYTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNNVFpeE5RVUZOTEVOQlFVTXNNRUpCUVdVc1EwRkJReXhSUVVGUkxFVkJRVVVzVjBGQlF5eERRVUZETEVkQlFVY3NVVUZCVVN4SFFVRkhMRTlCUVU4c1EwRkJRenRKUVVNelJDeERRVUZETzBsQlEwUXNLMFJCUVN0RU8wbEJReTlFTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1FVRkRia0lzUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1peGlucyA9IHJlcXVpcmUoXCIuL21peGluc1wiKTtcbnZhciByZWYgPSByZXF1aXJlKFwiLi92YWx1ZXJlZlwiKTtcbmV4cG9ydHMudGljayA9IHtcbiAgICB2Z01hcms6ICdyZWN0JyxcbiAgICBkZWZhdWx0Um9sZTogJ3RpY2snLFxuICAgIGVuY29kZUVudHJ5OiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZywgbWFya0RlZiA9IG1vZGVsLm1hcmtEZWYsIHdpZHRoID0gbW9kZWwud2lkdGgsIGhlaWdodCA9IG1vZGVsLmhlaWdodDtcbiAgICAgICAgdmFyIG9yaWVudCA9IG1hcmtEZWYub3JpZW50O1xuICAgICAgICB2YXIgdmdTaXplQ2hhbm5lbCA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICB2YXIgdmdUaGlja25lc3NDaGFubmVsID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneCcsIG1vZGVsLCByZWYubWlkWCh3aWR0aCwgY29uZmlnKSwgJ3hjJyksIG1peGlucy5wb2ludFBvc2l0aW9uKCd5JywgbW9kZWwsIHJlZi5taWRZKGhlaWdodCwgY29uZmlnKSwgJ3ljJyksIG1peGlucy5ub25Qb3NpdGlvbignc2l6ZScsIG1vZGVsLCB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRTaXplKG1vZGVsKSxcbiAgICAgICAgICAgIHZnQ2hhbm5lbDogdmdTaXplQ2hhbm5lbFxuICAgICAgICB9KSwgKF9hID0ge30sIF9hW3ZnVGhpY2tuZXNzQ2hhbm5lbF0gPSB7IHZhbHVlOiBjb25maWcudGljay50aGlja25lc3MgfSwgX2EpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMubm9uUG9zaXRpb24oJ29wYWNpdHknLCBtb2RlbCkpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRTaXplKG1vZGVsKSB7XG4gICAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZztcbiAgICB2YXIgb3JpZW50ID0gbW9kZWwubWFya0RlZi5vcmllbnQ7XG4gICAgdmFyIHNjYWxlUmFuZ2VTdGVwID0gKG1vZGVsLnNjYWxlKG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ3gnIDogJ3knKSB8fCB7fSkucmFuZ2VTdGVwO1xuICAgIGlmIChjb25maWcudGljay5iYW5kU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWcudGljay5iYW5kU2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByYW5nZVN0ZXAgPSBzY2FsZVJhbmdlU3RlcCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHNjYWxlUmFuZ2VTdGVwIDpcbiAgICAgICAgICAgIGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXA7XG4gICAgICAgIGlmICh0eXBlb2YgcmFuZ2VTdGVwICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gRklYTUUgY29uc29saWRhdGUgdGhpcyBsb2dcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZG9lcyBub3QgaGFuZGxlIG5vbi1udW1lcmljIHJhbmdlU3RlcCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZVN0ZXAgLyAxLjU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEdsamF5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMjFoY21zdmRHbGpheTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkhRU3hwUTBGQmJVTTdRVUZIYmtNc1owTkJRV3RETzBGQlJYSkNMRkZCUVVFc1NVRkJTU3hIUVVGcFFqdEpRVU5vUXl4TlFVRk5MRVZCUVVVc1RVRkJUVHRKUVVOa0xGZEJRVmNzUlVGQlJTeE5RVUZOTzBsQlJXNUNMRmRCUVZjc1JVRkJSU3hWUVVGRExFdEJRV2RDTzFGQlEzSkNMRWxCUVVFc2NVSkJRVTBzUlVGQlJTeDFRa0ZCVHl4RlFVRkZMRzFDUVVGTExFVkJRVVVzY1VKQlFVMHNRMEZCVlR0UlFVTXZReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUlRsQ0xFbEJRVTBzWVVGQllTeEhRVUZITEUxQlFVMHNTMEZCU3l4WlFVRlpMRWRCUVVjc1QwRkJUeXhIUVVGSExGRkJRVkVzUTBGQlF6dFJRVU51UlN4SlFVRk5MR3RDUVVGclFpeEhRVUZITEUxQlFVMHNTMEZCU3l4WlFVRlpMRWRCUVVjc1VVRkJVU3hIUVVGSExFOUJRVThzUTBGQlF6dFJRVVY0UlN4TlFVRk5MSE5DUVVORUxFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUlVGREwwUXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RlFVZG9SU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVVN1dVRkRia01zV1VGQldTeEZRVUZGTEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNN1dVRkRhRU1zVTBGQlV5eEZRVUZGTEdGQlFXRTdVMEZEZWtJc1EwRkJReXhsUVVORUxHdENRVUZyUWl4SlFVRkhMRVZCUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkRMRTlCUldwRUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUTI1Q0xFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1EwRkJReXhGUVVOMlF6czdTVUZEU2l4RFFVRkRPME5CUTBZc1EwRkJRenRCUVVWR0xIRkNRVUZ4UWl4TFFVRm5RanRKUVVNMVFpeEpRVUZCTEhGQ1FVRk5MRU5CUVZVN1NVRkRka0lzU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRmNFTXNTVUZCVFN4alFVRmpMRWRCUVd0Q0xFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1dVRkJXU3hIUVVGSExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhUUVVGVExFTkJRVU03U1VGRmVrY3NSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU03U1VGRE9VSXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzU1VGQlRTeFRRVUZUTEVkQlFVY3NZMEZCWXl4TFFVRkxMRk5CUVZNN1dVRkROVU1zWTBGQll6dFpRVU5rTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRE8xRkJRM3BDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1UwRkJVeXhMUVVGTExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYkVNc05rSkJRVFpDTzFsQlF6ZENMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zWjBSQlFXZEVMRU5CUVVNc1EwRkJRenRSUVVOd1JTeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1IwRkJSeXhIUVVGSExFTkJRVU03U1VGRGVrSXNRMEZCUXp0QlFVTklMRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVXRpbGl0eSBmaWxlcyBmb3IgcHJvZHVjaW5nIFZlZ2EgVmFsdWVSZWYgZm9yIG1hcmtzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpZWxkZGVmXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuLy8gVE9ETzogd2UgbmVlZCB0byBmaW5kIGEgd2F5IHRvIHJlZmFjdG9yIHRoZXNlIHNvIHRoYXQgc2NhbGVOYW1lIGlzIGEgcGFydCBvZiBzY2FsZVxuLy8gYnV0IHRoYXQncyBjb21wbGljYXRlZC4gIEZvciBub3csIHRoaXMgaXMgYSBodWdlIHN0ZXAgbW92aW5nIGZvcndhcmQuXG4vKipcbiAqIEByZXR1cm4gVmVnYSBWYWx1ZVJlZiBmb3Igc3RhY2thYmxlIHggb3IgeVxuICovXG5mdW5jdGlvbiBzdGFja2FibGUoY2hhbm5lbCwgY2hhbm5lbERlZiwgc2NhbGVOYW1lLCBzY2FsZSwgc3RhY2ssIGRlZmF1bHRSZWYpIHtcbiAgICBpZiAoY2hhbm5lbERlZiAmJiBzdGFjayAmJiBjaGFubmVsID09PSBzdGFjay5maWVsZENoYW5uZWwpIHtcbiAgICAgICAgLy8geCBvciB5IHVzZSBzdGFja19lbmQgc28gdGhhdCBzdGFja2VkIGxpbmUncyBwb2ludCBtYXJrIHVzZSBzdGFja19lbmQgdG9vLlxuICAgICAgICByZXR1cm4gZmllbGRSZWYoY2hhbm5lbERlZiwgc2NhbGVOYW1lLCB7IHN1ZmZpeDogJ2VuZCcgfSk7XG4gICAgfVxuICAgIHJldHVybiBtaWRQb2ludChjaGFubmVsLCBjaGFubmVsRGVmLCBzY2FsZU5hbWUsIHNjYWxlLCBkZWZhdWx0UmVmKTtcbn1cbmV4cG9ydHMuc3RhY2thYmxlID0gc3RhY2thYmxlO1xuLyoqXG4gKiBAcmV0dXJuIFZlZ2EgVmFsdWVSZWYgZm9yIHN0YWNrYWJsZSB4MiBvciB5MlxuICovXG5mdW5jdGlvbiBzdGFja2FibGUyKGNoYW5uZWwsIGFGaWVsZERlZiwgYTJmaWVsZERlZiwgc2NhbGVOYW1lLCBzY2FsZSwgc3RhY2ssIGRlZmF1bHRSZWYpIHtcbiAgICBpZiAoYUZpZWxkRGVmICYmIHN0YWNrICYmXG4gICAgICAgIC8vIElmIGZpZWxkQ2hhbm5lbCBpcyBYIGFuZCBjaGFubmVsIGlzIFgyIChvciBZIGFuZCBZMilcbiAgICAgICAgY2hhbm5lbC5jaGFyQXQoMCkgPT09IHN0YWNrLmZpZWxkQ2hhbm5lbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkUmVmKGFGaWVsZERlZiwgc2NhbGVOYW1lLCB7IHN1ZmZpeDogJ3N0YXJ0JyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1pZFBvaW50KGNoYW5uZWwsIGEyZmllbGREZWYsIHNjYWxlTmFtZSwgc2NhbGUsIGRlZmF1bHRSZWYpO1xufVxuZXhwb3J0cy5zdGFja2FibGUyID0gc3RhY2thYmxlMjtcbi8qKlxuICogVmFsdWUgUmVmIGZvciBiaW5uZWQgZmllbGRzXG4gKi9cbmZ1bmN0aW9uIGJpbihmaWVsZERlZiwgc2NhbGVOYW1lLCBzaWRlLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZmllbGRSZWYoZmllbGREZWYsIHNjYWxlTmFtZSwgeyBiaW5TdWZmaXg6IHNpZGUgfSwgb2Zmc2V0KTtcbn1cbmV4cG9ydHMuYmluID0gYmluO1xuZnVuY3Rpb24gZmllbGRSZWYoZmllbGREZWYsIHNjYWxlTmFtZSwgb3B0LCBvZmZzZXQpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgICBzY2FsZTogc2NhbGVOYW1lLFxuICAgICAgICBmaWVsZDogZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwgb3B0KSxcbiAgICB9O1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgcmVmLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMuZmllbGRSZWYgPSBmaWVsZFJlZjtcbmZ1bmN0aW9uIGJhbmQoc2NhbGVOYW1lLCBiYW5kKSB7XG4gICAgaWYgKGJhbmQgPT09IHZvaWQgMCkgeyBiYW5kID0gdHJ1ZTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlOiBzY2FsZU5hbWUsXG4gICAgICAgIGJhbmQ6IGJhbmRcbiAgICB9O1xufVxuZXhwb3J0cy5iYW5kID0gYmFuZDtcbi8qKlxuICogU2lnbmFsIHRoYXQgcmV0dXJucyB0aGUgbWlkZGxlIG9mIGEgYmluLiBTaG91bGQgb25seSBiZSB1c2VkIHdpdGggeCBhbmQgeS5cbiAqL1xuZnVuY3Rpb24gYmluTWlkU2lnbmFsKGZpZWxkRGVmLCBzY2FsZU5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYWw6IFwiKFwiICtcbiAgICAgICAgICAgIChcInNjYWxlKFxcXCJcIiArIHNjYWxlTmFtZSArIFwiXFxcIiwgXCIgKyBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ3N0YXJ0JywgZXhwcjogJ2RhdHVtJyB9KSArIFwiKVwiKSArXG4gICAgICAgICAgICBcIiArIFwiICtcbiAgICAgICAgICAgIChcInNjYWxlKFxcXCJcIiArIHNjYWxlTmFtZSArIFwiXFxcIiwgXCIgKyBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ2VuZCcsIGV4cHI6ICdkYXR1bScgfSkgKyBcIilcIikgK1xuICAgICAgICAgICAgXCIpLzJcIlxuICAgIH07XG59XG4vKipcbiAqIEByZXR1cm5zIHtWZ1ZhbHVlUmVmfSBWYWx1ZSBSZWYgZm9yIHhjIC8geWMgb3IgbWlkIHBvaW50IGZvciBvdGhlciBjaGFubmVscy5cbiAqL1xuZnVuY3Rpb24gbWlkUG9pbnQoY2hhbm5lbCwgY2hhbm5lbERlZiwgc2NhbGVOYW1lLCBzY2FsZSwgZGVmYXVsdFJlZikge1xuICAgIC8vIFRPRE86IGRhdHVtIHN1cHBvcnRcbiAgICBpZiAoY2hhbm5lbERlZikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGVfMS5pc0JpblNjYWxlKHNjYWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIG1pZGRsZSBvbmx5IGZvciB4IGFuIHkgdG8gcGxhY2UgbWFya3MgaW4gdGhlIGNlbnRlciBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGJpbiByYW5nZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIHRoZSBtaWQgcG9pbnQgZm9yIG90aGVyIGNoYW5uZWxzIChlLmcuIHNpemUpIHNvIHRoYXQgcHJvcGVydGllcyBvZiBsZWdlbmRzIGFuZCBtYXJrcyBtYXRjaC5cbiAgICAgICAgICAgICAgICBpZiAodXRpbF8xLmNvbnRhaW5zKFsneCcsICd5J10sIGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5NaWRTaWduYWwoY2hhbm5lbERlZiwgc2NhbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkUmVmKGNoYW5uZWxEZWYsIHNjYWxlTmFtZSwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZS50eXBlID09PSAnYmFuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJhbmQsIHRvIGdldCBtaWQgcG9pbnQsIG5lZWQgdG8gb2Zmc2V0IGJ5IGhhbGYgb2YgdGhlIGJhbmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkUmVmKGNoYW5uZWxEZWYsIHNjYWxlTmFtZSwgeyBiaW5TdWZmaXg6ICdyYW5nZScgfSwgYmFuZChzY2FsZU5hbWUsIDAuNSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRSZWYoY2hhbm5lbERlZiwgc2NhbGVOYW1lLCB7IGJpblN1ZmZpeDogJ3JhbmdlJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFJlZihjaGFubmVsRGVmLCBzY2FsZU5hbWUsIHt9KTsgLy8gbm8gbmVlZCBmb3IgYmluIHN1ZmZpeFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5uZWxEZWYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNoYW5uZWxEZWYudmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGREZWYgd2l0aG91dCBmaWVsZCBvciB2YWx1ZS4nKTsgLy8gRklYTUUgYWRkIHRoaXMgdG8gbG9nLm1lc3NhZ2VcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFJlZiA9PT0gJ3plcm9Pck1pbicpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YMikge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Pck1pblgoc2NhbGVOYW1lLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkgfHwgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkyKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb09yTWluWShzY2FsZU5hbWUsIHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgZm9yIGJhc2UgZnVuY3Rpb25cIik7IC8vIEZJWE1FIGFkZCB0aGlzIHRvIGxvZy5tZXNzYWdlXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmYXVsdFJlZiA9PT0gJ3plcm9Pck1heCcpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YMikge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Pck1heFgoc2NhbGVOYW1lLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkgfHwgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkyKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb09yTWF4WShzY2FsZU5hbWUsIHNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgZm9yIGJhc2UgZnVuY3Rpb25cIik7IC8vIEZJWE1FIGFkZCB0aGlzIHRvIGxvZy5tZXNzYWdlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZWY7XG59XG5leHBvcnRzLm1pZFBvaW50ID0gbWlkUG9pbnQ7XG5mdW5jdGlvbiB0ZXh0KHRleHREZWYsIGNvbmZpZykge1xuICAgIC8vIHRleHRcbiAgICBpZiAodGV4dERlZikge1xuICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKHRleHREZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZm9ybWF0U2lnbmFsUmVmKHRleHREZWYsIHRleHREZWYuZm9ybWF0LCAnZGF0dW0nLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHREZWYudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0ZXh0RGVmLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWU6IGNvbmZpZy50ZXh0LnRleHQgfTtcbn1cbmV4cG9ydHMudGV4dCA9IHRleHQ7XG5mdW5jdGlvbiBtaWRYKHdpZHRoLCBjb25maWcpIHtcbiAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHdpZHRoIC8gMiB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFRPRE86IEZvciBmaXQtbW9kZSwgdXNlIG1pZGRsZSBvZiB0aGUgd2lkdGhcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaWRYIGNhbiBub3QgaGFuZGxlIHN0cmluZyByYW5nZVN0ZXBzJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbHVlOiBjb25maWcuc2NhbGUucmFuZ2VTdGVwIC8gMiB9O1xufVxuZXhwb3J0cy5taWRYID0gbWlkWDtcbmZ1bmN0aW9uIG1pZFkoaGVpZ2h0LCBjb25maWcpIHtcbiAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uZmlnLnNjYWxlLnJhbmdlU3RlcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVE9ETzogRm9yIGZpdC1tb2RlLCB1c2UgbWlkZGxlIG9mIHRoZSB3aWR0aFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pZFggY2FuIG5vdCBoYW5kbGUgc3RyaW5nIHJhbmdlU3RlcHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWU6IGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgLyAyIH07XG59XG5leHBvcnRzLm1pZFkgPSBtaWRZO1xuZnVuY3Rpb24gemVyb09yTWluWChzY2FsZU5hbWUsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlTmFtZSkge1xuICAgICAgICAvLyBMb2cgLyBUaW1lIC8gVVRDIHNjYWxlIGRvIG5vdCBzdXBwb3J0IHplcm9cbiAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLkxPRywgc2NhbGVfMS5TY2FsZVR5cGUuVElNRSwgc2NhbGVfMS5TY2FsZVR5cGUuVVRDXSwgc2NhbGUudHlwZSkgJiZcbiAgICAgICAgICAgIHNjYWxlLnplcm8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZU5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUHV0IHRoZSBtYXJrIG9uIHRoZSB4LWF4aXNcbiAgICByZXR1cm4geyB2YWx1ZTogMCB9O1xufVxuLyoqXG4gKiBAcmV0dXJucyB7VmdWYWx1ZVJlZn0gYmFzZSB2YWx1ZSBpZiBzY2FsZSBleGlzdHMgYW5kIHJldHVybiBtYXggdmFsdWUgaWYgc2NhbGUgZG9lcyBub3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gemVyb09yTWF4WChzY2FsZU5hbWUsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlTmFtZSkge1xuICAgICAgICAvLyBMb2cgLyBUaW1lIC8gVVRDIHNjYWxlIGRvIG5vdCBzdXBwb3J0IHplcm9cbiAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLkxPRywgc2NhbGVfMS5TY2FsZVR5cGUuVElNRSwgc2NhbGVfMS5TY2FsZVR5cGUuVVRDXSwgc2NhbGUudHlwZSkgJiZcbiAgICAgICAgICAgIHNjYWxlLnplcm8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZU5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZmllbGQ6IHsgZ3JvdXA6ICd3aWR0aCcgfSB9O1xufVxuZnVuY3Rpb24gemVyb09yTWluWShzY2FsZU5hbWUsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlTmFtZSkge1xuICAgICAgICAvLyBMb2cgLyBUaW1lIC8gVVRDIHNjYWxlIGRvIG5vdCBzdXBwb3J0IHplcm9cbiAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLkxPRywgc2NhbGVfMS5TY2FsZVR5cGUuVElNRSwgc2NhbGVfMS5TY2FsZVR5cGUuVVRDXSwgc2NhbGUudHlwZSkgJiZcbiAgICAgICAgICAgIHNjYWxlLnplcm8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZU5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUHV0IHRoZSBtYXJrIG9uIHRoZSB5LWF4aXNcbiAgICByZXR1cm4geyBmaWVsZDogeyBncm91cDogJ2hlaWdodCcgfSB9O1xufVxuLyoqXG4gKiBAcmV0dXJucyB7VmdWYWx1ZVJlZn0gYmFzZSB2YWx1ZSBpZiBzY2FsZSBleGlzdHMgYW5kIHJldHVybiBtYXggdmFsdWUgaWYgc2NhbGUgZG9lcyBub3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gemVyb09yTWF4WShzY2FsZU5hbWUsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlTmFtZSkge1xuICAgICAgICAvLyBMb2cgLyBUaW1lIC8gVVRDIHNjYWxlIGRvIG5vdCBzdXBwb3J0IHplcm9cbiAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLkxPRywgc2NhbGVfMS5TY2FsZVR5cGUuVElNRSwgc2NhbGVfMS5TY2FsZVR5cGUuVVRDXSwgc2NhbGUudHlwZSkgJiZcbiAgICAgICAgICAgIHNjYWxlLnplcm8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZU5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUHV0IHRoZSBtYXJrIG9uIHRoZSB5LWF4aXNcbiAgICByZXR1cm4geyB2YWx1ZTogMCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZG1Gc2RXVnlaV1l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5dFlYSnJMM1poYkhWbGNtVm1MblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUczdSMEZGUnpzN1FVRkZTQ3g1UTBGQmIwUTdRVUZGY0VRc01rTkJRU3RITzBGQlF5OUhMSEZEUVVFMFJUdEJRVVUxUlN4dFEwRkJiME03UVVGRmNFTXNiME5CUVRoRk8wRkJSVGxGTEhGR1FVRnhSanRCUVVOeVJpeDNSVUZCZDBVN1FVRkZlRVU3TzBkQlJVYzdRVUZEU0N4dFFrRkJNRUlzVDBGQmEwSXNSVUZCUlN4VlFVRTRRaXhGUVVGRkxGTkJRV2xDTEVWQlFVVXNTMEZCV1N4RlFVTjZSeXhMUVVGelFpeEZRVUZGTEZWQlFYTkNPMGxCUTJoRUxFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNTVUZCU1N4TFFVRkxMRWxCUVVrc1QwRkJUeXhMUVVGTExFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpGRUxEUkZRVUUwUlR0UlFVTTFSU3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEZWQlFWVXNSVUZCUlN4VFFVRlRMRVZCUVVVc1JVRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eEZRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXhSQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGTkJRVk1zUlVGQlJTeExRVUZMTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1FVRkRja1VzUTBGQlF6dEJRVkJFTERoQ1FVOURPMEZCUlVRN08wZEJSVWM3UVVGRFNDeHZRa0ZCTWtJc1QwRkJiMElzUlVGQlJTeFRRVUV5UWl4RlFVRkZMRlZCUVRSQ0xFVkJRVVVzVTBGQmFVSXNSVUZCUlN4TFFVRlpMRVZCUTNaSkxFdEJRWE5DTEVWQlFVVXNWVUZCYzBJN1NVRkRhRVFzUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4SlFVRkpMRXRCUVVzN1VVRkRiRUlzZFVSQlFYVkVPMUZCUTNaRUxFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVTnFSQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5NTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhGUVVGRkxGTkJRVk1zUlVGQlJTeEZRVUZETEUxQlFVMHNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJReXhEUVVGRE8wbEJRek5FTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWTEVWQlFVVXNVMEZCVXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hWUVVGVkxFTkJRVU1zUTBGQlF6dEJRVU55UlN4RFFVRkRPMEZCVkVRc1owTkJVME03UVVGRlJEczdSMEZGUnp0QlFVTklMR0ZCUVc5Q0xGRkJRVEJDTEVWQlFVVXNVMEZCYVVJc1JVRkJSU3hKUVVGeFFpeEZRVUZITEUxQlFXVTdTVUZEZUVjc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVWQlFVVXNVMEZCVXl4RlFVRkZMRVZCUVVNc1UwRkJVeXhGUVVGRkxFbEJRVWtzUlVGQlF5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMEZCUTJ4RkxFTkJRVU03UVVGR1JDeHJRa0ZGUXp0QlFVVkVMR3RDUVVGNVFpeFJRVUV3UWl4RlFVRkZMRk5CUVdsQ0xFVkJRVVVzUjBGQmJVSXNSVUZCUlN4TlFVRTBRanRKUVVOMlNDeEpRVUZOTEVkQlFVY3NSMEZCWlR0UlFVTjBRaXhMUVVGTExFVkJRVVVzVTBGQlV6dFJRVU5vUWl4TFFVRkxMRVZCUVVVc1owSkJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNSMEZCUnl4RFFVRkRPMHRCUXpWQ0xFTkJRVU03U1VGRFJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMWdzUjBGQlJ5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRkRUlzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNN1FVRkRZaXhEUVVGRE8wRkJWRVFzTkVKQlUwTTdRVUZGUkN4alFVRnhRaXhUUVVGcFFpeEZRVUZGTEVsQlFUSkNPMGxCUVROQ0xIRkNRVUZCTEVWQlFVRXNWMEZCTWtJN1NVRkRha1VzVFVGQlRTeERRVUZETzFGQlEwd3NTMEZCU3l4RlFVRkZMRk5CUVZNN1VVRkRhRUlzU1VGQlNTeEZRVUZGTEVsQlFVazdTMEZEV0N4RFFVRkRPMEZCUTBvc1EwRkJRenRCUVV4RUxHOUNRVXRETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3h6UWtGQmMwSXNVVUZCTUVJc1JVRkJSU3hUUVVGcFFqdEpRVU5xUlN4TlFVRk5MRU5CUVVNN1VVRkRUQ3hOUVVGTkxFVkJRVVVzUjBGQlJ6dGhRVU5VTEdGQlFWVXNVMEZCVXl4WlFVRk5MR2RDUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEVWQlFVTXNVMEZCVXl4RlFVRkZMRTlCUVU4c1JVRkJSU3hKUVVGSkxFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTXNUVUZCUnl4RFFVRkJPMWxCUTJoR0xFdEJRVXM3WVVGRFRDeGhRVUZWTEZOQlFWTXNXVUZCVFN4blFrRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZETEZOQlFWTXNSVUZCUlN4TFFVRkxMRVZCUVVVc1NVRkJTU3hGUVVGRkxFOUJRVThzUlVGQlF5eERRVUZETEUxQlFVY3NRMEZCUVR0WlFVTm9SaXhMUVVGTE8wdEJRMDRzUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxHdENRVUY1UWl4UFFVRm5RaXhGUVVGRkxGVkJRVGhDTEVWQlFVVXNVMEZCYVVJc1JVRkJSU3hMUVVGWkxFVkJRM2hITEZWQlFXdEVPMGxCUTJ4RUxITkNRVUZ6UWp0SlFVVjBRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJZc01FSkJRVEJDTzFGQlF6RkNMRVZCUVVVc1EwRkJReXhEUVVGRExIRkNRVUZWTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRek5DTEVWQlFVVXNRMEZCUXl4RFFVRkRMR3RDUVVGVkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE0wSXNhMGRCUVd0SE8yZENRVU5zUnl3MFIwRkJORWM3WjBKQlF6VkhMRVZCUVVVc1EwRkJReXhEUVVGRExHVkJRVkVzUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTJ4RExFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNWVUZCVlN4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8yZENRVU0zUXl4RFFVRkRPMmRDUVVORUxFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNWVUZCVlN4RlFVRkZMRk5CUVZNc1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeFBRVUZQTEVWQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXk5RUxFTkJRVU03V1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4NVFrRkJhVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5zUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRekZDTEdsRlFVRnBSVHR2UWtGRGFrVXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhWUVVGVkxFVkJRVVVzVTBGQlV5eEZRVUZGTEVWQlFVTXNVMEZCVXl4RlFVRkZMRTlCUVU4c1JVRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrWXNRMEZCUXp0blFrRkRSQ3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEZWQlFWVXNSVUZCUlN4VFFVRlRMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXZSQ3hEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTA0c1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVXNVMEZCVXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFYbENPMWxCUTNaRkxFTkJRVU03VVVGRFNDeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eExRVUZMTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNeFF5eE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRVZCUVVVc1ZVRkJWU3hEUVVGRExFdEJRVXNzUlVGQlF5eERRVUZETzFGQlEyNURMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2EwTkJRV3RETEVOQlFVTXNRMEZCUXl4RFFVRkRMR2REUVVGblF6dFJRVU4yUml4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNTMEZCU3l4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlDTERCQ1FVRXdRanRSUVVNeFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhKUVVGSkxFOUJRVThzUzBGQlN5eFpRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRM1JETEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eExRVUZMTEZkQlFVTXNTVUZCU1N4UFFVRlBMRXRCUVVzc1dVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU16UXl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExGTkJRVk1zUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUXp0UlFVTjBReXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExIbENRVUYxUWl4UFFVRlBMSFZDUVVGdlFpeERRVUZETEVOQlFVTXNRMEZCUXl4blEwRkJaME03VVVGRGRrY3NRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4TFFVRkxMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFTXNNRUpCUVRCQ08xRkJRekZDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhYUVVGRExFbEJRVWtzVDBGQlR5eExRVUZMTEZsQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRjRU1zVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4VFFVRlRMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGRFTXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NWMEZCUXl4SlFVRkpMRTlCUVU4c1MwRkJTeXhaUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkRMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zVTBGQlV5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUTNSRExFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZVVKQlFYVkNMRTlCUVU4c2RVSkJRVzlDTEVOQlFVTXNRMEZCUXl4RFFVRkRMR2REUVVGblF6dFJRVU4yUnl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdRVUZEY0VJc1EwRkJRenRCUVhCRVJDdzBRa0Z2UkVNN1FVRkZSQ3hqUVVGeFFpeFBRVUUyUXl4RlFVRkZMRTFCUVdNN1NVRkRhRVlzVDBGQlR6dEpRVU5RTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFdpeEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjRRaXhOUVVGTkxFTkJRVU1zZDBKQlFXVXNRMEZCUXl4UFFVRlBMRVZCUVVVc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeFBRVUZQTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRia1VzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZRaXhOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RFFVRkRMRXRCUVVzc1JVRkJReXhEUVVGRE8xRkJRMmhETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hGUVVGRExFTkJRVU03UVVGRGJrTXNRMEZCUXp0QlFWWkVMRzlDUVZWRE8wRkJSVVFzWTBGQmNVSXNTMEZCWVN4RlFVRkZMRTFCUVdNN1NVRkRhRVFzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOV0xFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkxMRWRCUVVjc1EwRkJReXhGUVVGRExFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRXRCUVVzc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UXl3NFEwRkJPRU03VVVGRE9VTXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXgxUTBGQmRVTXNRMEZCUXl4RFFVRkRPMGxCUXpORUxFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVkQlFVY3NRMEZCUXl4RlFVRkRMRU5CUVVNN1FVRkROME1zUTBGQlF6dEJRVlpFTEc5Q1FWVkRPMEZCUlVRc1kwRkJjVUlzVFVGQll5eEZRVUZGTEUxQlFXTTdTVUZEYWtRc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTllMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVkQlFVY3NRMEZCUXl4RlFVRkRMRU5CUVVNN1NVRkROMElzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEV0QlFVc3NVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlF5dzRRMEZCT0VNN1VVRkRPVU1zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4MVEwRkJkVU1zUTBGQlF5eERRVUZETzBsQlF6TkVMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFZEJRVWNzUTBGQlF5eEZRVUZETEVOQlFVTTdRVUZETjBNc1EwRkJRenRCUVZaRUxHOUNRVlZETzBGQlJVUXNiMEpCUVc5Q0xGTkJRV2xDTEVWQlFVVXNTMEZCV1R0SlFVTnFSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJRc05rTkJRVFpETzFGQlF6ZERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNhVUpCUVZNc1EwRkJReXhIUVVGSExFVkJRVVVzYVVKQlFWTXNRMEZCUXl4SlFVRkpMRVZCUVVVc2FVSkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRE8xbEJRM1pGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVYyUWl4TlFVRk5MRU5CUVVNN1owSkJRMHdzUzBGQlN5eEZRVUZGTEZOQlFWTTdaMEpCUTJoQ0xFdEJRVXNzUlVGQlJTeERRVUZETzJGQlExUXNRMEZCUXp0UlFVTktMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzTmtKQlFUWkNPMGxCUXpkQ0xFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVNc1EwRkJRenRCUVVOd1FpeERRVUZETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3h2UWtGQmIwSXNVMEZCYVVJc1JVRkJSU3hMUVVGWk8wbEJRMnBFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFpDdzJRMEZCTmtNN1VVRkROME1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc1EwRkJReXhwUWtGQlV5eERRVUZETEVkQlFVY3NSVUZCUlN4cFFrRkJVeXhEUVVGRExFbEJRVWtzUlVGQlJTeHBRa0ZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTTdXVUZEZGtVc1MwRkJTeXhEUVVGRExFbEJRVWtzUzBGQlN5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUlhaQ0xFMUJRVTBzUTBGQlF6dG5Ra0ZEVEN4TFFVRkxMRVZCUVVVc1UwRkJVenRuUWtGRGFFSXNTMEZCU3l4RlFVRkZMRU5CUVVNN1lVRkRWQ3hEUVVGRE8xRkJRMG9zUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkRMRVZCUVVNc1EwRkJRenRCUVVOdVF5eERRVUZETzBGQlJVUXNiMEpCUVc5Q0xGTkJRV2xDTEVWQlFVVXNTMEZCV1R0SlFVTnFSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJRc05rTkJRVFpETzFGQlF6ZERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNhVUpCUVZNc1EwRkJReXhIUVVGSExFVkJRVVVzYVVKQlFWTXNRMEZCUXl4SlFVRkpMRVZCUVVVc2FVSkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRE8xbEJRM1pGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVYyUWl4TlFVRk5MRU5CUVVNN1owSkJRMHdzUzBGQlN5eEZRVUZGTEZOQlFWTTdaMEpCUTJoQ0xFdEJRVXNzUlVGQlJTeERRVUZETzJGQlExUXNRMEZCUXp0UlFVTktMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzTmtKQlFUWkNPMGxCUXpkQ0xFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hSUVVGUkxFVkJRVU1zUlVGQlF5eERRVUZETzBGQlEzQkRMRU5CUVVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEc5Q1FVRnZRaXhUUVVGcFFpeEZRVUZGTEV0QlFWazdTVUZEYWtRc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTmtMRFpEUVVFMlF6dFJRVU0zUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHVkJRVkVzUTBGQlF5eERRVUZETEdsQ1FVRlRMRU5CUVVNc1IwRkJSeXhGUVVGRkxHbENRVUZUTEVOQlFVTXNTVUZCU1N4RlFVRkZMR2xDUVVGVExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJRenRaUVVOMlJTeExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRmRrSXNUVUZCVFN4RFFVRkRPMmRDUVVOTUxFdEJRVXNzUlVGQlJTeFRRVUZUTzJkQ1FVTm9RaXhMUVVGTExFVkJRVVVzUTBGQlF6dGhRVU5VTEVOQlFVTTdVVUZEU2l4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxEWkNRVUUyUWp0SlFVTTNRaXhOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RlFVRkRMRU5CUVVNN1FVRkRjRUlzUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi9jaGFubmVsXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vZW5jb2RpbmdcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi9maWVsZGRlZlwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBoZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2xheW91dC9oZWFkZXJcIik7XG52YXIgYXNzZW1ibGVfMSA9IHJlcXVpcmUoXCIuL3NjYWxlL2Fzc2VtYmxlXCIpO1xudmFyIHVuaXRfMSA9IHJlcXVpcmUoXCIuL3VuaXRcIik7XG52YXIgTmFtZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZU1hcCgpIHtcbiAgICAgICAgdGhpcy5uYW1lTWFwID0ge307XG4gICAgfVxuICAgIE5hbWVNYXAucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uIChvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZU1hcFtvbGROYW1lXSA9IG5ld05hbWU7XG4gICAgfTtcbiAgICBOYW1lTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lTWFwW25hbWVdICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBOYW1lTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAvLyBJZiB0aGUgbmFtZSBhcHBlYXJzIGluIHRoZSBfbmFtZU1hcCwgd2UgbmVlZCB0byByZWFkIGl0cyBuZXcgbmFtZS5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBsb29wIG92ZXIgdGhlIGRpY3QganVzdCBpbiBjYXNlIHRoZSBuZXcgbmFtZSBhbHNvIGdldHMgcmVuYW1lZC5cbiAgICAgICAgd2hpbGUgKHRoaXMubmFtZU1hcFtuYW1lXSkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMubmFtZU1hcFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBOYW1lTWFwO1xufSgpKTtcbmV4cG9ydHMuTmFtZU1hcCA9IE5hbWVNYXA7XG52YXIgTW9kZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29ycmVjdHMgdGhlIGRhdGEgcmVmZXJlbmNlcyBpbiBtYXJrcyBhZnRlciBhc3NlbWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ycmVjdERhdGFOYW1lcyA9IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgY29ycmVjdFxuICAgICAgICAgICAgLy8gZm9yIG5vcm1hbCBkYXRhIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGlmIChtYXJrLmZyb20gJiYgbWFyay5mcm9tLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBtYXJrLmZyb20uZGF0YSA9IF90aGlzLmxvb2t1cERhdGFTb3VyY2UobWFyay5mcm9tLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yIGFjY2VzcyB0byBmYWNldCBkYXRhXG4gICAgICAgICAgICBpZiAobWFyay5mcm9tICYmIG1hcmsuZnJvbS5mYWNldCAmJiBtYXJrLmZyb20uZmFjZXQuZGF0YSkge1xuICAgICAgICAgICAgICAgIG1hcmsuZnJvbS5mYWNldC5kYXRhID0gX3RoaXMubG9va3VwRGF0YVNvdXJjZShtYXJrLmZyb20uZmFjZXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFyaztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBJZiBuYW1lIGlzIG5vdCBwcm92aWRlZCwgYWx3YXlzIHVzZSBwYXJlbnQncyBnaXZlbk5hbWUgdG8gYXZvaWQgbmFtZSBjb25mbGljdHMuXG4gICAgICAgIHRoaXMubmFtZSA9IHNwZWMubmFtZSB8fCBwYXJlbnRHaXZlbk5hbWU7XG4gICAgICAgIC8vIFNoYXJlZCBuYW1lIG1hcHNcbiAgICAgICAgdGhpcy5zY2FsZU5hbWVNYXAgPSBwYXJlbnQgPyBwYXJlbnQuc2NhbGVOYW1lTWFwIDogbmV3IE5hbWVNYXAoKTtcbiAgICAgICAgdGhpcy5zaXplTmFtZU1hcCA9IHBhcmVudCA/IHBhcmVudC5zaXplTmFtZU1hcCA6IG5ldyBOYW1lTWFwKCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHNwZWMuZGF0YTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IHNwZWMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IHNwZWMudHJhbnNmb3JtIHx8IFtdO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzOiBwYXJlbnQgPyBwYXJlbnQuY29tcG9uZW50LmRhdGEuc291cmNlcyA6IHt9LFxuICAgICAgICAgICAgICAgIG91dHB1dE5vZGVzOiBwYXJlbnQgPyBwYXJlbnQuY29tcG9uZW50LmRhdGEub3V0cHV0Tm9kZXMgOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcms6IG51bGwsIHNjYWxlczogbnVsbCwgYXhlczogeyB4OiBudWxsLCB5OiBudWxsIH0sXG4gICAgICAgICAgICBsYXlvdXRIZWFkZXJzOiB7IHJvdzoge30sIGNvbHVtbjoge30gfSwgbGVnZW5kczogbnVsbCwgc2VsZWN0aW9uOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIE1vZGVsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJzZURhdGEoKTtcbiAgICAgICAgdGhpcy5wYXJzZVNjYWxlKCk7IC8vIGRlcGVuZHMgb24gZGF0YSBuYW1lXG4gICAgICAgIHRoaXMucGFyc2VTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wYXJzZUF4aXNBbmRIZWFkZXIoKTsgLy8gZGVwZW5kcyBvbiBzY2FsZSBuYW1lXG4gICAgICAgIHRoaXMucGFyc2VMZWdlbmQoKTsgLy8gZGVwZW5kcyBvbiBzY2FsZSBuYW1lXG4gICAgICAgIHRoaXMucGFyc2VNYXJrKCk7IC8vIGRlcGVuZHMgb24gZGF0YSBuYW1lIGFuZCBzY2FsZSBuYW1lLCBheGlzR3JvdXAsIGFuZCBjaGlsZHJlbidzIHNjYWxlLCBheGlzLCBsZWdlbmQgYW5kIG1hcmsuXG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTY2FsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhc3NlbWJsZV8xLmFzc2VtYmxlU2NhbGUodGhpcyk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVIZWFkZXJNYXJrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxheW91dEhlYWRlcnMgPSB0aGlzLmNvbXBvbmVudC5sYXlvdXRIZWFkZXJzO1xuICAgICAgICB2YXIgaGVhZGVyTWFya3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBIRUFERVJfQ0hBTk5FTFNfMSA9IGhlYWRlcl8xLkhFQURFUl9DSEFOTkVMUzsgX2kgPCBIRUFERVJfQ0hBTk5FTFNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gSEVBREVSX0NIQU5ORUxTXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGxheW91dEhlYWRlcnNbY2hhbm5lbF0udGl0bGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJNYXJrcy5wdXNoKGhlYWRlcl8xLmdldFRpdGxlR3JvdXAodGhpcywgY2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgSEVBREVSX0NIQU5ORUxTXzIgPSBoZWFkZXJfMS5IRUFERVJfQ0hBTk5FTFM7IF9hIDwgSEVBREVSX0NIQU5ORUxTXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IEhFQURFUl9DSEFOTkVMU18yW19hXTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRIZWFkZXIgPSBsYXlvdXRIZWFkZXJzW2NoYW5uZWxdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBIRUFERVJfVFlQRVNfMSA9IGhlYWRlcl8xLkhFQURFUl9UWVBFUzsgX2IgPCBIRUFERVJfVFlQRVNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyVHlwZSA9IEhFQURFUl9UWVBFU18xW19iXTtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0SGVhZGVyW2hlYWRlclR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gMCwgX2QgPSBsYXlvdXRIZWFkZXJbaGVhZGVyVHlwZV07IF9jIDwgX2QubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gX2RbX2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlckdyb3VwID0gaGVhZGVyXzEuZ2V0SGVhZGVyR3JvdXAodGhpcywgY2hhbm5lbCwgaGVhZGVyVHlwZSwgbGF5b3V0SGVhZGVyLCBoZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyTWFya3MucHVzaChoZWFkZXJHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlck1hcmtzO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb21wb25lbnQuYXhlcywgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICByZXR1cm4gKHggPyB4LmF4ZXMuY29uY2F0KHguZ3JpZEF4ZXMpIDogW10pLmNvbmNhdCgoeSA/IHkuYXhlcy5jb25jYXQoeS5ncmlkQXhlcykgOiBbXSkpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTGVnZW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmxlZ2VuZHMpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlR3JvdXAgPSBmdW5jdGlvbiAoc2lnbmFscykge1xuICAgICAgICBpZiAoc2lnbmFscyA9PT0gdm9pZCAwKSB7IHNpZ25hbHMgPSBbXTsgfVxuICAgICAgICB2YXIgZ3JvdXAgPSB7fTtcbiAgICAgICAgc2lnbmFscyA9IHNpZ25hbHMuY29uY2F0KHRoaXMuYXNzZW1ibGVTZWxlY3Rpb25TaWduYWxzKCkpO1xuICAgICAgICBpZiAoc2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBncm91cC5zaWduYWxzID0gc2lnbmFscztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5hc3NlbWJsZUxheW91dCgpO1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBncm91cC5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAubWFya3MgPSBbXS5jb25jYXQodGhpcy5hc3NlbWJsZUhlYWRlck1hcmtzKCksIHRoaXMuYXNzZW1ibGVNYXJrcygpKTtcbiAgICAgICAgdmFyIHNjYWxlcyA9IHRoaXMuYXNzZW1ibGVTY2FsZXMoKTtcbiAgICAgICAgaWYgKHNjYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBncm91cC5zY2FsZXMgPSBzY2FsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLmFzc2VtYmxlQXhlcygpO1xuICAgICAgICBpZiAoYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBncm91cC5heGVzID0gYXhlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVnZW5kcyA9IHRoaXMuYXNzZW1ibGVMZWdlbmRzKCk7XG4gICAgICAgIGlmIChsZWdlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdyb3VwLmxlZ2VuZHMgPSBsZWdlbmRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5oYXNEZXNjZW5kYW50V2l0aEZpZWxkT25DaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiB1bml0XzEuVW5pdE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaGFzRGVzY2VuZGFudFdpdGhGaWVsZE9uQ2hhbm5lbChjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLnZhck5hbWUoKHRoaXMubmFtZSA/IHRoaXMubmFtZSArICdfJyA6ICcnKSArIHRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhIGRhdGEgc291cmNlIG5hbWUgZm9yIHRoZSBnaXZlbiBkYXRhIHNvdXJjZSB0eXBlIGFuZCBtYXJrIHRoYXQgZGF0YSBzb3VyY2UgYXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgaW4gcGFyc2UsIHNvIHRoYXQgYWxsIHVzZWQgZGF0YSBzb3VyY2UgY2FuIGJlIGNvcnJlY3RseSBpbnN0YW50aWF0ZWQgaW4gYXNzZW1ibGVEYXRhKCkuXG4gICAgICovXG4gICAgTW9kZWwucHJvdG90eXBlLnJlcXVlc3REYXRhTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuZ2V0TmFtZShuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwRGF0YVNvdXJjZShmdWxsTmFtZSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0U2l6ZVNpZ25hbFJlZiA9IGZ1bmN0aW9uIChzaXplVHlwZSkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlIG9uY2Ugd2UgaGF2ZSBzaXplU2lnbmFsIG1lcmdpbmdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5nZXROYW1lKHNpemVUeXBlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9va3VwIHRoZSBuYW1lIG9mIHRoZSBkYXRhc291cmNlIGZvciBhbiBvdXRwdXQgbm9kZS4gWW91IHByb2JhYmx5IHdhbnQgdG8gY2FsbCB0aGlzIGluIGFzc2VtYmxlLlxuICAgICAqL1xuICAgIE1vZGVsLnByb3RvdHlwZS5sb29rdXBEYXRhU291cmNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNvbXBvbmVudC5kYXRhLm91dHB1dE5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIC8vIG5hbWUgbm90IGZvdW5kIGluIG1hcCBzbyBsZXQncyBqdXN0IHJldHVybiB3aGF0IHdlIGdvdFxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuc291cmNlO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnJlbmFtZVNpemUgPSBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICB0aGlzLnNpemVOYW1lTWFwLnJlbmFtZShvbGROYW1lLCBuZXdOYW1lKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jaGFubmVsU2l6ZU5hbWUgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplTmFtZShjaGFubmVsID09PSBjaGFubmVsXzEuWCB8fCBjaGFubmVsID09PSBjaGFubmVsXzEuQ09MVU1OID8gJ3dpZHRoJyA6ICdoZWlnaHQnKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zaXplTmFtZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVOYW1lTWFwLmdldCh0aGlzLmdldE5hbWUoc2l6ZSkpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnJlbmFtZVNjYWxlID0gZnVuY3Rpb24gKG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgdGhpcy5zY2FsZU5hbWVNYXAucmVuYW1lKG9sZE5hbWUsIG5ld05hbWUpO1xuICAgIH07XG4gICAgLy8gRklYTUU6IHJlbW92ZSB0aGlzLCBidXQgY3VycmVudGx5IHRoZSBzY2FsZU5hbWUoKSBtZXRob2QgYmVsb3cgZGVwZW5kcyBvbiB0aGlzLlxuICAgIE1vZGVsLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBzY2FsZSBuYW1lIGZvciBhIGdpdmVuIGNoYW5uZWwgYWZ0ZXIgdGhlIHNjYWxlIGhhcyBiZWVuIHBhcnNlZCBhbmQgbmFtZWQuXG4gICAgICovXG4gICAgTW9kZWwucHJvdG90eXBlLnNjYWxlTmFtZSA9IGZ1bmN0aW9uIChvcmlnaW5hbFNjYWxlTmFtZSwgcGFyc2UpIHtcbiAgICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgdGhlIHBhcnNlIHBoYXNlIGFsd2F5cyByZXR1cm4gYSB2YWx1ZVxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZWZlciB0byByZW5hbWUgbWFwIGJlY2F1c2UgYSBzY2FsZSBjYW4ndCBiZSByZW5hbWVkXG4gICAgICAgICAgICAvLyBiZWZvcmUgaXQgaGFzIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZShvcmlnaW5hbFNjYWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzY2FsZSBmb3IgdGhlIGNoYW5uZWwsIGl0IHNob3VsZCBlaXRoZXJcbiAgICAgICAgLy8gYmUgaW4gdGhlIF9zY2FsZSBtYXBwaW5nIG9yIGV4aXN0IGluIHRoZSBuYW1lIG1hcFxuICAgICAgICBpZiAoXG4gICAgICAgIC8vIGluIHRoZSBzY2FsZSBtYXAgKHRoZSBzY2FsZSBpcyBub3QgbWVyZ2VkIGJ5IGl0cyBwYXJlbnQpXG4gICAgICAgICh0aGlzLnNjYWxlICYmIGNoYW5uZWxfMS5pc0NoYW5uZWwob3JpZ2luYWxTY2FsZU5hbWUpICYmIHRoaXMuc2NhbGUob3JpZ2luYWxTY2FsZU5hbWUpKSB8fFxuICAgICAgICAgICAgLy8gaW4gdGhlIHNjYWxlIG5hbWUgbWFwICh0aGUgdGhlIHNjYWxlIGdldCBtZXJnZWQgYnkgaXRzIHBhcmVudClcbiAgICAgICAgICAgIHRoaXMuc2NhbGVOYW1lTWFwLmhhcyh0aGlzLmdldE5hbWUob3JpZ2luYWxTY2FsZU5hbWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVOYW1lTWFwLmdldCh0aGlzLmdldE5hbWUob3JpZ2luYWxTY2FsZU5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgYSBtb2RlbCdzIGhpZXJhcmNoeSB0byBnZXQgdGhlIHNwZWNpZmllZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHR5cGUgU2NhbGVzIG9yIFNlbGVjdGlvblxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqL1xuICAgIE1vZGVsLnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRbdHlwZV1bbmFtZV0gfHwgdGhpcy5wYXJlbnQuZ2V0Q29tcG9uZW50KHR5cGUsIG5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbDtcbi8qKiBBYnN0cmFjdCBjbGFzcyBmb3IgVW5pdE1vZGVsIGFuZCBGYWNldE1vZGVsLiAgQm90aCBvZiB3aGljaCBjYW4gY29udGFpbiBmaWVsZERlZnMgYXMgYSBwYXJ0IG9mIGl0cyBvd24gc3BlY2lmaWNhdGlvbi4gKi9cbnZhciBNb2RlbFdpdGhGaWVsZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9kZWxXaXRoRmllbGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9kZWxXaXRoRmllbGQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqIEdldCBcImZpZWxkXCIgcmVmZXJlbmNlIGZvciB2ZWdhICovXG4gICAgTW9kZWxXaXRoRmllbGQucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24gKGNoYW5uZWwsIG9wdCkge1xuICAgICAgICBpZiAob3B0ID09PSB2b2lkIDApIHsgb3B0ID0ge307IH1cbiAgICAgICAgdmFyIGZpZWxkRGVmID0gdGhpcy5maWVsZERlZihjaGFubmVsKTtcbiAgICAgICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgb3B0ID0gdXRpbF8xLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgYmluU3VmZml4OiB0aGlzLmhhc0Rpc2NyZXRlRG9tYWluKGNoYW5uZWwpID8gJ3JhbmdlJyA6ICdzdGFydCdcbiAgICAgICAgICAgIH0sIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIG9wdCk7XG4gICAgfTtcbiAgICBNb2RlbFdpdGhGaWVsZC5wcm90b3R5cGUucmVkdWNlRmllbGREZWYgPSBmdW5jdGlvbiAoZiwgaW5pdCwgdCkge1xuICAgICAgICByZXR1cm4gZW5jb2RpbmdfMS5yZWR1Y2UodGhpcy5nZXRNYXBwaW5nKCksIGZ1bmN0aW9uIChhY2MsIGNkLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNkKSA/IGYoYWNjLCBjZCwgYykgOiBhY2M7XG4gICAgICAgIH0sIGluaXQsIHQpO1xuICAgIH07XG4gICAgTW9kZWxXaXRoRmllbGQucHJvdG90eXBlLmZvckVhY2hGaWVsZERlZiA9IGZ1bmN0aW9uIChmLCB0KSB7XG4gICAgICAgIGVuY29kaW5nXzEuZm9yRWFjaCh0aGlzLmdldE1hcHBpbmcoKSwgZnVuY3Rpb24gKGNkLCBjKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNkKSkge1xuICAgICAgICAgICAgICAgIGYoY2QsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0KTtcbiAgICB9O1xuICAgIHJldHVybiBNb2RlbFdpdGhGaWVsZDtcbn0oTW9kZWwpKTtcbmV4cG9ydHMuTW9kZWxXaXRoRmllbGQgPSBNb2RlbFdpdGhGaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJXOWtaV3d1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl0YjJSbGJDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGRFFTeHpRMEZCZVVRN1FVRkhla1FzZDBOQlFUUkRPMEZCUXpWRExIZERRVUZwUnp0QlFVOXFSeXhuUTBGQmIwUTdRVUZMY0VRc01FTkJRVzlJTzBGQlJYQklMRFpEUVVFclF6dEJRVVV2UXl3clFrRkJhVU03UVVGblEycERPMGxCUjBVN1VVRkRSU3hKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTndRaXhEUVVGRE8wbEJSVTBzZDBKQlFVMHNSMEZCWWl4VlFVRmpMRTlCUVdVc1JVRkJSU3hQUVVGbE8xRkJRelZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzVDBGQlR5eERRVUZETzBsQlEyeERMRU5CUVVNN1NVRkhUU3h4UWtGQlJ5eEhRVUZXTEZWQlFWY3NTVUZCV1R0UlFVTnlRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU03U1VGRE1VTXNRMEZCUXp0SlFVVk5MSEZDUVVGSExFZEJRVllzVlVGQlZ5eEpRVUZaTzFGQlEzSkNMSEZGUVVGeFJUdFJRVU55UlN3MlJVRkJOa1U3VVVGRE4wVXNUMEZCVHl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTTdXVUZETVVJc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkROVUlzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJRMGdzWTBGQlF6dEJRVUZFTEVOQlFVTXNRVUY2UWtRc1NVRjVRa003UVVGNlFsa3NNRUpCUVU4N1FVRXlRbkJDTzBsQmIwSkZMR1ZCUVZrc1NVRkJZeXhGUVVGRkxFMUJRV0VzUlVGQlJTeGxRVUYxUWl4RlFVRkZMRTFCUVdNN1VVRkJiRVlzYVVKQmQwSkRPMUZCTVVKM1FpeGhRVUZSTEVkQlFWa3NSVUZCUlN4RFFVRkRPMUZCTkU5b1JEczdWMEZGUnp0UlFVTkpMSEZDUVVGblFpeEhRVUZITEZWQlFVTXNTVUZCYlVJN1dVRkROVU1zTUVKQlFUQkNPMWxCUlRGQ0xEWkNRVUUyUWp0WlFVTTNRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SlFVRkpMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRhRU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1MwRkJTU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEZWtRc1EwRkJRenRaUVVWRUxESkNRVUV5UWp0WlFVTXpRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SlFVRkpMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwRUxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1IwRkJSeXhMUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRja1VzUTBGQlF6dFpRVVZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRExFTkJRVUU3VVVFeFVFTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRGNrSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRmNrSXNhMFpCUVd0R08xRkJRMnhHTEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzU1VGQlNTeGxRVUZsTEVOQlFVTTdVVUZGZWtNc2JVSkJRVzFDTzFGQlEyNUNMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXl4WlFVRlpMRWRCUVVjc1NVRkJTU3hQUVVGUExFVkJRVVVzUTBGQlF6dFJRVU5xUlN4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNWMEZCVnl4SFFVRkhMRWxCUVVrc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRkwwUXNTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlJYUkNMRWxCUVVrc1EwRkJReXhYUVVGWExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXp0UlFVTndReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJSWFpETEVsQlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjN1dVRkRaaXhKUVVGSkxFVkJRVVU3WjBKQlEwb3NUMEZCVHl4RlFVRkZMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRWRCUVVjc1JVRkJSVHRuUWtGRGNFUXNWMEZCVnl4RlFVRkZMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRWRCUVVjc1JVRkJSVHRoUVVNM1JEdFpRVU5FTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1RVRkJUU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNSVUZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEpRVUZKTEVWQlFVTTdXVUZEYkVRc1lVRkJZU3hGUVVGRExFVkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVXNSVUZCUlN4TlFVRk5MRVZCUVVVc1JVRkJSU3hGUVVGRExFVkJRVVVzVDBGQlR5eEZRVUZGTEVsQlFVa3NSVUZCUlN4VFFVRlRMRVZCUVVVc1NVRkJTVHRUUVVOd1JTeERRVUZETzBsQlEwb3NRMEZCUXp0SlFVVk5MSEZDUVVGTExFZEJRVm83VVVGRFJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1VVRkRha0lzU1VGQlNTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRMRU5CUVVNc2RVSkJRWFZDTzFGQlF6RkRMRWxCUVVrc1EwRkJReXhqUVVGakxFVkJRVVVzUTBGQlF6dFJRVU4wUWl4SlFVRkpMRU5CUVVNc2EwSkJRV3RDTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGRDUVVGM1FqdFJRVU51UkN4SlFVRkpMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU1zUTBGQlF5eDNRa0ZCZDBJN1VVRkROVU1zU1VGQlNTeERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRkRMRU5CUVVNc0swWkJRU3RHTzBsQlEyNUlMRU5CUVVNN1NVRjVRazBzT0VKQlFXTXNSMEZCY2tJN1VVRkRSU3hOUVVGTkxFTkJRVU1zZDBKQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNM1FpeERRVUZETzBsQlJVMHNiVU5CUVcxQ0xFZEJRVEZDTzFGQlExTXNTVUZCUVN3MFEwRkJZU3hEUVVGdFFqdFJRVU4yUXl4SlFVRk5MRmRCUVZjc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRmRrSXNSMEZCUnl4RFFVRkRMRU5CUVd0Q0xGVkJRV1VzUlVGQlppeHZRa0ZCUVN4M1FrRkJaU3hGUVVGbUxEWkNRVUZsTEVWQlFXWXNTVUZCWlR0WlFVRm9ReXhKUVVGTkxFOUJRVThzZDBKQlFVRTdXVUZEYUVJc1JVRkJSU3hEUVVGRExFTkJRVU1zWVVGQllTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEycERMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zYzBKQlFXRXNRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUkN4RFFVRkRPMU5CUTBZN1VVRkZSQ3hIUVVGSExFTkJRVU1zUTBGQmEwSXNWVUZCWlN4RlFVRm1MRzlDUVVGQkxIZENRVUZsTEVWQlFXWXNOa0pCUVdVc1JVRkJaaXhKUVVGbE8xbEJRV2hETEVsQlFVMHNUMEZCVHl4M1FrRkJRVHRaUVVOb1FpeEpRVUZOTEZsQlFWa3NSMEZCUnl4aFFVRmhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03V1VGRE5VTXNSMEZCUnl4RFFVRkRMRU5CUVhGQ0xGVkJRVmtzUlVGQldpeHBRa0ZCUVN4eFFrRkJXU3hGUVVGYUxEQkNRVUZaTEVWQlFWb3NTVUZCV1R0blFrRkJhRU1zU1VGQlRTeFZRVUZWTEhGQ1FVRkJPMmRDUVVOdVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTNRaXhIUVVGSExFTkJRVU1zUTBGQmFVSXNWVUZCZDBJc1JVRkJlRUlzUzBGQlFTeFpRVUZaTEVOQlFVTXNWVUZCVlN4RFFVRkRMRVZCUVhoQ0xHTkJRWGRDTEVWQlFYaENMRWxCUVhkQ08zZENRVUY0UXl4SlFVRk5MRTFCUVUwc1UwRkJRVHQzUWtGRFppeEpRVUZOTEZkQlFWY3NSMEZCUnl4MVFrRkJZeXhEUVVGRExFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNWVUZCVlN4RlFVRkZMRmxCUVZrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dDNRa0ZEY0VZc1JVRkJSU3hEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVVXNRMEZCUXpzMFFrRkRha0lzVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJRenQzUWtGRGFFTXNRMEZCUXp0eFFrRkRSanRuUWtGRFNDeERRVUZETzJGQlEwWTdVMEZEUmp0UlFVTkVMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU03U1VGRGNrSXNRMEZCUXp0SlFVbE5MRFJDUVVGWkxFZEJRVzVDTzFGQlExRXNTVUZCUVN4M1FrRkJORUlzUlVGQk0wSXNVVUZCUXl4RlFVRkZMRkZCUVVNc1EwRkJkMEk3VVVGRmJrTXNUVUZCVFN4RFFVTkVMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNVVUZEY0VNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4RlFVTjJRenRKUVVOS0xFTkJRVU03U1VGRlRTd3JRa0ZCWlN4SFFVRjBRanRSUVVORkxFMUJRVTBzUTBGQlF5eFhRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlUwc05rSkJRV0VzUjBGQmNFSXNWVUZCY1VJc1QwRkJkMEk3VVVGQmVFSXNkMEpCUVVFc1JVRkJRU3haUVVGM1FqdFJRVU16UXl4SlFVRk5MRXRCUVVzc1IwRkJhMElzUlVGQlJTeERRVUZETzFGQlJXaERMRTlCUVU4c1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4M1FrRkJkMElzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZETVVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1pDTEV0QlFVc3NRMEZCUXl4UFFVRlBMRWRCUVVjc1QwRkJUeXhEUVVGRE8xRkJRekZDTEVOQlFVTTdVVUZGUkN4SlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zWTBGQll5eEZRVUZGTEVOQlFVTTdVVUZEY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRXRCUVVzc1EwRkJReXhOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETzFGQlEzaENMRU5CUVVNN1VVRkZSQ3hMUVVGTExFTkJRVU1zUzBGQlN5eEhRVUZITEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUTNKQ0xFbEJRVWtzUTBGQlF5eHRRa0ZCYlVJc1JVRkJSU3hGUVVNeFFpeEpRVUZKTEVOQlFVTXNZVUZCWVN4RlFVRkZMRU5CUTNKQ0xFTkJRVU03VVVGRFJpeEpRVUZOTEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1kwRkJZeXhGUVVGRkxFTkJRVU03VVVGRGNrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNSQ0xFdEJRVXNzUTBGQlF5eE5RVUZOTEVkQlFVY3NUVUZCVFN4RFFVRkRPMUZCUTNoQ0xFTkJRVU03VVVGRlJDeEpRVUZOTEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1dVRkJXU3hGUVVGRkxFTkJRVU03VVVGRGFrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCQ0xFdEJRVXNzUTBGQlF5eEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTNCQ0xFTkJRVU03VVVGRlJDeEpRVUZOTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1pVRkJaU3hGUVVGRkxFTkJRVU03VVVGRGRrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNaQ0xFdEJRVXNzUTBGQlF5eFBRVUZQTEVkQlFVY3NUMEZCVHl4RFFVRkRPMUZCUXpGQ0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVsTkxDdERRVUVyUWl4SFFVRjBReXhWUVVGMVF5eFBRVUZuUWp0UlFVTnlSQ3hIUVVGSExFTkJRVU1zUTBGQlowSXNWVUZCWVN4RlFVRmlMRXRCUVVFc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQllpeGpRVUZoTEVWQlFXSXNTVUZCWVR0WlFVRTFRaXhKUVVGTkxFdEJRVXNzVTBGQlFUdFpRVU5rTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1dVRkJXU3huUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRMMElzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTI1RExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdaMEpCUTJRc1EwRkJRenRaUVVOSUxFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRUaXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNLMEpCUVN0Q0xFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOdVJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMmRDUVVOa0xFTkJRVU03V1VGRFNDeERRVUZETzFOQlEwWTdVVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wbEJRMllzUTBGQlF6dEpRVVZOTEhWQ1FVRlBMRWRCUVdRc1ZVRkJaU3hKUVVGWk8xRkJRM3BDTEUxQlFVMHNRMEZCUXl4alFVRlBMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXpWRUxFTkJRVU03U1VGRlJEczdUMEZGUnp0SlFVTkpMQ3RDUVVGbExFZEJRWFJDTEZWQlFYVkNMRWxCUVc5Q08xRkJRM3BETEVsQlFVMHNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZGY0VNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU42UXl4RFFVRkRPMGxCUlUwc1owTkJRV2RDTEVkQlFYWkNMRlZCUVhkQ0xGRkJRVFJDTzFGQlEyeEVMSGRGUVVGM1JUdFJRVU40UlN4TlFVRk5MRU5CUVVNN1dVRkRUQ3hOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNN1UwRkRMMElzUTBGQlF6dEpRVU5LTEVOQlFVTTdTVUZGUkRzN1QwRkZSenRKUVVOSkxHZERRVUZuUWl4SFFVRjJRaXhWUVVGM1FpeEpRVUZaTzFGQlEyeERMRWxCUVUwc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVVZ1UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVml4NVJFRkJlVVE3V1VGRGVrUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRSUVVOa0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVOeVFpeERRVUZETzBsQlJVMHNNRUpCUVZVc1IwRkJha0lzVlVGQmEwSXNUMEZCWlN4RlFVRkZMRTlCUVdVN1VVRkRhRVFzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzBsQlF6VkRMRU5CUVVNN1NVRkZUU3dyUWtGQlpTeEhRVUYwUWl4VlFVRjFRaXhQUVVGblFqdFJRVU55UXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEV0QlFVc3NWMEZCUXl4SlFVRkpMRTlCUVU4c1MwRkJTeXhuUWtGQlRTeEhRVUZITEU5QlFVOHNSMEZCUnl4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVOcVJpeERRVUZETzBsQlJVMHNkMEpCUVZFc1IwRkJaaXhWUVVGblFpeEpRVUZaTzFGQlEzcENMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEYmtRc1EwRkJRenRKUVVWTkxESkNRVUZYTEVkQlFXeENMRlZCUVcxQ0xFOUJRV1VzUlVGQlJTeFBRVUZsTzFGQlEycEVMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNM1F5eERRVUZETzBsQlJVUXNhMFpCUVd0R08wbEJRek5GTEhGQ1FVRkxMRWRCUVZvc1ZVRkJZU3hQUVVGblFqdFJRVU16UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc2VVSkJRVk1zUjBGQmFFSXNWVUZCT0VJc2FVSkJRVzFETEVWQlFVVXNTMEZCWlR0UlFVTm9SaXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTFZc0swTkJRU3RETzFsQlF5OURMR3RGUVVGclJUdFpRVU5zUlN4dFEwRkJiVU03V1VGRGJrTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1EwRkJRenRSUVVONlF5eERRVUZETzFGQlJVUXNkMFJCUVhkRU8xRkJRM2hFTEc5RVFVRnZSRHRSUVVOd1JDeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTkJMREpFUVVFeVJEdFJRVU16UkN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFbEJRVWtzYlVKQlFWTXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eEpRVUZKTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXp0WlFVTTNSU3hwUlVGQmFVVTdXVUZEYWtVc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4RFFVTjJSQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5JTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm9SU3hEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJjVUpFT3pzN08wOUJTVWM3U1VGRFNTdzBRa0ZCV1N4SFFVRnVRaXhWUVVGdlFpeEpRVUUwUWl4RlFVRkZMRWxCUVZrN1VVRkROVVFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXpWRkxFTkJRVU03U1VGRFNDeFpRVUZETzBGQlFVUXNRMEZCUXl4QlFYcFNSQ3hKUVhsU1F6dEJRWHBTY1VJc2MwSkJRVXM3UVVFeVVqTkNMRFJJUVVFMFNEdEJRVU0xU0R0SlFVRTJReXd3UTBGQlN6dEpRVUZzUkRzN1NVRnhRMEVzUTBGQlF6dEpRV3hEUXl4eFEwRkJjVU03U1VGRE9VSXNPRUpCUVVzc1IwRkJXaXhWUVVGaExFOUJRV2RDTEVWQlFVVXNSMEZCZDBJN1VVRkJlRUlzYjBKQlFVRXNSVUZCUVN4UlFVRjNRanRSUVVOeVJDeEpRVUZOTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlJYaERMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xFZEJRVWNzUjBGQlJ5eGhRVUZOTEVOQlFVTTdaMEpCUTFnc1UwRkJVeXhGUVVGRkxFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eFBRVUZQTEVkQlFVY3NUMEZCVHp0aFFVTXZSQ3hGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETzFGQlExWXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhuUWtGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJRenRKUVVNNVFpeERRVUZETzBsQlUwMHNkVU5CUVdNc1IwRkJja0lzVlVGQk5FSXNRMEZCYTBRc1JVRkJSU3hKUVVGUExFVkJRVVVzUTBGQlR6dFJRVU01Uml4TlFVRk5MRU5CUVVNc2FVSkJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RlFVRkZMRVZCUVVVc1ZVRkJReXhIUVVGTExFVkJRVWNzUlVGQmMwSXNSVUZCUlN4RFFVRlZPMWxCUXpGRkxFMUJRVTBzUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF6dFJRVU01UXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVk5MSGREUVVGbExFZEJRWFJDTEZWQlFYVkNMRU5CUVRaRExFVkJRVVVzUTBGQlR6dFJRVU16UlN4clFrRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNSVUZCUlN4VlFVRkRMRVZCUVhOQ0xFVkJRVVVzUTBGQlZUdFpRVU0xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXh4UWtGQlZTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGJrSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTTdVVUZEU0N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFVpeERRVUZETzBsQlJVZ3NjVUpCUVVNN1FVRkJSQ3hEUVVGRExFRkJja05FTEVOQlFUWkRMRXRCUVVzc1IwRnhRMnBFTzBGQmNrTnhRaXgzUTBGQll5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHZlZ2FfdXRpbF8xID0gcmVxdWlyZShcInZlZ2EtdXRpbFwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uL2ZpZWxkZGVmXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgdmVnYV9zY2hlbWFfMSA9IHJlcXVpcmUoXCIuLi92ZWdhLnNjaGVtYVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBhc3NlbWJsZV8xID0gcmVxdWlyZShcIi4vZGF0YS9hc3NlbWJsZVwiKTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4vZGF0YS9wYXJzZVwiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgZG9tYWluXzEgPSByZXF1aXJlKFwiLi9zY2FsZS9kb21haW5cIik7XG5mdW5jdGlvbiByZXBsYWNlUmVwZWF0ZXJJbkZhY2V0KGZhY2V0LCByZXBlYXRlcikge1xuICAgIHJldHVybiByZXBsYWNlUmVwZWF0ZXIoZmFjZXQsIHJlcGVhdGVyKTtcbn1cbmV4cG9ydHMucmVwbGFjZVJlcGVhdGVySW5GYWNldCA9IHJlcGxhY2VSZXBlYXRlckluRmFjZXQ7XG5mdW5jdGlvbiByZXBsYWNlUmVwZWF0ZXJJbkVuY29kaW5nKGVuY29kaW5nLCByZXBlYXRlcikge1xuICAgIHJldHVybiByZXBsYWNlUmVwZWF0ZXIoZW5jb2RpbmcsIHJlcGVhdGVyKTtcbn1cbmV4cG9ydHMucmVwbGFjZVJlcGVhdGVySW5FbmNvZGluZyA9IHJlcGxhY2VSZXBlYXRlckluRW5jb2Rpbmc7XG4vKipcbiAqIFJlcGxhY2UgcmVwZWF0ZXIgdmFsdWVzIGluIGEgZmllbGQgZGVmIHdpdGggdGhlIGNvbmNyZXRlIGZpZWxkIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VSZXBlYXRlckluRmllbGREZWYoZmllbGREZWYsIHJlcGVhdGVyKSB7XG4gICAgdmFyIGZpZWxkID0gZmllbGREZWYuZmllbGQ7XG4gICAgaWYgKGZpZWxkZGVmXzEuaXNSZXBlYXRSZWYoZmllbGQpKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXBlYXQgaW4gcmVwZWF0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBmaWVsZERlZiwgeyBmaWVsZDogcmVwZWF0ZXJbZmllbGQucmVwZWF0XSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLm5vU3VjaFJlcGVhdGVkVmFsdWUoZmllbGQucmVwZWF0KSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZmllbGQgaXMgbm90IGEgcmVwZWF0IHJlZiBzbyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGZpZWxkIGRlZlxuICAgICAgICByZXR1cm4gZmllbGREZWY7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJlcGVhdGVyKG1hcHBpbmcsIHJlcGVhdGVyKSB7XG4gICAgdmFyIG91dCA9IHt9O1xuICAgIGZvciAodmFyIGNoYW5uZWwgaW4gbWFwcGluZykge1xuICAgICAgICBpZiAobWFwcGluZy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsKSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkRGVmID0gbWFwcGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgIGlmICh2ZWdhX3V0aWxfMS5pc0FycmF5KGZpZWxkRGVmKSkge1xuICAgICAgICAgICAgICAgIG91dFtjaGFubmVsXSA9IGZpZWxkRGVmLm1hcChmdW5jdGlvbiAoZmQpIHsgcmV0dXJuIHJlcGxhY2VSZXBlYXRlckluRmllbGREZWYoZmQsIHJlcGVhdGVyKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZmQpIHsgcmV0dXJuIGZkICE9PSBudWxsOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmZCA9IHJlcGxhY2VSZXBlYXRlckluRmllbGREZWYoZmllbGREZWYsIHJlcGVhdGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2NoYW5uZWxdID0gZmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG52YXIgUmVwZWF0TW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlcGVhdE1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGVhdE1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCByZXBlYXRWYWx1ZXMsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXBlYXQgPSBzcGVjLnJlcGVhdDtcbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBfdGhpcy5faW5pdENoaWxkcmVuKHNwZWMsIF90aGlzLnJlcGVhdCwgcmVwZWF0VmFsdWVzLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlcGVhdE1vZGVsLnByb3RvdHlwZS5faW5pdENoaWxkcmVuID0gZnVuY3Rpb24gKHNwZWMsIHJlcGVhdCwgcmVwZWF0ZXIsIGNvbmZpZykge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIHJvdyA9IHJlcGVhdC5yb3cgfHwgW3JlcGVhdGVyID8gcmVwZWF0ZXIucm93IDogbnVsbF07XG4gICAgICAgIHZhciBjb2x1bW4gPSByZXBlYXQuY29sdW1uIHx8IFtyZXBlYXRlciA/IHJlcGVhdGVyLmNvbHVtbiA6IG51bGxdO1xuICAgICAgICAvLyBjcm9zcyBwcm9kdWN0XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcm93XzEgPSByb3c7IF9pIDwgcm93XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93RmllbGQgPSByb3dfMVtfaV07XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGNvbHVtbl8xID0gY29sdW1uOyBfYSA8IGNvbHVtbl8xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW5GaWVsZCA9IGNvbHVtbl8xW19hXTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gKHJvd0ZpZWxkID8gJ18nICsgcm93RmllbGQgOiAnJykgKyAoY29sdW1uRmllbGQgPyAnXycgKyBjb2x1bW5GaWVsZCA6ICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZXBlYXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93RmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uRmllbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY29tbW9uXzEuYnVpbGRNb2RlbChzcGVjLnNwZWMsIHRoaXMsIHRoaXMuZ2V0TmFtZSgnY2hpbGQnICsgbmFtZV8xKSwgdW5kZWZpbmVkLCBjaGlsZFJlcGVhdCwgY29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgUmVwZWF0TW9kZWwucHJvdG90eXBlLnBhcnNlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuZGF0YSA9IHBhcnNlXzEucGFyc2VEYXRhKHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZURhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUucGFyc2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE1lcmdlIHNlbGVjdGlvbnMgdXAgdGhlIGhpZXJhcmNoeSBzbyB0aGF0IHRoZXkgbWF5IGJlIHJlZmVyZW5jZWRcbiAgICAgICAgLy8gYWNyb3NzIHVuaXQgc3BlY3MuIFBlcnNpc3QgdGhlaXIgZGVmaW5pdGlvbnMgd2l0aGluIGVhY2ggY2hpbGRcbiAgICAgICAgLy8gdG8gYXNzZW1ibGUgc2lnbmFscyB3aGljaCByZW1haW4gd2l0aGluIG91dHB1dCBWZWdhIHVuaXQgZ3JvdXBzLlxuICAgICAgICB0aGlzLmNvbXBvbmVudC5zZWxlY3Rpb24gPSB7fTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB1dGlsXzEua2V5cyhjaGlsZC5jb21wb25lbnQuc2VsZWN0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnQuc2VsZWN0aW9uW2tleV0gPSBjaGlsZC5jb21wb25lbnQuc2VsZWN0aW9uW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYVtfaV07XG4gICAgICAgICAgICBfbG9vcF8xKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwZWF0TW9kZWwucHJvdG90eXBlLnBhcnNlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgIHZhciBzY2FsZUNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50LnNjYWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZVNjYWxlKCk7XG4gICAgICAgICAgICAvLyBGSVhNRSgjMTYwMik6IGNvcnJlY3RseSBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgc2NhbGVcbiAgICAgICAgICAgIC8vIEFsc28gbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBzY2FsZXMgYXJlIGFjdHVhbGx5IGNvbXBhdGlibGUsIGUuZy4gdXNlIHRoZSBzYW1lIHNvcnQgb3IgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmtleXMoY2hpbGQuY29tcG9uZW50LnNjYWxlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbF8xLmNvbnRhaW5zKGNoYW5uZWxfMS5OT05TUEFUSUFMX1NDQUxFX0NIQU5ORUxTLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkU2NhbGUgPSBjaGlsZC5jb21wb25lbnQuc2NhbGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsU2NhbGUgPSBzY2FsZUNvbXBvbmVudFtjaGFubmVsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRTY2FsZSB8fCB2ZWdhX3NjaGVtYV8xLmlzU2lnbmFsUmVmRG9tYWluKGNoaWxkU2NhbGUuZG9tYWluKSB8fCAobW9kZWxTY2FsZSAmJiB2ZWdhX3NjaGVtYV8xLmlzU2lnbmFsUmVmRG9tYWluKG1vZGVsU2NhbGUuZG9tYWluKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtZXJnZSBzaWduYWwgcmVmIGRvbWFpbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWxTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsU2NhbGUuZG9tYWluID0gZG9tYWluXzEudW5pb25Eb21haW5zKG1vZGVsU2NhbGUuZG9tYWluLCBjaGlsZFNjYWxlLmRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZUNvbXBvbmVudFtjaGFubmVsXSA9IGNoaWxkU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5hbWUgY2hpbGQgc2NhbGUgdG8gcGFyZW50IHNjYWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlTmFtZVdpdGhvdXRQcmVmaXggPSBjaGlsZFNjYWxlLm5hbWUuc3Vic3RyKGNoaWxkLmdldE5hbWUoJycpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG1vZGVsLnNjYWxlTmFtZShzY2FsZU5hbWVXaXRob3V0UHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlbmFtZVNjYWxlKGNoaWxkU2NhbGUubmFtZSwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFNjYWxlLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG1lcmdlZCBzY2FsZXMgZnJvbSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5zY2FsZXNbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUucGFyc2VNYXJrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlTWFyaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzQW5kSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlQXhpc0FuZEhlYWRlcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVwZWF0TW9kZWwucHJvdG90eXBlLnBhcnNlTGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVnZW5kQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQubGVnZW5kcyA9IHt9O1xuICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyc2VMZWdlbmQoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvcnJlY3RseSBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgbGVnZW5kc1xuICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEua2V5cyhjaGlsZC5jb21wb25lbnQubGVnZW5kcykuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHVzZSB0aGUgZmlyc3QgbGVnZW5kIGRlZmluaXRpb24gZm9yIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZ2VuZENvbXBvbmVudFtjaGFubmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kQ29tcG9uZW50W2NoYW5uZWxdID0gY2hpbGQuY29tcG9uZW50LmxlZ2VuZHNbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgIF9sb29wXzIoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBvbmx5IGFzc2VtYmxlIGRhdGEgaW4gdGhlIHJvb3RcbiAgICAgICAgICAgIHJldHVybiBhc3NlbWJsZV8xLmFzc2VtYmxlRGF0YSh1dGlsXzEudmFscyh0aGlzLmNvbXBvbmVudC5kYXRhLnNvdXJjZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVwZWF0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uVG9wTGV2ZWxTaWduYWxzID0gZnVuY3Rpb24gKHNpZ25hbHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChzZywgY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmFzc2VtYmxlU2VsZWN0aW9uVG9wTGV2ZWxTaWduYWxzKHNnKTsgfSwgc2lnbmFscyk7XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTZWxlY3Rpb25TaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5hc3NlbWJsZVNlbGVjdGlvblNpZ25hbHMoKTsgfSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFJlcGVhdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUxheW91dFNpZ25hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoc2lnbmFscywgY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduYWxzLmNvbmNhdChjaGlsZC5hc3NlbWJsZUxheW91dFNpZ25hbHMoKSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIFJlcGVhdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNlbGVjdGlvbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGRiLCBjaGlsZCkgeyByZXR1cm4gY2hpbGQuYXNzZW1ibGVTZWxlY3Rpb25EYXRhKGRiKTsgfSwgW10pO1xuICAgIH07XG4gICAgUmVwZWF0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2NhbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb21iaW5lIHdpdGggc2NhbGVzIGZyb20gY2hpbGRyZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChzY2FsZXMsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZXMuY29uY2F0KGMuYXNzZW1ibGVTY2FsZXMoKSk7XG4gICAgICAgIH0sIF9zdXBlci5wcm90b3R5cGUuYXNzZW1ibGVTY2FsZXMuY2FsbCh0aGlzKSk7XG4gICAgfTtcbiAgICBSZXBlYXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IGFsbG93IGN1c3RvbWl6YXRpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHsgcm93OiAxMCwgY29sdW1uOiAxMCB9LFxuICAgICAgICAgICAgb2Zmc2V0OiAxMCxcbiAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMucmVwZWF0ICYmIHRoaXMucmVwZWF0LmNvbHVtbiA/IHRoaXMucmVwZWF0LmNvbHVtbi5sZW5ndGggOiAxLFxuICAgICAgICAgICAgYm91bmRzOiAnZnVsbCcsXG4gICAgICAgICAgICBhbGlnbjogJ2FsbCdcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJlcGVhdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZU1hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbmx5IGNoaWxkcmVuIGhhdmUgbWFya3NcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIGVuY29kZUVudHJ5ID0gY2hpbGQuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHsgdHlwZTogJ2dyb3VwJywgbmFtZTogY2hpbGQuZ2V0TmFtZSgnZ3JvdXAnKSB9LCAoZW5jb2RlRW50cnkgPyB7XG4gICAgICAgICAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZW5jb2RlRW50cnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDoge30pLCBjaGlsZC5hc3NlbWJsZUdyb3VwKCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBlYXRNb2RlbDtcbn0obW9kZWxfMS5Nb2RlbCkpO1xuZXhwb3J0cy5SZXBlYXRNb2RlbCA9IFJlcGVhdE1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY21Wd1pXRjBMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjbVZ3WldGMExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVGQkxIVkRRVUZyUXp0QlFVTnNReXh6UTBGQmNVUTdRVUZKY2tRc2QwTkJRWGxFTzBGQlEzcEVMRFJDUVVFNFFqdEJRVWM1UWl4blEwRkJiVVE3UVVGRGJrUXNPRU5CUVhOR08wRkJRM1JHTEcxRFFVRnZRenRCUVVOd1F5dzBRMEZCTmtNN1FVRkROME1zYzBOQlFYVkRPMEZCUTNaRExHbERRVUU0UWp0QlFVTTVRaXg1UTBGQk5FTTdRVUZSTlVNc1owTkJRWFZETEV0QlFXMUNMRVZCUVVVc1VVRkJkVUk3U1VGRGFrWXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1EwRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdRVUZETVVNc1EwRkJRenRCUVVaRUxIZEVRVVZETzBGQlJVUXNiVU5CUVRCRExGRkJRWGxDTEVWQlFVVXNVVUZCZFVJN1NVRkRNVVlzVFVGQlRTeERRVUZETEdWQlFXVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03UVVGRE4wTXNRMEZCUXp0QlFVWkVMRGhFUVVWRE8wRkJTVVE3TzBkQlJVYzdRVUZEU0N4dFEwRkJiVU1zVVVGQmVVSXNSVUZCUlN4UlFVRjFRanRKUVVOdVJpeEpRVUZOTEV0QlFVc3NSMEZCUnl4UlFVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRE8wbEJRemRDTEVWQlFVVXNRMEZCUXl4RFFVRkRMSE5DUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNaQ0xFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRWxCUVVrc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0zUWl4TlFVRk5MSE5DUVVORUxGRkJRVkVzU1VGRFdDeExRVUZMTEVWQlFVVXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGRE4wSTdVVUZEU2l4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZUVRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU5rTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeG5SVUZCWjBVN1VVRkRhRVVzVFVGQlRTeERRVUZETEZGQlFUUkNMRU5CUVVNN1NVRkRkRU1zUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZGUkN4NVFrRkJlVUlzVDBGQkswSXNSVUZCUlN4UlFVRjFRanRKUVVNdlJTeEpRVUZOTEVkQlFVY3NSMEZCTkVJc1JVRkJSU3hEUVVGRE8wbEJRM2hETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVUwc1QwRkJUeXhKUVVGSkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VJc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEdOQlFXTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNTVUZCVFN4UlFVRlJMRWRCUVhkRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVVjJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eHRRa0ZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVJc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJRU3hGUVVGRkxFbEJRVWtzVDBGQlFTeDVRa0ZCZVVJc1EwRkJReXhGUVVGRkxFVkJRVVVzVVVGQlVTeERRVUZETEVWQlFYWkRMRU5CUVhWRExFTkJRVU03Y1VKQlEzWkZMRTFCUVUwc1EwRkJReXhWUVVGRExFVkJRVEpDTEVsQlFVc3NUMEZCUVN4RlFVRkZMRXRCUVVzc1NVRkJTU3hGUVVGWUxFTkJRVmNzUTBGQlF5eERRVUZETzFsQlF6RkVMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEVGl4SlFVRk5MRVZCUVVVc1IwRkJSeXg1UWtGQmVVSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03WjBKQlEzcEVMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUzBGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOb1FpeEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRE8yZENRVU53UWl4RFFVRkRPMWxCUTBnc1EwRkJRenRSUVVOSUxFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJRenRCUVVOaUxFTkJRVU03UVVGRlJEdEpRVUZwUXl4MVEwRkJTenRKUVV0d1F5eHhRa0ZCV1N4SlFVRm5RaXhGUVVGRkxFMUJRV0VzUlVGQlJTeGxRVUYxUWl4RlFVRkZMRmxCUVRKQ0xFVkJRVVVzVFVGQll6dFJRVUZxU0N4WlFVTkZMR3RDUVVGTkxFbEJRVWtzUlVGQlJTeE5RVUZOTEVWQlFVVXNaVUZCWlN4RlFVRkZMRTFCUVUwc1EwRkJReXhUUVVrM1F6dFJRVVpETEV0QlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU14UWl4TFFVRkpMRU5CUVVNc1VVRkJVU3hIUVVGSExFdEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNTVUZCU1N4RlFVRkZMRXRCUVVrc1EwRkJReXhOUVVGTkxFVkJRVVVzV1VGQldTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPenRKUVVNNVJTeERRVUZETzBsQlJVOHNiVU5CUVdFc1IwRkJja0lzVlVGQmMwSXNTVUZCWjBJc1JVRkJSU3hOUVVGakxFVkJRVVVzVVVGQmRVSXNSVUZCUlN4TlFVRmpPMUZCUXpkR0xFbEJRVTBzVVVGQlVTeEhRVUZaTEVWQlFVVXNRMEZCUXp0UlFVTTNRaXhKUVVGTkxFZEJRVWNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1VVRkJVU3hIUVVGSExGRkJRVkVzUTBGQlF5eEhRVUZITEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRNMFFzU1VGQlRTeE5RVUZOTEVkQlFVY3NUVUZCVFN4RFFVRkRMRTFCUVUwc1NVRkJTU3hEUVVGRExGRkJRVkVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJSWEJGTEdkQ1FVRm5RanRSUVVOb1FpeEhRVUZITEVOQlFVTXNRMEZCYlVJc1ZVRkJSeXhGUVVGSUxGZEJRVWNzUlVGQlNDeHBRa0ZCUnl4RlFVRklMRWxCUVVjN1dVRkJja0lzU1VGQlRTeFJRVUZSTEZsQlFVRTdXVUZEYWtJc1IwRkJSeXhEUVVGRExFTkJRWE5DTEZWQlFVMHNSVUZCVGl4cFFrRkJUU3hGUVVGT0xHOUNRVUZOTEVWQlFVNHNTVUZCVFR0blFrRkJNMElzU1VGQlRTeFhRVUZYTEdWQlFVRTdaMEpCUTNCQ0xFbEJRVTBzVFVGQlNTeEhRVUZITEVOQlFVTXNVVUZCVVN4SFFVRkhMRWRCUVVjc1IwRkJSeXhSUVVGUkxFZEJRVWNzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4WFFVRlhMRWRCUVVjc1IwRkJSeXhIUVVGSExGZEJRVmNzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkZka1lzU1VGQlRTeFhRVUZYTEVkQlFVYzdiMEpCUTJ4Q0xFZEJRVWNzUlVGQlJTeFJRVUZSTzI5Q1FVTmlMRTFCUVUwc1JVRkJSU3hYUVVGWE8ybENRVU53UWl4RFFVRkRPMmRDUVVWR0xGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNiVUpCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUjBGQlJ5eE5RVUZKTEVOQlFVTXNSVUZCUlN4VFFVRlRMRVZCUVVVc1YwRkJWeXhGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdZVUZETVVjN1UwRkRSanRSUVVWRUxFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVWTkxDdENRVUZUTEVkQlFXaENPMUZCUTBVc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVkQlFVY3NhVUpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU4wUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZETEV0QlFVczdXVUZETVVJc1MwRkJTeXhEUVVGRExGTkJRVk1zUlVGQlJTeERRVUZETzFGQlEzQkNMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZOTEc5RFFVRmpMRWRCUVhKQ08xRkJRVUVzYVVKQlYwTTdVVUZXUXl4dFJVRkJiVVU3VVVGRGJrVXNhVVZCUVdsRk8xRkJRMnBGTEcxRlFVRnRSVHRSUVVOdVJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNc1IwRkJSeXhGUVVGRkxFTkJRVU03WjBOQlEyNUNMRXRCUVVzN1dVRkRaQ3hMUVVGTExFTkJRVU1zWTBGQll5eEZRVUZGTEVOQlFVTTdXVUZEZGtJc1YwRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUjBGQlJ6dG5Ra0ZETVVNc1MwRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRha1VzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCVEVRc1IwRkJSeXhEUVVGRExFTkJRV2RDTEZWQlFXRXNSVUZCWWl4TFFVRkJMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRV0lzWTBGQllTeEZRVUZpTEVsQlFXRTdXVUZCTlVJc1NVRkJUU3hMUVVGTExGTkJRVUU3YjBKQlFVd3NTMEZCU3p0VFFVdG1PMGxCUTBnc1EwRkJRenRKUVVWTkxHZERRVUZWTEVkQlFXcENPMUZCUTBVc1NVRkJUU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETzFGQlJXNUNMRWxCUVUwc1kwRkJZeXhIUVVGclFpeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRmFrVXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlV5eExRVUZMTzFsQlEyeERMRXRCUVVzc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF6dFpRVVZ1UWl4elJFRkJjMFE3V1VGRGRFUXNkVWRCUVhWSE8xbEJRM1pITEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlExUXNWMEZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZNc1QwRkJUenR2UWtGRGJrUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJVU3hEUVVGRExHMURRVUY1UWl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZEYWtRc1NVRkJUU3hWUVVGVkxFZEJRVWNzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03ZDBKQlEyNUVMRWxCUVUwc1ZVRkJWU3hIUVVGSExHTkJRV01zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0M1FrRkZNME1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4VlFVRlZMRWxCUVVrc0swSkJRV2xDTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEpRVUZKTEN0Q1FVRnBRaXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenMwUWtGRGFFZ3NhVU5CUVdsRE96UkNRVU5xUXl4TlFVRk5MRU5CUVVNN2QwSkJRMVFzUTBGQlF6dDNRa0ZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZET3pSQ1FVTm1MRlZCUVZVc1EwRkJReXhOUVVGTkxFZEJRVWNzY1VKQlFWa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hGUVVGRkxGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0M1FrRkRla1VzUTBGQlF6dDNRa0ZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenMwUWtGRFRpeGpRVUZqTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1ZVRkJWU3hEUVVGRE8zZENRVU4yUXl4RFFVRkRPM2RDUVVWRUxITkRRVUZ6UXp0M1FrRkRkRU1zU1VGQlRTeHpRa0ZCYzBJc1IwRkJSeXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPM2RDUVVOb1JpeEpRVUZOTEU5QlFVOHNSMEZCUnl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExITkNRVUZ6UWl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8zZENRVU01UkN4TFFVRkxMRU5CUVVNc1YwRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN2QwSkJRelZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1QwRkJUeXhEUVVGRE8zZENRVVV4UWl4eFEwRkJjVU03ZDBKQlEzSkRMRTlCUVU4c1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN2IwSkJRM3BETEVOQlFVTTdaMEpCUTBnc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFRDeERRVUZETzFGQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVTBzSzBKQlFWTXNSMEZCYUVJN1VVRkRSU3hIUVVGSExFTkJRVU1zUTBGQlowSXNWVUZCWVN4RlFVRmlMRXRCUVVFc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQllpeGpRVUZoTEVWQlFXSXNTVUZCWVR0WlFVRTFRaXhKUVVGTkxFdEJRVXNzVTBGQlFUdFpRVU5rTEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRUUVVOdVFqdEpRVU5JTEVOQlFVTTdTVUZGVFN4M1EwRkJhMElzUjBGQmVrSTdVVUZEUlN4SFFVRkhMRU5CUVVNc1EwRkJaMElzVlVGQllTeEZRVUZpTEV0QlFVRXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJZaXhqUVVGaExFVkJRV0lzU1VGQllUdFpRVUUxUWl4SlFVRk5MRXRCUVVzc1UwRkJRVHRaUVVOa0xFdEJRVXNzUTBGQlF5eHJRa0ZCYTBJc1JVRkJSU3hEUVVGRE8xTkJRelZDTzBsQlEwZ3NRMEZCUXp0SlFVVk5MRzlEUVVGakxFZEJRWEpDTzFGQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRlRTeHBRMEZCVnl4SFFVRnNRanRSUVVORkxFbEJRVTBzWlVGQlpTeEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1QwRkJUeXhIUVVGSExFVkJRVVVzUTBGQlF6dG5RMEZGZWtNc1MwRkJTenRaUVVOa0xFdEJRVXNzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXp0WlFVVndRaXhuUkVGQlowUTdXVUZEYUVRc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRWQ3hYUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlV5eFBRVUZQTzI5Q1FVTndSQ3gzUkVGQmQwUTdiMEpCUTNoRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNaVUZCWlN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZET1VJc1pVRkJaU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzI5Q1FVTTVSQ3hEUVVGRE8yOUNRVU5FTEU5QlFVOHNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdaMEpCUXpGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEwd3NRMEZCUXp0UlFVTklMRU5CUVVNN1VVRmlSQ3hIUVVGSExFTkJRVU1zUTBGQlowSXNWVUZCWVN4RlFVRmlMRXRCUVVFc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQllpeGpRVUZoTEVWQlFXSXNTVUZCWVR0WlFVRTFRaXhKUVVGTkxFdEJRVXNzVTBGQlFUdHZRa0ZCVEN4TFFVRkxPMU5CWVdZN1NVRkRTQ3hEUVVGRE8wbEJSVTBzYTBOQlFWa3NSMEZCYmtJN1VVRkRSeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnhDTEdsRFFVRnBRenRaUVVOcVF5eE5RVUZOTEVOQlFVTXNkVUpCUVZrc1EwRkJReXhYUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU42UkN4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5hTEVOQlFVTTdTVUZGVFN4dFJFRkJOa0lzUjBGQmNFTTdVVUZEUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZOTEhORVFVRm5ReXhIUVVGMlF5eFZRVUYzUXl4UFFVRmpPMUZCUTNCRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGRExFVkJRVVVzUlVGQlJTeExRVUZMTEVsQlFVc3NUMEZCUVN4TFFVRkxMRU5CUVVNc1owTkJRV2RETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVRGRExFTkJRVEJETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRiRWNzUTBGQlF6dEpRVVZOTERoRFFVRjNRaXhIUVVFdlFqdFJRVU5GTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUzBGQlN5eEpRVUZMTEU5QlFVRXNTMEZCU3l4RFFVRkRMSGRDUVVGM1FpeEZRVUZGTEVWQlFXaERMRU5CUVdkRExFTkJRVU1zUTBGQlF6dFJRVU51UlN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZOTERKRFFVRnhRaXhIUVVFMVFqdFJRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxPMWxCUTNwRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXh4UWtGQmNVSXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRka1FzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVWTkxESkRRVUZ4UWl4SFFVRTFRaXhWUVVFMlFpeEpRVUZqTzFGQlEzcERMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRVZCUVVVc1JVRkJSU3hMUVVGTExFbEJRVXNzVDBGQlFTeExRVUZMTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFTOUNMRU5CUVN0Q0xFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEYkVZc1EwRkJRenRKUVVWTkxHOURRVUZqTEVkQlFYSkNPMUZCUTBVc2IwTkJRVzlETzFGQlEzQkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRE8xbEJRM0JETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eGpRVUZqTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUXpORExFTkJRVU1zUlVGQlJTeHBRa0ZCVFN4alFVRmpMRmRCUVVVc1EwRkJReXhEUVVGRE8wbEJRemRDTEVOQlFVTTdTVUZGVFN4dlEwRkJZeXhIUVVGeVFqdFJRVU5GTERSQ1FVRTBRanRSUVVNMVFpeE5RVUZOTEVOQlFVTTdXVUZEVEN4UFFVRlBMRVZCUVVVc1JVRkJReXhIUVVGSExFVkJRVVVzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4RlFVRkZMRVZCUVVNN1dVRkRPVUlzVFVGQlRTeEZRVUZGTEVWQlFVVTdXVUZEVml4UFFVRlBMRVZCUVVVc1NVRkJTU3hEUVVGRExFMUJRVTBzU1VGQlNTeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJRenRaUVVNeFJTeE5RVUZOTEVWQlFVVXNUVUZCVFR0WlFVTmtMRXRCUVVzc1JVRkJSU3hMUVVGTE8xTkJRMklzUTBGQlF6dEpRVU5LTEVOQlFVTTdTVUZGVFN4dFEwRkJZU3hIUVVGd1FqdFJRVU5GTERKQ1FVRXlRanRSUVVNelFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlFTeExRVUZMTzFsQlJUVkNMRWxCUVUwc1YwRkJWeXhIUVVGSExFdEJRVXNzUTBGQlF5dzJRa0ZCTmtJc1JVRkJSU3hEUVVGRE8xbEJSVEZFTEUxQlFVMHNiMEpCUTBvc1NVRkJTU3hGUVVGRkxFOUJRVThzUlVGRFlpeEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zU1VGRGVrSXNRMEZCUXl4WFFVRlhMRWRCUVVjN1owSkJRMmhDTEUxQlFVMHNSVUZCUlR0dlFrRkRUaXhOUVVGTkxFVkJRVVVzVjBGQlZ6dHBRa0ZEY0VJN1lVRkRSaXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVU5LTEV0QlFVc3NRMEZCUXl4aFFVRmhMRVZCUVVVc1JVRkRlRUk3VVVGRFNpeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkRTQ3hyUWtGQlF6dEJRVUZFTEVOQlFVTXNRVUYwVFVRc1EwRkJhVU1zWVVGQlN5eEhRWE5OY2tNN1FVRjBUVmtzYTBOQlFWY2lmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB2ZWdhX3V0aWxfMSA9IHJlcXVpcmUoXCJ2ZWdhLXV0aWxcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciB2ZWdhX3NjaGVtYV8xID0gcmVxdWlyZShcIi4uLy4uL3ZlZ2Euc2NoZW1hXCIpO1xudmFyIFNFTEVDVElPTl9PUFMgPSB7XG4gICAgZ2xvYmFsOiAndW5pb24nLCBpbmRlcGVuZGVudDogJ2ludGVyc2VjdCcsXG4gICAgdW5pb246ICd1bmlvbicsIHVuaW9uX290aGVyczogJ3VuaW9uJyxcbiAgICBpbnRlcnNlY3Q6ICdpbnRlcnNlY3QnLCBpbnRlcnNlY3Rfb3RoZXJzOiAnaW50ZXJzZWN0J1xufTtcbmZ1bmN0aW9uIGFzc2VtYmxlU2NhbGUobW9kZWwpIHtcbiAgICByZXR1cm4gdXRpbF8xLnZhbHMobW9kZWwuY29tcG9uZW50LnNjYWxlcykubWFwKGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICAvLyBBcyBzZWxlY3Rpb25zIGFyZSBwYXJzZWQgX2FmdGVyXyBzY2FsZXMsIHdlIGNhbiBvbmx5IHNoaW0gaW4gYSBkb21haW5SYXdcbiAgICAgICAgLy8gaW4gdGhlIG91dHB1dCBWZWdhIGR1cmluZyBhc3NlbWJseS4gRklYTUU6IFRoaXMgc2hvdWxkIGJlIG1vdmVkIHRvXG4gICAgICAgIC8vIHNlbGVjdGlvbi50cywgYnV0IGFueSByZWZlcmVuY2UgdG8gaXQgdGhyb3dzIGFuIGVycm9yLiBQb3NzaWJsZSBjaXJjdWxhciBkZXBlbmRlbmN5P1xuICAgICAgICB2YXIgcmF3ID0gc2NhbGUuZG9tYWluUmF3O1xuICAgICAgICBpZiAocmF3ICYmIHJhdy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJhdy5maWVsZCA9IHJhdy5maWVsZCB8fCBudWxsO1xuICAgICAgICAgICAgcmF3LmVuY29kaW5nID0gcmF3LmVuY29kaW5nIHx8IG51bGw7XG4gICAgICAgICAgICB2YXIgc2VsTmFtZSA9IHJhdy5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgc2VsQ21wdCA9IG1vZGVsLmNvbXBvbmVudC5zZWxlY3Rpb24gJiYgbW9kZWwuY29tcG9uZW50LnNlbGVjdGlvbltzZWxOYW1lXTtcbiAgICAgICAgICAgIGlmIChzZWxDbXB0KSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oJ1VzZSBcImJpbmRcIjogXCJzY2FsZXNcIiB0byBzZXR1cCBhIGJpbmRpbmcgZm9yIHNjYWxlcyBhbmQgc2VsZWN0aW9ucyB3aXRoaW4gdGhlIHNhbWUgdmlldy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbENtcHQgPSBtb2RlbC5nZXRDb21wb25lbnQoJ3NlbGVjdGlvbicsIHNlbE5hbWUpO1xuICAgICAgICAgICAgICAgIHNjYWxlLmRvbWFpblJhdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiAoc2VsQ21wdC50eXBlID09PSAnaW50ZXJ2YWwnID8gJ3ZsSW50ZXJ2YWxEb21haW4nIDogJ3ZsUG9pbnREb21haW4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIoXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUoc2VsQ21wdC5uYW1lICsgJ19zdG9yZScpICsgXCIsIFwiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKHJhdy5lbmNvZGluZykgKyBcIiwgXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUocmF3LmZpZWxkKSArIFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHV0aWxfMS5zdHJpbmdWYWx1ZShTRUxFQ1RJT05fT1BTW3NlbENtcHQucmVzb2x2ZV0pICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb3JyZWN0IHJlZmVyZW5jZXMgdG8gZGF0YVxuICAgICAgICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuICAgICAgICBpZiAodmVnYV9zY2hlbWFfMS5pc0RhdGFSZWZEb21haW4oZG9tYWluKSB8fCB2ZWdhX3NjaGVtYV8xLmlzRmllbGRSZWZVbmlvbkRvbWFpbihkb21haW4pKSB7XG4gICAgICAgICAgICBkb21haW4uZGF0YSA9IG1vZGVsLmxvb2t1cERhdGFTb3VyY2UoZG9tYWluLmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmVW5pb25lZERvbWFpbihkb21haW4pKSB7XG4gICAgICAgICAgICBkb21haW4uZmllbGRzID0gZG9tYWluLmZpZWxkcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZiwgeyBkYXRhOiBtb2RlbC5sb29rdXBEYXRhU291cmNlKGYuZGF0YSkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZWdhX3NjaGVtYV8xLmlzU2lnbmFsUmVmRG9tYWluKGRvbWFpbikgfHwgdmVnYV91dGlsXzEuaXNBcnJheShkb21haW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGUgZG9tYWluJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuYXNzZW1ibGVTY2FsZSA9IGFzc2VtYmxlU2NhbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZWE56WlcxaWJHVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl6WTJGc1pTOWhjM05sYldKc1pTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDFRMEZCYTBNN1FVRkRiRU1zSzBKQlFXbERPMEZCUldwRExHMURRVUUyUXp0QlFVTTNReXhwUkVGQkswZzdRVUZITDBnc1NVRkJUU3hoUVVGaExFZEJRVWM3U1VGRGNFSXNUVUZCVFN4RlFVRkZMRTlCUVU4c1JVRkJSU3hYUVVGWExFVkJRVVVzVjBGQlZ6dEpRVU42UXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxGbEJRVmtzUlVGQlJTeFBRVUZQTzBsQlEzSkRMRk5CUVZNc1JVRkJSU3hYUVVGWExFVkJRVVVzWjBKQlFXZENMRVZCUVVVc1YwRkJWenREUVVOMFJDeERRVUZETzBGQlJVWXNkVUpCUVRoQ0xFdEJRVms3U1VGRGRFTXNUVUZCVFN4RFFVRkRMRmRCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGQkxFdEJRVXM3VVVGRE0wTXNNa1ZCUVRKRk8xRkJRek5GTEhGRlFVRnhSVHRSUVVOeVJTeDFSa0ZCZFVZN1VVRkRka1lzU1VGQlRTeEhRVUZITEVkQlFVY3NTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJRenRSUVVNMVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1IwRkJSeXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtJc1IwRkJSeXhEUVVGRExFdEJRVXNzUjBGQlJ5eEhRVUZITEVOQlFVTXNTMEZCU3l4SlFVRkpMRWxCUVVrc1EwRkJRenRaUVVNNVFpeEhRVUZITEVOQlFVTXNVVUZCVVN4SFFVRkhMRWRCUVVjc1EwRkJReXhSUVVGUkxFbEJRVWtzU1VGQlNTeERRVUZETzFsQlEzQkRMRWxCUVUwc1QwRkJUeXhIUVVGSExFZEJRVWNzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZET1VJc1NVRkJTU3hQUVVGUExFZEJRVWNzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4VFFVRlRMRWxCUVVrc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRPVVVzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRFdpeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMSGxHUVVGNVJpeERRVUZETEVOQlFVTTdXVUZEZEVjc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MRTlCUVU4c1IwRkJSeXhMUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEZkQlFWY3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRuUWtGRGJrUXNTMEZCU3l4RFFVRkRMRk5CUVZNc1IwRkJSenR2UWtGRGFFSXNUVUZCVFN4RlFVRkZMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUzBGQlN5eFZRVUZWTEVkQlFVY3NhMEpCUVd0Q0xFZEJRVWNzWlVGQlpTeERRVUZETzNsQ1FVTTFSU3hOUVVGSkxHdENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhSUVVGUkxFTkJRVU1zVlVGQlN5eHJRa0ZCVnl4RFFVRkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVU1zVlVGQlN5eHJRa0ZCVnl4RFFVRkRMRWRCUVVjc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlNTeERRVUZCTzNsQ1FVTnNSeXhyUWtGQlZ5eERRVUZETEdGQlFXRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVFVGQlJ5eERRVUZCTzJsQ1FVTnNSQ3hEUVVGRE8xbEJRMG9zUTBGQlF6dFJRVU5JTEVOQlFVTTdVVUZGUkN3MlFrRkJOa0k3VVVGRE4wSXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU0xUWl4RlFVRkZMRU5CUVVNc1EwRkJReXcyUWtGQlpTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRzFEUVVGeFFpeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNM1JDeE5RVUZOTEVOQlFVTXNTVUZCU1N4SFFVRkhMRXRCUVVzc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRGJFUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVObUxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2IwTkJRWE5DTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUXl4RFFVRlpPMmRDUVVNM1F5eE5RVUZOTEhOQ1FVTkVMRU5CUVVNc1NVRkRTaXhKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZEY0VNN1dVRkRTaXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5JTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRaaXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMQ3RDUVVGcFFpeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRzFDUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNoRUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZEWml4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSE5DUVVGelFpeERRVUZETEVOQlFVTTdVVUZETVVNc1EwRkJRenRKUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlExQXNRMEZCUXp0QlFURkRSQ3h6UTBFd1EwTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciBhZ2dyZWdhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9hZ2dyZWdhdGVcIik7XG52YXIgYmluXzEgPSByZXF1aXJlKFwiLi4vLi4vYmluXCIpO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0ZXRpbWVcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciBzb3J0XzEgPSByZXF1aXJlKFwiLi4vLi4vc29ydFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgdmVnYV9zY2hlbWFfMSA9IHJlcXVpcmUoXCIuLi8uLi92ZWdhLnNjaGVtYVwiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbmZ1bmN0aW9uIGluaXREb21haW4oZG9tYWluLCBmaWVsZERlZiwgc2NhbGUsIHNjYWxlQ29uZmlnKSB7XG4gICAgaWYgKGRvbWFpbiA9PT0gJ3VuYWdncmVnYXRlZCcpIHtcbiAgICAgICAgdmFyIF9hID0gY2FuVXNlVW5hZ2dyZWdhdGVkRG9tYWluKGZpZWxkRGVmLCBzY2FsZSksIHZhbGlkID0gX2EudmFsaWQsIHJlYXNvbiA9IF9hLnJlYXNvbjtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgbG9nLndhcm4ocmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tYWluID09PSB1bmRlZmluZWQgJiYgc2NhbGVDb25maWcudXNlVW5hZ2dyZWdhdGVkRG9tYWluKSB7XG4gICAgICAgIC8vIEFwcGx5IGNvbmZpZyBpZiBkb21haW4gaXMgbm90IHNwZWNpZmllZC5cbiAgICAgICAgdmFyIHZhbGlkID0gY2FuVXNlVW5hZ2dyZWdhdGVkRG9tYWluKGZpZWxkRGVmLCBzY2FsZSkudmFsaWQ7XG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuICd1bmFnZ3JlZ2F0ZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb21haW47XG59XG5leHBvcnRzLmluaXREb21haW4gPSBpbml0RG9tYWluO1xuZnVuY3Rpb24gcGFyc2VEb21haW4obW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgc2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsKTtcbiAgICAvLyBJZiBjaGFubmVsIGlzIGVpdGhlciBYIG9yIFkgdGhlbiB1bmlvbiB0aGVtIHdpdGggWDIgJiBZMiBpZiB0aGV5IGV4aXN0XG4gICAgaWYgKGNoYW5uZWwgPT09ICd4JyAmJiBtb2RlbC5jaGFubmVsSGFzRmllbGQoJ3gyJykpIHtcbiAgICAgICAgaWYgKG1vZGVsLmNoYW5uZWxIYXNGaWVsZCgneCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5pb25Eb21haW5zKHBhcnNlU2luZ2xlQ2hhbm5lbERvbWFpbihzY2FsZSwgbW9kZWwsICd4JyksIHBhcnNlU2luZ2xlQ2hhbm5lbERvbWFpbihzY2FsZSwgbW9kZWwsICd4MicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVNpbmdsZUNoYW5uZWxEb21haW4oc2NhbGUsIG1vZGVsLCAneDInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGFubmVsID09PSAneScgJiYgbW9kZWwuY2hhbm5lbEhhc0ZpZWxkKCd5MicpKSB7XG4gICAgICAgIGlmIChtb2RlbC5jaGFubmVsSGFzRmllbGQoJ3knKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW9uRG9tYWlucyhwYXJzZVNpbmdsZUNoYW5uZWxEb21haW4oc2NhbGUsIG1vZGVsLCAneScpLCBwYXJzZVNpbmdsZUNoYW5uZWxEb21haW4oc2NhbGUsIG1vZGVsLCAneTInKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTaW5nbGVDaGFubmVsRG9tYWluKHNjYWxlLCBtb2RlbCwgJ3kyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlU2luZ2xlQ2hhbm5lbERvbWFpbihzY2FsZSwgbW9kZWwsIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5wYXJzZURvbWFpbiA9IHBhcnNlRG9tYWluO1xuZnVuY3Rpb24gcGFyc2VTaW5nbGVDaGFubmVsRG9tYWluKHNjYWxlLCBtb2RlbCwgY2hhbm5lbCkge1xuICAgIHZhciBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgIGlmIChzY2FsZS5kb21haW4gJiYgc2NhbGUuZG9tYWluICE9PSAndW5hZ2dyZWdhdGVkJyAmJiAhc2NhbGVfMS5pc1NlbGVjdGlvbkRvbWFpbihzY2FsZS5kb21haW4pKSB7XG4gICAgICAgIGlmIChkYXRldGltZV8xLmlzRGF0ZVRpbWUoc2NhbGUuZG9tYWluWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbi5tYXAoZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGV0aW1lXzEudGltZXN0YW1wKGR0LCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZS5kb21haW47XG4gICAgfVxuICAgIHZhciBzdGFjayA9IG1vZGVsLnN0YWNrO1xuICAgIGlmIChzdGFjayAmJiBjaGFubmVsID09PSBzdGFjay5maWVsZENoYW5uZWwpIHtcbiAgICAgICAgaWYgKHN0YWNrLm9mZnNldCA9PT0gJ25vcm1hbGl6ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG1vZGVsLnJlcXVlc3REYXRhTmFtZShkYXRhXzEuTUFJTiksXG4gICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICBtb2RlbC5maWVsZChjaGFubmVsLCB7IHN1ZmZpeDogJ3N0YXJ0JyB9KSxcbiAgICAgICAgICAgICAgICBtb2RlbC5maWVsZChjaGFubmVsLCB7IHN1ZmZpeDogJ2VuZCcgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHNvcnQgPSBkb21haW5Tb3J0KG1vZGVsLCBjaGFubmVsLCBzY2FsZS50eXBlKTtcbiAgICBpZiAoc2NhbGUuZG9tYWluID09PSAndW5hZ2dyZWdhdGVkJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbW9kZWwucmVxdWVzdERhdGFOYW1lKGRhdGFfMS5NQUlOKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkKGNoYW5uZWwsIHsgYWdncmVnYXRlOiAnbWluJyB9KSxcbiAgICAgICAgICAgICAgICBtb2RlbC5maWVsZChjaGFubmVsLCB7IGFnZ3JlZ2F0ZTogJ21heCcgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgIGlmIChzY2FsZV8xLmlzQmluU2NhbGUoc2NhbGUudHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBzaWduYWwgPSBtb2RlbC5nZXROYW1lKGJpbl8xLmJpblRvU3RyaW5nKGZpZWxkRGVmLmJpbikgKyBcIl9cIiArIGZpZWxkRGVmLmZpZWxkICsgXCJfYmluc1wiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNpZ25hbDogXCJzZXF1ZW5jZShcIiArIHNpZ25hbCArIFwiLnN0YXJ0LCBcIiArIHNpZ25hbCArIFwiLnN0b3AgKyBcIiArIHNpZ25hbCArIFwiLnN0ZXAsIFwiICsgc2lnbmFsICsgXCIuc3RlcClcIiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHNjYWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAvLyBvcmRpbmFsIGJpbiBzY2FsZSB0YWtlcyBkb21haW4gZnJvbSBiaW5fcmFuZ2UsIG9yZGVyZWQgYnkgYmluX3N0YXJ0XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3IgYm90aCBheGlzLWJhc2VkIHNjYWxlICh4LCB5LCBjb2x1bW4sIGFuZCByb3cpIGFuZCBsZWdlbmQtYmFzZWQgc2NhbGUgKG90aGVyIGNoYW5uZWxzKS5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbW9kZWwucmVxdWVzdERhdGFOYW1lKGRhdGFfMS5NQUlOKSxcbiAgICAgICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoY2hhbm5lbCwgeyBiaW5TdWZmaXg6ICdyYW5nZScgfSksXG4gICAgICAgICAgICAgICAgc29ydDoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoY2hhbm5lbCwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSksXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnbWluJyAvLyBtaW4gb3IgbWF4IGRvZXNuJ3QgbWF0dGVyIHNpbmNlIHNhbWUgX3JhbmdlIHdvdWxkIGhhdmUgdGhlIHNhbWUgX3N0YXJ0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAneCcgfHwgY2hhbm5lbCA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgLy8gWC9ZIHBvc2l0aW9uIGhhdmUgdG8gaW5jbHVkZSBzdGFydCBhbmQgZW5kIGZvciBub24tb3JkaW5hbCBzY2FsZVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1vZGVsLnJlcXVlc3REYXRhTmFtZShkYXRhXzEuTUFJTiksXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZmllbGQoY2hhbm5lbCwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5maWVsZChjaGFubmVsLCB7IGJpblN1ZmZpeDogJ2VuZCcgfSlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB1c2UgYmluX21pZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1vZGVsLnJlcXVlc3REYXRhTmFtZShkYXRhXzEuTUFJTiksXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsLCB7IGJpblN1ZmZpeDogJ3N0YXJ0JyB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc29ydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gSWYgc29ydCBieSBhZ2dyZWdhdGlvbiBvZiBhIHNwZWNpZmllZCBzb3J0IGZpZWxkLCB3ZSBuZWVkIHRvIHVzZSBSQVcgdGFibGUsXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gYWdncmVnYXRlIHZhbHVlcyBmb3IgdGhlIHNjYWxlIGluZGVwZW5kZW50bHkgZnJvbSB0aGUgbWFpbiBhZ2dyZWdhdGlvbi5cbiAgICAgICAgICAgIGRhdGE6IHV0aWwuaXNCb29sZWFuKHNvcnQpID8gbW9kZWwucmVxdWVzdERhdGFOYW1lKGRhdGFfMS5NQUlOKSA6IG1vZGVsLnJlcXVlc3REYXRhTmFtZShkYXRhXzEuUkFXKSxcbiAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsKSxcbiAgICAgICAgICAgIHNvcnQ6IHNvcnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBtb2RlbC5yZXF1ZXN0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgZmllbGQ6IG1vZGVsLmZpZWxkKGNoYW5uZWwpXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tYWluU29ydChtb2RlbCwgY2hhbm5lbCwgc2NhbGVUeXBlKSB7XG4gICAgaWYgKCFzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHNjYWxlVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHNvcnQgPSBtb2RlbC5zb3J0KGNoYW5uZWwpO1xuICAgIC8vIFNvcnRlZCBiYXNlZCBvbiBhbiBhZ2dyZWdhdGUgY2FsY3VsYXRpb24gb3ZlciBhIHNwZWNpZmllZCBzb3J0IGZpZWxkIChvbmx5IGZvciBvcmRpbmFsIHNjYWxlKVxuICAgIGlmIChzb3J0XzEuaXNTb3J0RmllbGQoc29ydCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wOiBzb3J0Lm9wLFxuICAgICAgICAgICAgZmllbGQ6IHNvcnQuZmllbGRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHV0aWwuY29udGFpbnMoWydhc2NlbmRpbmcnLCAnZGVzY2VuZGluZycsIHVuZGVmaW5lZCAvKiBkZWZhdWx0ID1hc2NlbmRpbmcqL10sIHNvcnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBzb3J0ID09PSAnbm9uZSdcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5kb21haW5Tb3J0ID0gZG9tYWluU29ydDtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgc2NhbGUgY2FuIHVzZSB1bmFnZ3JlZ2F0ZWQgZG9tYWluLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdG9ucyBhcHBsaWVzOlxuICogMS4gYHNjYWxlLmRvbWFpbmAgaXMgYHVuYWdncmVnYXRlZGBcbiAqIDIuIEFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIGlzIG5vdCBgY291bnRgIG9yIGBzdW1gXG4gKiAzLiBUaGUgc2NhbGUgaXMgcXVhbnRpdGF0aXZlIG9yIHRpbWUgc2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGNhblVzZVVuYWdncmVnYXRlZERvbWFpbihmaWVsZERlZiwgc2NhbGVUeXBlKSB7XG4gICAgaWYgKCFmaWVsZERlZi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogbG9nLm1lc3NhZ2UudW5hZ2dyZWdhdGVEb21haW5IYXNOb0VmZmVjdEZvclJhd0ZpZWxkKGZpZWxkRGVmKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWFnZ3JlZ2F0ZV8xLlNIQVJFRF9ET01BSU5fT1BfSU5ERVhbZmllbGREZWYuYWdncmVnYXRlXSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBsb2cubWVzc2FnZS51bmFnZ3JlZ2F0ZURvbWFpbldpdGhOb25TaGFyZWREb21haW5PcChmaWVsZERlZi5hZ2dyZWdhdGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChmaWVsZERlZi50eXBlID09PSAncXVhbnRpdGF0aXZlJykge1xuICAgICAgICBpZiAoc2NhbGVUeXBlID09PSAnbG9nJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBsb2cubWVzc2FnZS51bmFnZ3JlZ2F0ZWREb21haW5XaXRoTG9nU2NhbGUoZmllbGREZWYpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG59XG5leHBvcnRzLmNhblVzZVVuYWdncmVnYXRlZERvbWFpbiA9IGNhblVzZVVuYWdncmVnYXRlZERvbWFpbjtcbi8qKlxuICogQ29udmVydCB0aGUgZG9tYWluIHRvIGFuIGFycmF5IG9mIGRhdGEgcmVmcyBvciBhbiBhcnJheSBvZiB2YWx1ZXMuIEFsc28sIHRocm93XG4gKiBhd2F5IHNvcnRpbmcgaW5mb3JtYXRpb24gc2luY2Ugd2UgYWx3YXlzIHNvcnQgdGhlIGRvbWFpbiB3aGVuIHdlIHVuaW9uIHR3byBkb21haW5zLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEb21haW4oZG9tYWluKSB7XG4gICAgaWYgKHV0aWwuaXNBcnJheShkb21haW4pKSB7XG4gICAgICAgIHJldHVybiBbZG9tYWluXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmVnYV9zY2hlbWFfMS5pc0RhdGFSZWZEb21haW4oZG9tYWluKSkge1xuICAgICAgICBkZWxldGUgZG9tYWluLnNvcnQ7XG4gICAgICAgIHJldHVybiBbZG9tYWluXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmVnYV9zY2hlbWFfMS5pc0ZpZWxkUmVmVW5pb25Eb21haW4oZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gZG9tYWluLmZpZWxkcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogZG9tYWluLmRhdGEsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ZWdhX3NjaGVtYV8xLmlzRGF0YVJlZlVuaW9uZWREb21haW4oZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gZG9tYWluLmZpZWxkcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzQXJyYXkoZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogZC5kYXRhLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBkLmZpZWxkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuSU5WQUlEX0RPTUFJTik7XG59XG4vKipcbiAqIFVuaW9uIHR3byBkYXRhIGRvbWFpbnMuIEEgdW5pb25lZCBkb21haW4gaXMgYWx3YXlzIHNvcnRlZC5cbiAqL1xuZnVuY3Rpb24gdW5pb25Eb21haW5zKGRvbWFpbjEsIGRvbWFpbjIpIHtcbiAgICBpZiAodmVnYV9zY2hlbWFfMS5pc1NpZ25hbFJlZkRvbWFpbihkb21haW4xKSB8fCB2ZWdhX3NjaGVtYV8xLmlzU2lnbmFsUmVmRG9tYWluKGRvbWFpbjIpKSB7XG4gICAgICAgIGlmICghdmVnYV9zY2hlbWFfMS5pc1NpZ25hbFJlZkRvbWFpbihkb21haW4xKSB8fCAhdmVnYV9zY2hlbWFfMS5pc1NpZ25hbFJlZkRvbWFpbihkb21haW4yKSB8fCBkb21haW4xLnNpZ25hbCAhPT0gZG9tYWluMi5zaWduYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5VTkFCTEVfVE9fTUVSR0VfRE9NQUlOUyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjE7XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkRG9tYWluMSA9IG5vcm1hbGl6ZURvbWFpbihkb21haW4xKTtcbiAgICB2YXIgbm9ybWFsaXplZERvbWFpbjIgPSBub3JtYWxpemVEb21haW4oZG9tYWluMik7XG4gICAgdmFyIGRvbWFpbnMgPSBub3JtYWxpemVkRG9tYWluMS5jb25jYXQobm9ybWFsaXplZERvbWFpbjIpO1xuICAgIGRvbWFpbnMgPSB1dGlsLnVuaXF1ZShkb21haW5zLCB1dGlsLmhhc2gpO1xuICAgIGlmIChkb21haW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGFsbERhdGEgPSBkb21haW5zLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmRG9tYWluKGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHV0aWwudW5pcXVlKGFsbERhdGEsIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KS5sZW5ndGggPT09IDEgJiYgYWxsRGF0YVswXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhbGxEYXRhWzBdLFxuICAgICAgICAgICAgICAgIGZpZWxkczogZG9tYWlucy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZmllbGQ7IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZpZWxkczogZG9tYWlucywgc29ydDogdHJ1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbnNbMF07XG4gICAgfVxufVxuZXhwb3J0cy51bmlvbkRvbWFpbnMgPSB1bmlvbkRvbWFpbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laRzl0WVdsdUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMk5oYkdVdlpHOXRZV2x1TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzSzBKQlFXbERPMEZCUldwRExEWkRRVUYxUkR0QlFVTjJSQ3hwUTBGQmMwTTdRVUZGZEVNc01rTkJRU3RFTzBGQlJTOUVMSEZEUVVGdlNEdEJRVU53U0N4dFEwRkJkVU03UVVGRGRrTXNhVU5CUVcxRE8wRkJRMjVETEdsRVFWVXlRanRCUVVVelFpeHRRMEZCY1VNN1FVRkpja01zYjBKQlFUSkNMRTFCUVdNc1JVRkJSU3hSUVVFd1FpeEZRVUZGTEV0QlFXZENMRVZCUVVVc1YwRkJkMEk3U1VGREwwY3NSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVJc1NVRkJRU3c0UTBGQk1rUXNSVUZCTVVRc1owSkJRVXNzUlVGQlJTeHJRa0ZCVFN4RFFVRTRRenRSUVVOc1JTeEZRVUZGTEVOQlFVRXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFZpeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJRMnBDTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1VVRkRia0lzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeExRVUZMTEZOQlFWTXNTVUZCU1N4WFFVRlhMRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKRkxESkRRVUV5UXp0UlFVTndReXhKUVVGQkxIVkVRVUZMTEVOQlFUaERPMUZCUXpGRUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRWaXhOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETzFGQlEzaENMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXp0QlFVTm9RaXhEUVVGRE8wRkJhRUpFTEdkRFFXZENRenRCUVVkRUxIRkNRVUUwUWl4TFFVRm5RaXhGUVVGRkxFOUJRV2RDTzBsQlF6VkVMRWxCUVUwc1MwRkJTeXhIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkZia01zZVVWQlFYbEZPMGxCUTNwRkxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4SFFVRkhMRWxCUVVrc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRia1FzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETDBJc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXhMUVVGTExFVkJRVVVzUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RlFVRkZMSGRDUVVGM1FpeERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkxMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5xU0N4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOMFJDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NSMEZCUnl4SlFVRkpMRXRCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpGRUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF5OUNMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUlVGQlJTeEhRVUZITEVOQlFVTXNSVUZCUlN4M1FrRkJkMElzUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrZ3NRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzVFVGQlRTeERRVUZETEhkQ1FVRjNRaXhEUVVGRExFdEJRVXNzUlVGQlJTeExRVUZMTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRkRVFzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc2QwSkJRWGRDTEVOQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEJRVU42UkN4RFFVRkRPMEZCYkVKRUxHdERRV3RDUXp0QlFVVkVMR3REUVVGclF5eExRVUZaTEVWQlFVVXNTMEZCWjBJc1JVRkJSU3hQUVVGbE8wbEJReTlGTEVsQlFVMHNVVUZCVVN4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZGZWtNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hMUVVGTExHTkJRV01zU1VGQlNTeERRVUZETEhsQ1FVRnBRaXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRlRVlzUlVGQlJTeERRVUZETEVOQlFVTXNjVUpCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhETEUxQlFVMHNRMEZCUlN4TFFVRkxMRU5CUVVNc1RVRkJjVUlzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUXl4RlFVRkZPMmRDUVVONlF5eE5RVUZOTEVOQlFVTXNiMEpCUVZNc1EwRkJReXhGUVVGRkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdXVUZETjBJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFRDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGRFSXNRMEZCUXp0SlFVVkVMRWxCUVUwc1MwRkJTeXhIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTTdTVUZETVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEU5QlFVOHNTMEZCU3l4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0xUXl4RlFVRkZMRU5CUVVFc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeExRVUZMTEZkQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEVOQlFVTTdVVUZEUkN4TlFVRk5MRU5CUVVNN1dVRkRUQ3hKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4WFFVRkpMRU5CUVVNN1dVRkRha01zVFVGQlRTeEZRVUZGTzJkQ1FVTk9MRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eEZRVUZGTEVWQlFVTXNUVUZCVFN4RlFVRkZMRTlCUVU4c1JVRkJReXhEUVVGRE8yZENRVU4yUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVNc1EwRkJRenRoUVVOMFF6dFRRVU5HTEVOQlFVTTdTVUZEU2l4RFFVRkRPMGxCUlVRc1NVRkJUU3hKUVVGSkxFZEJRVWNzVlVGQlZTeERRVUZETEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlJYQkVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEV0QlFVc3NZMEZCWXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOd1F5eE5RVUZOTEVOQlFVTTdXVUZEVEN4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eFhRVUZKTEVOQlFVTTdXVUZEYWtNc1RVRkJUU3hGUVVGRk8yZENRVU5PTEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxFVkJRVU1zVTBGQlV5eEZRVUZGTEV0QlFVc3NSVUZCUXl4RFFVRkRPMmRDUVVONFF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeExRVUZMTEVWQlFVTXNRMEZCUXp0aFFVTjZRenRUUVVOR0xFTkJRVU03U1VGRFNpeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNoQ0xFVkJRVVVzUTBGQlF5eERRVUZETEd0Q1FVRlZMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhKUVVGTkxFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkpMR2xDUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4VFFVRkpMRkZCUVZFc1EwRkJReXhMUVVGTExGVkJRVThzUTBGQlF5eERRVUZETzFsQlEzQkdMRTFCUVUwc1EwRkJReXhGUVVGRExFMUJRVTBzUlVGQlJTeGpRVUZaTEUxQlFVMHNaMEpCUVZjc1RVRkJUU3huUWtGQlZ5eE5RVUZOTEdWQlFWVXNUVUZCVFN4WFFVRlJMRVZCUVVNc1EwRkJRenRSUVVOb1J5eERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc2VVSkJRV2xDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUXl4elJVRkJjMFU3V1VGRGRFVXNORWRCUVRSSE8xbEJRelZITEUxQlFVMHNRMEZCUXp0blFrRkRUQ3hKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4WFFVRkpMRU5CUVVNN1owSkJRMnBETEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZETEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJRenRuUWtGRGFrUXNTVUZCU1N4RlFVRkZPMjlDUVVOS0xFdEJRVXNzUlVGQlJTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeFBRVUZQTEVWQlFVTXNRMEZCUXp0dlFrRkRha1FzUlVGQlJTeEZRVUZGTEV0QlFVc3NRMEZCUXl4NVJVRkJlVVU3YVVKQlEzQkdPMkZCUTBZc1EwRkJRenRSUVVOS0xFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUzBGQlN5eEhRVUZITEVsQlFVa3NUMEZCVHl4TFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzWkRMRzFGUVVGdFJUdG5Ra0ZEYmtVc1RVRkJUU3hEUVVGRE8yOUNRVU5NTEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1pVRkJaU3hEUVVGRExGZEJRVWtzUTBGQlF6dHZRa0ZEYWtNc1RVRkJUU3hGUVVGRk8zZENRVU5PTEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxFVkJRVU1zVTBGQlV5eEZRVUZGTEU5QlFVOHNSVUZCUXl4RFFVRkRPM2RDUVVNeFF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeExRVUZMTEVWQlFVTXNRMEZCUXp0eFFrRkRla003YVVKQlEwWXNRMEZCUXp0WlFVTktMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEVGl4dlFrRkJiMEk3WjBKQlEzQkNMRTFCUVUwc1EwRkJRenR2UWtGRFRDeEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhYUVVGSkxFTkJRVU03YjBKQlEycERMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNSVUZCUlN4RlFVRkRMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF6dHBRa0ZEYkVRc1EwRkJRenRaUVVOS0xFTkJRVU03VVVGRFNDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUldoQ0xFMUJRVTBzUTBGQlF6dFpRVU5NTERoRlFVRTRSVHRaUVVNNVJTeHZSa0ZCYjBZN1dVRkRjRVlzU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4WFFVRkpMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEZWQlFVY3NRMEZCUXp0WlFVTnlSaXhMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNN1dVRkRNMElzU1VGQlNTeEZRVUZGTEVsQlFVazdVMEZEV0N4RFFVRkRPMGxCUTBvc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNUVUZCVFN4RFFVRkRPMWxCUTB3c1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eGxRVUZsTEVOQlFVTXNWMEZCU1N4RFFVRkRPMWxCUTJwRExFdEJRVXNzUlVGQlJTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJRenRUUVVNMVFpeERRVUZETzBsQlEwb3NRMEZCUXp0QlFVTklMRU5CUVVNN1FVRkhSQ3h2UWtGQk1rSXNTMEZCWjBJc1JVRkJSU3hQUVVGblFpeEZRVUZGTEZOQlFXOUNPMGxCUTJwR0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNlVUpCUVdsQ0xFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJ4RExFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZEYmtJc1EwRkJRenRKUVVWRUxFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRmFrTXNaMGRCUVdkSE8wbEJRMmhITEVWQlFVVXNRMEZCUXl4RFFVRkRMR3RDUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFMUJRVTBzUTBGQlF6dFpRVU5NTEVWQlFVVXNSVUZCUlN4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVOWUxFdEJRVXNzUlVGQlJTeEpRVUZKTEVOQlFVTXNTMEZCU3p0VFFVTnNRaXhEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNXVUZCV1N4RlFVRkZMRk5CUVZNc1EwRkJReXgxUWtGQmRVSXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40Uml4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZFTEd0Q1FVRnJRanRKUVVOc1FpeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMEZCUTI1Q0xFTkJRVU03UVVGeVFrUXNaME5CY1VKRE8wRkJTVVE3T3pzN096dEhRVTFITzBGQlEwZ3NhME5CUVhsRExGRkJRVEJDTEVWQlFVVXNVMEZCYjBJN1NVRkRka1lzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40UWl4TlFVRk5MRU5CUVVNN1dVRkRUQ3hMUVVGTExFVkJRVVVzUzBGQlN6dFpRVU5hTEUxQlFVMHNSVUZCUlN4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExIVkRRVUYxUXl4RFFVRkRMRkZCUVZFc1EwRkJRenRUUVVOMFJTeERRVUZETzBsQlEwb3NRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zYTBOQlFYTkNMRU5CUVVNc1VVRkJVU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm9SQ3hOUVVGTkxFTkJRVU03V1VGRFRDeExRVUZMTEVWQlFVVXNTMEZCU3p0WlFVTmFMRTFCUVUwc1JVRkJSU3hIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEhORFFVRnpReXhEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVOQlFVTTdVMEZETDBVc1EwRkJRenRKUVVOS0xFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hMUVVGTExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eExRVUZMTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRlRUlzVFVGQlRTeERRVUZETzJkQ1FVTk1MRXRCUVVzc1JVRkJSU3hMUVVGTE8yZENRVU5hTEUxQlFVMHNSVUZCUlN4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExEaENRVUU0UWl4RFFVRkRMRkZCUVZFc1EwRkJRenRoUVVNM1JDeERRVUZETzFGQlEwb3NRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNTVUZCU1N4RlFVRkRMRU5CUVVNN1FVRkRka0lzUTBGQlF6dEJRWHBDUkN3MFJFRjVRa003UVVGVFJEczdPMGRCUjBjN1FVRkRTQ3g1UWtGQmVVSXNUVUZCZFVJN1NVRkRPVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZWtJc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl3MlFrRkJaU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVReXhQUVVGUExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEYmtJc1RVRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYkVJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVRXNRMEZCUXl4dFEwRkJjVUlzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRlRU1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVUVzUTBGQlF6dFpRVU40UWl4TlFVRk5MRU5CUVVNN1owSkJRMHdzU1VGQlNTeEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpPMmRDUVVOcVFpeExRVUZMTEVWQlFVVXNRMEZCUXp0aFFVTlVMRU5CUVVNN1VVRkRTaXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zYjBOQlFYTkNMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6RkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkJMRU5CUVVNN1dVRkRlRUlzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNCQ0xFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRE8yZENRVU5NTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTVHRuUWtGRFdpeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzN1lVRkRaaXhEUVVGRE8xRkJRMG9zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVEN4RFFVRkRPMGxCUTBRc2NVUkJRWEZFTzBsQlEzSkVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRCUVVNM1F5eERRVUZETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3h6UWtGQk5rSXNUMEZCYVVJc1JVRkJSU3hQUVVGcFFqdEpRVU12UkN4RlFVRkZMRU5CUVVNc1EwRkJReXdyUWtGQmFVSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3dyUWtGQmFVSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE4wUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXdyUWtGQmFVSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExDdENRVUZwUWl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFOUJRVThzUTBGQlF5eE5RVUZOTEV0QlFVc3NUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFY3NUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEhWQ1FVRjFRaXhEUVVGRExFTkJRVU03VVVGRGRrUXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRGFrSXNRMEZCUXp0SlFVVkVMRWxCUVUwc2FVSkJRV2xDTEVkQlFVY3NaVUZCWlN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRMjVFTEVsQlFVMHNhVUpCUVdsQ0xFZEJRVWNzWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUlc1RUxFbEJRVWtzVDBGQlR5eEhRVUZITEdsQ1FVRnBRaXhEUVVGRExFMUJRVTBzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8wbEJRekZFTEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkZNVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzWkNMRWxCUVUwc1QwRkJUeXhIUVVGSExFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRPMWxCUXpOQ0xFVkJRVVVzUTBGQlF5eERRVUZETERaQ1FVRmxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjJRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTm9RaXhEUVVGRE8xbEJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0UlFVTmtMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4RFFVRkRMRVZCUVVRc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeExRVUZMTEVOQlFVTXNTVUZCU1N4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnlSU3hOUVVGTkxFTkJRVU03WjBKQlEwd3NTVUZCU1N4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyaENMRTFCUVUwc1JVRkJSU3hQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVRXNRMEZCUXl4SlFVRkpMRTlCUVVNc1EwRkJaU3hEUVVGRExFdEJRVXNzUlVGQmRFSXNRMEZCYzBJc1EwRkJRenRoUVVOcVJDeERRVUZETzFGQlEwb3NRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhGUVVGRExFMUJRVTBzUlVGQlJTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWxCUVVrc1JVRkJReXhEUVVGRE8wbEJRM1pETEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRjRUlzUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZxUTBRc2IwTkJhVU5ESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZG9tYWluXzEgPSByZXF1aXJlKFwiLi9kb21haW5cIik7XG52YXIgcmFuZ2VfMSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xudmFyIHJ1bGVzID0gcmVxdWlyZShcIi4vcnVsZXNcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbi8qKlxuICogQWxsIHNjYWxlIHByb3BlcnRpZXMgZXhjZXB0IHR5cGUgYW5kIGFsbCByYW5nZSBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnRzLk5PTl9UWVBFX1JBTkdFX1NDQUxFX1BST1BFUlRJRVMgPSBbXG4gICAgLy8gZ2VuZXJhbCBwcm9wZXJ0aWVzXG4gICAgJ2RvbWFpbicsXG4gICAgJ3JvdW5kJyxcbiAgICAvLyBxdWFudGl0YXRpdmUgLyB0aW1lXG4gICAgJ2NsYW1wJywgJ25pY2UnLFxuICAgIC8vIHF1YW50aXRhdGl2ZVxuICAgICdleHBvbmVudCcsICd6ZXJvJyxcbiAgICAnaW50ZXJwb2xhdGUnLFxuICAgIC8vIG9yZGluYWxcbiAgICAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJyAvLyBwYWRkaW5nXG5dO1xuLyoqXG4gKiBJbml0aWFsaXplIFZlZ2EtTGl0ZSBTY2FsZSdzIHByb3BlcnRpZXNcbiAqXG4gKiBOb3RlIHRoYXQgd2UgaGF2ZSB0byBhcHBseSB0aGVzZSBydWxlcyBoZXJlIGJlY2F1c2U6XG4gKiAtIG1hbnkgb3RoZXIgc2NhbGUgYW5kIG5vbi1zY2FsZSBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgbGF5b3V0LCBtYXJrKSBkZXBlbmQgb24gc2NhbGUgdHlwZVxuICogLSBsYXlvdXQgZGVwZW5kcyBvbiBwYWRkaW5nXG4gKiAtIHJhbmdlIGRlcGVuZHMgb24gemVybyBhbmQgc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgZGVwZW5kcyBvbiByYW5nZVxuICovXG5mdW5jdGlvbiBpbml0KGNoYW5uZWwsIGZpZWxkRGVmLCBjb25maWcsIG1hcmssIHRvcExldmVsU2l6ZSwgeHlSYW5nZVN0ZXBzKSB7XG4gICAgdmFyIHNwZWNpZmllZFNjYWxlID0gKGZpZWxkRGVmIHx8IHt9KS5zY2FsZSB8fCB7fTtcbiAgICB2YXIgc2NhbGUgPSB7XG4gICAgICAgIHR5cGU6IHR5cGVfMS5kZWZhdWx0KHNwZWNpZmllZFNjYWxlLnR5cGUsIGNoYW5uZWwsIGZpZWxkRGVmLCBtYXJrLCB0b3BMZXZlbFNpemUgIT09IHVuZGVmaW5lZCwgc3BlY2lmaWVkU2NhbGUucmFuZ2VTdGVwLCBjb25maWcuc2NhbGUpXG4gICAgfTtcbiAgICAvLyBVc2Ugc3BlY2lmaWVkIHZhbHVlIGlmIGNvbXBhdGlibGUgb3IgZGV0ZXJtaW5lIGRlZmF1bHQgdmFsdWVzIGZvciBlYWNoIHByb3BlcnR5XG4gICAgZXhwb3J0cy5OT05fVFlQRV9SQU5HRV9TQ0FMRV9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBzcGVjaWZpZWRWYWx1ZSA9IHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XTtcbiAgICAgICAgdmFyIHN1cHBvcnRlZEJ5U2NhbGVUeXBlID0gc2NhbGVfMS5zY2FsZVR5cGVTdXBwb3J0UHJvcGVydHkoc2NhbGUudHlwZSwgcHJvcGVydHkpO1xuICAgICAgICB2YXIgY2hhbm5lbEluY29tcGF0YWJpbGl0eSA9IHNjYWxlXzEuY2hhbm5lbFNjYWxlUHJvcGVydHlJbmNvbXBhdGFiaWxpdHkoY2hhbm5lbCwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoc3BlY2lmaWVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzcGVjaWZpZWQgdmFsdWUsIGNoZWNrIGlmIGl0IGlzIGNvbXBhdGlibGUgd2l0aCBzY2FsZSB0eXBlIGFuZCBjaGFubmVsXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRlZEJ5U2NhbGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2Uuc2NhbGVQcm9wZXJ0eU5vdFdvcmtXaXRoU2NhbGVUeXBlKHNjYWxlLnR5cGUsIHByb3BlcnR5LCBjaGFubmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsSW5jb21wYXRhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oY2hhbm5lbEluY29tcGF0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRlZEJ5U2NhbGVUeXBlICYmIGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoc3BlY2lmaWVkVmFsdWUsIHByb3BlcnR5LCBzY2FsZSwgY2hhbm5lbCwgZmllbGREZWYsIGNvbmZpZy5zY2FsZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNjYWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHNjYWxlLCByYW5nZV8xLmRlZmF1bHQoY2hhbm5lbCwgc2NhbGUudHlwZSwgZmllbGREZWYudHlwZSwgc3BlY2lmaWVkU2NhbGUsIGNvbmZpZywgc2NhbGUuemVybywgbWFyaywgdG9wTGV2ZWxTaXplLCB4eVJhbmdlU3RlcHMpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGluaXQ7XG5mdW5jdGlvbiBnZXRWYWx1ZShzcGVjaWZpZWRWYWx1ZSwgcHJvcGVydHksIHNjYWxlLCBjaGFubmVsLCBmaWVsZERlZiwgc2NhbGVDb25maWcpIHtcbiAgICAvLyBGb3IgZG9tYWluLCB3ZSBtaWdodCBvdmVycmlkZSBzcGVjaWZpZWQgdmFsdWVcbiAgICBpZiAocHJvcGVydHkgPT09ICdkb21haW4nKSB7XG4gICAgICAgIHJldHVybiBkb21haW5fMS5pbml0RG9tYWluKHNwZWNpZmllZFZhbHVlLCBmaWVsZERlZiwgc2NhbGUudHlwZSwgc2NhbGVDb25maWcpO1xuICAgIH1cbiAgICAvLyBPdGhlciBwcm9wZXJ0aWVzLCBubyBvdmVycmlkaW5nIGRlZmF1bHQgdmFsdWVzXG4gICAgaWYgKHNwZWNpZmllZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllZFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGVmYXVsdFZhbHVlKHByb3BlcnR5LCBzY2FsZSwgY2hhbm5lbCwgZmllbGREZWYsIHNjYWxlQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZShwcm9wZXJ0eSwgc2NhbGUsIGNoYW5uZWwsIGZpZWxkRGVmLCBzY2FsZUNvbmZpZykge1xuICAgIC8vIElmIHdlIGhhdmUgZGVmYXVsdCBydWxlLWJhc2UsIGRldGVybWluZSBkZWZhdWx0IHZhbHVlIGZpcnN0XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlICduaWNlJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5uaWNlKHNjYWxlLnR5cGUsIGNoYW5uZWwsIGZpZWxkRGVmKTtcbiAgICAgICAgY2FzZSAncGFkZGluZyc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMucGFkZGluZyhjaGFubmVsLCBzY2FsZS50eXBlLCBzY2FsZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdJbm5lcic6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMucGFkZGluZ0lubmVyKHNjYWxlLnBhZGRpbmcsIGNoYW5uZWwsIHNjYWxlQ29uZmlnKTtcbiAgICAgICAgY2FzZSAncGFkZGluZ091dGVyJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5wYWRkaW5nT3V0ZXIoc2NhbGUucGFkZGluZywgY2hhbm5lbCwgc2NhbGUudHlwZSwgc2NhbGUucGFkZGluZ0lubmVyLCBzY2FsZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5yb3VuZChjaGFubmVsLCBzY2FsZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ3plcm8nOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnplcm8oc2NhbGUsIGNoYW5uZWwsIGZpZWxkRGVmKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2Ugc2NhbGUgY29uZmlnXG4gICAgcmV0dXJuIHNjYWxlQ29uZmlnW3Byb3BlcnR5XTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNXBkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDNOallXeGxMMmx1YVhRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN3clFrRkJhVU03UVVGTmFrTXNjVU5CUVRoSE8wRkJRemxITEdsRFFVRnRRenRCUVVWdVF5eHRRMEZCYjBNN1FVRkRjRU1zYVVOQlFXdERPMEZCUTJ4RExDdENRVUZwUXp0QlFVTnFReXdyUWtGQkswSTdRVUZGTDBJN08wZEJSVWM3UVVGRFZTeFJRVUZCTEN0Q1FVRXJRaXhIUVVGdlFqdEpRVU01UkN4eFFrRkJjVUk3U1VGRGNrSXNVVUZCVVR0SlFVTlNMRTlCUVU4N1NVRkRVQ3h6UWtGQmMwSTdTVUZEZEVJc1QwRkJUeXhGUVVGRkxFMUJRVTA3U1VGRFppeGxRVUZsTzBsQlEyWXNWVUZCVlN4RlFVRkZMRTFCUVUwN1NVRkRiRUlzWVVGQllUdEpRVU5pTEZWQlFWVTdTVUZEVml4VFFVRlRMRVZCUVVVc1kwRkJZeXhGUVVGRkxHTkJRV01zUTBGQlF5eFZRVUZWTzBOQlEzSkVMRU5CUVVNN1FVRkZSanM3T3pzN096dEhRVTlITzBGQlEwZ3NZMEZEU1N4UFFVRm5RaXhGUVVGRkxGRkJRU3RDTEVWQlFVVXNUVUZCWXl4RlFVTnFSU3hKUVVGelFpeEZRVUZGTEZsQlFXZERMRVZCUVVVc1dVRkJjMEk3U1VGRGJFWXNTVUZCVFN4alFVRmpMRWRCUVVjc1EwRkJReXhSUVVGUkxFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4SlFVRkpMRVZCUVVVc1EwRkJRenRKUVVWd1JDeEpRVUZOTEV0QlFVc3NSMEZCVlR0UlFVTnVRaXhKUVVGSkxFVkJRVVVzWTBGQlV5eERRVU5pTEdOQlFXTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhGUVVGRkxGRkJRVkVzUlVGQlJTeEpRVUZKTEVWQlFVVXNXVUZCV1N4TFFVRkxMRk5CUVZNc1JVRkRlRVVzWTBGQll5eERRVUZETEZOQlFWTXNSVUZCUlN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVOMlF6dExRVU5HTEVOQlFVTTdTVUZGUml4clJrRkJhMFk3U1VGRGJFWXNkVU5CUVN0Q0xFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWTXNVVUZCVVR0UlFVTjJSQ3hKUVVGTkxHTkJRV01zUjBGQlJ5eGpRVUZqTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1VVRkZhRVFzU1VGQlRTeHZRa0ZCYjBJc1IwRkJSeXhuUTBGQmQwSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzFGQlF6VkZMRWxCUVUwc2MwSkJRWE5DTEVkQlFVY3NNa05CUVcxRExFTkJRVU1zVDBGQlR5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUlhSR0xFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFXTXNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBETEhWR1FVRjFSanRaUVVOMlJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRzlDUVVGdlFpeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRNVUlzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExHbERRVUZwUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzVVVGQlVTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRla1lzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXh6UWtGQmMwSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnhETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNRMEZCUXp0WlFVTnVReXhEUVVGRE8xRkJRMGdzUTBGQlF6dFJRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRzlDUVVGdlFpeEpRVUZKTEhOQ1FVRnpRaXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtVc1NVRkJUU3hMUVVGTExFZEJRVWNzVVVGQlVTeERRVUZETEdOQlFXTXNSVUZCUlN4UlFVRlJMRVZCUVVVc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVWQlFVVXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRM3BHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjRRaXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRPMWxCUXpGQ0xFTkJRVU03VVVGRFNDeERRVUZETzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZTQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZEYUVJc1MwRkJTeXhGUVVOTUxHVkJRVmNzUTBGRFZDeFBRVUZQTEVWQlFVVXNTMEZCU3l4RFFVRkRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFTkJRVU1zU1VGQlNTeEZRVUZGTEdOQlFXTXNSVUZCUlN4TlFVRk5MRVZCUXpGRUxFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRmxCUVZrc1JVRkJSU3haUVVGWkxFTkJRemRETEVOQlEwWXNRMEZCUXp0QlFVTktMRU5CUVVNN1FVRXhRMFFzZFVKQk1FTkRPMEZCUlVRc2EwSkJRV3RDTEdOQlFXMUNMRVZCUVVVc1VVRkJjVUlzUlVGQlJTeExRVUZaTEVWQlFVVXNUMEZCWjBJc1JVRkJSU3hSUVVFd1FpeEZRVUZGTEZkQlFYZENPMGxCUTJoS0xHZEVRVUZuUkR0SlFVTm9SQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEV0QlFVc3NVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNeFFpeE5RVUZOTEVOQlFVTXNiVUpCUVZVc1EwRkJReXhqUVVGakxFVkJRVVVzVVVGQlVTeEZRVUZGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1YwRkJWeXhEUVVGRExFTkJRVU03U1VGRGRrVXNRMEZCUXp0SlFVVkVMR2xFUVVGcFJEdEpRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhqUVVGakxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnFReXhOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETzBsQlEzaENMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zWlVGQlpTeERRVUZETEZGQlFWRXNSVUZCUlN4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxGRkJRVkVzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXp0QlFVTXhSU3hEUVVGRE8wRkJSVVFzZVVKQlFYbENMRkZCUVhGQ0xFVkJRVVVzUzBGQldTeEZRVUZGTEU5QlFXZENMRVZCUVVVc1VVRkJNRUlzUlVGQlJTeFhRVUYzUWp0SlFVVnNTU3c0UkVGQk9FUTdTVUZET1VRc1RVRkJUU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnFRaXhMUVVGTExFMUJRVTA3V1VGRFZDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeEZRVUZGTEU5QlFVOHNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVOdVJDeExRVUZMTEZOQlFWTTdXVUZEV2l4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVWQlFVVXNTMEZCU3l4RFFVRkRMRWxCUVVrc1JVRkJSU3hYUVVGWExFTkJRVU1zUTBGQlF6dFJRVU42UkN4TFFVRkxMR05CUVdNN1dVRkRha0lzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeFBRVUZQTEVWQlFVVXNWMEZCVnl4RFFVRkRMRU5CUVVNN1VVRkRha1VzUzBGQlN5eGpRVUZqTzFsQlEycENMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1QwRkJUeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMRmxCUVZrc1JVRkJSU3hYUVVGWExFTkJRVU1zUTBGQlF6dFJRVU5xUnl4TFFVRkxMRTlCUVU4N1dVRkRWaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1YwRkJWeXhEUVVGRExFTkJRVU03VVVGRE0wTXNTMEZCU3l4TlFVRk5PMWxCUTFRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCUTBRc09FSkJRVGhDTzBsQlF6bENMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdRVUZETDBJc1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciBzb3J0XzEgPSByZXF1aXJlKFwiLi4vLi4vc29ydFwiKTtcbnZhciBkb21haW5fMSA9IHJlcXVpcmUoXCIuL2RvbWFpblwiKTtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG4vKipcbiAqIFBhcnNlIHNjYWxlcyBmb3IgYWxsIGNoYW5uZWxzIG9mIGEgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2NhbGVDb21wb25lbnQobW9kZWwpIHtcbiAgICAvLyBUT0RPOiBzaG91bGQgbW9kZWwuY2hhbm5lbHMoKSBpbmxjdWRlIFgyL1kyP1xuICAgIHJldHVybiBtb2RlbC5jaGFubmVscygpLnJlZHVjZShmdW5jdGlvbiAoc2NhbGVDb21wb25lbnRzSW5kZXgsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIHNjYWxlQ29tcG9uZW50cyA9IHBhcnNlU2NhbGUobW9kZWwsIGNoYW5uZWwpO1xuICAgICAgICBpZiAoc2NhbGVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBzY2FsZUNvbXBvbmVudHNJbmRleFtjaGFubmVsXSA9IHNjYWxlQ29tcG9uZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbGVDb21wb25lbnRzSW5kZXg7XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VTY2FsZUNvbXBvbmVudDtcbmV4cG9ydHMuTk9OX1RZUEVfRE9NQUlOX1JBTkdFX1ZFR0FfU0NBTEVfUFJPUEVSVElFUyA9IFtcbiAgICAncm91bmQnLFxuICAgIC8vIHF1YW50aXRhdGl2ZSAvIHRpbWVcbiAgICAnY2xhbXAnLCAnbmljZScsXG4gICAgLy8gcXVhbnRpdGF0aXZlXG4gICAgJ2V4cG9uZW50JywgJ2ludGVycG9sYXRlJywgJ3plcm8nLFxuICAgIC8vIG9yZGluYWxcbiAgICAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJyxcbl07XG4vKipcbiAqIFBhcnNlIHNjYWxlcyBmb3IgYSBzaW5nbGUgY2hhbm5lbCBvZiBhIG1vZGVsLlxuICovXG5mdW5jdGlvbiBwYXJzZVNjYWxlKG1vZGVsLCBjaGFubmVsKSB7XG4gICAgaWYgKCFtb2RlbC5zY2FsZShjaGFubmVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbCk7XG4gICAgdmFyIHNvcnQgPSBtb2RlbC5zb3J0KGNoYW5uZWwpO1xuICAgIHZhciBzY2FsZUNvbXBvbmVudCA9IHtcbiAgICAgICAgbmFtZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwgKyAnJywgdHJ1ZSksXG4gICAgICAgIHR5cGU6IHNjYWxlLnR5cGUsXG4gICAgICAgIGRvbWFpbjogZG9tYWluXzEucGFyc2VEb21haW4obW9kZWwsIGNoYW5uZWwpLFxuICAgICAgICByYW5nZTogcmFuZ2VfMS5wYXJzZVJhbmdlKHNjYWxlKVxuICAgIH07XG4gICAgaWYgKHNjYWxlXzEuaXNTZWxlY3Rpb25Eb21haW4oc2NhbGUuZG9tYWluKSkge1xuICAgICAgICBzY2FsZUNvbXBvbmVudC5kb21haW5SYXcgPSBzY2FsZS5kb21haW47XG4gICAgfVxuICAgIGV4cG9ydHMuTk9OX1RZUEVfRE9NQUlOX1JBTkdFX1ZFR0FfU0NBTEVfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICBzY2FsZUNvbXBvbmVudFtwcm9wZXJ0eV0gPSBzY2FsZVtwcm9wZXJ0eV07XG4gICAgfSk7XG4gICAgaWYgKHNvcnQgJiYgKHNvcnRfMS5pc1NvcnRGaWVsZChzb3J0KSA/IHNvcnQub3JkZXIgOiBzb3J0KSA9PT0gJ2Rlc2NlbmRpbmcnKSB7XG4gICAgICAgIHNjYWxlQ29tcG9uZW50LnJldmVyc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGVDb21wb25lbnQ7XG59XG5leHBvcnRzLnBhcnNlU2NhbGUgPSBwYXJzZVNjYWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0dGeWMyVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl6WTJGc1pTOXdZWEp6WlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEhGRFFVRnhSRHRCUVVOeVJDeHRRMEZCZFVNN1FVRk5ka01zYlVOQlFYRkRPMEZCUTNKRExHbERRVUZ0UXp0QlFVVnVRenM3UjBGRlJ6dEJRVU5JTERaQ1FVRTBReXhMUVVGblFqdEpRVU14UkN3clEwRkJLME03U1VGREwwTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVXl4dlFrRkJiVU1zUlVGQlJTeFBRVUZuUWp0UlFVTXpSaXhKUVVGTkxHVkJRV1VzUjBGQlJ5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRMjVFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFSXNiMEpCUVc5Q0xFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NaVUZCWlN4RFFVRkRPMUZCUTJ4RUxFTkJRVU03VVVGRFJDeE5RVUZOTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU03U1VGRE9VSXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8wRkJRMVFzUTBGQlF6dEJRVlJFTEhORFFWTkRPMEZCUlZrc1VVRkJRU3d5UTBGQk1rTXNSMEZCYjBJN1NVRkRNVVVzVDBGQlR6dEpRVU5RTEhOQ1FVRnpRanRKUVVOMFFpeFBRVUZQTEVWQlFVVXNUVUZCVFR0SlFVTm1MR1ZCUVdVN1NVRkRaaXhWUVVGVkxFVkJRVVVzWVVGQllTeEZRVUZGTEUxQlFVMDdTVUZEYWtNc1ZVRkJWVHRKUVVOV0xGTkJRVk1zUlVGQlJTeGpRVUZqTEVWQlFVVXNZMEZCWXp0RFFVTXhReXhEUVVGRE8wRkJSVVk3TzBkQlJVYzdRVUZEU0N4dlFrRkJNa0lzUzBGQlowSXNSVUZCUlN4UFFVRm5RanRKUVVNelJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpGQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlVRc1NVRkJUU3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOdVF5eEpRVUZOTEVsQlFVa3NSMEZCUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlJXcERMRWxCUVUwc1kwRkJZeXhIUVVGWk8xRkJRemxDTEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUjBGQlJ5eEZRVUZGTEVWQlFVVXNTVUZCU1N4RFFVRkRPMUZCUTNwRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNTVUZCU1R0UlFVTm9RaXhOUVVGTkxFVkJRVVVzYjBKQlFWY3NRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRE8xRkJRMjVETEV0QlFVc3NSVUZCUlN4clFrRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF6dExRVU42UWl4RFFVRkRPMGxCUlVZc1JVRkJSU3hEUVVGRExFTkJRVU1zZVVKQlFXbENMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndReXhqUVVGakxFTkJRVU1zVTBGQlV5eEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRNVU1zUTBGQlF6dEpRVVZFTEcxRVFVRXlReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZETEZGQlFWRTdVVUZETTBRc1kwRkJZeXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVNM1F5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVklMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEd0Q1FVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkZMR05CUVdNc1EwRkJReXhQUVVGUExFZEJRVWNzU1VGQlNTeERRVUZETzBsQlEyaERMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETzBGQlEzaENMRU5CUVVNN1FVRXpRa1FzWjBOQk1rSkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIHBhcnNlUmFuZ2Uoc2NhbGUpIHtcbiAgICBpZiAoc2NhbGUucmFuZ2VTdGVwKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXA6IHNjYWxlLnJhbmdlU3RlcCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2FsZS5zY2hlbWUpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IHNjYWxlLnNjaGVtZTtcbiAgICAgICAgaWYgKHNjYWxlXzEuaXNFeHRlbmRlZFNjaGVtZShzY2hlbWUpKSB7XG4gICAgICAgICAgICB2YXIgciA9IHsgc2NoZW1lOiBzY2hlbWUubmFtZSB9O1xuICAgICAgICAgICAgaWYgKHNjaGVtZS5jb3VudCkge1xuICAgICAgICAgICAgICAgIHIuY291bnQgPSBzY2hlbWUuY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1lLmV4dGVudCkge1xuICAgICAgICAgICAgICAgIHIuZXh0ZW50ID0gc2NoZW1lLmV4dGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1lOiBzY2hlbWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NhbGUucmFuZ2U7XG59XG5leHBvcnRzLnBhcnNlUmFuZ2UgPSBwYXJzZVJhbmdlO1xuZXhwb3J0cy5SQU5HRV9QUk9QRVJUSUVTID0gWydyYW5nZScsICdyYW5nZVN0ZXAnLCAnc2NoZW1lJ107XG4vKipcbiAqIFJldHVybiBtaXhpbnMgdGhhdCBpbmNsdWRlcyBvbmUgb2YgdGhlIHJhbmdlIHByb3BlcnRpZXMgKHJhbmdlLCByYW5nZVN0ZXAsIHNjaGVtZSkuXG4gKi9cbmZ1bmN0aW9uIHJhbmdlTWl4aW5zKGNoYW5uZWwsIHNjYWxlVHlwZSwgdHlwZSwgc3BlY2lmaWVkU2NhbGUsIGNvbmZpZywgemVybywgbWFyaywgdG9wTGV2ZWxTaXplLCB4eVJhbmdlU3RlcHMpIHtcbiAgICB2YXIgc3BlY2lmaWVkUmFuZ2VTdGVwSXNOdWxsID0gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSByYW5nZSBwcm9wZXJ0aWVzIGlzIHNwZWNpZmllZC5cbiAgICAvLyBJZiBzbywgY2hlY2sgaWYgaXQgaXMgY29tcGF0aWJsZSBhbmQgbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBvdXRwdXQgb25lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgX2kgPSAwLCBSQU5HRV9QUk9QRVJUSUVTXzEgPSBleHBvcnRzLlJBTkdFX1BST1BFUlRJRVM7IF9pIDwgUkFOR0VfUFJPUEVSVElFU18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBSQU5HRV9QUk9QRVJUSUVTXzFbX2ldO1xuICAgICAgICBpZiAoc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0ZWRCeVNjYWxlVHlwZSA9IHNjYWxlXzEuc2NhbGVUeXBlU3VwcG9ydFByb3BlcnR5KHNjYWxlVHlwZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkgPSBzY2FsZV8xLmNoYW5uZWxTY2FsZVByb3BlcnR5SW5jb21wYXRhYmlsaXR5KGNoYW5uZWwsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydGVkQnlTY2FsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5zY2FsZVByb3BlcnR5Tm90V29ya1dpdGhTY2FsZVR5cGUoc2NhbGVUeXBlLCBwcm9wZXJ0eSwgY2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbEluY29tcGF0YWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NjaGVtZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzY2hlbWU6IHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XSB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyYW5nZVN0ZXAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcExldmVsU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXBTaXplID0gc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZVN0ZXA6IHN0ZXBTaXplIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWRSYW5nZVN0ZXBJc051bGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRvcC1sZXZlbCBzaXplIGlzIHNwZWNpZmllZCwgd2UgaWdub3JlIHNwZWNpZmllZCByYW5nZVN0ZXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UucmFuZ2VTdGVwRHJvcHBlZChjaGFubmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgICAgICAvLyBUT0RPOiByZXZpc2Ugcm93L2NvbHVtbiB3aGVuIGZhY2V0U3BlYyBoYXMgdG9wLWxldmVsIHdpZHRoL2hlaWdodFxuICAgICAgICBjYXNlIGNoYW5uZWxfMS5ST1c6XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogJ2hlaWdodCcgfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuQ09MVU1OOlxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6ICd3aWR0aCcgfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuWDpcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuWTpcbiAgICAgICAgICAgIGlmICh0b3BMZXZlbFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmNvbnRhaW5zKFsncG9pbnQnLCAnYmFuZCddLCBzY2FsZVR5cGUpICYmICFzcGVjaWZpZWRSYW5nZVN0ZXBJc051bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YICYmIG1hcmsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zY2FsZS50ZXh0WFJhbmdlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlU3RlcDogY29uZmlnLnNjYWxlLnRleHRYUmFuZ2VTdGVwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNjYWxlLnJhbmdlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlU3RlcDogY29uZmlnLnNjYWxlLnJhbmdlU3RlcCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHNwZWNpZmllZCByYW5nZSBzdGVwIGlzIG51bGwgb3IgdGhlIHJhbmdlIHN0ZXAgY29uZmlnIGlzIG51bGwuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgdG9wTGV2ZWxTaXplIHJ1bGUvY29uZmlnXG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxTaXplID0gY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyBjb25maWcuY2VsbC53aWR0aCA6IGNvbmZpZy5jZWxsLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBjaGFubmVsID09PSBjaGFubmVsXzEuWCA/IFswLCB0b3BMZXZlbFNpemVdIDogW3RvcExldmVsU2l6ZSwgMF0gfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0laRTpcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgY3VzdG9tIHJhbmdlTWluLCByYW5nZU1heFxuICAgICAgICAgICAgdmFyIHJhbmdlTWluID0gc2l6ZVJhbmdlTWluKG1hcmssIHplcm8sIGNvbmZpZyk7XG4gICAgICAgICAgICB2YXIgcmFuZ2VNYXggPSBzaXplUmFuZ2VNYXgobWFyaywgeHlSYW5nZVN0ZXBzLCBjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IFtyYW5nZU1pbiwgcmFuZ2VNYXhdIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlNIQVBFOlxuICAgICAgICBjYXNlIGNoYW5uZWxfMS5DT0xPUjpcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBkZWZhdWx0UmFuZ2UoY2hhbm5lbCwgc2NhbGVUeXBlLCB0eXBlLCBtYXJrKSB9O1xuICAgICAgICBjYXNlIGNoYW5uZWxfMS5PUEFDSVRZOlxuICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBjdXN0b20gcmFuZ2VNaW4sIHJhbmdlTWF4XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogW2NvbmZpZy5zY2FsZS5taW5PcGFjaXR5LCBjb25maWcuc2NhbGUubWF4T3BhY2l0eV0gfTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgcmFuZ2UgdW5kZWZpbmVkIGZvciBjaGFubmVsIFwiICsgY2hhbm5lbCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSByYW5nZU1peGlucztcbmZ1bmN0aW9uIGRlZmF1bHRSYW5nZShjaGFubmVsLCBzY2FsZVR5cGUsIHR5cGUsIG1hcmspIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLkNPTE9SOlxuICAgICAgICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBub21pbmFsIGRhdGEgdXNlcyBvcmRpbmFsIHNjYWxlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ25vbWluYWwnID8gJ2NhdGVnb3J5JyA6ICdvcmRpbmFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrID09PSAncmVjdCcgPyAnaGVhdG1hcCcgOiAncmFtcCc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2l6ZVJhbmdlTWluKG1hcmssIHplcm8sIGNvbmZpZykge1xuICAgIGlmICh6ZXJvKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzd2l0Y2ggKG1hcmspIHtcbiAgICAgICAgY2FzZSAnYmFyJzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluQmFuZFNpemUgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zY2FsZS5taW5CYW5kU2l6ZSA6IGNvbmZpZy5iYXIuY29udGludW91c0JhbmRTaXplO1xuICAgICAgICBjYXNlICd0aWNrJzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluQmFuZFNpemU7XG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICBjYXNlICdydWxlJzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluU3Ryb2tlV2lkdGg7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5taW5Gb250U2l6ZTtcbiAgICAgICAgY2FzZSAncG9pbnQnOlxuICAgICAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zY2FsZS5taW5TaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5taW5TaXplO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgKi9cbiAgICAvLyBzaXplUmFuZ2VNaW4gbm90IGltcGxlbWVudGVkIGZvciB0aGUgbWFya1xuICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5pbmNvbXBhdGlibGVDaGFubmVsKCdzaXplJywgbWFyaykpO1xufVxuZnVuY3Rpb24gc2l6ZVJhbmdlTWF4KG1hcmssIHh5UmFuZ2VTdGVwcywgY29uZmlnKSB7XG4gICAgdmFyIHNjYWxlQ29uZmlnID0gY29uZmlnLnNjYWxlO1xuICAgIC8vIFRPRE8oIzExNjgpOiBtYWtlIG1heCBzaXplIHNjYWxlIGJhc2VkIG9uIHJhbmdlU3RlcCAvIG92ZXJhbGwgcGxvdCBzaXplXG4gICAgc3dpdGNoIChtYXJrKSB7XG4gICAgICAgIGNhc2UgJ2Jhcic6XG4gICAgICAgIGNhc2UgJ3RpY2snOlxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zY2FsZS5tYXhCYW5kU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5tYXhCYW5kU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW5YWVJhbmdlU3RlcCh4eVJhbmdlU3RlcHMsIGNvbmZpZy5zY2FsZSkgLSAxO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgY2FzZSAncnVsZSc6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1heFN0cm9rZVdpZHRoO1xuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWF4Rm9udFNpemU7XG4gICAgICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIGlmIChjb25maWcuc2NhbGUubWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWF4U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FIHRoaXMgY2FzZSB0b3RhbGx5IHNob3VsZCBiZSByZWZhY3RvcmVkXG4gICAgICAgICAgICB2YXIgcG9pbnRTdGVwID0gbWluWFlSYW5nZVN0ZXAoeHlSYW5nZVN0ZXBzLCBzY2FsZUNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gKHBvaW50U3RlcCAtIDIpICogKHBvaW50U3RlcCAtIDIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgKi9cbiAgICAvLyBzaXplUmFuZ2VNYXggbm90IGltcGxlbWVudGVkIGZvciB0aGUgbWFya1xuICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5pbmNvbXBhdGlibGVDaGFubmVsKCdzaXplJywgbWFyaykpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSYW5nZSBzdGVwIG9mIHggb3IgeSBvciBtaW5pbXVtIGJldHdlZW4gdGhlIHR3byBpZiBib3RoIGFyZSBvcmRpbmFsIHNjYWxlLlxuICovXG5mdW5jdGlvbiBtaW5YWVJhbmdlU3RlcCh4eVJhbmdlU3RlcHMsIHNjYWxlQ29uZmlnKSB7XG4gICAgaWYgKHh5UmFuZ2VTdGVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCB4eVJhbmdlU3RlcHMpO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25maWcucmFuZ2VTdGVwKSB7XG4gICAgICAgIHJldHVybiBzY2FsZUNvbmZpZy5yYW5nZVN0ZXA7XG4gICAgfVxuICAgIHJldHVybiAyMTsgLy8gRklYTUU6IHJlLWV2YWx1YXRlIHRoZSBkZWZhdWx0IHZhbHVlIGhlcmUuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljbUZ1WjJVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXpZMkZzWlM5eVlXNW5aUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMQ3RDUVVGcFF6dEJRVVZxUXl4NVEwRkJjMFk3UVVGSGRFWXNjVU5CUVRCS08wRkJSVEZLTEdsRFFVRnRRenRCUVV0dVF5eHZRa0ZCTWtJc1MwRkJXVHRKUVVOeVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU53UWl4TlFVRk5MRU5CUVVNc1JVRkJReXhKUVVGSkxFVkJRVVVzUzBGQlN5eERRVUZETEZOQlFWTXNSVUZCUXl4RFFVRkRPMGxCUTJwRExFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVJc1NVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTTFRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eDNRa0ZCWjBJc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBJc1NVRkJUU3hEUVVGRExFZEJRV3RDTEVWQlFVTXNUVUZCVFN4RlFVRkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFVkJRVU1zUTBGQlF6dFpRVU12UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRha0lzUTBGQlF5eERRVUZETEV0QlFVc3NSMEZCUnl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xbEJRM3BDTEVOQlFVTTdXVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRiRUlzUTBGQlF5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRE8xbEJRek5DTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMWdzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTA0c1RVRkJUU3hEUVVGRExFVkJRVU1zVFVGQlRTeFJRVUZCTEVWQlFVTXNRMEZCUXp0UlFVTnNRaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRM0pDTEVOQlFVTTdRVUZ1UWtRc1owTkJiVUpETzBGQlJWa3NVVUZCUVN4blFrRkJaMElzUjBGQmIwSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1YwRkJWeXhGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzBGQlJXeEdPenRIUVVWSE8wRkJRMGdzY1VKQlEwVXNUMEZCWjBJc1JVRkJSU3hUUVVGdlFpeEZRVUZGTEVsQlFWVXNSVUZCUlN4alFVRnhRaXhGUVVGRkxFMUJRV01zUlVGRGVrWXNTVUZCWVN4RlFVRkZMRWxCUVZVc1JVRkJSU3haUVVGblF5eEZRVUZGTEZsQlFYTkNPMGxCUlc1R0xFbEJRVWtzZDBKQlFYZENMRWRCUVVjc1MwRkJTeXhEUVVGRE8wbEJSWEpETEhGRVFVRnhSRHRKUVVOeVJDd3lSa0ZCTWtZN1NVRkRNMFlzUjBGQlJ5eERRVUZETEVOQlFXMUNMRlZCUVdkQ0xFVkJRV2hDTEhGQ1FVRkJMSGRDUVVGblFpeEZRVUZvUWl3NFFrRkJaMElzUlVGQmFFSXNTVUZCWjBJN1VVRkJiRU1zU1VGQlRTeFJRVUZSTEhsQ1FVRkJPMUZCUTJwQ0xFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFXTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkRMRWxCUVUwc2IwSkJRVzlDTEVkQlFVY3NaME5CUVhkQ0xFTkJRVU1zVTBGQlV5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMWxCUXpORkxFbEJRVTBzYzBKQlFYTkNMRWRCUVVjc01rTkJRVzFETEVOQlFVTXNUMEZCVHl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xbEJRM1JHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNeFFpeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1UwRkJVeXhGUVVGRkxGRkJRVkVzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNoR0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOc1F5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMSE5DUVVGelFpeERRVUZETEVOQlFVTTdXVUZEYmtNc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MRTFCUVUwc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTJwQ0xFdEJRVXNzVDBGQlR6dDNRa0ZEVml4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzWTBGQll5eERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRkRMRU5CUVVNN2IwSkJRek5ETEV0QlFVc3NVVUZCVVR0M1FrRkRXQ3hOUVVGTkxFTkJRVU1zUlVGQlF5eE5RVUZOTEVWQlFVVXNZMEZCWXl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRExFTkJRVU03YjBKQlF6VkRMRXRCUVVzc1YwRkJWenQzUWtGRFpDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6czBRa0ZETDBJc1NVRkJUU3hSUVVGUkxFZEJRVWNzWTBGQll5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPelJDUVVNeFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5RMEZEZEVJc1RVRkJUU3hEUVVGRExFVkJRVU1zVTBGQlV5eEZRVUZGTEZGQlFWRXNSVUZCUXl4RFFVRkRPelJDUVVNdlFpeERRVUZET3pSQ1FVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZERRVU5PTEhkQ1FVRjNRaXhIUVVGSExFbEJRVWtzUTBGQlF6czBRa0ZEYkVNc1EwRkJRenQzUWtGRFNDeERRVUZETzNkQ1FVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE96UkNRVU5PTEdsRlFVRnBSVHMwUWtGRGFrVXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdkMEpCUTJ4RUxFTkJRVU03WjBKQlEwd3NRMEZCUXp0WlFVTklMRU5CUVVNN1VVRkRTQ3hEUVVGRE8wdEJRMFk3U1VGRlJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEc5RlFVRnZSVHRSUVVOd1JTeExRVUZMTEdGQlFVYzdXVUZEVGl4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeEZRVUZETEVOQlFVTTdVVUZETTBJc1MwRkJTeXhuUWtGQlRUdFpRVU5VTEUxQlFVMHNRMEZCUXl4RlFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF6dFJRVU14UWl4TFFVRkxMRmRCUVVNc1EwRkJRenRSUVVOUUxFdEJRVXNzVjBGQlF6dFpRVU5LTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmxCUVZrc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTXZRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1QwRkJUeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc2QwSkJRWGRDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNM1JTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhKUVVGSkxFbEJRVWtzUzBGQlN5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPM2RDUVVOeVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdORUpCUTJoRExFMUJRVTBzUTBGQlF5eEZRVUZETEZOQlFWTXNSVUZCUlN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExHTkJRV01zUlVGQlF5eERRVUZETzNkQ1FVTnNSQ3hEUVVGRE8yOUNRVU5JTEVOQlFVTTdiMEpCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03ZDBKQlEwNHNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPelJDUVVNelFpeE5RVUZOTEVOQlFVTXNSVUZCUXl4VFFVRlRMRVZCUVVVc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVWQlFVTXNRMEZCUXp0M1FrRkROME1zUTBGQlF6dHZRa0ZEU0N4RFFVRkRPMmRDUVVOSUxFTkJRVU03WjBKQlEwUXNiMFZCUVc5Rk8yZENRVU53UlN4MVEwRkJkVU03WjBKQlEzWkRMRmxCUVZrc1IwRkJSeXhQUVVGUExFdEJRVXNzVjBGQlF5eEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhIUVVGSExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUTNoRkxFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhMUVVGTExGZEJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4WlFVRlpMRU5CUVVNc1IwRkJSeXhEUVVGRExGbEJRVmtzUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUXl4RFFVRkRPMUZCUlhoRkxFdEJRVXNzWTBGQlNUdFpRVU5RTERCRFFVRXdRenRaUVVNeFF5eEpRVUZOTEZGQlFWRXNSMEZCUnl4WlFVRlpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0WlFVTnNSQ3hKUVVGTkxGRkJRVkVzUjBGQlJ5eFpRVUZaTEVOQlFVTXNTVUZCU1N4RlFVRkZMRmxCUVZrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dFpRVU14UkN4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRVZCUVVNc1EwRkJRenRSUVVOMlF5eExRVUZMTEdWQlFVc3NRMEZCUXp0UlFVTllMRXRCUVVzc1pVRkJTenRaUVVOU0xFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4WlFVRlpMRU5CUVVNc1QwRkJUeXhGUVVGRkxGTkJRVk1zUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RFFVRkRMRVZCUVVNc1EwRkJRenRSUVVjdlJDeExRVUZMTEdsQ1FVRlBPMWxCUTFZc01FTkJRVEJETzFsQlF6RkRMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRVZCUVVNc1EwRkJRenRKUVVOMlJTeERRVUZETzBsQlEwUXNiVVJCUVcxRU8wbEJRMjVFTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2RVTkJRWEZETEU5QlFWTXNRMEZCUXl4RFFVRkRPMEZCUTJ4RkxFTkJRVU03UVVGcVJrUXNPRUpCYVVaRE8wRkJSVVFzYzBKQlFYTkNMRTlCUVRCQ0xFVkJRVVVzVTBGQmIwSXNSVUZCUlN4SlFVRlZMRVZCUVVVc1NVRkJWVHRKUVVNMVJpeE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEV0QlFVc3NaVUZCU3p0WlFVTlNMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03VVVGRGJFSXNTMEZCU3l4bFFVRkxPMWxCUTFJc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRelZDTEd0RVFVRnJSRHRuUWtGRGJFUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1MwRkJTeXhUUVVGVExFZEJRVWNzVlVGQlZTeEhRVUZITEZOQlFWTXNRMEZCUXp0WlFVTnlSQ3hEUVVGRE8xbEJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NTMEZCU3l4TlFVRk5MRWRCUVVjc1UwRkJVeXhIUVVGSExFMUJRVTBzUTBGQlF6dEpRVU5vUkN4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxITkNRVUZ6UWl4SlFVRlZMRVZCUVVVc1NVRkJZU3hGUVVGRkxFMUJRV003U1VGRE4wUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5VTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRXQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOaUxFdEJRVXNzUzBGQlN6dFpRVU5TTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGZEJRVmNzUzBGQlN5eFRRVUZUTEVkQlFVY3NUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhYUVVGWExFZEJRVWNzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4clFrRkJhMElzUTBGQlF6dFJRVU16Unl4TFFVRkxMRTFCUVUwN1dVRkRWQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4WFFVRlhMRU5CUVVNN1VVRkRiRU1zUzBGQlN5eE5RVUZOTEVOQlFVTTdVVUZEV2l4TFFVRkxMRTFCUVUwN1dVRkRWQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4alFVRmpMRU5CUVVNN1VVRkRja01zUzBGQlN5eE5RVUZOTzFsQlExUXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETzFGQlEyeERMRXRCUVVzc1QwRkJUeXhEUVVGRE8xRkJRMklzUzBGQlN5eFJRVUZSTEVOQlFVTTdVVUZEWkN4TFFVRkxMRkZCUVZFN1dVRkRXQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzcENMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXp0WlFVTTVRaXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVU5FTEcxRVFVRnRSRHRKUVVOdVJDdzBRMEZCTkVNN1NVRkROVU1zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRTFCUVUwc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlEycEZMRU5CUVVNN1FVRkZSQ3h6UWtGQmMwSXNTVUZCVlN4RlFVRkZMRmxCUVhOQ0xFVkJRVVVzVFVGQll6dEpRVU4wUlN4SlFVRk5MRmRCUVZjc1IwRkJSeXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBsQlEycERMREJGUVVFd1JUdEpRVU14UlN4TlFVRk5MRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEySXNTMEZCU3l4TFFVRkxMRU5CUVVNN1VVRkRXQ3hMUVVGTExFMUJRVTA3V1VGRFZDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGZEJRVmNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNelF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU03V1VGRGJFTXNRMEZCUXp0WlFVTkVMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU1zV1VGQldTeEZRVUZGTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGVFUXNTMEZCU3l4TlFVRk5MRU5CUVVNN1VVRkRXaXhMUVVGTExFMUJRVTA3V1VGRFZDeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhqUVVGakxFTkJRVU03VVVGRGNrTXNTMEZCU3l4TlFVRk5PMWxCUTFRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCVnl4RFFVRkRPMUZCUTJ4RExFdEJRVXNzVDBGQlR5eERRVUZETzFGQlEySXNTMEZCU3l4UlFVRlJMRU5CUVVNN1VVRkRaQ3hMUVVGTExGRkJRVkU3V1VGRFdDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwQ0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJRenRaUVVNNVFpeERRVUZETzFsQlJVUXNLME5CUVN0RE8xbEJReTlETEVsQlFVMHNVMEZCVXl4SFFVRkhMR05CUVdNc1EwRkJReXhaUVVGWkxFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdXVUZETlVRc1RVRkJUU3hEUVVGRExFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1UwRkJVeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlF6ZERMRU5CUVVNN1NVRkRSQ3h0UkVGQmJVUTdTVUZEYmtRc05FTkJRVFJETzBsQlF6VkRMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eE5RVUZOTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOcVJTeERRVUZETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3gzUWtGQmQwSXNXVUZCYzBJc1JVRkJSU3hYUVVGM1FqdEpRVU4wUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkROVUlzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFpRVUZaTEVOQlFVTXNRMEZCUXp0SlFVTTFReXhEUVVGRE8wbEJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE1VSXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhUUVVGVExFTkJRVU03U1VGREwwSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5dzJRMEZCTmtNN1FVRkRNVVFzUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHRpbWV1bml0XzEgPSByZXF1aXJlKFwiLi4vLi4vdGltZXVuaXRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuZnVuY3Rpb24gbmljZShzY2FsZVR5cGUsIGNoYW5uZWwsIGZpZWxkRGVmKSB7XG4gICAgaWYgKHV0aWwuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLlRJTUUsIHNjYWxlXzEuU2NhbGVUeXBlLlVUQ10sIHNjYWxlVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRpbWV1bml0XzEuc21hbGxlc3RVbml0KGZpZWxkRGVmLnRpbWVVbml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWwuY29udGFpbnMoW2NoYW5uZWxfMS5YLCBjaGFubmVsXzEuWV0sIGNoYW5uZWwpOyAvLyByZXR1cm4gdHJ1ZSBmb3IgcXVhbnRpdGF0aXZlIFgvWVxufVxuZXhwb3J0cy5uaWNlID0gbmljZTtcbmZ1bmN0aW9uIHBhZGRpbmcoY2hhbm5lbCwgc2NhbGVUeXBlLCBzY2FsZUNvbmZpZykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKFtjaGFubmVsXzEuWCwgY2hhbm5lbF8xLlldLCBjaGFubmVsKSkge1xuICAgICAgICBpZiAoc2NhbGVUeXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5QT0lOVCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlQ29uZmlnLnBvaW50UGFkZGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5wYWRkaW5nID0gcGFkZGluZztcbmZ1bmN0aW9uIHBhZGRpbmdJbm5lcihwYWRkaW5nLCBjaGFubmVsLCBzY2FsZUNvbmZpZykge1xuICAgIGlmIChwYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdXNlciBoYXMgYWxyZWFkeSBtYW51YWxseSBzcGVjaWZpZWQgXCJwYWRkaW5nXCIsIG5vIG5lZWQgdG8gYWRkIGRlZmF1bHQgcGFkZGluZ0lubmVyLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodXRpbC5jb250YWlucyhbY2hhbm5lbF8xLlgsIGNoYW5uZWxfMS5ZXSwgY2hhbm5lbCkpIHtcbiAgICAgICAgLy8gUGFkZGluZyBpcyBvbmx5IHNldCBmb3IgWCBhbmQgWSBieSBkZWZhdWx0LlxuICAgICAgICAvLyBCYXNpY2FsbHkgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGFkZCBwYWRkaW5nIGZvciBjb2xvciBhbmQgc2l6ZS5cbiAgICAgICAgLy8gcGFkZGluZ091dGVyIHdvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIGl0J3MgYSBiYW5kIHNjYWxlLCBqdXN0IHJldHVybiB0aGUgZGVmYXVsdCBmb3IgYmFuZFNjYWxlLlxuICAgICAgICByZXR1cm4gc2NhbGVDb25maWcuYmFuZFBhZGRpbmdJbm5lcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMucGFkZGluZ0lubmVyID0gcGFkZGluZ0lubmVyO1xuZnVuY3Rpb24gcGFkZGluZ091dGVyKHBhZGRpbmcsIGNoYW5uZWwsIHNjYWxlVHlwZSwgcGFkZGluZ0lubmVyLCBzY2FsZUNvbmZpZykge1xuICAgIGlmIChwYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdXNlciBoYXMgYWxyZWFkeSBtYW51YWxseSBzcGVjaWZpZWQgXCJwYWRkaW5nXCIsIG5vIG5lZWQgdG8gYWRkIGRlZmF1bHQgcGFkZGluZ091dGVyLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodXRpbC5jb250YWlucyhbY2hhbm5lbF8xLlgsIGNoYW5uZWxfMS5ZXSwgY2hhbm5lbCkpIHtcbiAgICAgICAgLy8gUGFkZGluZyBpcyBvbmx5IHNldCBmb3IgWCBhbmQgWSBieSBkZWZhdWx0LlxuICAgICAgICAvLyBCYXNpY2FsbHkgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGFkZCBwYWRkaW5nIGZvciBjb2xvciBhbmQgc2l6ZS5cbiAgICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuQkFORCkge1xuICAgICAgICAgICAgaWYgKHNjYWxlQ29uZmlnLmJhbmRQYWRkaW5nT3V0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZUNvbmZpZy5iYW5kUGFkZGluZ091dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogQnkgZGVmYXVsdCwgcGFkZGluZ091dGVyIGlzIHBhZGRpbmdJbm5lciAvIDIuIFRoZSByZWFzb24gaXMgdGhhdFxuICAgICAgICAgICAgICAgIHNpemUgKHdpZHRoL2hlaWdodCkgPSBzdGVwICogKGNhcmRpbmFsaXR5IC0gcGFkZGluZ0lubmVyICsgMiAqIHBhZGRpbmdPdXRlcikuXG4gICAgICAgICAgICAgICAgYW5kIHdlIHdhbnQgdGhlIHdpZHRoL2hlaWdodCB0byBiZSBpbnRlZ2VyIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgTm90ZSB0aGF0IHN0ZXAgKGJ5IGRlZmF1bHQpIGFuZCBjYXJkaW5hbGl0eSBhcmUgaW50ZWdlcnMuKSAqL1xuICAgICAgICAgICAgcmV0dXJuIHBhZGRpbmdJbm5lciAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMucGFkZGluZ091dGVyID0gcGFkZGluZ091dGVyO1xuZnVuY3Rpb24gcm91bmQoY2hhbm5lbCwgc2NhbGVDb25maWcpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhbJ3gnLCAneScsICdyb3cnLCAnY29sdW1uJ10sIGNoYW5uZWwpKSB7XG4gICAgICAgIHJldHVybiBzY2FsZUNvbmZpZy5yb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmZ1bmN0aW9uIHplcm8oc3BlY2lmaWVkU2NhbGUsIGNoYW5uZWwsIGZpZWxkRGVmKSB7XG4gICAgLy8gQnkgZGVmYXVsdCwgcmV0dXJuIHRydWUgb25seSBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvLyAxKSB1c2luZyBxdWFudGl0YXRpdmUgZmllbGQgd2l0aCBzaXplXG4gICAgLy8gV2hpbGUgdGhpcyBjYW4gYmUgZWl0aGVyIHJhdGlvIG9yIGludGVydmFsIGZpZWxkcywgb3VyIGFzc3VtcHRpb24gaXMgdGhhdFxuICAgIC8vIHJhdGlvIGFyZSBtb3JlIGNvbW1vbi5cbiAgICBpZiAoY2hhbm5lbCA9PT0gJ3NpemUnICYmIGZpZWxkRGVmLnR5cGUgPT09ICdxdWFudGl0YXRpdmUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyAyKSBub24tYmlubmVkLCBxdWFudGl0YXRpdmUgeC1zY2FsZSBvciB5LXNjYWxlIGlmIG5vIGN1c3RvbSBkb21haW4gaXMgcHJvdmlkZWQuXG4gICAgLy8gKEZvciBiaW5uaW5nLCB3ZSBzaG91bGQgbm90IGluY2x1ZGUgemVybyBieSBkZWZhdWx0IGJlY2F1c2UgYmlubmluZyBhcmUgY2FsY3VsYXRlZCB3aXRob3V0IHplcm8uXG4gICAgLy8gU2ltaWxhciwgaWYgdXNlcnMgZXhwbGljaXRseSBwcm92aWRlIGEgZG9tYWluIHJhbmdlLCB3ZSBzaG91bGQgbm90IGF1Z21lbnQgemVybyBhcyB0aGF0IHdpbGwgYmUgdW5leHBlY3RlZC4pXG4gICAgaWYgKCFzcGVjaWZpZWRTY2FsZS5kb21haW4gJiYgIWZpZWxkRGVmLmJpbiAmJiB1dGlsLmNvbnRhaW5zKFtjaGFubmVsXzEuWCwgY2hhbm5lbF8xLlldLCBjaGFubmVsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy56ZXJvID0gemVybztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNuVnNaWE11YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5elkyRnNaUzl5ZFd4bGN5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVVOQkxIbERRVUUwUXp0QlFVVTFReXh4UTBGQmIwVTdRVUZEY0VVc01rTkJRVFJETzBGQlF6VkRMR2xEUVVGdFF6dEJRVVZ1UXl4alFVRnhRaXhUUVVGdlFpeEZRVUZGTEU5QlFXZENMRVZCUVVVc1VVRkJNRUk3U1VGRGNrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxHbENRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6bEVMRTFCUVUwc1EwRkJReXgxUWtGQldTeERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVZFc1EwRkJRenRKUVVOb1JDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eFhRVUZETEVWQlFVVXNWMEZCUXl4RFFVRkRMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eHRRMEZCYlVNN1FVRkROVVVzUTBGQlF6dEJRVXhFTEc5Q1FVdERPMEZCUlVRc2FVSkJRWGRDTEU5QlFXZENMRVZCUVVVc1UwRkJiMElzUlVGQlJTeFhRVUYzUWp0SlFVTjBSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1YwRkJReXhGUVVGRkxGZEJRVU1zUTBGQlF5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4VFFVRlRMRXRCUVVzc2FVSkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNXVUZCV1N4RFFVRkRPMUZCUTJ4RExFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRCUVVOdVFpeERRVUZETzBGQlVFUXNNRUpCVDBNN1FVRkZSQ3h6UWtGQk5rSXNUMEZCWlN4RlFVRkZMRTlCUVdkQ0xFVkJRVWNzVjBGQmQwSTdTVUZEZGtZc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRNVUlzZVVaQlFYbEdPMUZCUTNwR0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZEYmtJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhYUVVGRExFVkJRVVVzVjBGQlF5eERRVUZETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMjVETERoRFFVRTRRenRSUVVNNVF5eHhSVUZCY1VVN1VVRkZja1VzYVVkQlFXbEhPMUZCUTJwSExFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU03U1VGRGRFTXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03UVVGRGJrSXNRMEZCUXp0QlFXUkVMRzlEUVdORE8wRkJSVVFzYzBKQlFUWkNMRTlCUVdVc1JVRkJSU3hQUVVGblFpeEZRVUZGTEZOQlFXOUNMRVZCUVVVc1dVRkJiMElzUlVGQlJTeFhRVUYzUWp0SlFVTnNTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNeFFpeDVSa0ZCZVVZN1VVRkRla1lzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExGZEJRVU1zUlVGQlJTeFhRVUZETEVOQlFVTXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJrTXNPRU5CUVRoRE8xRkJRemxETEhGRlFVRnhSVHRSUVVOeVJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4VFFVRlRMRXRCUVVzc2FVSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwRExFVkJRVVVzUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4blFrRkJaMElzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNdlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMR2RDUVVGblFpeERRVUZETzFsQlEzUkRMRU5CUVVNN1dVRkRSRHM3T3paRlFVZHBSVHRaUVVOcVJTeE5RVUZOTEVOQlFVTXNXVUZCV1N4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVNeFFpeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03UVVGRGJrSXNRMEZCUXp0QlFYSkNSQ3h2UTBGeFFrTTdRVUZGUkN4bFFVRnpRaXhQUVVGblFpeEZRVUZGTEZkQlFYZENPMGxCUXpsRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEV0QlFVc3NSVUZCUlN4UlFVRlJMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVRc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTTdTVUZETTBJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVV4RUxITkNRVXRETzBGQlJVUXNZMEZCY1VJc1kwRkJjVUlzUlVGQlJTeFBRVUZuUWl4RlFVRkZMRkZCUVRCQ08wbEJRM1JHTEhkRVFVRjNSRHRKUVVWNFJDeDNRMEZCZDBNN1NVRkRlRU1zTkVWQlFUUkZPMGxCUXpWRkxIbENRVUY1UWp0SlFVTjZRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NUVUZCVFN4SlFVRkpMRkZCUVZFc1EwRkJReXhKUVVGSkxFdEJRVXNzWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXpSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVkVMR3RHUVVGclJqdEpRVU5zUml4dFIwRkJiVWM3U1VGRGJrY3NLMGRCUVN0SE8wbEJReTlITEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVTBzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRWxCUVVrc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEZkQlFVTXNSVUZCUlN4WFFVRkRMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VVc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU5rTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRV3BDUkN4dlFrRnBRa01pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB0aW1ldW5pdF8xID0gcmVxdWlyZShcIi4uLy4uL3RpbWV1bml0XCIpO1xudmFyIHNjYWxlXzIgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlcmUgaXMgYSBzcGVjaWZpZWQgc2NhbGUgdHlwZSBhbmQgaWYgaXQgaXMgYXBwcm9wcmlhdGUsXG4gKiBvciBkZXRlcm1pbmUgZGVmYXVsdCB0eXBlIGlmIHR5cGUgaXMgdW5zcGVjaWZpZWQgb3IgaW5hcHByb3ByaWF0ZS5cbiAqL1xuLy8gTk9URTogQ29tcGFzc1FMIHVzZXMgdGhpcyBtZXRob2QuXG5mdW5jdGlvbiB0eXBlKHNwZWNpZmllZFR5cGUsIGNoYW5uZWwsIGZpZWxkRGVmLCBtYXJrLCBoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpIHtcbiAgICB2YXIgZGVmYXVsdFNjYWxlVHlwZSA9IGRlZmF1bHRUeXBlKGNoYW5uZWwsIGZpZWxkRGVmLCBtYXJrLCBoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpO1xuICAgIGlmICghY2hhbm5lbF8xLmhhc1NjYWxlKGNoYW5uZWwpKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHNjYWxlIGZvciB0aGVzZSBjaGFubmVsc1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHNwZWNpZmllZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDaGVjayBpZiBleHBsaWNpdGx5IHNwZWNpZmllZCBzY2FsZSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgY2hhbm5lbFxuICAgICAgICBpZiAoIWNoYW5uZWxfMS5zdXBwb3J0U2NhbGVUeXBlKGNoYW5uZWwsIHNwZWNpZmllZFR5cGUpKSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aENoYW5uZWwoY2hhbm5lbCwgc3BlY2lmaWVkVHlwZSwgZGVmYXVsdFNjYWxlVHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTY2FsZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgZXhwbGljaXRseSBzcGVjaWZpZWQgc2NhbGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGRhdGEgdHlwZVxuICAgICAgICBpZiAoIWZpZWxkRGVmTWF0Y2hTY2FsZVR5cGUoc3BlY2lmaWVkVHlwZSwgZmllbGREZWYpKSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aEZpZWxkRGVmKHNwZWNpZmllZFR5cGUsIGRlZmF1bHRTY2FsZVR5cGUpKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2NhbGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGVjaWZpZWRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFNjYWxlVHlwZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGU7XG4vKipcbiAqIERldGVybWluZSBhcHByb3ByaWF0ZSBkZWZhdWx0IHNjYWxlIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUeXBlKGNoYW5uZWwsIGZpZWxkRGVmLCBtYXJrLCBoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhbJ3JvdycsICdjb2x1bW4nXSwgY2hhbm5lbCkpIHtcbiAgICAgICAgcmV0dXJuICdiYW5kJztcbiAgICB9XG4gICAgc3dpdGNoIChmaWVsZERlZi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ25vbWluYWwnOlxuICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09ICdjb2xvcicgfHwgY2hhbm5lbF8xLnJhbmdlVHlwZShjaGFubmVsKSA9PT0gJ2Rpc2NyZXRlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb3JkaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlzY3JldGVUb0NvbnRpbnVvdXNUeXBlKGNoYW5uZWwsIG1hcmssIGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ29yZGluYWwnOlxuICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29yZGluYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbF8xLnJhbmdlVHlwZShjaGFubmVsKSA9PT0gJ2Rpc2NyZXRlJykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZShjaGFubmVsLCAnb3JkaW5hbCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29yZGluYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpc2NyZXRlVG9Db250aW51b3VzVHlwZShjaGFubmVsLCBtYXJrLCBoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpO1xuICAgICAgICBjYXNlICd0ZW1wb3JhbCc6XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgYHNlcXVlbnRpYWxgIGFzIHRoZSBkZWZhdWx0IGNvbG9yIHNjYWxlIGZvciBjb250aW51b3VzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCBzdXBwb3J0cyBib3RoIGFycmF5IHJhbmdlIGFuZCBzY2hlbWUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuICdzZXF1ZW50aWFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxfMS5yYW5nZVR5cGUoY2hhbm5lbCkgPT09ICdkaXNjcmV0ZScpIHtcbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5kaXNjcmV0ZUNoYW5uZWxDYW5ub3RFbmNvZGUoY2hhbm5lbCwgJ3RlbXBvcmFsJykpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIHF1YW50aXplIChlcXVpdmFsZW50IHRvIGJpbm5pbmcpIG9uY2Ugd2UgaGF2ZSBpdFxuICAgICAgICAgICAgICAgIHJldHVybiAnb3JkaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZXVuaXRfMS5pc0Rpc2NyZXRlQnlEZWZhdWx0KGZpZWxkRGVmLnRpbWVVbml0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXNjcmV0ZVRvQ29udGludW91c1R5cGUoY2hhbm5lbCwgbWFyaywgaGFzVG9wTGV2ZWxTaXplLCBzcGVjaWZpZWRSYW5nZVN0ZXAsIHNjYWxlQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAndGltZSc7XG4gICAgICAgIGNhc2UgJ3F1YW50aXRhdGl2ZSc6XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZERlZi5iaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdiaW4tb3JkaW5hbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVzZSBgc2VxdWVudGlhbGAgYXMgdGhlIGRlZmF1bHQgY29sb3Igc2NhbGUgZm9yIGNvbnRpbnVvdXMgZGF0YVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IHN1cHBvcnRzIGJvdGggYXJyYXkgcmFuZ2UgYW5kIHNjaGVtZSByYW5nZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NlcXVlbnRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbF8xLnJhbmdlVHlwZShjaGFubmVsKSA9PT0gJ2Rpc2NyZXRlJykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZShjaGFubmVsLCAncXVhbnRpdGF0aXZlJykpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIHF1YW50aXplIChlcXVpdmFsZW50IHRvIGJpbm5pbmcpIG9uY2Ugd2UgaGF2ZSBpdFxuICAgICAgICAgICAgICAgIHJldHVybiAnb3JkaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdiaW4tbGluZWFyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnbGluZWFyJztcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciByZWFjaCB0aGlzICovXG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLmludmFsaWRGaWVsZFR5cGUoZmllbGREZWYudHlwZSkpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGRlZmF1bHQgc2NhbGUgdHlwZSBmb3Igbm9taW5hbC9vcmRpbmFsIGZpZWxkLlxuICogQHJldHVybnMgQkFORCBvciBQT0lOVCBzY2FsZSBiYXNlZCBvbiBjaGFubmVsLCBtYXJrLCBhbmQgcmFuZ2VTdGVwXG4gKi9cbmZ1bmN0aW9uIGRpc2NyZXRlVG9Db250aW51b3VzVHlwZShjaGFubmVsLCBtYXJrLCBoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhbJ3gnLCAneSddLCBjaGFubmVsKSkge1xuICAgICAgICBpZiAobWFyayA9PT0gJ3JlY3QnKSB7XG4gICAgICAgICAgICAvLyBUaGUgcmVjdCBtYXJrIHNob3VsZCBmaXQgaW50byBhIGJhbmQuXG4gICAgICAgICAgICByZXR1cm4gJ2JhbmQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrID09PSAnYmFyJykge1xuICAgICAgICAgICAgLy8gRm9yIGJhciwgdXNlIGJhbmQgb25seSBpZiB0aGVyZSBpcyBubyByYW5nZVN0ZXAgc2luY2Ugd2UgbmVlZCB0byB1c2UgYmFuZCBmb3IgZml0IG1vZGUuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBmb3Igbm9uLWZpdCBtb2RlLCBwb2ludCBzY2FsZSBwcm92aWRlcyBiZXR0ZXIgY2VudGVyIHBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKGhhdmVSYW5nZVN0ZXAoaGFzVG9wTGV2ZWxTaXplLCBzcGVjaWZpZWRSYW5nZVN0ZXAsIHNjYWxlQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncG9pbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdiYW5kJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBvcmRpbmFsIHBvaW50IHNjYWxlIHNvIHdlIGNhbiBlYXNpbHkgZ2V0IGNlbnRlciBwb3NpdGlvbnMgb2YgdGhlIG1hcmtzLlxuICAgIHJldHVybiAncG9pbnQnO1xufVxuZnVuY3Rpb24gaGF2ZVJhbmdlU3RlcChoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpIHtcbiAgICBpZiAoaGFzVG9wTGV2ZWxTaXplKSB7XG4gICAgICAgIC8vIGlmIHRvcExldmVsU2l6ZSBpcyBwcm92aWRlZCwgcmFuZ2VTdGVwIHdpbGwgYmUgZHJvcHBlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3BlY2lmaWVkUmFuZ2VTdGVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllZFJhbmdlU3RlcCAhPT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICEhc2NhbGVDb25maWcucmFuZ2VTdGVwO1xufVxuZnVuY3Rpb24gZmllbGREZWZNYXRjaFNjYWxlVHlwZShzcGVjaWZpZWRUeXBlLCBmaWVsZERlZikge1xuICAgIHZhciB0eXBlID0gZmllbGREZWYudHlwZTtcbiAgICBpZiAodXRpbF8xLmNvbnRhaW5zKFt0eXBlXzEuVHlwZS5PUkRJTkFMLCB0eXBlXzEuVHlwZS5OT01JTkFMXSwgdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllZFR5cGUgPT09IHVuZGVmaW5lZCB8fCBzY2FsZV8yLmhhc0Rpc2NyZXRlRG9tYWluKHNwZWNpZmllZFR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSB0eXBlXzEuVHlwZS5URU1QT1JBTCkge1xuICAgICAgICBpZiAoIWZpZWxkRGVmLnRpbWVVbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKFtzY2FsZV8xLlNjYWxlVHlwZS5USU1FLCBzY2FsZV8xLlNjYWxlVHlwZS5VVEMsIHVuZGVmaW5lZF0sIHNwZWNpZmllZFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5jb250YWlucyhbc2NhbGVfMS5TY2FsZVR5cGUuVElNRSwgc2NhbGVfMS5TY2FsZVR5cGUuVVRDLCB1bmRlZmluZWRdLCBzcGVjaWZpZWRUeXBlKSB8fCBzY2FsZV8yLmhhc0Rpc2NyZXRlRG9tYWluKHNwZWNpZmllZFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IHR5cGVfMS5UeXBlLlFVQU5USVRBVElWRSkge1xuICAgICAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY2lmaWVkVHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuQklOX0xJTkVBUiB8fCBzcGVjaWZpZWRUeXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CSU5fT1JESU5BTDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKFtzY2FsZV8xLlNjYWxlVHlwZS5MT0csIHNjYWxlXzEuU2NhbGVUeXBlLlBPVywgc2NhbGVfMS5TY2FsZVR5cGUuU1FSVCwgc2NhbGVfMS5TY2FsZVR5cGUuUVVBTlRJTEUsIHNjYWxlXzEuU2NhbGVUeXBlLlFVQU5USVpFLCBzY2FsZV8xLlNjYWxlVHlwZS5MSU5FQVIsIHVuZGVmaW5lZF0sIHNwZWNpZmllZFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZmllbGREZWZNYXRjaFNjYWxlVHlwZSA9IGZpZWxkRGVmTWF0Y2hTY2FsZVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSGx3WlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwzTmpZV3hsTDNSNWNHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTd3JRa0ZCYVVNN1FVRkZha01zZVVOQlFUWkZPMEZCUlRkRkxIRkRRVUZ0UkR0QlFVTnVSQ3d5UTBGQmJVUTdRVUZIYmtRc2NVTkJRVGhETzBGQlF6bERMRzFEUVVGblF6dEJRVU5vUXl4cFEwRkJiVU03UVVGRGJrTXNiVU5CUVc5RE8wRkJTWEJET3pzN1IwRkhSenRCUVVOSUxHOURRVUZ2UXp0QlFVTndReXhqUVVORkxHRkJRWGRDTEVWQlFVVXNUMEZCWjBJc1JVRkJSU3hSUVVFd1FpeEZRVUZGTEVsQlFWVXNSVUZEYkVZc1pVRkJkMElzUlVGQlJTeHJRa0ZCTUVJc1JVRkJSU3hYUVVGM1FqdEpRVVU1UlN4SlFVRk5MR2RDUVVGblFpeEhRVUZITEZkQlFWY3NRMEZCUXl4UFFVRlBMRVZCUVVVc1VVRkJVU3hGUVVGRkxFbEJRVWtzUlVGQlJTeGxRVUZsTEVWQlFVVXNhMEpCUVd0Q0xFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdTVUZGYUVnc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eHJRa0ZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4yUWl4MVEwRkJkVU03VVVGRGRrTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4aFFVRmhMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5vUXl4MVJVRkJkVVU3VVVGRGRrVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXd3UWtGQlowSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1lVRkJZU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bERMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl3eVFrRkJNa0lzUTBGQlF5eFBRVUZQTEVWQlFVVXNZVUZCWVN4RlFVRkZMR2RDUVVGblFpeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTFSaXhOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNN1VVRkRNVUlzUTBGQlF6dFJRVVZFTEhsRlFVRjVSVHRSUVVONlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSE5DUVVGelFpeERRVUZETEdGQlFXRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNrUXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETERSQ1FVRTBRaXhEUVVGRExHRkJRV0VzUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFWXNUVUZCVFN4RFFVRkRMR2RDUVVGblFpeERRVUZETzFGQlF6RkNMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETzBsQlEzWkNMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNN1FVRkRNVUlzUTBGQlF6dEJRVE5DUkN4MVFrRXlRa003UVVGRlJEczdSMEZGUnp0QlFVTklMSEZDUVVGeFFpeFBRVUZuUWl4RlFVRkZMRkZCUVRCQ0xFVkJRVVVzU1VGQlZTeEZRVU16UlN4bFFVRjNRaXhGUVVGRkxHdENRVUV3UWl4RlFVRkZMRmRCUVhkQ08wbEJSVGxGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RFFVRkRMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6bERMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGFFSXNRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFdEJRVXNzVTBGQlV6dFpRVU5hTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhQUVVGUExFbEJRVWtzYlVKQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJTeXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTTNSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzFsQlEyNUNMRU5CUVVNN1dVRkRSQ3hOUVVGTkxFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1QwRkJUeXhGUVVGRkxFbEJRVWtzUlVGQlJTeGxRVUZsTEVWQlFVVXNhMEpCUVd0Q0xFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZGYmtjc1MwRkJTeXhUUVVGVE8xbEJRMW9zUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzaENMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03V1VGRGJrSXNRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHRRa0ZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpkRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXd5UWtGQk1rSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVVc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dFpRVU51UWl4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExIZENRVUYzUWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFVkJRVVVzWlVGQlpTeEZRVUZGTEd0Q1FVRnJRaXhGUVVGRkxGZEJRVmNzUTBGQlF5eERRVUZETzFGQlJXNUhMRXRCUVVzc1ZVRkJWVHRaUVVOaUxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU40UWl4NVJVRkJlVVU3WjBKQlEzcEZMSFZFUVVGMVJEdG5Ra0ZEZGtRc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF6dFpRVU4wUWl4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEcxQ1FVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkROME1zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExESkNRVUV5UWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjJSU3gzUlVGQmQwVTdaMEpCUTNoRkxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZEYmtJc1EwRkJRenRaUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETERoQ1FVRnRRaXhEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRek5ETEUxQlFVMHNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eFBRVUZQTEVWQlFVVXNTVUZCU1N4RlFVRkZMR1ZCUVdVc1JVRkJSU3hyUWtGQmEwSXNSVUZCUlN4WFFVRlhMRU5CUVVNc1EwRkJRenRaUVVOdVJ5eERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVWb1FpeExRVUZMTEdOQlFXTTdXVUZEYWtJc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eExRVUZMTEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM2hDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTnFRaXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETzJkQ1FVTjJRaXhEUVVGRE8yZENRVU5FTEd0RlFVRnJSVHRuUWtGRGJFVXNkVVJCUVhWRU8yZENRVU4yUkN4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRE8xbEJRM1JDTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zYlVKQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJTeXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTTNReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc01rSkJRVEpDTEVOQlFVTXNUMEZCVHl4RlFVRkZMR05CUVdNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6TkZMSGRGUVVGM1JUdG5Ra0ZEZUVVc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dFpRVU51UWl4RFFVRkRPMWxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnBDTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNN1dVRkRkRUlzUTBGQlF6dFpRVU5FTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1NVRkRjRUlzUTBGQlF6dEpRVVZFTEcxRVFVRnRSRHRKUVVOdVJDeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZETDBRc1EwRkJRenRCUVVWRU96czdSMEZIUnp0QlFVTklMR3REUVVOSkxFOUJRV2RDTEVWQlFVVXNTVUZCVlN4RlFVRkZMR1ZCUVhkQ0xFVkJRM1JFTEd0Q1FVRXdRaXhGUVVGRkxGZEJRWGRDTzBsQlJYUkVMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNaRExFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JDTEhkRFFVRjNRenRaUVVONFF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTJoQ0xFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UWl3d1JrRkJNRVk3V1VGRE1VWXNNRVZCUVRCRk8xbEJRekZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMR0ZCUVdFc1EwRkJReXhsUVVGbExFVkJRVVVzYTBKQlFXdENMRVZCUVVVc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTndSU3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzFsQlEycENMRU5CUVVNN1dVRkRSQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlEyaENMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzZVVaQlFYbEdPMGxCUTNwR0xFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTTdRVUZEYWtJc1EwRkJRenRCUVVWRUxIVkNRVUYxUWl4bFFVRjNRaXhGUVVGRkxHdENRVUV3UWl4RlFVRkZMRmRCUVhkQ08wbEJRMjVITEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNFSXNNRVJCUVRCRU8xRkJRekZFTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1NVRkRaaXhEUVVGRE8wbEJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNhMEpCUVd0Q0xFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlReXhOUVVGTkxFTkJRVU1zYTBKQlFXdENMRXRCUVVzc1NVRkJTU3hEUVVGRE8wbEJRM0pETEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYWtNc1EwRkJRenRCUVVWRUxHZERRVUYxUXl4aFFVRjNRaXhGUVVGRkxGRkJRVEJDTzBsQlEzcEdMRWxCUVUwc1NVRkJTU3hIUVVGVExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEYWtNc1JVRkJSU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNWMEZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSU3hYUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBFTEUxQlFVMHNRMEZCUXl4aFFVRmhMRXRCUVVzc1UwRkJVeXhKUVVGSkxIbENRVUZwUWl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8wbEJRM3BGTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEZkQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZGtJc1RVRkJUU3hEUVVGRExHVkJRVkVzUTBGQlF5eERRVUZETEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxHbENRVUZUTEVOQlFVTXNSMEZCUnl4RlFVRkZMRk5CUVZNc1EwRkJReXhGUVVGRkxHRkJRV0VzUTBGQlF5eERRVUZETzFGQlF6ZEZMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEUxQlFVMHNRMEZCUXl4bFFVRlJMRU5CUVVNc1EwRkJReXhwUWtGQlV5eERRVUZETEVsQlFVa3NSVUZCUlN4cFFrRkJVeXhEUVVGRExFZEJRVWNzUlVGQlJTeFRRVUZUTEVOQlFVTXNSVUZCUlN4aFFVRmhMRU5CUVVNc1NVRkJTU3g1UWtGQmFVSXNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVOcVNDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NWMEZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtJc1RVRkJUU3hEUVVGRExHRkJRV0VzUzBGQlN5eHBRa0ZCVXl4RFFVRkRMRlZCUVZVc1NVRkJTU3hoUVVGaExFdEJRVXNzYVVKQlFWTXNRMEZCUXl4WFFVRlhMRU5CUVVNN1VVRkRNMFlzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4bFFVRlJMRU5CUVVNc1EwRkJReXhwUWtGQlV5eERRVUZETEVkQlFVY3NSVUZCUlN4cFFrRkJVeXhEUVVGRExFZEJRVWNzUlVGQlJTeHBRa0ZCVXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hwUWtGQlV5eERRVUZETEZGQlFWRXNSVUZCUlN4cFFrRkJVeXhEUVVGRExGRkJRVkVzUlVGQlJTeHBRa0ZCVXl4RFFVRkRMRTFCUVUwc1JVRkJSU3hUUVVGVExFTkJRVU1zUlVGQlJTeGhRVUZoTEVOQlFVTXNRMEZCUXp0SlFVTjBTaXhEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRnNRa1FzZDBSQmEwSkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2VsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25cIik7XG52YXIgc2NhbGVzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1zL3NjYWxlc1wiKTtcbmV4cG9ydHMuQlJVU0ggPSAnX2JydXNoJywgZXhwb3J0cy5TSVpFID0gJ19zaXplJztcbnZhciBpbnRlcnZhbCA9IHtcbiAgICBwcmVkaWNhdGU6ICd2bEludGVydmFsJyxcbiAgICBzaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIHNpZ25hbHMgPSBbXSwgaW50ZXJ2YWxzID0gW10sIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHNpemUgPSBuYW1lICsgZXhwb3J0cy5TSVpFO1xuICAgICAgICBpZiAoc2VsQ21wdC50cmFuc2xhdGUgJiYgIShzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSkpIHtcbiAgICAgICAgICAgIGV2ZW50cyhzZWxDbXB0LCBmdW5jdGlvbiAoXywgZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBldnQuYmV0d2VlblswXS5maWx0ZXIgfHwgKGV2dC5iZXR3ZWVuWzBdLmZpbHRlciA9IFtdKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goJyFldmVudC5pdGVtIHx8IChldmVudC5pdGVtICYmICcgK1xuICAgICAgICAgICAgICAgICAgICAoXCJldmVudC5pdGVtLm1hcmsubmFtZSAhPT0gXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUobmFtZSArIGV4cG9ydHMuQlJVU0gpICsgXCIpXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbENtcHQucHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocC5lbmNvZGluZyAhPT0gY2hhbm5lbF8xLlggJiYgcC5lbmNvZGluZyAhPT0gY2hhbm5lbF8xLlkpIHtcbiAgICAgICAgICAgICAgICBsb2dfMS53YXJuKCdJbnRlcnZhbCBzZWxlY3Rpb25zIG9ubHkgc3VwcG9ydCB4IGFuZCB5IGVuY29kaW5nIGNoYW5uZWxzLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcyA9IGNoYW5uZWxTaWduYWwobW9kZWwsIHNlbENtcHQsIHAuZW5jb2RpbmcpO1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKGNzKTtcbiAgICAgICAgICAgIGludGVydmFscy5wdXNoKFwie2VuY29kaW5nOiBcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShwLmVuY29kaW5nKSArIFwiLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZmllbGQ6IFwiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKHAuZmllbGQpICsgXCIsIGV4dGVudDogXCIgKyBjcy5uYW1lICsgXCJ9XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzaXplLFxuICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgb246IGV2ZW50cyhzZWxDbXB0LCBmdW5jdGlvbiAob24sIGV2dCkge1xuICAgICAgICAgICAgICAgIG9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2dC5iZXR3ZWVuWzBdLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6ICd7eDogeCh1bml0KSwgeTogeSh1bml0KSwgd2lkdGg6IDAsIGhlaWdodDogMH0nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZ0LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IFwie3g6IFwiICsgc2l6ZSArIFwiLngsIHk6IFwiICsgc2l6ZSArIFwiLnksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIndpZHRoOiBhYnMoeCh1bml0KSAtIFwiICsgc2l6ZSArIFwiLngpLCBoZWlnaHQ6IGFicyh5KHVuaXQpIC0gXCIgKyBzaXplICsgXCIueSl9XCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHVwZGF0ZTogXCJbXCIgKyBpbnRlcnZhbHMuam9pbignLCAnKSArIFwiXVwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmFscztcbiAgICB9LFxuICAgIHR1cGxlRXhwcjogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBcImludGVydmFsczogXCIgKyBzZWxDbXB0Lm5hbWU7XG4gICAgfSxcbiAgICBtb2RpZnlFeHByOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIHRwbCA9IHNlbENtcHQubmFtZSArIHNlbGVjdGlvbl8xLlRVUExFO1xuICAgICAgICByZXR1cm4gdHBsICsgJywgJyArXG4gICAgICAgICAgICAoc2VsQ21wdC5yZXNvbHZlID09PSAnZ2xvYmFsJyA/ICd0cnVlJyA6IFwie3VuaXQ6IFwiICsgdHBsICsgXCIudW5pdH1cIik7XG4gICAgfSxcbiAgICBtYXJrczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBtYXJrcykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgX2EgPSBwcm9qZWN0aW9ucyhzZWxDbXB0KSwgeGkgPSBfYS54aSwgeWkgPSBfYS55aSwgdHBsID0gbmFtZSArIHNlbGVjdGlvbl8xLlRVUExFLCBzdG9yZSA9IFwiZGF0YShcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShzZWxDbXB0Lm5hbWUgKyBzZWxlY3Rpb25fMS5TVE9SRSkgKyBcIilcIjtcbiAgICAgICAgLy8gRG8gbm90IGFkZCBhIGJydXNoIGlmIHdlJ3JlIGJpbmRpbmcgdG8gc2NhbGVzLlxuICAgICAgICBpZiAoc2NhbGVzXzEuZGVmYXVsdC5oYXMoc2VsQ21wdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXJrcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICAgICAgeDogdXRpbF8xLmV4dGVuZCh7fSwgeGkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgIHsgc2NhbGU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuWCksIHNpZ25hbDogbmFtZSArIFwiW1wiICsgeGkgKyBcIl0uZXh0ZW50WzBdXCIgfSA6XG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogMCB9KSxcbiAgICAgICAgICAgIHgyOiB1dGlsXzEuZXh0ZW5kKHt9LCB4aSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgeyBzY2FsZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5YKSwgc2lnbmFsOiBuYW1lICsgXCJbXCIgKyB4aSArIFwiXS5leHRlbnRbMV1cIiB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB7IGdyb3VwOiAnd2lkdGgnIH0gfSksXG4gICAgICAgICAgICB5OiB1dGlsXzEuZXh0ZW5kKHt9LCB5aSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgeyBzY2FsZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ZKSwgc2lnbmFsOiBuYW1lICsgXCJbXCIgKyB5aSArIFwiXS5leHRlbnRbMF1cIiB9IDpcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiAwIH0pLFxuICAgICAgICAgICAgeTI6IHV0aWxfMS5leHRlbmQoe30sIHlpICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICB7IHNjYWxlOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlkpLCBzaWduYWw6IG5hbWUgKyBcIltcIiArIHlpICsgXCJdLmV4dGVudFsxXVwiIH0gOlxuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHsgZ3JvdXA6ICdoZWlnaHQnIH0gfSlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyByZXNvbHZlZCB0byBnbG9iYWwsIG9ubHkgYSBzaW5nbGUgaW50ZXJ2YWwgaXMgaW5cbiAgICAgICAgLy8gdGhlIHN0b3JlLiBXcmFwIGJydXNoIG1hcmsncyBlbmNvZGluZ3Mgd2l0aCBhIHByb2R1Y3Rpb24gcnVsZSB0byB0ZXN0XG4gICAgICAgIC8vIHRoaXMgYmFzZWQgb24gdGhlIGB1bml0YCBwcm9wZXJ0eS4gSGlkZSB0aGUgYnJ1c2ggbWFyayBpZiBpdCBjb3JyZXNwb25kc1xuICAgICAgICAvLyB0byBhIHVuaXQgZGlmZmVyZW50IGZyb20gdGhlIG9uZSBpbiB0aGUgc3RvcmUuXG4gICAgICAgIGlmIChzZWxDbXB0LnJlc29sdmUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICB1dGlsXzEua2V5cyh1cGRhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gW3RzbGliXzEuX19hc3NpZ24oeyB0ZXN0OiBzdG9yZSArIFwiLmxlbmd0aCAmJiBcIiArIHRwbCArIFwiICYmIFwiICsgdHBsICsgXCIudW5pdCA9PT0gXCIgKyBzdG9yZSArIFwiWzBdLnVuaXRcIiB9LCB1cGRhdGVba2V5XSksIHsgdmFsdWU6IDAgfV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgICAgICBlbnRlcjogeyBmaWxsOiB7IHZhbHVlOiAnI2VlZScgfSB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLmNvbmNhdChtYXJrcywge1xuICAgICAgICAgICAgbmFtZTogbmFtZSArIGV4cG9ydHMuQlJVU0gsXG4gICAgICAgICAgICB0eXBlOiAncmVjdCcsXG4gICAgICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgICAgICBlbnRlcjogeyBmaWxsOiB7IHZhbHVlOiAndHJhbnNwYXJlbnQnIH0gfSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaW50ZXJ2YWw7XG5mdW5jdGlvbiBwcm9qZWN0aW9ucyhzZWxDbXB0KSB7XG4gICAgdmFyIHggPSBudWxsLCB4aSA9IG51bGwsIHkgPSBudWxsLCB5aSA9IG51bGw7XG4gICAgc2VsQ21wdC5wcm9qZWN0LmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgaWYgKHAuZW5jb2RpbmcgPT09IGNoYW5uZWxfMS5YKSB7XG4gICAgICAgICAgICB4ID0gcDtcbiAgICAgICAgICAgIHhpID0gaTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwLmVuY29kaW5nID09PSBjaGFubmVsXzEuWSkge1xuICAgICAgICAgICAgeSA9IHA7XG4gICAgICAgICAgICB5aSA9IGk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyB4OiB4LCB4aTogeGksIHk6IHksIHlpOiB5aSB9O1xufVxuZXhwb3J0cy5wcm9qZWN0aW9ucyA9IHByb2plY3Rpb25zO1xuZnVuY3Rpb24gY2hhbm5lbFNpZ25hbChtb2RlbCwgc2VsQ21wdCwgY2hhbm5lbCkge1xuICAgIHZhciBuYW1lID0gc2VsZWN0aW9uXzEuY2hhbm5lbFNpZ25hbE5hbWUoc2VsQ21wdCwgY2hhbm5lbCksIHNpemUgPSBtb2RlbC5nZXRTaXplU2lnbmFsUmVmKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gJ3dpZHRoJyA6ICdoZWlnaHQnKS5zaWduYWwsIGNvb3JkID0gY2hhbm5lbCArIFwiKHVuaXQpXCIsIGludmVydCA9IHNlbGVjdGlvbl8xLmludmVydC5iaW5kKG51bGwsIG1vZGVsLCBzZWxDbXB0LCBjaGFubmVsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIG9uOiBzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSA/IFtdIDogZXZlbnRzKHNlbENtcHQsIGZ1bmN0aW9uIChvbiwgZXZ0KSB7XG4gICAgICAgICAgICBvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBldmVudHM6IGV2dC5iZXR3ZWVuWzBdLFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogaW52ZXJ0KFwiW1wiICsgY29vcmQgKyBcIiwgXCIgKyBjb29yZCArIFwiXVwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICBldmVudHM6IGV2dCxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IFwiW1wiICsgbmFtZSArIFwiWzBdLCBcIiArIGludmVydChcImNsYW1wKFwiICsgY29vcmQgKyBcIiwgMCwgXCIgKyBzaXplICsgXCIpXCIpICsgJ10nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvbjtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZXZlbnRzKHNlbENtcHQsIGNiKSB7XG4gICAgcmV0dXJuIHNlbENtcHQuZXZlbnRzLnJlZHVjZShmdW5jdGlvbiAob24sIGV2dCkge1xuICAgICAgICBpZiAoIWV2dC5iZXR3ZWVuKSB7XG4gICAgICAgICAgICBsb2dfMS53YXJuKGV2dCArIFwiIGlzIG5vdCBhbiBvcmRlcmVkIGV2ZW50IHN0cmVhbSBmb3IgaW50ZXJ2YWwgc2VsZWN0aW9uc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2Iob24sIGV2dCk7XG4gICAgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1MFpYSjJZV3d1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5elpXeGxZM1JwYjI0dmFXNTBaWEoyWVd3dWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc2VVTkJRVFJETzBGQlF6VkRMR2xEUVVFclFqdEJRVU12UWl4dFEwRkJjVVE3UVVGRmNrUXNlVU5CUVhsSk8wRkJRM3BKTERoRFFVRjVRenRCUVVVMVFpeFJRVUZCTEV0QlFVc3NSMEZCUnl4UlFVRlJMRVZCUXpOQ0xGRkJRVUVzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXp0QlFVVnFRaXhKUVVGTkxGRkJRVkVzUjBGQmNVSTdTVUZEYWtNc1UwRkJVeXhGUVVGRkxGbEJRVms3U1VGRmRrSXNUMEZCVHl4RlFVRkZMRlZCUVZNc1MwRkJTeXhGUVVGRkxFOUJRVTg3VVVGRE9VSXNTVUZCVFN4UFFVRlBMRWRCUVZVc1JVRkJSU3hGUVVOeVFpeFRRVUZUTEVkQlFWTXNSVUZCUlN4RlFVTndRaXhKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZEYmtJc1NVRkJTU3hIUVVGSExFbEJRVWtzUjBGQlJ5eFpRVUZKTEVOQlFVTTdVVUZGZGtJc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1owSkJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFUXNUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hWUVVGVExFTkJRVkVzUlVGQlJTeEhRVUZSTzJkQ1FVTjZReXhKUVVGTkxFOUJRVThzUjBGQlJ5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOMFJTeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMR2REUVVGblF6dHhRa0ZETTBNc09FSkJRVFJDTEd0Q1FVRlhMRU5CUVVNc1NVRkJTU3hIUVVGSExHRkJRVXNzUTBGQlF5eE5RVUZITEVOQlFVRXNRMEZCUXl4RFFVRkRPMWxCUXpsRUxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEwd3NRMEZCUXp0UlFVVkVMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWTXNRMEZCUXp0WlFVTm9ReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4TFFVRkxMRmRCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zVVVGQlVTeExRVUZMTEZkQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM3BETEZWQlFVa3NRMEZCUXl3MlJFRkJOa1FzUTBGQlF5eERRVUZETzJkQ1FVTndSU3hOUVVGTkxFTkJRVU03V1VGRFZDeERRVUZETzFsQlJVUXNTVUZCVFN4RlFVRkZMRWRCUVVjc1lVRkJZU3hEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8xbEJRM0pFTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGFrSXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQll5eHJRa0ZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlNUdHBRa0ZEZUVRc1dVRkJWU3hyUWtGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc2EwSkJRV0VzUlVGQlJTeERRVUZETEVsQlFVa3NUVUZCUnl4RFFVRkJMRU5CUVVNc1EwRkJRenRSUVVONlJDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU03V1VGRFdDeEpRVUZKTEVWQlFVVXNTVUZCU1R0WlFVTldMRXRCUVVzc1JVRkJSU3hGUVVGRk8xbEJRMVFzUlVGQlJTeEZRVUZGTEUxQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJVeXhGUVVGVExFVkJRVVVzUjBGQlVUdG5Ra0ZET1VNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF6dHZRa0ZEVGl4TlFVRk5MRVZCUVVVc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNSQ0xFMUJRVTBzUlVGQlJTd3JRMEZCSzBNN2FVSkJRM2hFTEVOQlFVTXNRMEZCUXp0blFrRkZTQ3hGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETzI5Q1FVTk9MRTFCUVUwc1JVRkJSU3hIUVVGSE8yOUNRVU5ZTEUxQlFVMHNSVUZCUlN4VFFVRlBMRWxCUVVrc1pVRkJWU3hKUVVGSkxGTkJRVTA3ZVVKQlEzUkRMREJDUVVGM1FpeEpRVUZKTEcxRFFVRTRRaXhKUVVGSkxGTkJRVTBzUTBGQlFUdHBRa0ZEZEVVc1EwRkJReXhEUVVGRE8yZENRVVZJTEUxQlFVMHNRMEZCUXl4RlFVRkZMRU5CUVVNN1dVRkRXaXhEUVVGRExFTkJRVU03VTBGRFNDeEZRVUZGTzFsQlEwUXNTVUZCU1N4RlFVRkZMRWxCUVVrN1dVRkRWaXhOUVVGTkxFVkJRVVVzVFVGQlNTeFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGSE8xTkJRM0JETEVOQlFVTXNRMEZCUXp0UlFVVklMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRGFrSXNRMEZCUXp0SlFVVkVMRk5CUVZNc1JVRkJSU3hWUVVGVExFdEJRVXNzUlVGQlJTeFBRVUZQTzFGQlEyaERMRTFCUVUwc1EwRkJReXhuUWtGQll5eFBRVUZQTEVOQlFVTXNTVUZCVFN4RFFVRkRPMGxCUTNSRExFTkJRVU03U1VGRlJDeFZRVUZWTEVWQlFVVXNWVUZCVXl4TFFVRkxMRVZCUVVVc1QwRkJUenRSUVVOcVF5eEpRVUZOTEVkQlFVY3NSMEZCUnl4UFFVRlBMRU5CUVVNc1NVRkJTU3hIUVVGSExHbENRVUZMTEVOQlFVTTdVVUZEYWtNc1RVRkJUU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEpRVUZKTzFsQlEyWXNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhMUVVGTExGRkJRVkVzUjBGQlJ5eE5RVUZOTEVkQlFVY3NXVUZCVlN4SFFVRkhMRmRCUVZFc1EwRkJReXhEUVVGRE8wbEJRM0JGTEVOQlFVTTdTVUZGUkN4TFFVRkxMRVZCUVVVc1ZVRkJVeXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEV0QlFVczdVVUZEYmtNc1NVRkJUU3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZEY2tJc2VVSkJRU3RDTEVWQlFUbENMRlZCUVVVc1JVRkJSU3hWUVVGRkxFVkJRMUFzUjBGQlJ5eEhRVUZITEVsQlFVa3NSMEZCUnl4cFFrRkJTeXhGUVVOc1FpeExRVUZMTEVkQlFVY3NWVUZCVVN4clFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVkQlFVY3NhVUpCUVVzc1EwRkJReXhOUVVGSExFTkJRVU03VVVGRmVrUXNhVVJCUVdsRU8xRkJRMnBFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFFpeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTJZc1EwRkJRenRSUVVWRUxFbEJRVTBzVFVGQlRTeEhRVUZITzFsQlEySXNRMEZCUXl4RlFVRkZMR0ZCUVUwc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeExRVUZMTEVsQlFVazdaMEpCUTNaQ0xFVkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1YwRkJReXhEUVVGRExFVkJRVVVzVFVGQlRTeEZRVUZMTEVsQlFVa3NVMEZCU1N4RlFVRkZMR2RDUVVGaExFVkJRVU03WjBKQlF5OUVMRVZCUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUlVGQlF5eERRVUZETzFsQlJXSXNSVUZCUlN4RlFVRkZMR0ZCUVUwc1EwRkJReXhGUVVGRkxFVkJRVVVzUlVGQlJTeExRVUZMTEVsQlFVazdaMEpCUTNoQ0xFVkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1YwRkJReXhEUVVGRExFVkJRVVVzVFVGQlRTeEZRVUZMTEVsQlFVa3NVMEZCU1N4RlFVRkZMR2RDUVVGaExFVkJRVU03WjBKQlF5OUVMRVZCUVVNc1MwRkJTeXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUXl4RlFVRkRMRU5CUVVNN1dVRkZOVUlzUTBGQlF5eEZRVUZGTEdGQlFVMHNRMEZCUXl4RlFVRkZMRVZCUVVVc1JVRkJSU3hMUVVGTExFbEJRVWs3WjBKQlEzWkNMRVZCUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNWMEZCUXl4RFFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGTExFbEJRVWtzVTBGQlNTeEZRVUZGTEdkQ1FVRmhMRVZCUVVNN1owSkJReTlFTEVWQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1JVRkJReXhEUVVGRE8xbEJSV0lzUlVGQlJTeEZRVUZGTEdGQlFVMHNRMEZCUXl4RlFVRkZMRVZCUVVVc1JVRkJSU3hMUVVGTExFbEJRVWs3WjBKQlEzaENMRVZCUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNWMEZCUXl4RFFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGTExFbEJRVWtzVTBGQlNTeEZRVUZGTEdkQ1FVRmhMRVZCUVVNN1owSkJReTlFTEVWQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlF5eEZRVUZETEVOQlFVTTdVMEZET1VJc1EwRkJRenRSUVVWR0xIVkZRVUYxUlR0UlFVTjJSU3gzUlVGQmQwVTdVVUZEZUVVc01rVkJRVEpGTzFGQlF6TkZMR2xFUVVGcFJEdFJRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eExRVUZMTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha01zVjBGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGVExFZEJRVWM3WjBKQlF5OUNMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eHZRa0ZEV2l4SlFVRkpMRVZCUVVzc1MwRkJTeXh0UWtGQll5eEhRVUZITEZsQlFVOHNSMEZCUnl4clFrRkJZU3hMUVVGTExHRkJRVlVzU1VGRGJFVXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVOaUxFVkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNSVUZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha0lzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEwNHNTVUZCU1N4RlFVRkZMRk5CUVZNN1owSkJRMllzU1VGQlNTeEZRVUZGTEUxQlFVMDdaMEpCUTFvc1RVRkJUU3hGUVVGRk8yOUNRVU5PTEV0QlFVc3NSVUZCUlN4RlFVRkRMRWxCUVVrc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVWQlFVTXNSVUZCUXp0dlFrRkRPVUlzVFVGQlRTeEZRVUZGTEUxQlFVMDdhVUpCUTJZN1lVRkRSaXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NSVUZCUlR0WlFVTm1MRWxCUVVrc1JVRkJSU3hKUVVGSkxFZEJRVWNzWVVGQlN6dFpRVU5zUWl4SlFVRkpMRVZCUVVVc1RVRkJUVHRaUVVOYUxFMUJRVTBzUlVGQlJUdG5Ra0ZEVGl4TFFVRkxMRVZCUVVVc1JVRkJReXhKUVVGSkxFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNZVUZCWVN4RlFVRkRMRVZCUVVNN1owSkJRM0pETEUxQlFVMHNSVUZCUlN4TlFVRk5PMkZCUTJZN1UwRkRSaXhEUVVGRExFTkJRVU03U1VGRFRDeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVTnJRaXd5UWtGQlR6dEJRVVV6UWl4eFFrRkJORUlzVDBGQk1rSTdTVUZEY2tRc1NVRkJTU3hEUVVGRExFZEJRVzlDTEVsQlFVa3NSVUZCUlN4RlFVRkZMRWRCUVZVc1NVRkJTU3hGUVVNelF5eERRVUZETEVkQlFXOUNMRWxCUVVrc1JVRkJSU3hGUVVGRkxFZEJRVmNzU1VGQlNTeERRVUZETzBsQlEycEVMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWTXNRMEZCUXl4RlFVRkZMRU5CUVVNN1VVRkRia01zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1MwRkJTeXhYUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzSkNMRU5CUVVNc1IwRkJTU3hEUVVGRExFTkJRVU03V1VGRFVDeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTFRc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hMUVVGTExGZEJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETlVJc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU5PTEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRWQ3hEUVVGRE8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEU0N4TlFVRk5MRU5CUVVNc1JVRkJReXhEUVVGRExFZEJRVUVzUlVGQlJTeEZRVUZGTEVsQlFVRXNSVUZCUlN4RFFVRkRMRWRCUVVFc1JVRkJSU3hGUVVGRkxFbEJRVUVzUlVGQlF5eERRVUZETzBGQlEzaENMRU5CUVVNN1FVRmlSQ3hyUTBGaFF6dEJRVVZFTEhWQ1FVRjFRaXhMUVVGblFpeEZRVUZGTEU5QlFUSkNMRVZCUVVVc1QwRkJaMEk3U1VGRGNFWXNTVUZCVFN4SlFVRkpMRWRCUVVrc05rSkJRV2xDTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTlCUVU4c1EwRkJReXhGUVVNM1F5eEpRVUZKTEVkQlFVa3NTMEZCU3l4RFFVRkRMR2RDUVVGblFpeERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWRCUVVjc1QwRkJUeXhIUVVGSExGRkJRVkVzUTBGQlF5eERRVUZETEUxQlFVMHNSVUZEZWtVc1MwRkJTeXhIUVVGTkxFOUJRVThzVjBGQlVTeEZRVU14UWl4TlFVRk5MRWRCUVVjc2EwSkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RlFVRkZMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdTVUZGTVVRc1RVRkJUU3hEUVVGRE8xRkJRMHdzU1VGQlNTeEZRVUZGTEVsQlFVazdVVUZEVml4TFFVRkxMRVZCUVVVc1JVRkJSVHRSUVVOVUxFVkJRVVVzUlVGQlJTeG5Ra0ZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hWUVVGVExFVkJRVk1zUlVGQlJTeEhRVUZSTzFsQlEzcEZMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU03WjBKQlEwNHNUVUZCVFN4RlFVRkZMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjBRaXhOUVVGTkxFVkJRVVVzVFVGQlRTeERRVUZETEUxQlFVa3NTMEZCU3l4VlFVRkxMRXRCUVVzc1RVRkJSeXhEUVVGRE8yRkJRM1pETEVOQlFVTXNRMEZCUXp0WlFVVklMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU03WjBKQlEwNHNUVUZCVFN4RlFVRkZMRWRCUVVjN1owSkJRMWdzVFVGQlRTeEZRVUZGTEUxQlFVa3NTVUZCU1N4VlFVRlBMRWRCUVVjc1RVRkJUU3hEUVVGRExGZEJRVk1zUzBGQlN5eGhRVUZSTEVsQlFVa3NUVUZCUnl4RFFVRkRMRWRCUVVjc1IwRkJSenRoUVVOMFJTeERRVUZETEVOQlFVTTdXVUZGU0N4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8xRkJRMW9zUTBGQlF5eERRVUZETzB0QlEwZ3NRMEZCUXp0QlFVTktMRU5CUVVNN1FVRkZSQ3huUWtGQlowSXNUMEZCTWtJc1JVRkJSU3hGUVVGWk8wbEJRM1pFTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZUTEVWQlFWTXNSVUZCUlN4SFFVRlJPMUZCUTNaRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrSXNWVUZCU1N4RFFVRkpMRWRCUVVjc05FUkJRWGxFTEVOQlFVTXNRMEZCUXp0WlFVTjBSU3hOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETzFGQlExb3NRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMGxCUTNKQ0xFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0QlFVTlVMRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBzZWxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvblwiKTtcbnZhciBtdWx0aSA9IHtcbiAgICBwcmVkaWNhdGU6ICd2bFBvaW50JyxcbiAgICBzaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIHByb2ogPSBzZWxDbXB0LnByb2plY3QsIGRhdHVtID0gJyhpdGVtKCkuaXNWb3Jvbm9pID8gZGF0dW0uZGF0dW0gOiBkYXR1bSknLCBlbmNvZGluZ3MgPSBwcm9qLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gdXRpbF8xLnN0cmluZ1ZhbHVlKHAuZW5jb2RpbmcpOyB9KS5qb2luKCcsICcpLCBmaWVsZHMgPSBwcm9qLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gdXRpbF8xLnN0cmluZ1ZhbHVlKHAuZmllbGQpOyB9KS5qb2luKCcsICcpLCB2YWx1ZXMgPSBwcm9qLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gZGF0dW0gKyBcIltcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShwLmZpZWxkKSArIFwiXVwiOyB9KS5qb2luKCcsICcpO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiBzZWxDbXB0Lm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICAgICAgICAgIG9uOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBzZWxDbXB0LmV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogXCJ7ZW5jb2RpbmdzOiBbXCIgKyBlbmNvZGluZ3MgKyBcIl0sIGZpZWxkczogW1wiICsgZmllbGRzICsgXCJdLCB2YWx1ZXM6IFtcIiArIHZhbHVlcyArIFwiXX1cIlxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV07XG4gICAgfSxcbiAgICB0dXBsZUV4cHI6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCkge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZTtcbiAgICAgICAgcmV0dXJuIFwiZW5jb2RpbmdzOiBcIiArIG5hbWUgKyBcIi5lbmNvZGluZ3MsIGZpZWxkczogXCIgKyBuYW1lICsgXCIuZmllbGRzLCB2YWx1ZXM6IFwiICsgbmFtZSArIFwiLnZhbHVlc1wiO1xuICAgIH0sXG4gICAgbW9kaWZ5RXhwcjogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0KSB7XG4gICAgICAgIHZhciB0cGwgPSBzZWxDbXB0Lm5hbWUgKyBzZWxlY3Rpb25fMS5UVVBMRTtcbiAgICAgICAgcmV0dXJuIHRwbCArICcsICcgK1xuICAgICAgICAgICAgKHNlbENtcHQucmVzb2x2ZSA9PT0gJ2dsb2JhbCcgPyAnbnVsbCcgOiBcInt1bml0OiBcIiArIHRwbCArIFwiLnVuaXR9XCIpO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBtdWx0aTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJYVnNkR2t1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5elpXeGxZM1JwYjI0dmJYVnNkR2t1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3h0UTBGQmRVTTdRVUZEZGtNc2VVTkJRWEZFTzBGQlJYSkVMRWxCUVUwc1MwRkJTeXhIUVVGeFFqdEpRVU01UWl4VFFVRlRMRVZCUVVVc1UwRkJVenRKUVVWd1FpeFBRVUZQTEVWQlFVVXNWVUZCVXl4TFFVRkxMRVZCUVVVc1QwRkJUenRSUVVNNVFpeEpRVUZOTEVsQlFVa3NSMEZCUnl4UFFVRlBMRU5CUVVNc1QwRkJUeXhGUVVONFFpeExRVUZMTEVkQlFVa3NNRU5CUVRCRExFVkJRMjVFTEZOQlFWTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNhMEpCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFYWkNMRU5CUVhWQ0xFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUXk5RUxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1EwRkJReXhKUVVGTExFOUJRVUVzYTBKQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRWEJDTEVOQlFXOUNMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVWQlEzcEVMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNRMEZCUXl4SlFVRkxMRTlCUVVjc1MwRkJTeXhUUVVGSkxHdENRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGSExFVkJRVzVETEVOQlFXMURMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZETjBVc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEwNHNTVUZCU1N4RlFVRkZMRTlCUVU4c1EwRkJReXhKUVVGSk8yZENRVU5zUWl4TFFVRkxMRVZCUVVVc1JVRkJSVHRuUWtGRFZDeEZRVUZGTEVWQlFVVXNRMEZCUXp0M1FrRkRTQ3hOUVVGTkxFVkJRVVVzVDBGQlR5eERRVUZETEUxQlFVMDdkMEpCUTNSQ0xFMUJRVTBzUlVGQlJTeHJRa0ZCWjBJc1UwRkJVeXh2UWtGQlpTeE5RVUZOTEc5Q1FVRmxMRTFCUVUwc1QwRkJTVHR4UWtGRGFFWXNRMEZCUXp0aFFVTklMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJDeFRRVUZUTEVWQlFVVXNWVUZCVXl4TFFVRkxMRVZCUVVVc1QwRkJUenRSUVVOb1F5eEpRVUZOTEVsQlFVa3NSMEZCUnl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRekZDTEUxQlFVMHNRMEZCUXl4blFrRkJZeXhKUVVGSkxEUkNRVUYxUWl4SlFVRkpMSGxDUVVGdlFpeEpRVUZKTEZsQlFWTXNRMEZCUXp0SlFVTjRSaXhEUVVGRE8wbEJSVVFzVlVGQlZTeEZRVUZGTEZWQlFWTXNTMEZCU3l4RlFVRkZMRTlCUVU4N1VVRkRha01zU1VGQlRTeEhRVUZITEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhwUWtGQlN5eERRVUZETzFGQlEycERMRTFCUVUwc1EwRkJReXhIUVVGSExFZEJRVWNzU1VGQlNUdFpRVU5tTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1MwRkJTeXhSUVVGUkxFZEJRVWNzVFVGQlRTeEhRVUZITEZsQlFWVXNSMEZCUnl4WFFVRlJMRU5CUVVNc1EwRkJRenRKUVVOd1JTeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVmxMSGRDUVVGUEluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2ZWdhX2V2ZW50X3NlbGVjdG9yXzEgPSByZXF1aXJlKFwidmVnYS1ldmVudC1zZWxlY3RvclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBsYXllcl8xID0gcmVxdWlyZShcIi4uL2xheWVyXCIpO1xudmFyIGludGVydmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcnZhbFwiKTtcbnZhciBtdWx0aV8xID0gcmVxdWlyZShcIi4vbXVsdGlcIik7XG52YXIgc2luZ2xlXzEgPSByZXF1aXJlKFwiLi9zaW5nbGVcIik7XG52YXIgdHJhbnNmb3Jtc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3Jtcy90cmFuc2Zvcm1zXCIpO1xuZXhwb3J0cy5TVE9SRSA9ICdfc3RvcmUnO1xuZXhwb3J0cy5UVVBMRSA9ICdfdHVwbGUnO1xuZXhwb3J0cy5NT0RJRlkgPSAnX21vZGlmeSc7XG5mdW5jdGlvbiBwYXJzZVVuaXRTZWxlY3Rpb24obW9kZWwsIHNlbERlZnMpIHtcbiAgICB2YXIgc2VsQ21wdHMgPSB7fSwgc2VsZWN0aW9uQ29uZmlnID0gbW9kZWwuY29uZmlnLnNlbGVjdGlvbjtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChuYW1lXzEpIHtcbiAgICAgICAgaWYgKCFzZWxEZWZzLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbERlZiA9IHNlbERlZnNbbmFtZV8xXSwgY2ZnID0gc2VsZWN0aW9uQ29uZmlnW3NlbERlZi50eXBlXTtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZyb20gY29uZmlnIGlmIGEgcHJvcGVydHkgaGFzbid0IGJlZW4gc3BlY2lmaWVkLFxuICAgICAgICAvLyBvciBpZiBpdCBpcyB0cnVlLiBFLmcuLCBcInRyYW5zbGF0ZVwiOiB0cnVlIHNob3VsZCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnMgZm9yIHRyYW5zbGF0ZS4gSG93ZXZlciwgdHJ1ZSBtYXkgYmUgYSB2YWxpZCB2YWx1ZSBmb3JcbiAgICAgICAgLy8gYSBwcm9wZXJ0eSAoZS5nLiwgXCJuZWFyZXN0XCI6IHRydWUpLlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2ZnKSB7XG4gICAgICAgICAgICAvLyBBIHNlbGVjdGlvbiBzaG91bGQgY29udGFpbiBlaXRoZXIgYGVuY29kaW5nc2Agb3IgYGZpZWxkc2AsIG9ubHkgdXNlXG4gICAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlc2UgdHdvIHZhbHVlcyBpZiBuZWl0aGVyIG9mIHRoZW0gaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgaWYgKChrZXkgPT09ICdlbmNvZGluZ3MnICYmIHNlbERlZi5maWVsZHMpIHx8IChrZXkgPT09ICdmaWVsZHMnICYmIHNlbERlZi5lbmNvZGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsRGVmW2tleV0gPT09IHVuZGVmaW5lZCB8fCBzZWxEZWZba2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNlbERlZltrZXldID0gY2ZnW2tleV0gfHwgc2VsRGVmW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbENtcHQgPSBzZWxDbXB0c1tuYW1lXzFdID0gdXRpbF8xLmV4dGVuZCh7fSwgc2VsRGVmLCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lXzEsXG4gICAgICAgICAgICBldmVudHM6IHV0aWxfMS5pc1N0cmluZyhzZWxEZWYub24pID8gdmVnYV9ldmVudF9zZWxlY3Rvcl8xLnNlbGVjdG9yKHNlbERlZi5vbiwgJ3Njb3BlJykgOiBzZWxEZWYub24sXG4gICAgICAgICAgICBkb21haW46ICdkYXRhJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybXNfMS5mb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIGZ1bmN0aW9uICh0eENvbXBpbGVyKSB7XG4gICAgICAgICAgICBpZiAodHhDb21waWxlci5wYXJzZSkge1xuICAgICAgICAgICAgICAgIHR4Q29tcGlsZXIucGFyc2UobW9kZWwsIHNlbERlZiwgc2VsQ21wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIHNlbERlZnMpIHtcbiAgICAgICAgX2xvb3BfMShuYW1lXzEpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsQ21wdHM7XG59XG5leHBvcnRzLnBhcnNlVW5pdFNlbGVjdGlvbiA9IHBhcnNlVW5pdFNlbGVjdGlvbjtcbmZ1bmN0aW9uIGFzc2VtYmxlVW5pdFNlbGVjdGlvblNpZ25hbHMobW9kZWwsIHNpZ25hbHMpIHtcbiAgICBmb3JFYWNoU2VsZWN0aW9uKG1vZGVsLCBmdW5jdGlvbiAoc2VsQ21wdCwgc2VsQ29tcGlsZXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHR1cGxlRXhwciA9IHNlbENvbXBpbGVyLnR1cGxlRXhwcihtb2RlbCwgc2VsQ21wdCk7XG4gICAgICAgIHZhciBtb2RpZnlFeHByID0gc2VsQ29tcGlsZXIubW9kaWZ5RXhwcihtb2RlbCwgc2VsQ21wdCk7XG4gICAgICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBzZWxDb21waWxlci5zaWduYWxzKG1vZGVsLCBzZWxDbXB0KSk7XG4gICAgICAgIHRyYW5zZm9ybXNfMS5mb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIGZ1bmN0aW9uICh0eENvbXBpbGVyKSB7XG4gICAgICAgICAgICBpZiAodHhDb21waWxlci5zaWduYWxzKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFscyA9IHR4Q29tcGlsZXIuc2lnbmFscyhtb2RlbCwgc2VsQ21wdCwgc2lnbmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHhDb21waWxlci5tb2RpZnlFeHByKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZ5RXhwciA9IHR4Q29tcGlsZXIubW9kaWZ5RXhwcihtb2RlbCwgc2VsQ21wdCwgbW9kaWZ5RXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWxzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSArIGV4cG9ydHMuVFVQTEUsXG4gICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiB7IHNpZ25hbDogbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IFwie3VuaXQ6IHVuaXQuZGF0dW0gJiYgdW5pdC5kYXR1bS5faWQsIFwiICsgdHVwbGVFeHByICsgXCJ9XCJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lICsgZXhwb3J0cy5NT0RJRlksXG4gICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiB7IHNpZ25hbDogbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IFwibW9kaWZ5KFwiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKHNlbENtcHQubmFtZSArIGV4cG9ydHMuU1RPUkUpICsgXCIsIFwiICsgbW9kaWZ5RXhwciArIFwiKVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ25hbHM7XG59XG5leHBvcnRzLmFzc2VtYmxlVW5pdFNlbGVjdGlvblNpZ25hbHMgPSBhc3NlbWJsZVVuaXRTZWxlY3Rpb25TaWduYWxzO1xuZnVuY3Rpb24gYXNzZW1ibGVUb3BMZXZlbFNpZ25hbHMobW9kZWwsIHNpZ25hbHMpIHtcbiAgICB2YXIgaGFzVW5pdCA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm5hbWUgPT09ICd1bml0JzsgfSk7XG4gICAgaWYgKCEoaGFzVW5pdC5sZW5ndGgpKSB7XG4gICAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAndW5pdCcsXG4gICAgICAgICAgICB2YWx1ZToge30sXG4gICAgICAgICAgICBvbjogW3sgZXZlbnRzOiAnbW91c2Vtb3ZlJywgdXBkYXRlOiAnZ3JvdXAoKS5faWQgPyBncm91cCgpIDogdW5pdCcgfV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIGZ1bmN0aW9uIChzZWxDbXB0LCBzZWxDb21waWxlcikge1xuICAgICAgICBpZiAoc2VsQ29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgc2VsQ29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKG1vZGVsLCBzZWxDbXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3Jtc18xLmZvckVhY2hUcmFuc2Zvcm0oc2VsQ21wdCwgZnVuY3Rpb24gKHR4Q29tcGlsZXIpIHtcbiAgICAgICAgICAgIGlmICh0eENvbXBpbGVyLnRvcExldmVsU2lnbmFscykge1xuICAgICAgICAgICAgICAgIHNpZ25hbHMgPSB0eENvbXBpbGVyLnRvcExldmVsU2lnbmFscyhtb2RlbCwgc2VsQ21wdCwgc2lnbmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzaWduYWxzO1xufVxuZXhwb3J0cy5hc3NlbWJsZVRvcExldmVsU2lnbmFscyA9IGFzc2VtYmxlVG9wTGV2ZWxTaWduYWxzO1xuZnVuY3Rpb24gYXNzZW1ibGVVbml0U2VsZWN0aW9uRGF0YShtb2RlbCwgZGF0YSkge1xuICAgIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHZhciBjb250YWlucyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09IHNlbENtcHQubmFtZSArIGV4cG9ydHMuU1RPUkU7IH0pO1xuICAgICAgICBpZiAoIWNvbnRhaW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKHsgbmFtZTogc2VsQ21wdC5uYW1lICsgZXhwb3J0cy5TVE9SRSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy5hc3NlbWJsZVVuaXRTZWxlY3Rpb25EYXRhID0gYXNzZW1ibGVVbml0U2VsZWN0aW9uRGF0YTtcbmZ1bmN0aW9uIGFzc2VtYmxlVW5pdFNlbGVjdGlvbk1hcmtzKG1vZGVsLCBtYXJrcykge1xuICAgIHZhciBjbGlwR3JvdXAgPSBmYWxzZSwgc2VsTWFya3MgPSBtYXJrcztcbiAgICBmb3JFYWNoU2VsZWN0aW9uKG1vZGVsLCBmdW5jdGlvbiAoc2VsQ21wdCwgc2VsQ29tcGlsZXIpIHtcbiAgICAgICAgc2VsTWFya3MgPSBzZWxDb21waWxlci5tYXJrcyA/IHNlbENvbXBpbGVyLm1hcmtzKG1vZGVsLCBzZWxDbXB0LCBzZWxNYXJrcykgOiBzZWxNYXJrcztcbiAgICAgICAgdHJhbnNmb3Jtc18xLmZvckVhY2hUcmFuc2Zvcm0oc2VsQ21wdCwgZnVuY3Rpb24gKHR4Q29tcGlsZXIpIHtcbiAgICAgICAgICAgIGNsaXBHcm91cCA9IGNsaXBHcm91cCB8fCB0eENvbXBpbGVyLmNsaXBHcm91cDtcbiAgICAgICAgICAgIGlmICh0eENvbXBpbGVyLm1hcmtzKSB7XG4gICAgICAgICAgICAgICAgc2VsTWFya3MgPSB0eENvbXBpbGVyLm1hcmtzKG1vZGVsLCBzZWxDbXB0LCBtYXJrcywgc2VsTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBJbiBhIGxheWVyZWQgc3BlYywgd2Ugd2FudCB0byBjbGlwIGFsbCBsYXllcnMgdG9nZXRoZXIgcmF0aGVyIHRoYW5cbiAgICAvLyBvbmx5IHRoZSBsYXllciB3aXRoaW4gd2hpY2ggdGhlIHNlbGVjdGlvbiBpcyBkZWZpbmVkLiBQcm9wYWdhdGVcbiAgICAvLyBvdXIgYXNzZW1ibGVkIHN0YXRlIHVwIGFuZCBsZXQgdGhlIExheWVyTW9kZWwgbWFrZSB0aGUgcmlnaHQgY2FsbC5cbiAgICBpZiAobW9kZWwucGFyZW50ICYmIG1vZGVsLnBhcmVudCBpbnN0YW5jZW9mIGxheWVyXzEuTGF5ZXJNb2RlbCkge1xuICAgICAgICByZXR1cm4gW3NlbE1hcmtzLCBjbGlwTWFya3NdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNsaXBHcm91cCA/IGNsaXBNYXJrcyhzZWxNYXJrcykgOiBzZWxNYXJrcztcbiAgICB9XG59XG5leHBvcnRzLmFzc2VtYmxlVW5pdFNlbGVjdGlvbk1hcmtzID0gYXNzZW1ibGVVbml0U2VsZWN0aW9uTWFya3M7XG5mdW5jdGlvbiBhc3NlbWJsZUxheWVyU2VsZWN0aW9uTWFya3MobW9kZWwsIG1hcmtzKSB7XG4gICAgdmFyIGNsaXBHcm91cCA9IGZhbHNlO1xuICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciB1bml0ID0gYXNzZW1ibGVVbml0U2VsZWN0aW9uTWFya3MoY2hpbGQsIG1hcmtzKTtcbiAgICAgICAgbWFya3MgPSB1bml0WzBdO1xuICAgICAgICBjbGlwR3JvdXAgPSBjbGlwR3JvdXAgfHwgdW5pdFsxXTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2xpcEdyb3VwID8gY2xpcE1hcmtzKG1hcmtzKSA6IG1hcmtzO1xufVxuZXhwb3J0cy5hc3NlbWJsZUxheWVyU2VsZWN0aW9uTWFya3MgPSBhc3NlbWJsZUxheWVyU2VsZWN0aW9uTWFya3M7XG52YXIgUFJFRElDQVRFU19PUFMgPSB7XG4gICAgZ2xvYmFsOiAnXCJ1bmlvblwiLCBcImFsbFwiJyxcbiAgICBpbmRlcGVuZGVudDogJ1wiaW50ZXJzZWN0XCIsIFwidW5pdFwiJyxcbiAgICB1bmlvbjogJ1widW5pb25cIiwgXCJhbGxcIicsXG4gICAgdW5pb25fb3RoZXJzOiAnXCJ1bmlvblwiLCBcIm90aGVyc1wiJyxcbiAgICBpbnRlcnNlY3Q6ICdcImludGVyc2VjdFwiLCBcImFsbFwiJyxcbiAgICBpbnRlcnNlY3Rfb3RoZXJzOiAnXCJpbnRlcnNlY3RcIiwgXCJvdGhlcnNcIidcbn07XG4vLyBUT0RPOiBIb3cgdG8gYmV0dGVyIGRpZmZlcmVudGlhdGUgdW5pdCB0aGFuIHBhcmVudC5faWQ/XG5mdW5jdGlvbiBwcmVkaWNhdGUobmFtZSwgdHlwZSwgcmVzb2x2ZSwgZGF0dW0sIHBhcmVudCkge1xuICAgIHZhciBzdG9yZSA9IHV0aWxfMS5zdHJpbmdWYWx1ZShuYW1lICsgZXhwb3J0cy5TVE9SRSksIG9wID0gUFJFRElDQVRFU19PUFNbcmVzb2x2ZSB8fCAnZ2xvYmFsJ107XG4gICAgZGF0dW0gPSBkYXR1bSB8fCAnZGF0dW0nO1xuICAgIHBhcmVudCA9IHBhcmVudCA9PT0gbnVsbCA/IG51bGwgOiAncGFyZW50Ll9pZCc7XG4gICAgcmV0dXJuIGNvbXBpbGVyKHR5cGUpLnByZWRpY2F0ZSArIChcIihcIiArIHN0b3JlICsgXCIsIFwiICsgcGFyZW50ICsgXCIsIFwiICsgZGF0dW0gKyBcIiwgXCIgKyBvcCArIFwiKVwiKTtcbn1cbmV4cG9ydHMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbmZ1bmN0aW9uIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIGNiKSB7XG4gICAgdmFyIHNlbGVjdGlvbnMgPSBtb2RlbC5jb21wb25lbnQuc2VsZWN0aW9uO1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zLmhhc093blByb3BlcnR5KG5hbWVfMikpIHtcbiAgICAgICAgICAgIHZhciBzZWwgPSBzZWxlY3Rpb25zW25hbWVfMl07XG4gICAgICAgICAgICBjYihzZWwsIGNvbXBpbGVyKHNlbC50eXBlKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21waWxlcih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlXzEuZGVmYXVsdDtcbiAgICAgICAgY2FzZSAnbXVsdGknOlxuICAgICAgICAgICAgcmV0dXJuIG11bHRpXzEuZGVmYXVsdDtcbiAgICAgICAgY2FzZSAnaW50ZXJ2YWwnOlxuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsXzEuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpbnZlcnQobW9kZWwsIHNlbENtcHQsIGNoYW5uZWwsIGV4cHIpIHtcbiAgICB2YXIgc2NhbGUgPSB1dGlsXzEuc3RyaW5nVmFsdWUobW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpKTtcbiAgICByZXR1cm4gc2VsQ21wdC5kb21haW4gPT09ICdkYXRhJyA/IFwiaW52ZXJ0KFwiICsgc2NhbGUgKyBcIiwgXCIgKyBleHByICsgXCIpXCIgOiBleHByO1xufVxuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5mdW5jdGlvbiBjaGFubmVsU2lnbmFsTmFtZShzZWxDbXB0LCBjaGFubmVsKSB7XG4gICAgcmV0dXJuIHNlbENtcHQubmFtZSArICdfJyArIHNlbENtcHQuZmllbGRzW2NoYW5uZWxdO1xufVxuZXhwb3J0cy5jaGFubmVsU2lnbmFsTmFtZSA9IGNoYW5uZWxTaWduYWxOYW1lO1xuZnVuY3Rpb24gY2xpcE1hcmtzKG1hcmtzKSB7XG4gICAgcmV0dXJuIG1hcmtzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gKG0uY2xpcCA9IHRydWUsIG0pOyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMyVnNaV04wYVc5dUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMlZzWldOMGFXOXVMM05sYkdWamRHbHZiaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMREpFUVVFNFJEdEJRVWs1UkN4dFEwRkJLMFE3UVVGRkwwUXNhME5CUVc5RE8wRkJSM0JETEhWRFFVRXdRenRCUVVNeFF5eHBRMEZCYjBNN1FVRkZjRU1zYlVOQlFYTkRPMEZCUTNSRExITkVRVUY1UkR0QlFVVTFReXhSUVVGQkxFdEJRVXNzUjBGQlJ5eFJRVUZSTEVOQlFVTTdRVUZEYWtJc1VVRkJRU3hMUVVGTExFZEJRVWtzVVVGQlVTeERRVUZETzBGQlEyeENMRkZCUVVFc1RVRkJUU3hIUVVGSExGTkJRVk1zUTBGQlF6dEJRVzFEYUVNc05FSkJRVzFETEV0QlFXZENMRVZCUVVVc1QwRkJNa0k3U1VGRE9VVXNTVUZCVFN4UlFVRlJMRWRCUVRaQ0xFVkJRVVVzUlVGRGVrTXNaVUZCWlN4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZET3pSQ1FVVnNReXhOUVVGSk8xRkJRMklzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXpzN1VVRkZjRU1zUTBGQlF6dFJRVVZFTEVsQlFVMHNUVUZCVFN4SFFVRkhMRTlCUVU4c1EwRkJReXhOUVVGSkxFTkJRVU1zUlVGRGVFSXNSMEZCUnl4SFFVRkhMR1ZCUVdVc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZGZGtNc2MwVkJRWE5GTzFGQlEzUkZMRzFGUVVGdFJUdFJRVU51UlN4MVJVRkJkVVU3VVVGRGRrVXNjME5CUVhORE8xRkJRM1JETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVUwc1IwRkJSeXhKUVVGSkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVJc2MwVkJRWE5GTzFsQlEzUkZMSFZGUVVGMVJUdFpRVU4yUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUzBGQlN5eFhRVUZYTEVsQlFVa3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eExRVUZMTEZGQlFWRXNTVUZCU1N4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnlSaXhSUVVGUkxFTkJRVU03V1VGRFdDeERRVUZETzFsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eExRVUZMTEZOQlFWTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRVFzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRlRU1zUTBGQlF6dFJRVU5JTEVOQlFVTTdVVUZGUkN4SlFVRk5MRTlCUVU4c1IwRkJSeXhSUVVGUkxFTkJRVU1zVFVGQlNTeERRVUZETEVkQlFVY3NZVUZCVFN4RFFVRkRMRVZCUVVVc1JVRkJSU3hOUVVGTkxFVkJRVVU3V1VGRGJFUXNTVUZCU1N4RlFVRkZMRTFCUVVrN1dVRkRWaXhOUVVGTkxFVkJRVVVzWlVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXc0UWtGQllTeERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZMRVZCUVVVc1QwRkJUeXhEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEVWQlFVVTdXVUZETTBVc1RVRkJUU3hGUVVGRkxFMUJRWGxDTzFOQlEyeERMRU5CUVhWQ0xFTkJRVU03VVVGRmVrSXNOa0pCUVdkQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEZWQlFVRXNWVUZCVlR0WlFVTnNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrSXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFVkJRVVVzVFVGQlRTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUXpORExFTkJRVU03VVVGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRnVRMFFzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCVFN4TlFVRkpMRWxCUVVrc1QwRkJUeXhEUVVGRE8yZENRVUZvUWl4TlFVRkpPMHRCYlVOa08wbEJSVVFzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXp0QlFVTnNRaXhEUVVGRE8wRkJNVU5FTEdkRVFUQkRRenRCUVVWRUxITkRRVUUyUXl4TFFVRm5RaXhGUVVGRkxFOUJRV003U1VGRE0wVXNaMEpCUVdkQ0xFTkJRVU1zUzBGQlN5eEZRVUZGTEZWQlFVTXNUMEZCVHl4RlFVRkZMRmRCUVZjN1VVRkRNME1zU1VGQlRTeEpRVUZKTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkRja0lzVTBGQlV5eEhRVUZITEZkQlFWY3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFGQlEzUkVMRWxCUVVrc1ZVRkJWU3hIUVVGSExGZEJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJSWGhFTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeFhRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJXcEZMRFpDUVVGblFpeERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRkJMRlZCUVZVN1dVRkRiRU1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzWkNMRTlCUVU4c1IwRkJSeXhWUVVGVkxFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03V1VGRGVFUXNRMEZCUXp0WlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNeFFpeFZRVUZWTEVkQlFVY3NWVUZCVlN4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRPMWxCUTJwRkxFTkJRVU03VVVGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU03V1VGRFdDeEpRVUZKTEVWQlFVVXNTVUZCU1N4SFFVRkhMR0ZCUVVzN1dVRkRiRUlzUlVGQlJTeEZRVUZGTEVOQlFVTTdiMEpCUTBnc1RVRkJUU3hGUVVGRkxFVkJRVU1zVFVGQlRTeEZRVUZGTEVsQlFVa3NSVUZCUXp0dlFrRkRkRUlzVFVGQlRTeEZRVUZGTERCRFFVRjNReXhUUVVGVExFMUJRVWM3YVVKQlF6ZEVMRU5CUVVNN1UwRkRTQ3hGUVVGRk8xbEJRMFFzU1VGQlNTeEZRVUZGTEVsQlFVa3NSMEZCUnl4alFVRk5PMWxCUTI1Q0xFVkJRVVVzUlVGQlJTeERRVUZETzI5Q1FVTklMRTFCUVUwc1JVRkJSU3hGUVVGRExFMUJRVTBzUlVGQlJTeEpRVUZKTEVWQlFVTTdiMEpCUTNSQ0xFMUJRVTBzUlVGQlJTeFpRVUZWTEd0Q1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUjBGQlJ5eGhRVUZMTEVOQlFVTXNWVUZCU3l4VlFVRlZMRTFCUVVjN2FVSkJRM1JGTEVOQlFVTTdVMEZEU0N4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZJTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNN1FVRkRha0lzUTBGQlF6dEJRV3BEUkN4dlJVRnBRME03UVVGRlJDeHBRMEZCZDBNc1MwRkJaMElzUlVGQlJTeFBRVUZqTzBsQlEzUkZMRWxCUVUwc1QwRkJUeXhIUVVGSExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4RFFVRkRMRWxCUVVzc1QwRkJRU3hEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEUxQlFVMHNSVUZCYWtJc1EwRkJhVUlzUTBGQlF5eERRVUZETzBsQlEzcEVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRXQ3hKUVVGSkxFVkJRVVVzVFVGQlRUdFpRVU5hTEV0QlFVc3NSVUZCUlN4RlFVRkZPMWxCUTFRc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlF5eE5RVUZOTEVWQlFVVXNWMEZCVnl4RlFVRkZMRTFCUVUwc1JVRkJSU3c0UWtGQk9FSXNSVUZCUXl4RFFVRkRPMU5CUTNCRkxFTkJRVU1zUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkN4blFrRkJaMElzUTBGQlF5eExRVUZMTEVWQlFVVXNWVUZCUXl4UFFVRlBMRVZCUVVVc1YwRkJWenRSUVVNelF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5vUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVWQlFVVXNWMEZCVnl4RFFVRkRMR1ZCUVdVc1EwRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXpSU3hEUVVGRE8xRkJSVVFzTmtKQlFXZENMRU5CUVVNc1QwRkJUeXhGUVVGRkxGVkJRVUVzVlVGQlZUdFpRVU5zUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zWlVGQlpTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRMMElzVDBGQlR5eEhRVUZITEZWQlFWVXNRMEZCUXl4bFFVRmxMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTm9SU3hEUVVGRE8xRkJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVWSUxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTTdRVUZEYWtJc1EwRkJRenRCUVhaQ1JDd3dSRUYxUWtNN1FVRkZSQ3h0UTBGQk1FTXNTMEZCWjBJc1JVRkJSU3hKUVVGak8wbEJRM2hGTEdkQ1FVRm5RaXhEUVVGRExFdEJRVXNzUlVGQlJTeFZRVUZCTEU5QlFVODdVVUZETjBJc1NVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRU5CUVVNc1NVRkJTeXhQUVVGQkxFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhoUVVGTExFVkJRUzlDTEVOQlFTdENMRU5CUVVNc1EwRkJRenRSUVVOeVJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzSkNMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlF5eEpRVUZKTEVWQlFVVXNUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhoUVVGTExFVkJRVU1zUTBGQlF5eERRVUZETzFGQlF6RkRMRU5CUVVNN1NVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZJTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJWRVFzT0VSQlUwTTdRVUZGUkN4dlEwRkJNa01zUzBGQlowSXNSVUZCUlN4TFFVRlpPMGxCUTNaRkxFbEJRVWtzVTBGQlV5eEhRVUZITEV0QlFVc3NSVUZEYWtJc1VVRkJVU3hIUVVGSExFdEJRVXNzUTBGQlF6dEpRVU55UWl4blFrRkJaMElzUTBGQlF5eExRVUZMTEVWQlFVVXNWVUZCUXl4UFFVRlBMRVZCUVVVc1YwRkJWenRSUVVNelF5eFJRVUZSTEVkQlFVY3NWMEZCVnl4RFFVRkRMRXRCUVVzc1IwRkJSeXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1VVRkJVU3hEUVVGRExFZEJRVWNzVVVGQlVTeERRVUZETzFGQlEzUkdMRFpDUVVGblFpeERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRkRMRlZCUVZVN1dVRkRia01zVTBGQlV5eEhRVUZITEZOQlFWTXNTVUZCU1N4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRE8xbEJRemxETEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnlRaXhSUVVGUkxFZEJRVWNzVlVGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0WlFVTXZSQ3hEUVVGRE8xRkJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVWSUxIRkZRVUZ4UlR0SlFVTnlSU3hyUlVGQmEwVTdTVUZEYkVVc2NVVkJRWEZGTzBsQlEzSkZMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRTFCUVUwc1dVRkJXU3hyUWtGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hOUVVGTkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1NVRkRMMElzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTA0c1RVRkJUU3hEUVVGRExGTkJRVk1zUjBGQlJ5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1VVRkJVU3hEUVVGRE8wbEJRM0JFTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCY2tKRUxHZEZRWEZDUXp0QlFVVkVMSEZEUVVFMFF5eExRVUZwUWl4RlFVRkZMRXRCUVZrN1NVRkRla1VzU1VGQlNTeFRRVUZUTEVkQlFVY3NTMEZCU3l4RFFVRkRPMGxCUTNSQ0xFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVFc1MwRkJTenRSUVVNeFFpeEpRVUZOTEVsQlFVa3NSMEZCUnl3d1FrRkJNRUlzUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRkRVFzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOb1FpeFRRVUZUTEVkQlFVY3NVMEZCVXl4SlFVRkpMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU51UXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOSUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVkQlFVY3NVMEZCVXl4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF6dEJRVU01UXl4RFFVRkRPMEZCVWtRc2EwVkJVVU03UVVGRlJDeEpRVUZOTEdOQlFXTXNSMEZCUnp0SlFVTnlRaXhOUVVGTkxFVkJRVVVzWjBKQlFXZENPMGxCUTNoQ0xGZEJRVmNzUlVGQlJTeHhRa0ZCY1VJN1NVRkRiRU1zUzBGQlN5eEZRVUZGTEdkQ1FVRm5RanRKUVVOMlFpeFpRVUZaTEVWQlFVVXNiVUpCUVcxQ08wbEJRMnBETEZOQlFWTXNSVUZCUlN4dlFrRkJiMEk3U1VGREwwSXNaMEpCUVdkQ0xFVkJRVVVzZFVKQlFYVkNPME5CUXpGRExFTkJRVU03UVVGRlJpd3dSRUZCTUVRN1FVRkRNVVFzYlVKQlFUQkNMRWxCUVZrc1JVRkJSU3hKUVVGdlFpeEZRVUZGTEU5QlFXZENMRVZCUVVVc1MwRkJZeXhGUVVGRkxFMUJRV1U3U1VGRE4wY3NTVUZCVFN4TFFVRkxMRWRCUVVjc2EwSkJRVmNzUTBGQlF5eEpRVUZKTEVkQlFVY3NZVUZCU3l4RFFVRkRMRVZCUTJwRExFVkJRVVVzUjBGQlJ5eGpRVUZqTEVOQlFVTXNUMEZCVHl4SlFVRkpMRkZCUVZFc1EwRkJReXhEUVVGRE8wbEJReTlETEV0QlFVc3NSMEZCUnl4TFFVRkxMRWxCUVVrc1QwRkJUeXhEUVVGRE8wbEJRM3BDTEUxQlFVMHNSMEZCUnl4TlFVRk5MRXRCUVVzc1NVRkJTU3hIUVVGSExFbEJRVWtzUjBGQlJ5eFpRVUZaTEVOQlFVTTdTVUZETDBNc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4VFFVRlRMRWxCUVVjc1RVRkJTU3hMUVVGTExGVkJRVXNzVFVGQlRTeFZRVUZMTEV0QlFVc3NWVUZCU3l4RlFVRkZMRTFCUVVjc1EwRkJRU3hEUVVGRE8wRkJRemRGTEVOQlFVTTdRVUZPUkN3NFFrRk5RenRCUVVWRUxHOUNRVUZ2UWp0QlFVVndRaXd3UWtGQk1FSXNTMEZCV1N4RlFVRkZMRVZCUVhsRk8wbEJReTlITEVsQlFVMHNWVUZCVlN4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVTBGQlV5eERRVUZETzBsQlF6ZERMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVTBzVFVGQlNTeEpRVUZKTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRPVUlzUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMR05CUVdNc1EwRkJReXhOUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VNc1NVRkJUU3hIUVVGSExFZEJRVWNzVlVGQlZTeERRVUZETEUxQlFVa3NRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6bENMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVVZFTEd0Q1FVRnJRaXhKUVVGdlFqdEpRVU53UXl4TlFVRk5MRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEySXNTMEZCU3l4UlFVRlJPMWxCUTFnc1RVRkJUU3hEUVVGRExHZENRVUZqTEVOQlFVTTdVVUZEZUVJc1MwRkJTeXhQUVVGUE8xbEJRMVlzVFVGQlRTeERRVUZETEdWQlFXRXNRMEZCUXp0UlFVTjJRaXhMUVVGTExGVkJRVlU3V1VGRFlpeE5RVUZOTEVOQlFVTXNhMEpCUVdkQ0xFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlJVUXNaMEpCUVhWQ0xFdEJRV2RDTEVWQlFVVXNUMEZCTWtJc1JVRkJSU3hQUVVGblFpeEZRVUZGTEVsQlFWazdTVUZEYkVjc1NVRkJUU3hMUVVGTExFZEJRVWNzYTBKQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEY0VRc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEV0QlFVc3NUVUZCVFN4SFFVRkhMRmxCUVZVc1MwRkJTeXhWUVVGTExFbEJRVWtzVFVGQlJ5eEhRVUZITEVsQlFVa3NRMEZCUXp0QlFVTjRSU3hEUVVGRE8wRkJTRVFzZDBKQlIwTTdRVUZGUkN3eVFrRkJhME1zVDBGQk1rSXNSVUZCUlN4UFFVRm5RanRKUVVNM1JTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhIUVVGSExFZEJRVWNzVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRCUVVOMFJDeERRVUZETzBGQlJrUXNPRU5CUlVNN1FVRkZSQ3h0UWtGQmJVSXNTMEZCV1R0SlFVTTNRaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkRMRU5CUVVNc1NVRkJTeXhQUVVGQkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NSMEZCUnl4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRV3hDTEVOQlFXdENMRU5CUVVNc1EwRkJRenRCUVVNNVF5eERRVUZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG11bHRpXzEgPSByZXF1aXJlKFwiLi9tdWx0aVwiKTtcbnZhciBzZWxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvblwiKTtcbnZhciBzaW5nbGUgPSB7XG4gICAgcHJlZGljYXRlOiBtdWx0aV8xLmRlZmF1bHQucHJlZGljYXRlLFxuICAgIHNpZ25hbHM6IG11bHRpXzEuZGVmYXVsdC5zaWduYWxzLFxuICAgIHRvcExldmVsU2lnbmFsczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IHNlbENtcHQubmFtZSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IFwiZGF0YShcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShzZWxDbXB0Lm5hbWUgKyBzZWxlY3Rpb25fMS5TVE9SRSkgKyBcIilbMF1cIlxuICAgICAgICAgICAgfV07XG4gICAgfSxcbiAgICB0dXBsZUV4cHI6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCkge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgdmFsdWVzID0gbmFtZSArIFwiLnZhbHVlc1wiO1xuICAgICAgICByZXR1cm4gXCJlbmNvZGluZ3M6IFwiICsgbmFtZSArIFwiLmVuY29kaW5ncywgZmllbGRzOiBcIiArIG5hbWUgKyBcIi5maWVsZHMsIFwiICtcbiAgICAgICAgICAgIChcInZhbHVlczogXCIgKyB2YWx1ZXMgKyBcIiwgXCIpICtcbiAgICAgICAgICAgIHNlbENtcHQucHJvamVjdC5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5maWVsZCArIFwiOiBcIiArIHZhbHVlcyArIFwiW1wiICsgaSArIFwiXVwiO1xuICAgICAgICAgICAgfSkuam9pbignLCAnKTtcbiAgICB9LFxuICAgIG1vZGlmeUV4cHI6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCkge1xuICAgICAgICB2YXIgdHBsID0gc2VsQ21wdC5uYW1lICsgc2VsZWN0aW9uXzEuVFVQTEU7XG4gICAgICAgIHJldHVybiB0cGwgKyAnLCAnICtcbiAgICAgICAgICAgIChzZWxDbXB0LnJlc29sdmUgPT09ICdnbG9iYWwnID8gJ3RydWUnIDogXCJ7dW5pdDogXCIgKyB0cGwgKyBcIi51bml0fVwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gc2luZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzJsdVoyeGxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YzJWc1pXTjBhVzl1TDNOcGJtZHNaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMRzFEUVVGMVF6dEJRVU4yUXl4cFEwRkJORUk3UVVGRE5VSXNlVU5CUVRSRU8wRkJSVFZFTEVsQlFVMHNUVUZCVFN4SFFVRnhRanRKUVVNdlFpeFRRVUZUTEVWQlFVVXNaVUZCU3l4RFFVRkRMRk5CUVZNN1NVRkZNVUlzVDBGQlR5eEZRVUZGTEdWQlFVc3NRMEZCUXl4UFFVRlBPMGxCUlhSQ0xHVkJRV1VzUlVGQlJTeFZRVUZUTEV0QlFVc3NSVUZCUlN4UFFVRlBPMUZCUTNSRExFMUJRVTBzUTBGQlF5eERRVUZETzJkQ1FVTk9MRWxCUVVrc1JVRkJSU3hQUVVGUExFTkJRVU1zU1VGQlNUdG5Ra0ZEYkVJc1RVRkJUU3hGUVVGRkxGVkJRVkVzYTBKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hIUVVGSExHbENRVUZMTEVOQlFVTXNVMEZCVFR0aFFVTjRSQ3hEUVVGRExFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUXNVMEZCVXl4RlFVRkZMRlZCUVZNc1MwRkJTeXhGUVVGRkxFOUJRVTg3VVVGRGFFTXNTVUZCVFN4SlFVRkpMRWRCUVVjc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeE5RVUZOTEVkQlFVMHNTVUZCU1N4WlFVRlRMRU5CUVVNN1VVRkRja1FzVFVGQlRTeERRVUZETEdkQ1FVRmpMRWxCUVVrc05FSkJRWFZDTEVsQlFVa3NZMEZCVnp0aFFVTTNSQ3hoUVVGWExFMUJRVTBzVDBGQlNTeERRVUZCTzFsQlEzSkNMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFWTXNRMEZCUXl4RlFVRkZMRU5CUVVNN1owSkJReTlDTEUxQlFVMHNRMEZCU1N4RFFVRkRMRU5CUVVNc1MwRkJTeXhWUVVGTExFMUJRVTBzVTBGQlNTeERRVUZETEUxQlFVY3NRMEZCUXp0WlFVTjJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRVVZFTEZWQlFWVXNSVUZCUlN4VlFVRlRMRXRCUVVzc1JVRkJSU3hQUVVGUE8xRkJRMnBETEVsQlFVMHNSMEZCUnl4SFFVRkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFZEJRVWNzYVVKQlFVc3NRMEZCUXp0UlFVTnFReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVsQlFVazdXVUZEWml4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFdEJRVXNzVVVGQlVTeEhRVUZITEUxQlFVMHNSMEZCUnl4WlFVRlZMRWRCUVVjc1YwRkJVU3hEUVVGRExFTkJRVU03U1VGRGNFVXNRMEZCUXp0RFFVTkdMRU5CUVVNN1FVRkZaMElzZVVKQlFVOGlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgaW5wdXRCaW5kaW5ncyA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0LnR5cGUgPT09ICdzaW5nbGUnICYmIHNlbENtcHQucmVzb2x2ZSA9PT0gJ2dsb2JhbCcgJiZcbiAgICAgICAgICAgIHNlbENtcHQuYmluZCAmJiBzZWxDbXB0LmJpbmQgIT09ICdzY2FsZXMnO1xuICAgIH0sXG4gICAgdG9wTGV2ZWxTaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQsIHNpZ25hbHMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHByb2ogPSBzZWxDbXB0LnByb2plY3QsIGJpbmQgPSBzZWxDbXB0LmJpbmQsIGRhdHVtID0gJyhpdGVtKCkuaXNWb3Jvbm9pID8gZGF0dW0uZGF0dW0gOiBkYXR1bSknO1xuICAgICAgICBwcm9qLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHNpZ25hbHMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSArIGlkKHAuZmllbGQpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogc2VsQ21wdC5ldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGRhdHVtICsgXCJbXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUocC5maWVsZCkgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBiaW5kOiBiaW5kW3AuZmllbGRdIHx8IGJpbmRbcC5lbmNvZGluZ10gfHwgYmluZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmFscztcbiAgICB9LFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgc2lnbmFscykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgcHJvaiA9IHNlbENtcHQucHJvamVjdCwgc2lnbmFsID0gc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gbmFtZTsgfSlbMF0sIGZpZWxkcyA9IHByb2oubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiB1dGlsXzEuc3RyaW5nVmFsdWUocC5maWVsZCk7IH0pLmpvaW4oJywgJyksIHZhbHVlcyA9IHByb2oubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBuYW1lICsgaWQocC5maWVsZCk7IH0pLmpvaW4oJywgJyk7XG4gICAgICAgIHNpZ25hbC51cGRhdGUgPSBcIntmaWVsZHM6IFtcIiArIGZpZWxkcyArIFwiXSwgdmFsdWVzOiBbXCIgKyB2YWx1ZXMgKyBcIl19XCI7XG4gICAgICAgIGRlbGV0ZSBzaWduYWwudmFsdWU7XG4gICAgICAgIGRlbGV0ZSBzaWduYWwub247XG4gICAgICAgIHJldHVybiBzaWduYWxzO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpbnB1dEJpbmRpbmdzO1xuZnVuY3Rpb24gaWQoc3RyKSB7XG4gICAgcmV0dXJuICdfJyArIHN0ci5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNXdkWFJ6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMlZzWldOMGFXOXVMM1J5WVc1elptOXliWE12YVc1d2RYUnpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNjME5CUVRCRE8wRkJSekZETEVsQlFVMHNZVUZCWVN4SFFVRnhRanRKUVVOMFF5eEhRVUZITEVWQlFVVXNWVUZCVXl4UFFVRlBPMUZCUTI1Q0xFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRkZCUVZFc1NVRkJTU3hQUVVGUExFTkJRVU1zVDBGQlR5eExRVUZMTEZGQlFWRTdXVUZET1VRc1QwRkJUeXhEUVVGRExFbEJRVWtzU1VGQlNTeFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRkZCUVZFc1EwRkJRenRKUVVNNVF5eERRVUZETzBsQlJVUXNaVUZCWlN4RlFVRkZMRlZCUVZNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeFBRVUZQTzFGQlF5OURMRWxCUVUwc1NVRkJTU3hIUVVGSExFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlEzSkNMRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU1zVDBGQlR5eEZRVU4wUWl4SlFVRkpMRWRCUVVjc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGRGJrSXNTMEZCU3l4SFFVRkhMREJEUVVFd1F5eERRVUZETzFGQlJYWkVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlV5eERRVUZETzFsQlEzSkNMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU03WjBKQlEyUXNTVUZCU1N4RlFVRkZMRWxCUVVrc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXp0blFrRkRlRUlzUzBGQlN5eEZRVUZGTEVWQlFVVTdaMEpCUTFRc1JVRkJSU3hGUVVGRkxFTkJRVU03ZDBKQlEwZ3NUVUZCVFN4RlFVRkZMRTlCUVU4c1EwRkJReXhOUVVGTk8zZENRVU4wUWl4TlFVRk5MRVZCUVVzc1MwRkJTeXhUUVVGSkxHdENRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGSE8zRkNRVU0xUXl4RFFVRkRPMmRDUVVOR0xFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1NVRkJTVHRoUVVOb1JDeERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVWSUxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTTdTVUZEYWtJc1EwRkJRenRKUVVWRUxFOUJRVThzUlVGQlJTeFZRVUZUTEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1QwRkJUenRSUVVOMlF5eEpRVUZOTEVsQlFVa3NSMEZCUnl4UFFVRlBMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVTTNReXhOUVVGTkxFZEJRVWNzVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRU5CUVVNc1NVRkJTeXhQUVVGQkxFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NTVUZCU1N4RlFVRm1MRU5CUVdVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVU5zUkN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZETEVOQlFVTXNTVUZCU3l4UFFVRkJMR3RDUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RlFVRndRaXhEUVVGdlFpeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVONlJDeE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGRExFTkJRVU1zU1VGQlN5eFBRVUZCTEVsQlFVa3NSMEZCUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZzUWl4RFFVRnJRaXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUlRWRUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVkQlFVY3NaVUZCWVN4TlFVRk5MRzlDUVVGbExFMUJRVTBzVDBGQlNTeERRVUZETzFGQlF6ZEVMRTlCUVU4c1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU53UWl4UFFVRlBMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRmFrSXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJRenRKUVVOcVFpeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVjFRaXhuUTBGQlR6dEJRVVZvUXl4WlFVRlpMRWRCUVZjN1NVRkRja0lzVFVGQlRTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0QlFVTjJReXhEUVVGREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBWT1JPTk9JID0gJ3Zvcm9ub2knO1xudmFyIG5lYXJlc3QgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiAoc2VsQ21wdCkge1xuICAgICAgICByZXR1cm4gc2VsQ21wdC5uZWFyZXN0ICE9PSB1bmRlZmluZWQgJiYgc2VsQ21wdC5uZWFyZXN0ICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIG1hcmtzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQsIG1hcmtzLCBzZWxNYXJrcykge1xuICAgICAgICB2YXIgbWFyayA9IG1hcmtzWzBdLCBpbmRleCA9IHNlbE1hcmtzLmluZGV4T2YobWFyayksIGlzUGF0aGdyb3VwID0gbWFyay5uYW1lID09PSBtb2RlbC5nZXROYW1lKCdwYXRoZ3JvdXAnKSwgZXhpc3RzID0gKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm5hbWUgJiYgbS5uYW1lLmluZGV4T2YoVk9ST05PSSkgPj0gMDsgfSksIGNlbGxEZWYgPSB7XG4gICAgICAgICAgICBuYW1lOiBtb2RlbC5nZXROYW1lKFZPUk9OT0kpLFxuICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgZnJvbTogeyBkYXRhOiBtb2RlbC5nZXROYW1lKCdtYXJrcycpIH0sXG4gICAgICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgICAgICBlbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiB7IHZhbHVlOiAndHJhbnNwYXJlbnQnIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB7IHZhbHVlOiAwLjM1IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogeyB2YWx1ZTogJ3RyYW5zcGFyZW50JyB9LFxuICAgICAgICAgICAgICAgICAgICBpc1Zvcm9ub2k6IHsgdmFsdWU6IHRydWUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2b3Jvbm9pJyxcbiAgICAgICAgICAgICAgICAgICAgeDogJ2RhdHVtLngnLFxuICAgICAgICAgICAgICAgICAgICB5OiAnZGF0dW0ueScsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFttb2RlbC5nZXRTaXplU2lnbmFsUmVmKCd3aWR0aCcpLCBtb2RlbC5nZXRTaXplU2lnbmFsUmVmKCdoZWlnaHQnKV1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNQYXRoZ3JvdXAgJiYgIW1hcmsubWFya3MuZmlsdGVyKGV4aXN0cykubGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXJrLm1hcmtzLnB1c2goY2VsbERlZik7XG4gICAgICAgICAgICBzZWxNYXJrcy5zcGxpY2UoaW5kZXgsIDEsIG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1BhdGhncm91cCAmJiAhc2VsTWFya3MuZmlsdGVyKGV4aXN0cykubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxNYXJrcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBjZWxsRGVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsTWFya3M7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG5lYXJlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2libVZoY21WemRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDNObGJHVmpkR2x2Ymk5MGNtRnVjMlp2Y20xekwyNWxZWEpsYzNRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZGUVN4SlFVRk5MRTlCUVU4c1IwRkJSeXhUUVVGVExFTkJRVU03UVVGRk1VSXNTVUZCVFN4UFFVRlBMRWRCUVhGQ08wbEJRMmhETEVkQlFVY3NSVUZCUlN4VlFVRlRMRTlCUVU4N1VVRkRia0lzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRXRCUVVzc1UwRkJVeXhKUVVGSkxFOUJRVThzUTBGQlF5eFBRVUZQTEV0QlFVc3NTMEZCU3l4RFFVRkRPMGxCUTNCRkxFTkJRVU03U1VGRlJDeExRVUZMTEVWQlFVVXNWVUZCVXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFJRVUZSTzFGQlF6ZERMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZEYWtJc1MwRkJTeXhIUVVGSExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUXpsQ0xGZEJRVmNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4TFFVRkxMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVjBGQlZ5eERRVUZETEVWQlEzUkVMRTFCUVUwc1IwRkJSeXhEUVVGRExGVkJRVU1zUTBGQlRTeEpRVUZMTEU5QlFVRXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRWFJETEVOQlFYTkRMRU5CUVVNc1JVRkROMFFzVDBGQlR5eEhRVUZITzFsQlExSXNTVUZCU1N4RlFVRkZMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETzFsQlF6VkNMRWxCUVVrc1JVRkJSU3hOUVVGTk8xbEJRMW9zU1VGQlNTeEZRVUZGTEVWQlFVTXNTVUZCU1N4RlFVRkZMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVTTdXVUZEY0VNc1RVRkJUU3hGUVVGRk8yZENRVU5PTEV0QlFVc3NSVUZCUlR0dlFrRkRUQ3hKUVVGSkxFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNZVUZCWVN4RlFVRkRPMjlDUVVNMVFpeFhRVUZYTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hGUVVGRE8yOUNRVU14UWl4TlFVRk5MRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzWVVGQllTeEZRVUZETzI5Q1FVTTVRaXhUUVVGVExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNTVUZCU1N4RlFVRkRPMmxDUVVONlFqdGhRVU5HTzFsQlEwUXNVMEZCVXl4RlFVRkZMRU5CUVVNN2IwSkJRMVlzU1VGQlNTeEZRVUZGTEZOQlFWTTdiMEpCUTJZc1EwRkJReXhGUVVGRkxGTkJRVk03YjBKQlExb3NRMEZCUXl4RlFVRkZMRk5CUVZNN2IwSkJRMW9zU1VGQlNTeEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMR2RDUVVGblFpeERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZMRXRCUVVzc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRwUWtGRE1VVXNRMEZCUXp0VFFVTklMRU5CUVVNN1VVRkZUaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pFTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFsQlEzcENMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOc1F5eERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpORUxGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEZWtNc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTTdTVUZEYkVJc1EwRkJRenREUVVOR0xFTkJRVU03UVVGRmFVSXNNRUpCUVU4aWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9qZWN0ID0ge1xuICAgIGhhczogZnVuY3Rpb24gKHNlbERlZikge1xuICAgICAgICByZXR1cm4gc2VsRGVmLmZpZWxkcyAhPT0gdW5kZWZpbmVkIHx8IHNlbERlZi5lbmNvZGluZ3MgIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobW9kZWwsIHNlbERlZiwgc2VsQ21wdCkge1xuICAgICAgICB2YXIgZmllbGRzID0ge307XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBwb3NzaWJsZSBjaGFubmVsIG1hcHBpbmcgZm9yIHRoZXNlIGZpZWxkcy5cbiAgICAgICAgKHNlbERlZi5maWVsZHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZpZWxkc1tmXSA9IG51bGw7IH0pO1xuICAgICAgICAoc2VsRGVmLmVuY29kaW5ncyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZmllbGRzW21vZGVsLmZpZWxkRGVmKGMpLmZpZWxkXSA9IGM7IH0pO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHNlbENtcHQucHJvamVjdCB8fCAoc2VsQ21wdC5wcm9qZWN0ID0gW10pO1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZHMuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wdXNoKHsgZmllbGQ6IGZpZWxkLCBlbmNvZGluZzogZmllbGRzW2ZpZWxkXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWVsZHMgPSBzZWxDbXB0LmZpZWxkcyB8fCAoc2VsQ21wdC5maWVsZHMgPSB7fSk7XG4gICAgICAgIHByb2plY3Rpb24uZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmVuY29kaW5nOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBmaWVsZHNbcC5lbmNvZGluZ10gPSBwLmZpZWxkOyB9KTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcHJvamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNISnZhbVZqZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMM05sYkdWamRHbHZiaTkwY21GdWMyWnZjbTF6TDNCeWIycGxZM1F1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkpRU3hKUVVGTkxFOUJRVThzUjBGQmNVSTdTVUZEYUVNc1IwRkJSeXhGUVVGRkxGVkJRVk1zVFVGQmIwSTdVVUZEYUVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEV0QlFVc3NVMEZCVXl4SlFVRkpMRTFCUVUwc1EwRkJReXhUUVVGVExFdEJRVXNzVTBGQlV5eERRVUZETzBsQlEzWkZMRU5CUVVNN1NVRkZSQ3hMUVVGTExFVkJRVVVzVlVGQlV5eExRVUZMTEVWQlFVVXNUVUZCVFN4RlFVRkZMRTlCUVU4N1VVRkRjRU1zU1VGQlNTeE5RVUZOTEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUTJoQ0xEQkVRVUV3UkR0UlFVTXhSQ3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUlVGQmFFSXNRMEZCWjBJc1EwRkJReXhEUVVGRE8xRkJRM1pFTEVOQlFVTXNUVUZCVFN4RFFVRkRMRk5CUVZNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUXl4RFFVRlZMRWxCUVVzc1QwRkJRU3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFXNURMRU5CUVcxRExFTkJRVU1zUTBGQlF6dFJRVVYwUml4SlFVRk5MRlZCUVZVc1IwRkJSeXhQUVVGUExFTkJRVU1zVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU0zUkN4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGTkxFdEJRVXNzU1VGQlNTeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnFReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hSUVVGUkxFVkJRVVVzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4RlFVRkRMRU5CUVVNc1EwRkJRenRaUVVNelJDeERRVUZETzFGQlEwZ3NRMEZCUXp0UlFVVkVMRTFCUVUwc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVU5xUkN4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJWaXhEUVVGVkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUXl4RFFVRkRMRWxCUVVzc1QwRkJRU3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhMUVVGTExFVkJRVFZDTEVOQlFUUkNMRU5CUVVNc1EwRkJRenRKUVVOd1JpeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVnBRaXd3UWtGQlR5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sb2dcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbFwiKTtcbnZhciBpbnRlcnZhbF8xID0gcmVxdWlyZShcIi4uL2ludGVydmFsXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvblwiKTtcbnZhciBzY2FsZUJpbmRpbmdzID0ge1xuICAgIGNsaXBHcm91cDogdHJ1ZSxcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0LnR5cGUgPT09ICdpbnRlcnZhbCcgJiYgc2VsQ21wdC5yZXNvbHZlID09PSAnZ2xvYmFsJyAmJlxuICAgICAgICAgICAgc2VsQ21wdC5iaW5kICYmIHNlbENtcHQuYmluZCA9PT0gJ3NjYWxlcyc7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1vZGVsLCBzZWxEZWYsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gc2VsQ21wdC5zY2FsZXMgPSBbXTtcbiAgICAgICAgc2VsQ21wdC5wcm9qZWN0LmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gcC5lbmNvZGluZztcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG1vZGVsLmdldENvbXBvbmVudCgnc2NhbGVzJywgY2hhbm5lbCk7XG4gICAgICAgICAgICBpZiAoIXNjYWxlIHx8ICFzY2FsZV8xLmhhc0NvbnRpbnVvdXNEb21haW4oc2NhbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dfMS53YXJuKCdTY2FsZSBiaW5kaW5ncyBhcmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGZvciBzY2FsZXMgd2l0aCBjb250aW51b3VzIGRvbWFpbnMuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NhbGUuZG9tYWluUmF3ID0geyBzaWduYWw6IHNlbGVjdGlvbl8xLmNoYW5uZWxTaWduYWxOYW1lKHNlbENtcHQsIGNoYW5uZWwpIH07XG4gICAgICAgICAgICBib3VuZC5wdXNoKGNoYW5uZWwpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHRvcExldmVsU2lnbmFsczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKSB7XG4gICAgICAgIHZhciBjaGFubmVscyA9IHNlbENtcHQuc2NhbGVzLmZpbHRlcihmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuICEoc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gc2VsZWN0aW9uXzEuY2hhbm5lbFNpZ25hbE5hbWUoc2VsQ21wdCwgY2hhbm5lbCk7IH0pLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmFscy5jb25jYXQoY2hhbm5lbHMubWFwKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBzZWxlY3Rpb25fMS5jaGFubmVsU2lnbmFsTmFtZShzZWxDbXB0LCBjaGFubmVsKSB9O1xuICAgICAgICB9KSk7XG4gICAgfSxcbiAgICBzaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQsIHNpZ25hbHMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWU7XG4gICAgICAgIHNpZ25hbHMgPSBzaWduYWxzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHMubmFtZSAhPT0gbmFtZSArIGludGVydmFsXzEuU0laRSAmJlxuICAgICAgICAgICAgICAgIHMubmFtZSAhPT0gbmFtZSArIHNlbGVjdGlvbl8xLlRVUExFICYmIHMubmFtZSAhPT0gc2VsZWN0aW9uXzEuTU9ESUZZO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsQ21wdC5zY2FsZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIHNpZ25hbCA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm5hbWUgPT09IHNlbGVjdGlvbl8xLmNoYW5uZWxTaWduYWxOYW1lKHNlbENtcHQsIGNoYW5uZWwpOyB9KVswXTtcbiAgICAgICAgICAgIHNpZ25hbC5wdXNoID0gJ291dGVyJztcbiAgICAgICAgICAgIGRlbGV0ZSBzaWduYWwudmFsdWU7XG4gICAgICAgICAgICBkZWxldGUgc2lnbmFsLnVwZGF0ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaWduYWxzO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBzY2FsZUJpbmRpbmdzO1xuZnVuY3Rpb24gZG9tYWluKG1vZGVsLCBjaGFubmVsKSB7XG4gICAgdmFyIHNjYWxlID0gdXRpbF8xLnN0cmluZ1ZhbHVlKG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKSk7XG4gICAgcmV0dXJuIFwiZG9tYWluKFwiICsgc2NhbGUgKyBcIilcIjtcbn1cbmV4cG9ydHMuZG9tYWluID0gZG9tYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzJOaGJHVnpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdmMyVnNaV04wYVc5dUwzUnlZVzV6Wm05eWJYTXZjMk5oYkdWekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUTBFc2IwTkJRV3RETzBGQlEyeERMSGREUVVGdFJEdEJRVU51UkN4elEwRkJNRU03UVVGRk1VTXNkME5CUVd0RU8wRkJRMnhFTERCRFFVRTRSRHRCUVVjNVJDeEpRVUZOTEdGQlFXRXNSMEZCY1VJN1NVRkRkRU1zVTBGQlV5eEZRVUZGTEVsQlFVazdTVUZGWml4SFFVRkhMRVZCUVVVc1ZVRkJVeXhQUVVGUE8xRkJRMjVDTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hMUVVGTExGVkJRVlVzU1VGQlNTeFBRVUZQTEVOQlFVTXNUMEZCVHl4TFFVRkxMRkZCUVZFN1dVRkRhRVVzVDBGQlR5eERRVUZETEVsQlFVa3NTVUZCU1N4UFFVRlBMRU5CUVVNc1NVRkJTU3hMUVVGTExGRkJRVkVzUTBGQlF6dEpRVU01UXl4RFFVRkRPMGxCUlVRc1MwRkJTeXhGUVVGRkxGVkJRVk1zUzBGQlN5eEZRVUZGTEUxQlFVMHNSVUZCUlN4UFFVRlBPMUZCUTNCRExFbEJRVTBzUzBGQlN5eEhRVUZoTEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJSVFZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVk1zUTBGQlF6dFpRVU5vUXl4SlFVRk5MRTlCUVU4c1IwRkJSeXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETzFsQlF6TkNMRWxCUVUwc1MwRkJTeXhIUVVGSExFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xbEJSWEJFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhKUVVGSkxFTkJRVU1zTWtKQlFXMUNMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRMME1zVlVGQlNTeERRVUZETEdsR1FVRnBSaXhEUVVGRExFTkJRVU03WjBKQlEzaEdMRTFCUVUwc1EwRkJRenRaUVVOVUxFTkJRVU03V1VGRlJDeExRVUZMTEVOQlFVTXNVMEZCVXl4SFFVRkhMRVZCUVVNc1RVRkJUU3hGUVVGRkxEWkNRVUZwUWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zUlVGQlF5eERRVUZETzFsQlEyaEZMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEZEVJc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUXNaVUZCWlN4RlFVRkZMRlZCUVZNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeFBRVUZQTzFGQlF5OURMRWxCUVUwc1VVRkJVU3hIUVVGSExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1QwRkJUenRaUVVNM1F5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eERRVUZETEVsQlFVc3NUMEZCUVN4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExEWkNRVUZwUWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zUlVGQk9VTXNRMEZCT0VNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEzcEdMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZETEU5QlFVODdXVUZEZWtNc1RVRkJUU3hEUVVGRExFVkJRVU1zU1VGQlNTeEZRVUZGTERaQ1FVRnBRaXhEUVVGRExFOUJRVThzUlVGQlJTeFBRVUZQTEVOQlFVTXNSVUZCUXl4RFFVRkRPMUZCUTNKRUxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVGl4RFFVRkRPMGxCUlVRc1QwRkJUeXhGUVVGRkxGVkJRVk1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4UFFVRlBPMUZCUTNaRExFbEJRVTBzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRNVUlzVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJVeXhEUVVGRE8xbEJRMnBETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExFbEJRVWtzUjBGQlJ5eGxRVUZoTzJkQ1FVTndReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEVsQlFVa3NSMEZCUnl4cFFrRkJTeXhKUVVGSkxFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NhMEpCUVUwc1EwRkJRenRSUVVOcVJDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWTXNUMEZCVHp0WlFVTnlReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJReXhKUVVGTExFOUJRVUVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l3MlFrRkJhVUlzUTBGQlF5eFBRVUZQTEVWQlFVVXNUMEZCVHl4RFFVRkRMRVZCUVRsRExFTkJRVGhETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFJpeE5RVUZOTEVOQlFVTXNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJRenRaUVVOMFFpeFBRVUZQTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1dVRkRjRUlzVDBGQlR5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTNaQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJVZ3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJRenRKUVVOcVFpeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVjFRaXhuUTBGQlR6dEJRVVZvUXl4blFrRkJkVUlzUzBGQlowSXNSVUZCUlN4UFFVRm5RanRKUVVOMlJDeEpRVUZOTEV0QlFVc3NSMEZCUnl4clFrRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOd1JDeE5RVUZOTEVOQlFVTXNXVUZCVlN4TFFVRkxMRTFCUVVjc1EwRkJRenRCUVVNMVFpeERRVUZETzBGQlNFUXNkMEpCUjBNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9zZWxlY3Rpb25cIik7XG52YXIgVE9HR0xFID0gJ190b2dnbGUnO1xudmFyIHRvZ2dsZSA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0LnRvZ2dsZSAhPT0gdW5kZWZpbmVkICYmIHNlbENtcHQudG9nZ2xlICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgc2lnbmFscykge1xuICAgICAgICByZXR1cm4gc2lnbmFscy5jb25jYXQoe1xuICAgICAgICAgICAgbmFtZTogc2VsQ21wdC5uYW1lICsgVE9HR0xFLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgb246IFt7IGV2ZW50czogc2VsQ21wdC5ldmVudHMsIHVwZGF0ZTogc2VsQ21wdC50b2dnbGUgfV1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBtb2RpZnlFeHByOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQsIGV4cHIpIHtcbiAgICAgICAgdmFyIHRwbCA9IHNlbENtcHQubmFtZSArIHNlbGVjdGlvbl8xLlRVUExFLCBzaWduYWwgPSBzZWxDbXB0Lm5hbWUgKyBUT0dHTEU7XG4gICAgICAgIHJldHVybiBzaWduYWwgKyBcIiA/IG51bGwgOiBcIiArIHRwbCArIFwiLCBcIiArXG4gICAgICAgICAgICAoc2VsQ21wdC5yZXNvbHZlID09PSAnZ2xvYmFsJyA/XG4gICAgICAgICAgICAgICAgc2lnbmFsICsgXCIgPyBudWxsIDogdHJ1ZSwgXCIgOlxuICAgICAgICAgICAgICAgIHNpZ25hbCArIFwiID8gbnVsbCA6IHt1bml0OiBcIiArIHRwbCArIFwiLnVuaXR9LCBcIikgK1xuICAgICAgICAgICAgKHNpZ25hbCArIFwiID8gXCIgKyB0cGwgKyBcIiA6IG51bGxcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvZ2dsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHOW5aMnhsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMlZzWldOMGFXOXVMM1J5WVc1elptOXliWE12ZEc5bloyeGxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNNRU5CUVcxRE8wRkJSMjVETEVsQlFVMHNUVUZCVFN4SFFVRkhMRk5CUVZNc1EwRkJRenRCUVVWNlFpeEpRVUZOTEUxQlFVMHNSMEZCY1VJN1NVRkRMMElzUjBGQlJ5eEZRVUZGTEZWQlFWTXNUMEZCVHp0UlFVTnVRaXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNTMEZCU3l4VFFVRlRMRWxCUVVrc1QwRkJUeXhEUVVGRExFMUJRVTBzUzBGQlN5eExRVUZMTEVOQlFVTTdTVUZEYkVVc1EwRkJRenRKUVVWRUxFOUJRVThzUlVGQlJTeFZRVUZUTEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1QwRkJUenRSUVVOMlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJRenRaUVVOd1FpeEpRVUZKTEVWQlFVVXNUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhOUVVGTk8xbEJRek5DTEV0QlFVc3NSVUZCUlN4TFFVRkxPMWxCUTFvc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlF5eE5RVUZOTEVWQlFVVXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hOUVVGTkxFVkJRVVVzVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUXl4RFFVRkRPMU5CUTNaRUxFTkJRVU1zUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkN4VlFVRlZMRVZCUVVVc1ZVRkJVeXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEVsQlFVazdVVUZEZGtNc1NVRkJUU3hIUVVGSExFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSMEZCUnl4cFFrRkJTeXhGUVVNMVFpeE5RVUZOTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRmJrTXNUVUZCVFN4RFFVRkpMRTFCUVUwc2EwSkJRV0VzUjBGQlJ5eFBRVUZKTzFsQlEyeERMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUzBGQlN5eFJRVUZSTzJkQ1FVTjRRaXhOUVVGTkxIRkNRVUZyUWp0blFrRkRlRUlzVFVGQlRTeDVRa0ZCYjBJc1IwRkJSeXhoUVVGVkxFTkJRVU03WVVGRE1VTXNUVUZCVFN4WFFVRk5MRWRCUVVjc1dVRkJVeXhEUVVGQkxFTkJRVU03U1VGRGFFTXNRMEZCUXp0RFFVTkdMRU5CUVVNN1FVRkZaMElzZVVKQlFVOGlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5wdXRzXzEgPSByZXF1aXJlKFwiLi9pbnB1dHNcIik7XG52YXIgbmVhcmVzdF8xID0gcmVxdWlyZShcIi4vbmVhcmVzdFwiKTtcbnZhciBwcm9qZWN0XzEgPSByZXF1aXJlKFwiLi9wcm9qZWN0XCIpO1xudmFyIHNjYWxlc18xID0gcmVxdWlyZShcIi4vc2NhbGVzXCIpO1xudmFyIHRvZ2dsZV8xID0gcmVxdWlyZShcIi4vdG9nZ2xlXCIpO1xudmFyIHRyYW5zbGF0ZV8xID0gcmVxdWlyZShcIi4vdHJhbnNsYXRlXCIpO1xudmFyIHpvb21fMSA9IHJlcXVpcmUoXCIuL3pvb21cIik7XG52YXIgY29tcGlsZXJzID0geyBwcm9qZWN0OiBwcm9qZWN0XzEuZGVmYXVsdCwgdG9nZ2xlOiB0b2dnbGVfMS5kZWZhdWx0LCBzY2FsZXM6IHNjYWxlc18xLmRlZmF1bHQsXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGVfMS5kZWZhdWx0LCB6b29tOiB6b29tXzEuZGVmYXVsdCwgaW5wdXRzOiBpbnB1dHNfMS5kZWZhdWx0LCBuZWFyZXN0OiBuZWFyZXN0XzEuZGVmYXVsdCB9O1xuZnVuY3Rpb24gZm9yRWFjaFRyYW5zZm9ybShzZWxDbXB0LCBjYikge1xuICAgIGZvciAodmFyIHQgaW4gY29tcGlsZXJzKSB7XG4gICAgICAgIGlmIChjb21waWxlcnNbdF0uaGFzKHNlbENtcHQpKSB7XG4gICAgICAgICAgICBjYihjb21waWxlcnNbdF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5mb3JFYWNoVHJhbnNmb3JtID0gZm9yRWFjaFRyYW5zZm9ybTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmhibk5tYjNKdGN5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDNObGJHVmpkR2x2Ymk5MGNtRnVjMlp2Y20xekwzUnlZVzV6Wm05eWJYTXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGcFFrRXNiVU5CUVRoQ08wRkJRemxDTEhGRFFVRm5RenRCUVVOb1F5eHhRMEZCWjBNN1FVRkRhRU1zYlVOQlFUaENPMEZCUXpsQ0xHMURRVUU0UWp0QlFVTTVRaXg1UTBGQmIwTTdRVUZEY0VNc0swSkJRVEJDTzBGQlF6RkNMRWxCUVUwc1UwRkJVeXhIUVVFMFFpeEZRVUZETEU5QlFVOHNiVUpCUVVFc1JVRkJSU3hOUVVGTkxHdENRVUZCTEVWQlFVVXNUVUZCVFN4clFrRkJRVHRKUVVOcVJTeFRRVUZUTEhGQ1FVRkJMRVZCUVVVc1NVRkJTU3huUWtGQlFTeEZRVUZGTEUxQlFVMHNhMEpCUVVFc1JVRkJSU3hQUVVGUExHMUNRVUZCTEVWQlFVTXNRMEZCUXp0QlFVVndReXd3UWtGQmFVTXNUMEZCTWtJc1JVRkJSU3hGUVVGdFF6dEpRVU12Uml4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGTkxFTkJRVU1zU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpGQ0xFVkJRVVVzUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsQ0xFVkJRVVVzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVFpeERRVUZETzBsQlEwZ3NRMEZCUXp0QlFVTklMRU5CUVVNN1FVRk9SQ3cwUTBGTlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB2ZWdhX2V2ZW50X3NlbGVjdG9yXzEgPSByZXF1aXJlKFwidmVnYS1ldmVudC1zZWxlY3RvclwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2hhbm5lbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbFwiKTtcbnZhciBpbnRlcnZhbF8xID0gcmVxdWlyZShcIi4uL2ludGVydmFsXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvblwiKTtcbnZhciBzY2FsZXNfMSA9IHJlcXVpcmUoXCIuL3NjYWxlc1wiKTtcbnZhciBBTkNIT1IgPSAnX3RyYW5zbGF0ZV9hbmNob3InLCBERUxUQSA9ICdfdHJhbnNsYXRlX2RlbHRhJztcbnZhciB0cmFuc2xhdGUgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiAoc2VsQ21wdCkge1xuICAgICAgICByZXR1cm4gc2VsQ21wdC50eXBlID09PSAnaW50ZXJ2YWwnICYmIHNlbENtcHQudHJhbnNsYXRlICE9PSB1bmRlZmluZWQgJiYgc2VsQ21wdC50cmFuc2xhdGUgIT09IGZhbHNlO1xuICAgIH0sXG4gICAgc2lnbmFsczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKSB7XG4gICAgICAgIHZhciBuYW1lID0gc2VsQ21wdC5uYW1lLCBzY2FsZXMgPSBzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSwgc2l6ZSA9IHNjYWxlcyA/ICd1bml0JyA6IG5hbWUgKyBpbnRlcnZhbF8xLlNJWkUsIGFuY2hvciA9IG5hbWUgKyBBTkNIT1IsIF9hID0gaW50ZXJ2YWxfMS5wcm9qZWN0aW9ucyhzZWxDbXB0KSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICB2YXIgZXZlbnRzID0gdmVnYV9ldmVudF9zZWxlY3Rvcl8xLnNlbGVjdG9yKHNlbENtcHQudHJhbnNsYXRlLCAnc2NvcGUnKTtcbiAgICAgICAgaWYgKCFzY2FsZXMpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlLmJldHdlZW5bMF0ubWFya25hbWUgPSBuYW1lICsgaW50ZXJ2YWxfMS5CUlVTSCwgZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhbmNob3IsXG4gICAgICAgICAgICB2YWx1ZToge30sXG4gICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmJldHdlZW5bMF07IH0pLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6ICd7eDogeCh1bml0KSwgeTogeSh1bml0KSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJ3aWR0aDogXCIgKyBzaXplICsgXCIud2lkdGgsIGhlaWdodDogXCIgKyBzaXplICsgXCIuaGVpZ2h0LCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHggIT09IG51bGwgPyAnZXh0ZW50X3g6ICcgKyAoc2NhbGVzID8gc2NhbGVzXzEuZG9tYWluKG1vZGVsLCBjaGFubmVsXzEuWCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2xpY2UoXCIgKyBuYW1lICsgXCJfXCIgKyB4LmZpZWxkICsgXCIpXCIpICsgJywgJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeSAhPT0gbnVsbCA/ICdleHRlbnRfeTogJyArIChzY2FsZXMgPyBzY2FsZXNfMS5kb21haW4obW9kZWwsIGNoYW5uZWxfMS5ZKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzbGljZShcIiArIG5hbWUgKyBcIl9cIiArIHkuZmllbGQgKyBcIilcIikgKyAnLCAnIDogJycpICsgJ30nXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogbmFtZSArIERFTFRBLFxuICAgICAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IFwie3g6IHgodW5pdCkgLSBcIiArIGFuY2hvciArIFwiLngsIHk6IHkodW5pdCkgLSBcIiArIGFuY2hvciArIFwiLnl9XCJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9uRGVsdGEobW9kZWwsIHNlbENtcHQsIGNoYW5uZWxfMS5YLCAnd2lkdGgnLCBzaWduYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25EZWx0YShtb2RlbCwgc2VsQ21wdCwgY2hhbm5lbF8xLlksICdoZWlnaHQnLCBzaWduYWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmFscztcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhbnNsYXRlO1xuZnVuY3Rpb24gZ2V0U2lnbihzZWxDbXB0LCBjaGFubmVsKSB7XG4gICAgdmFyIHMgPSBjaGFubmVsID09PSBjaGFubmVsXzEuWCA/ICcrJyA6ICctJztcbiAgICBpZiAoc2NhbGVzXzEuZGVmYXVsdC5oYXMoc2VsQ21wdCkpIHtcbiAgICAgICAgcyA9IHMgPT09ICcrJyA/ICctJyA6ICcrJztcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBvbkRlbHRhKG1vZGVsLCBzZWxDbXB0LCBjaGFubmVsLCBzaXplLCBzaWduYWxzKSB7XG4gICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHNpZ25hbCA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm5hbWUgPT09IHNlbGVjdGlvbl8xLmNoYW5uZWxTaWduYWxOYW1lKHNlbENtcHQsIGNoYW5uZWwpOyB9KVswXSwgYW5jaG9yID0gbmFtZSArIEFOQ0hPUiwgZGVsdGEgPSBuYW1lICsgREVMVEEsIHNjYWxlID0gdXRpbF8xLnN0cmluZ1ZhbHVlKG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKSksIGV4dGVudCA9IFwiLmV4dGVudF9cIiArIGNoYW5uZWwsIHNpZ24gPSBnZXRTaWduKHNlbENtcHQsIGNoYW5uZWwpLCBvZmZzZXQgPSBzaWduICsgXCIgYWJzKHNwYW4oXCIgKyBhbmNob3IgKyBleHRlbnQgKyBcIikpICogXCIgK1xuICAgICAgICAoZGVsdGEgKyBcIi5cIiArIGNoYW5uZWwgKyBcIiAvIFwiICsgYW5jaG9yICsgXCIuXCIgKyBzaXplKSwgcmFuZ2UgPSBcIltcIiArIGFuY2hvciArIGV4dGVudCArIFwiWzBdIFwiICsgb2Zmc2V0ICsgXCIsIFwiICtcbiAgICAgICAgKFwiXCIgKyBhbmNob3IgKyBleHRlbnQgKyBcIlsxXSBcIiArIG9mZnNldCArIFwiXVwiKSwgbG8gPSBcImludmVydChcIiArIHNjYWxlICsgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gJywgMCcgOiBcIiwgdW5pdC5cIiArIHNpemUpICsgJyknLCBoaSA9IFwiaW52ZXJ0KFwiICsgc2NhbGUgKyAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyBcIiwgdW5pdC5cIiArIHNpemUgOiAnLCAwJykgKyAnKSc7XG4gICAgc2lnbmFsLm9uLnB1c2goe1xuICAgICAgICBldmVudHM6IHsgc2lnbmFsOiBkZWx0YSB9LFxuICAgICAgICB1cGRhdGU6IHNjYWxlc18xLmRlZmF1bHQuaGFzKHNlbENtcHQpID8gcmFuZ2UgOiBcImNsYW1wUmFuZ2UoXCIgKyByYW5nZSArIFwiLCBcIiArIGxvICsgXCIsIFwiICsgaGkgKyBcIilcIlxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKaGJuTnNZWFJsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMlZzWldOMGFXOXVMM1J5WVc1elptOXliWE12ZEhKaGJuTnNZWFJsTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzTWtSQlFUaEVPMEZCUXpsRUxEUkRRVUVyUXp0QlFVTXZReXh6UTBGQk1FTTdRVUZETVVNc2QwTkJRU3RITzBGQlF5OUhMREJEUVVGdFJUdEJRVVZ1UlN4dFEwRkJNa1E3UVVGSE0wUXNTVUZCVFN4TlFVRk5MRWRCUVVjc2JVSkJRVzFDTEVWQlF6VkNMRXRCUVVzc1IwRkJTU3hyUWtGQmEwSXNRMEZCUXp0QlFVVnNReXhKUVVGTkxGTkJRVk1zUjBGQmNVSTdTVUZEYkVNc1IwRkJSeXhGUVVGRkxGVkJRVk1zVDBGQlR6dFJRVU51UWl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUzBGQlN5eFZRVUZWTEVsQlFVa3NUMEZCVHl4RFFVRkRMRk5CUVZNc1MwRkJTeXhUUVVGVExFbEJRVWtzVDBGQlR5eERRVUZETEZOQlFWTXNTMEZCU3l4TFFVRkxMRU5CUVVNN1NVRkRka2NzUTBGQlF6dEpRVVZFTEU5QlFVOHNSVUZCUlN4VlFVRlRMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVVVzVDBGQlR6dFJRVU5xUXl4SlFVRkJMRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU1zU1VGQlNTeEZRVU55UWl4TlFVRk5MRWRCUVVjc1owSkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUTNCRExFbEJRVWtzUjBGQlJ5eE5RVUZOTEVkQlFVY3NUVUZCVFN4SFFVRkhMRWxCUVVrc1IwRkJSeXhsUVVGaExFVkJRemRETEUxQlFVMHNSMEZCUnl4SlFVRkpMRWRCUVVjc1RVRkJUU3hGUVVOMFFpeHZRMEZCY1VNc1JVRkJjRU1zVVVGQlF5eEZRVUZGTEZGQlFVTXNRMEZCYVVNN1VVRkRNVU1zU1VGQlNTeE5RVUZOTEVkQlFVY3NPRUpCUVdFc1EwRkJReXhQUVVGUExFTkJRVU1zVTBGQlV5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUlhaRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOYUxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1EwRkJReXhKUVVGTExFOUJRVUVzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUjBGQlJ5eEpRVUZKTEVkQlFVY3NaMEpCUVdNc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQmJFUXNRMEZCYTBRc1EwRkJReXhEUVVGRE8xRkJRMnBHTEVOQlFVTTdVVUZGUkN4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRE8xbEJRMWdzU1VGQlNTeEZRVUZGTEUxQlFVMDdXVUZEV2l4TFFVRkxMRVZCUVVVc1JVRkJSVHRaUVVOVUxFVkJRVVVzUlVGQlJTeERRVUZETzI5Q1FVTklMRTFCUVUwc1JVRkJSU3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNRMEZCUXl4SlFVRkxMRTlCUVVFc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCV2l4RFFVRlpMRU5CUVVNN2IwSkJRM1pETEUxQlFVMHNSVUZCUlN3eVFrRkJNa0k3ZVVKQlEycERMRmxCUVZVc1NVRkJTU3gzUWtGQmJVSXNTVUZCU1N4alFVRlhMRU5CUVVFN2QwSkJSV2hFTEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1IwRkJSeXhaUVVGWkxFZEJRVWNzUTBGQlF5eE5RVUZOTEVkQlFVY3NaVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hYUVVGRExFTkJRVU03TkVKQlEyNUVMRmRCUVZNc1NVRkJTU3hUUVVGSkxFTkJRVU1zUTBGQlF5eExRVUZMTEUxQlFVY3NRMEZCUXl4SFFVRkhMRWxCUVVrc1IwRkJSeXhGUVVGRkxFTkJRVU03ZDBKQlJUZERMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUjBGQlJ5eFpRVUZaTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1pVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZETEVOQlFVTTdORUpCUTI1RUxGZEJRVk1zU1VGQlNTeFRRVUZKTEVOQlFVTXNRMEZCUXl4TFFVRkxMRTFCUVVjc1EwRkJReXhIUVVGSExFbEJRVWtzUjBGQlJ5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhPMmxDUVVOMFJDeERRVUZETzFOQlEwZ3NSVUZCUlR0WlFVTkVMRWxCUVVrc1JVRkJSU3hKUVVGSkxFZEJRVWNzUzBGQlN6dFpRVU5zUWl4TFFVRkxMRVZCUVVVc1JVRkJSVHRaUVVOVUxFVkJRVVVzUlVGQlJTeERRVUZETzI5Q1FVTklMRTFCUVUwc1JVRkJSU3hOUVVGTk8yOUNRVU5rTEUxQlFVMHNSVUZCUlN4dFFrRkJhVUlzVFVGQlRTeDVRa0ZCYjBJc1RVRkJUU3hSUVVGTE8ybENRVU12UkN4RFFVRkRPMU5CUTBnc1EwRkJReXhEUVVGRE8xRkJSVWdzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFppeFBRVUZQTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hYUVVGRExFVkJRVVVzVDBGQlR5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUXk5RExFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5tTEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxGZEJRVU1zUlVGQlJTeFJRVUZSTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRhRVFzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNN1NVRkRha0lzUTBGQlF6dERRVU5HTEVOQlFVTTdRVUZGYlVJc05FSkJRVTg3UVVGRk5VSXNhVUpCUVdsQ0xFOUJRVEpDTEVWQlFVVXNUMEZCWjBJN1NVRkROVVFzU1VGQlNTeERRVUZETEVkQlFVY3NUMEZCVHl4TFFVRkxMRmRCUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETzBsQlEyeERMRVZCUVVVc1EwRkJReXhEUVVGRExHZENRVUZqTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5vUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhMUVVGTExFZEJRVWNzUjBGQlJ5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUXpWQ0xFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTFnc1EwRkJRenRCUVVWRUxHbENRVUZwUWl4TFFVRm5RaXhGUVVGRkxFOUJRVEpDTEVWQlFVVXNUMEZCWjBJc1JVRkJSU3hKUVVGM1FpeEZRVUZGTEU5QlFXTTdTVUZEZUVnc1NVRkJUU3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZEY2tJc1RVRkJUU3hIUVVGUExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4RFFVRkxMRWxCUVVzc1QwRkJRU3hEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTERaQ1FVRnBRaXhEUVVGRExFOUJRVThzUlVGQlJTeFBRVUZQTEVOQlFVTXNSVUZCT1VNc1EwRkJPRU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVTjZSaXhOUVVGTkxFZEJRVWNzU1VGQlNTeEhRVUZITEUxQlFVMHNSVUZEZEVJc1MwRkJTeXhIUVVGSkxFbEJRVWtzUjBGQlJ5eExRVUZMTEVWQlEzSkNMRXRCUVVzc1IwRkJTU3hyUWtGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUlVGRE9VTXNUVUZCVFN4SFFVRkhMR0ZCUVZjc1QwRkJVeXhGUVVNM1FpeEpRVUZKTEVkQlFVY3NUMEZCVHl4RFFVRkRMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zUlVGRGFFTXNUVUZCVFN4SFFVRk5MRWxCUVVrc2EwSkJRV0VzVFVGQlRTeEhRVUZITEUxQlFVMHNWVUZCVHp0VFFVTTVReXhMUVVGTExGTkJRVWtzVDBGQlR5eFhRVUZOTEUxQlFVMHNVMEZCU1N4SlFVRk5MRU5CUVVFc1JVRkRNME1zUzBGQlN5eEhRVUZITEUxQlFVa3NUVUZCVFN4SFFVRkhMRTFCUVUwc1dVRkJUeXhOUVVGTkxFOUJRVWs3VTBGRE1VTXNTMEZCUnl4TlFVRk5MRWRCUVVjc1RVRkJUU3haUVVGUExFMUJRVTBzVFVGQlJ5eERRVUZCTEVWQlEzQkRMRVZCUVVVc1IwRkJSeXhaUVVGVkxFdEJRVThzUjBGQlJ5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWRCUVVjc1MwRkJTeXhIUVVGSExGbEJRVlVzU1VGQlRTeERRVUZETEVkQlFVY3NSMEZCUnl4RlFVTjZSU3hGUVVGRkxFZEJRVWNzV1VGQlZTeExRVUZQTEVkQlFVY3NRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhIUVVGSExGbEJRVlVzU1VGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJRenRKUVVVNVJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJRenRSUVVOaUxFMUJRVTBzUlVGQlJTeEZRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVNN1VVRkRka0lzVFVGQlRTeEZRVUZGTEdkQ1FVRmpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEV0QlFVc3NSMEZCUnl4blFrRkJZeXhMUVVGTExGVkJRVXNzUlVGQlJTeFZRVUZMTEVWQlFVVXNUVUZCUnp0TFFVTnVSaXhEUVVGRExFTkJRVU03UVVGRFRDeERRVUZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlZ2FfZXZlbnRfc2VsZWN0b3JfMSA9IHJlcXVpcmUoXCJ2ZWdhLWV2ZW50LXNlbGVjdG9yXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGFubmVsXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGludGVydmFsXzEgPSByZXF1aXJlKFwiLi4vaW50ZXJ2YWxcIik7XG52YXIgc2VsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vc2VsZWN0aW9uXCIpO1xudmFyIHNjYWxlc18xID0gcmVxdWlyZShcIi4vc2NhbGVzXCIpO1xudmFyIEFOQ0hPUiA9ICdfem9vbV9hbmNob3InLCBERUxUQSA9ICdfem9vbV9kZWx0YSc7XG52YXIgem9vbSA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0LnR5cGUgPT09ICdpbnRlcnZhbCcgJiYgc2VsQ21wdC56b29tICE9PSB1bmRlZmluZWQgJiYgc2VsQ21wdC56b29tICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgc2lnbmFscykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgZGVsdGEgPSBuYW1lICsgREVMVEEsIF9hID0gaW50ZXJ2YWxfMS5wcm9qZWN0aW9ucyhzZWxDbXB0KSwgeCA9IF9hLngsIHkgPSBfYS55LCBzeCA9IHV0aWxfMS5zdHJpbmdWYWx1ZShtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlgpKSwgc3kgPSB1dGlsXzEuc3RyaW5nVmFsdWUobW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ZKSk7XG4gICAgICAgIHZhciBldmVudHMgPSB2ZWdhX2V2ZW50X3NlbGVjdG9yXzEuc2VsZWN0b3Ioc2VsQ21wdC56b29tLCAnc2NvcGUnKTtcbiAgICAgICAgaWYgKCFzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSkge1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUubWFya25hbWUgPSBuYW1lICsgaW50ZXJ2YWxfMS5CUlVTSCwgZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lICsgQU5DSE9SLFxuICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IFwie3g6IGludmVydChcIiArIHN4ICsgXCIsIHgodW5pdCkpLCB5OiBpbnZlcnQoXCIgKyBzeSArIFwiLCB5KHVuaXQpKX1cIlxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IGRlbHRhLFxuICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiAncG93KDEuMDAxLCBldmVudC5kZWx0YVkgKiBwb3coMTYsIGV2ZW50LmRlbHRhTW9kZSkpJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25EZWx0YShtb2RlbCwgc2VsQ21wdCwgJ3gnLCAnd2lkdGgnLCBzaWduYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25EZWx0YShtb2RlbCwgc2VsQ21wdCwgJ3knLCAnaGVpZ2h0Jywgc2lnbmFscyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSBzaWduYWxzLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcy5uYW1lID09PSBuYW1lICsgaW50ZXJ2YWxfMS5TSVpFOyB9KTtcbiAgICAgICAgaWYgKHNpemUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc25hbWUgPSBzaXplWzBdLm5hbWU7XG4gICAgICAgICAgICBzaXplWzBdLm9uLnB1c2goe1xuICAgICAgICAgICAgICAgIGV2ZW50czogeyBzaWduYWw6IGRlbHRhIH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlOiBcInt4OiBcIiArIHNuYW1lICsgXCIueCwgeTogXCIgKyBzbmFtZSArIFwiLnksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwid2lkdGg6IFwiICsgc25hbWUgKyBcIi53aWR0aCAqIFwiICsgZGVsdGEgKyBcIiAsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChcImhlaWdodDogXCIgKyBzbmFtZSArIFwiLmhlaWdodCAqIFwiICsgZGVsdGEgKyBcIn1cIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduYWxzO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSB6b29tO1xuZnVuY3Rpb24gb25EZWx0YShtb2RlbCwgc2VsQ21wdCwgY2hhbm5lbCwgc2l6ZSwgc2lnbmFscykge1xuICAgIHZhciBuYW1lID0gc2VsQ21wdC5uYW1lLCBzaWduYWwgPSBzaWduYWxzLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gcy5uYW1lID09PSBzZWxlY3Rpb25fMS5jaGFubmVsU2lnbmFsTmFtZShzZWxDbXB0LCBjaGFubmVsKTsgfSlbMF0sIHNjYWxlcyA9IHNjYWxlc18xLmRlZmF1bHQuaGFzKHNlbENtcHQpLCBiYXNlID0gc2NhbGVzID8gc2NhbGVzXzEuZG9tYWluKG1vZGVsLCBjaGFubmVsKSA6IHNpZ25hbC5uYW1lLCBhbmNob3IgPSBcIlwiICsgbmFtZSArIEFOQ0hPUiArIFwiLlwiICsgY2hhbm5lbCwgZGVsdGEgPSBuYW1lICsgREVMVEEsIHNjYWxlID0gdXRpbF8xLnN0cmluZ1ZhbHVlKG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKSksIHJhbmdlID0gXCJbXCIgKyBhbmNob3IgKyBcIiArIChcIiArIGJhc2UgKyBcIlswXSAtIFwiICsgYW5jaG9yICsgXCIpICogXCIgKyBkZWx0YSArIFwiLCBcIiArXG4gICAgICAgIChhbmNob3IgKyBcIiArIChcIiArIGJhc2UgKyBcIlsxXSAtIFwiICsgYW5jaG9yICsgXCIpICogXCIgKyBkZWx0YSArIFwiXVwiKSwgbG8gPSBcImludmVydChcIiArIHNjYWxlICsgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gJywgMCcgOiBcIiwgdW5pdC5cIiArIHNpemUpICsgJyknLCBoaSA9IFwiaW52ZXJ0KFwiICsgc2NhbGUgKyAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyBcIiwgdW5pdC5cIiArIHNpemUgOiAnLCAwJykgKyAnKSc7XG4gICAgc2lnbmFsLm9uLnB1c2goe1xuICAgICAgICBldmVudHM6IHsgc2lnbmFsOiBkZWx0YSB9LFxuICAgICAgICB1cGRhdGU6IHNjYWxlcyA/IHJhbmdlIDogXCJjbGFtcFJhbmdlKFwiICsgcmFuZ2UgKyBcIiwgXCIgKyBsbyArIFwiLCBcIiArIGhpICsgXCIpXCJcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWVtOXZiUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwzTmxiR1ZqZEdsdmJpOTBjbUZ1YzJadmNtMXpMM3B2YjIwdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN3eVJFRkJPRVE3UVVGRE9VUXNORU5CUVN0RE8wRkJReTlETEhORFFVRXdRenRCUVVNeFF5eDNRMEZCSzBjN1FVRkRMMGNzTUVOQlFXMUZPMEZCUlc1RkxHMURRVUV5UkR0QlFVY3pSQ3hKUVVGTkxFMUJRVTBzUjBGQlJ5eGpRVUZqTEVWQlEzWkNMRXRCUVVzc1IwRkJTU3hoUVVGaExFTkJRVU03UVVGRk4wSXNTVUZCVFN4SlFVRkpMRWRCUVhGQ08wbEJRemRDTEVkQlFVY3NSVUZCUlN4VlFVRlRMRTlCUVU4N1VVRkRia0lzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRXRCUVVzc1ZVRkJWU3hKUVVGSkxFOUJRVThzUTBGQlF5eEpRVUZKTEV0QlFVc3NVMEZCVXl4SlFVRkpMRTlCUVU4c1EwRkJReXhKUVVGSkxFdEJRVXNzUzBGQlN5eERRVUZETzBsQlF6ZEdMRU5CUVVNN1NVRkZSQ3hQUVVGUExFVkJRVVVzVlVGQlV5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkZMRTlCUVU4N1VVRkRka01zU1VGQlRTeEpRVUZKTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkRja0lzUzBGQlN5eEhRVUZITEVsQlFVa3NSMEZCUnl4TFFVRkxMRVZCUTNCQ0xHOURRVUZ4UXl4RlFVRndReXhSUVVGRExFVkJRVVVzVVVGQlF5eEZRVU5NTEVWQlFVVXNSMEZCUnl4clFrRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkRjRU1zUlVGQlJTeEhRVUZITEd0Q1FVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFhRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlhwRExFbEJRVWtzVFVGQlRTeEhRVUZITERoQ1FVRmhMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVVnNSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdkQ1FVRmpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnFReXhOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkRMRU5CUVVNc1NVRkJTeXhQUVVGQkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSMEZCUnl4SlFVRkpMRWRCUVVjc1owSkJRV01zUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCZGtNc1EwRkJkVU1zUTBGQlF5eERRVUZETzFGQlEzUkZMRU5CUVVNN1VVRkZSQ3hQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETzFsQlExZ3NTVUZCU1N4RlFVRkZMRWxCUVVrc1IwRkJSeXhOUVVGTk8xbEJRMjVDTEVWQlFVVXNSVUZCUlN4RFFVRkRPMjlDUVVOSUxFMUJRVTBzUlVGQlJTeE5RVUZOTzI5Q1FVTmtMRTFCUVUwc1JVRkJSU3huUWtGQll5eEZRVUZGTERoQ1FVRjVRaXhGUVVGRkxHZENRVUZoTzJsQ1FVTnFSU3hEUVVGRE8xTkJRMGdzUlVGQlJUdFpRVU5FTEVsQlFVa3NSVUZCUlN4TFFVRkxPMWxCUTFnc1JVRkJSU3hGUVVGRkxFTkJRVU03YjBKQlEwZ3NUVUZCVFN4RlFVRkZMRTFCUVUwN2IwSkJRMlFzUzBGQlN5eEZRVUZGTEVsQlFVazdiMEpCUTFnc1RVRkJUU3hGUVVGRkxIRkVRVUZ4UkR0cFFrRkRPVVFzUTBGQlF6dFRRVU5JTEVOQlFVTXNRMEZCUXp0UlFVVklMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJZc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVVXNSMEZCUnl4RlFVRkZMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU5xUkN4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRaaXhQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4SFFVRkhMRVZCUVVVc1VVRkJVU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFGQlEyeEVMRU5CUVVNN1VVRkZSQ3hKUVVGTkxFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJTeXhKUVVGTExFOUJRVUVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4SlFVRkpMRWRCUVVjc1pVRkJZU3hGUVVFdlFpeERRVUVyUWl4RFFVRkRMRU5CUVVNN1VVRkRlRVVzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFSXNTVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTXpRaXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJRenRuUWtGRFpDeE5RVUZOTEVWQlFVVXNSVUZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTeXhGUVVGRE8yZENRVU4yUWl4TlFVRk5MRVZCUVVVc1UwRkJUeXhMUVVGTExHVkJRVlVzUzBGQlN5eFRRVUZOTzNGQ1FVTjJReXhaUVVGVkxFdEJRVXNzYVVKQlFWa3NTMEZCU3l4UlFVRkxMRU5CUVVFN2NVSkJRM0pETEdGQlFWY3NTMEZCU3l4clFrRkJZU3hMUVVGTExFMUJRVWNzUTBGQlFUdGhRVU40UXl4RFFVRkRMRU5CUVVNN1VVRkRUQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTnFRaXhEUVVGRE8wTkJRMFlzUTBGQlF6dEJRVVZqTEhWQ1FVRlBPMEZCUlhaQ0xHbENRVUZwUWl4TFFVRm5RaXhGUVVGRkxFOUJRVEpDTEVWQlFVVXNUMEZCWjBJc1JVRkJSU3hKUVVGM1FpeEZRVUZGTEU5QlFXTTdTVUZEZUVnc1NVRkJUU3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZEY2tJc1RVRkJUU3hIUVVGUExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4RFFVRkxMRWxCUVVzc1QwRkJRU3hEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTERaQ1FVRnBRaXhEUVVGRExFOUJRVThzUlVGQlJTeFBRVUZQTEVOQlFVTXNSVUZCT1VNc1EwRkJPRU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVTjZSaXhOUVVGTkxFZEJRVWNzWjBKQlFXTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRM0JETEVsQlFVa3NSMEZCUnl4TlFVRk5MRWRCUVVjc1pVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVOQlFVTXNSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hGUVVOd1JDeE5RVUZOTEVkQlFVY3NTMEZCUnl4SlFVRkpMRWRCUVVjc1RVRkJUU3hUUVVGSkxFOUJRVk1zUlVGRGRFTXNTMEZCU3l4SFFVRkpMRWxCUVVrc1IwRkJSeXhMUVVGTExFVkJRM0pDTEV0QlFVc3NSMEZCU1N4clFrRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1JVRkRPVU1zUzBGQlN5eEhRVUZKTEUxQlFVa3NUVUZCVFN4WlFVRlBMRWxCUVVrc1kwRkJVeXhOUVVGTkxGbEJRVThzUzBGQlN5eFBRVUZKTzFOQlEzaEVMRTFCUVUwc1dVRkJUeXhKUVVGSkxHTkJRVk1zVFVGQlRTeFpRVUZQTEV0QlFVc3NUVUZCUnl4RFFVRkJMRVZCUTNCRUxFVkJRVVVzUjBGQlJ5eFpRVUZWTEV0QlFVOHNSMEZCUnl4RFFVRkRMRTlCUVU4c1MwRkJTeXhYUVVGRExFZEJRVWNzUzBGQlN5eEhRVUZITEZsQlFWVXNTVUZCVFN4RFFVRkRMRWRCUVVjc1IwRkJSeXhGUVVONlJTeEZRVUZGTEVkQlFVY3NXVUZCVlN4TFFVRlBMRWRCUVVjc1EwRkJReXhQUVVGUExFdEJRVXNzVjBGQlF5eEhRVUZITEZsQlFWVXNTVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF6dEpRVVU1UlN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU5pTEUxQlFVMHNSVUZCUlN4RlFVRkRMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVU03VVVGRGRrSXNUVUZCVFN4RlFVRkZMRTFCUVUwc1IwRkJSeXhMUVVGTExFZEJRVWNzWjBKQlFXTXNTMEZCU3l4VlFVRkxMRVZCUVVVc1ZVRkJTeXhGUVVGRkxFMUJRVWM3UzBGRE9VUXNRMEZCUXl4RFFVRkRPMEZCUTB3c1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL2VuY29kaW5nXCIpO1xudmFyIHZsRW5jb2RpbmcgPSByZXF1aXJlKFwiLi4vZW5jb2RpbmdcIik7IC8vIFRPRE86IHJlbW92ZVxudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vZmllbGRkZWZcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4uL21hcmtcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi9zY2FsZVwiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4uL3N0YWNrXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi9heGlzL3BhcnNlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGFzc2VtYmxlXzEgPSByZXF1aXJlKFwiLi9kYXRhL2Fzc2VtYmxlXCIpO1xudmFyIHBhcnNlXzIgPSByZXF1aXJlKFwiLi9kYXRhL3BhcnNlXCIpO1xudmFyIGZhY2V0XzEgPSByZXF1aXJlKFwiLi9mYWNldFwiKTtcbnZhciBsYXllcl8xID0gcmVxdWlyZShcIi4vbGF5ZXJcIik7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2xheW91dC9pbmRleFwiKTtcbnZhciBwYXJzZV8zID0gcmVxdWlyZShcIi4vbGVnZW5kL3BhcnNlXCIpO1xudmFyIGluaXRfMSA9IHJlcXVpcmUoXCIuL21hcmsvaW5pdFwiKTtcbnZhciBtYXJrXzIgPSByZXF1aXJlKFwiLi9tYXJrL21hcmtcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIHJlcGVhdF8xID0gcmVxdWlyZShcIi4vcmVwZWF0XCIpO1xudmFyIGluaXRfMiA9IHJlcXVpcmUoXCIuL3NjYWxlL2luaXRcIik7XG52YXIgcGFyc2VfNCA9IHJlcXVpcmUoXCIuL3NjYWxlL3BhcnNlXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vc2VsZWN0aW9uL3NlbGVjdGlvblwiKTtcbi8qKlxuICogSW50ZXJuYWwgbW9kZWwgb2YgVmVnYS1MaXRlIHNwZWNpZmljYXRpb24gZm9yIHRoZSBjb21waWxlci5cbiAqL1xudmFyIFVuaXRNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVW5pdE1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuaXRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgcGFyZW50VW5pdFNpemUsIHJlcGVhdGVyLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHBhcmVudFVuaXRTaXplID09PSB2b2lkIDApIHsgcGFyZW50VW5pdFNpemUgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuYXhlcyA9IHt9O1xuICAgICAgICBfdGhpcy5sZWdlbmRzID0ge307XG4gICAgICAgIF90aGlzLnNlbGVjdGlvbiA9IHt9O1xuICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBGSVhNRSgjMjA0MSk6IGNvcHkgY29uZmlnLmZhY2V0LmNlbGwgdG8gY29uZmlnLmNlbGwgLS0gdGhpcyBzZWVtcyBpbmNvcnJlY3QgYW5kIHNob3VsZCBiZSByZXdyaXR0ZW5cbiAgICAgICAgX3RoaXMuaW5pdEZhY2V0Q2VsbENvbmZpZygpO1xuICAgICAgICAvLyB1c2UgdG9wLWxldmVsIHdpZHRoIC8gaGVpZ2h0IG9yIGFuY2VzdG9yJ3Mgd2lkdGggLyBoZWlnaHRcbiAgICAgICAgdmFyIHByb3ZpZGVkV2lkdGggPSBzcGVjLndpZHRoIHx8IHBhcmVudFVuaXRTaXplLndpZHRoO1xuICAgICAgICB2YXIgcHJvdmlkZWRIZWlnaHQgPSBzcGVjLmhlaWdodCB8fCBwYXJlbnRVbml0U2l6ZS5oZWlnaHQ7XG4gICAgICAgIHZhciBtYXJrID0gbWFya18xLmlzTWFya0RlZihzcGVjLm1hcmspID8gc3BlYy5tYXJrLnR5cGUgOiBzcGVjLm1hcms7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IF90aGlzLmVuY29kaW5nID0gZW5jb2RpbmdfMS5ub3JtYWxpemVFbmNvZGluZyhyZXBlYXRfMS5yZXBsYWNlUmVwZWF0ZXJJbkVuY29kaW5nKHNwZWMuZW5jb2RpbmcgfHwge30sIHJlcGVhdGVyKSwgbWFyayk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzdGFjayBwcm9wZXJ0aWVzXG4gICAgICAgIF90aGlzLnN0YWNrID0gc3RhY2tfMS5zdGFjayhtYXJrLCBlbmNvZGluZywgX3RoaXMuY29uZmlnLnN0YWNrKTtcbiAgICAgICAgX3RoaXMuc2NhbGVzID0gX3RoaXMuaW5pdFNjYWxlcyhtYXJrLCBlbmNvZGluZywgcHJvdmlkZWRXaWR0aCwgcHJvdmlkZWRIZWlnaHQpO1xuICAgICAgICBfdGhpcy5tYXJrRGVmID0gaW5pdF8xLmluaXRNYXJrRGVmKHNwZWMubWFyaywgZW5jb2RpbmcsIF90aGlzLnNjYWxlcywgX3RoaXMuY29uZmlnKTtcbiAgICAgICAgX3RoaXMuZW5jb2RpbmcgPSBpbml0XzEuaW5pdEVuY29kaW5nKG1hcmssIGVuY29kaW5nLCBfdGhpcy5zdGFjaywgX3RoaXMuY29uZmlnKTtcbiAgICAgICAgX3RoaXMuYXhlcyA9IF90aGlzLmluaXRBeGVzKGVuY29kaW5nKTtcbiAgICAgICAgX3RoaXMubGVnZW5kcyA9IF90aGlzLmluaXRMZWdlbmQoZW5jb2RpbmcpO1xuICAgICAgICAvLyBTZWxlY3Rpb25zIHdpbGwgYmUgaW5pdGlhbGl6ZWQgdXBvbiBwYXJzZS5cbiAgICAgICAgX3RoaXMuc2VsZWN0aW9uID0gc3BlYy5zZWxlY3Rpb247XG4gICAgICAgIC8vIHdpZHRoIC8gaGVpZ2h0XG4gICAgICAgIHZhciBfYSA9IF90aGlzLmluaXRTaXplKG1hcmssIF90aGlzLnNjYWxlcywgcHJvdmlkZWRXaWR0aCwgcHJvdmlkZWRIZWlnaHQpLCBfYiA9IF9hLndpZHRoLCB3aWR0aCA9IF9iID09PSB2b2lkIDAgPyBfdGhpcy53aWR0aCA6IF9iLCBfYyA9IF9hLmhlaWdodCwgaGVpZ2h0ID0gX2MgPT09IHZvaWQgMCA/IF90aGlzLmhlaWdodCA6IF9jO1xuICAgICAgICBfdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBfdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlc1tjaGFubmVsXTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuaGFzRGlzY3JldGVEb21haW4gPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4gc2NhbGUgJiYgc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZS50eXBlKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRNYXBwaW5nKClbY2hhbm5lbF0gfHwge30pLnNvcnQ7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmF4aXMgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5heGVzW2NoYW5uZWxdO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5sZWdlbmQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRzW2NoYW5uZWxdO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5pbml0RmFjZXRDZWxsQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgaGFzRmFjZXRBbmNlc3RvciA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoYW5jZXN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChhbmNlc3RvciBpbnN0YW5jZW9mIGZhY2V0XzEuRmFjZXRNb2RlbCkge1xuICAgICAgICAgICAgICAgIGhhc0ZhY2V0QW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0ZhY2V0QW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jZWxsID0gdXRpbF8xLmV4dGVuZCh7fSwgY29uZmlnLmNlbGwsIGNvbmZpZy5mYWNldC5jZWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5pbml0U2NhbGVzID0gZnVuY3Rpb24gKG1hcmssIGVuY29kaW5nLCB0b3BMZXZlbFdpZHRoLCB0b3BMZXZlbEhlaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeHlSYW5nZVN0ZXBzID0gW107XG4gICAgICAgIHJldHVybiBjaGFubmVsXzEuVU5JVF9TQ0FMRV9DSEFOTkVMUy5yZWR1Y2UoZnVuY3Rpb24gKHNjYWxlcywgY2hhbm5lbCkge1xuICAgICAgICAgICAgaWYgKHZsRW5jb2RpbmcuY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBjaGFubmVsKSB8fFxuICAgICAgICAgICAgICAgIChjaGFubmVsID09PSBjaGFubmVsXzEuWCAmJiB2bEVuY29kaW5nLmNoYW5uZWxIYXNGaWVsZChlbmNvZGluZywgY2hhbm5lbF8xLlgyKSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkgJiYgdmxFbmNvZGluZy5jaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWxfMS5ZMikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVzW2NoYW5uZWxdID0gaW5pdF8yLmRlZmF1bHQoY2hhbm5lbCwgZW5jb2RpbmdbY2hhbm5lbF0sIF90aGlzLmNvbmZpZywgbWFyaywgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyB0b3BMZXZlbFdpZHRoIDogY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkgPyB0b3BMZXZlbEhlaWdodCA6IHVuZGVmaW5lZCwgeHlSYW5nZVN0ZXBzIC8vIGZvciBkZXRlcm1pbmUgcG9pbnQgLyBiYXIgc2l6ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ZKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZS5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5UmFuZ2VTdGVwcy5wdXNoKHNjYWxlLnJhbmdlU3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjb25zb2xpZGF0ZSB0aGlzIHdpdGggc2NhbGU/ICBDdXJyZW50IHNjYWxlIHJhbmdlIGlzIGluIHBhcnNlU2NhbGUgKGxhdGVyKSxcbiAgICAvLyBidXQgbm90IGluIGluaXRTY2FsZSBiZWNhdXNlIHNjYWxlIHJhbmdlIGRlcGVuZHMgb24gc2l6ZSxcbiAgICAvLyBidXQgc2l6ZSBkZXBlbmRzIG9uIHNjYWxlIHR5cGUgYW5kIHJhbmdlU3RlcFxuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuaW5pdFNpemUgPSBmdW5jdGlvbiAobWFyaywgc2NhbGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNlbGxDb25maWcgPSB0aGlzLmNvbmZpZy5jZWxsO1xuICAgICAgICB2YXIgc2NhbGVDb25maWcgPSB0aGlzLmNvbmZpZy5zY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZVtjaGFubmVsXzEuWF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oc2NhbGVbY2hhbm5lbF8xLlhdLnR5cGUpIHx8ICFzY2FsZVtjaGFubmVsXzEuWF0ucmFuZ2VTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY2VsbENvbmZpZy53aWR0aDtcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2U6IERvIG5vdGhpbmcsIHVzZSBkeW5hbWljIHdpZHRoLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmsgPT09IG1hcmtfMS5URVhUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0ZXh0IHRhYmxlIHdpdGhvdXQgeC95IHNjYWxlIHdlIG5lZWQgd2lkZXIgcmFuZ2VTdGVwXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2NhbGVDb25maWcudGV4dFhSYW5nZVN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjYWxlQ29uZmlnLnJhbmdlU3RlcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX2luaXRTaXplIGRvZXMgbm90IGhhbmRsZSBzdHJpbmcgcmFuZ2VTdGVwcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2NhbGVDb25maWcucmFuZ2VTdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZVtjaGFubmVsXzEuWV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oc2NhbGVbY2hhbm5lbF8xLlldLnR5cGUpIHx8ICFzY2FsZVtjaGFubmVsXzEuWV0ucmFuZ2VTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGNlbGxDb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gLy8gZWxzZTogRG8gbm90aGluZywgdXNlIGR5bmFtaWMgaGVpZ2h0IC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NhbGVDb25maWcucmFuZ2VTdGVwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19pbml0U2l6ZSBkb2VzIG5vdCBoYW5kbGUgc3RyaW5nIHJhbmdlU3RlcHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2NhbGVDb25maWcucmFuZ2VTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuaW5pdEF4ZXMgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIFtjaGFubmVsXzEuWCwgY2hhbm5lbF8xLlldLnJlZHVjZShmdW5jdGlvbiAoX2F4aXMsIGNoYW5uZWwpIHtcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIEF4aXNcbiAgICAgICAgICAgIHZhciBjaGFubmVsRGVmID0gZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YICYmIGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy54MikpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ZICYmIGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy55MikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNTcGVjID0gZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpID8gY2hhbm5lbERlZi5heGlzIDogbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBXZSBubyBsb25nZXIgc3VwcG9ydCBmYWxzZSBpbiB0aGUgc2NoZW1hLCBidXQgd2Uga2VlcCBmYWxzZSBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRhYmlsaXR5LlxuICAgICAgICAgICAgICAgIGlmIChheGlzU3BlYyAhPT0gbnVsbCAmJiBheGlzU3BlYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX2F4aXNbY2hhbm5lbF0gPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBheGlzU3BlYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9heGlzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmluaXRMZWdlbmQgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxfMS5OT05TUEFUSUFMX1NDQUxFX0NIQU5ORUxTLnJlZHVjZShmdW5jdGlvbiAoX2xlZ2VuZCwgY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxEZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kU3BlYyA9IGNoYW5uZWxEZWYubGVnZW5kO1xuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRTcGVjICE9PSBudWxsICYmIGxlZ2VuZFNwZWMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sZWdlbmRbY2hhbm5lbF0gPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBsZWdlbmRTcGVjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2xlZ2VuZDtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5wYXJzZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmRhdGEgPSBwYXJzZV8yLnBhcnNlRGF0YSh0aGlzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnNlbGVjdGlvbiA9IHNlbGVjdGlvbl8xLnBhcnNlVW5pdFNlbGVjdGlvbih0aGlzLCB0aGlzLnNlbGVjdGlvbik7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLnBhcnNlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnNjYWxlcyA9IHBhcnNlXzQuZGVmYXVsdCh0aGlzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VNYXJrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5tYXJrID0gbWFya18yLnBhcnNlTWFyayh0aGlzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzQW5kSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5heGVzID0gcGFyc2VfMS5wYXJzZUF4aXNDb21wb25lbnQodGhpcywgW2NoYW5uZWxfMS5YLCBjaGFubmVsXzEuWV0pO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5wYXJzZUxlZ2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQubGVnZW5kcyA9IHBhcnNlXzMucGFyc2VMZWdlbmRDb21wb25lbnQodGhpcyk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgLy8gb25seSBhc3NlbWJsZSBkYXRhIGluIHRoZSByb290XG4gICAgICAgICAgICByZXR1cm4gYXNzZW1ibGVfMS5hc3NlbWJsZURhdGEodXRpbF8xLnZhbHModGhpcy5jb21wb25lbnQuZGF0YS5zb3VyY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNlbGVjdGlvblRvcExldmVsU2lnbmFscyA9IGZ1bmN0aW9uIChzaWduYWxzKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25fMS5hc3NlbWJsZVRvcExldmVsU2lnbmFscyh0aGlzLCBzaWduYWxzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTZWxlY3Rpb25TaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uXzEuYXNzZW1ibGVVbml0U2VsZWN0aW9uU2lnbmFscyh0aGlzLCBbXSk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25fMS5hc3NlbWJsZVVuaXRTZWxlY3Rpb25EYXRhKHRoaXMsIGRhdGEpO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTGF5b3V0U2lnbmFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4XzEuYXNzZW1ibGVMYXlvdXRVbml0U2lnbmFscyh0aGlzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVNYXJrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcmtzID0gdGhpcy5jb21wb25lbnQubWFyayB8fCBbXTtcbiAgICAgICAgLy8gSWYgdGhpcyB1bml0IGlzIHBhcnQgb2YgYSBsYXllciwgc2VsZWN0aW9ucyBzaG91bGQgYXVnbWVudFxuICAgICAgICAvLyBhbGwgaW4gY29uY2VydCByYXRoZXIgdGhhbiBlYWNoIHVuaXQgaW5kaXZpZHVhbGx5LiBUaGlzXG4gICAgICAgIC8vIGVuc3VyZXMgY29ycmVjdCBpbnRlcmxlYXZpbmcgb2YgY2xpcHBpbmcgYW5kIGJydXNoZWQgbWFya3MuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgfHwgISh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIGxheWVyXzEuTGF5ZXJNb2RlbCkpIHtcbiAgICAgICAgICAgIG1hcmtzID0gc2VsZWN0aW9uXzEuYXNzZW1ibGVVbml0U2VsZWN0aW9uTWFya3ModGhpcywgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrcy5tYXAodGhpcy5jb3JyZWN0RGF0YU5hbWVzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHsgd2lkdGg6IHRoaXMuZ2V0U2l6ZVNpZ25hbFJlZignd2lkdGgnKSwgaGVpZ2h0OiB0aGlzLmdldFNpemVTaWduYWxSZWYoJ2hlaWdodCcpIH0sIGNvbW1vbl8xLmFwcGx5Q29uZmlnKHt9LCB0aGlzLmNvbmZpZy5jZWxsLCBtYXJrXzEuRklMTF9TVFJPS0VfQ09ORklHLmNvbmNhdChbJ2NsaXAnXSkpKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuY2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjaGFubmVsXzEuVU5JVF9DSEFOTkVMUztcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuZ2V0TWFwcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2Rpbmc7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLnRvU3BlYyA9IGZ1bmN0aW9uIChleGNsdWRlQ29uZmlnLCBleGNsdWRlRGF0YSkge1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSB1dGlsXzEuZHVwbGljYXRlKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB2YXIgc3BlYztcbiAgICAgICAgc3BlYyA9IHtcbiAgICAgICAgICAgIG1hcms6IHRoaXMubWFya0RlZixcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWV4Y2x1ZGVDb25maWcpIHtcbiAgICAgICAgICAgIHNwZWMuY29uZmlnID0gdXRpbF8xLmR1cGxpY2F0ZSh0aGlzLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNsdWRlRGF0YSkge1xuICAgICAgICAgICAgc3BlYy5kYXRhID0gdXRpbF8xLmR1cGxpY2F0ZSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBkZWZhdWx0c1xuICAgICAgICByZXR1cm4gc3BlYztcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya0RlZi50eXBlO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5jaGFubmVsSGFzRmllbGQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdmxFbmNvZGluZy5jaGFubmVsSGFzRmllbGQodGhpcy5lbmNvZGluZywgY2hhbm5lbCk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmZpZWxkRGVmID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgfHwge31cbiAgICAgICAgLy8gQ3VycmVudGx5IHdlIGhhdmUgaXQgdG8gcHJldmVudCBudWxsIHBvaW50ZXIgZXhjZXB0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGluZ1tjaGFubmVsXSB8fCB7fTtcbiAgICB9O1xuICAgIC8qKiBHZXQgXCJmaWVsZFwiIHJlZmVyZW5jZSBmb3IgdmVnYSAqL1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbiAoY2hhbm5lbCwgb3B0KSB7XG4gICAgICAgIGlmIChvcHQgPT09IHZvaWQgMCkgeyBvcHQgPSB7fTsgfVxuICAgICAgICB2YXIgZmllbGREZWYgPSB0aGlzLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgICAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgICAgICBvcHQgPSB1dGlsXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBiaW5TdWZmaXg6IHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4odGhpcy5zY2FsZShjaGFubmVsKS50eXBlKSA/ICdyYW5nZScgOiAnc3RhcnQnXG4gICAgICAgICAgICB9LCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCBvcHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuaXRNb2RlbDtcbn0obW9kZWxfMS5Nb2RlbFdpdGhGaWVsZCkpO1xuZXhwb3J0cy5Vbml0TW9kZWwgPSBVbml0TW9kZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkVzVwZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDNWdWFYUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlEwRXNjME5CUVdkSU8wRkJSV2hJTEhkRFFVRjNSRHRCUVVONFJDeDNRMEZCTUVNc1EwRkJReXhsUVVGbE8wRkJRekZFTEhkRFFVRjNSVHRCUVVWNFJTeG5RMEZCZDBZN1FVRkRlRVlzYTBOQlFXdEVPMEZCU1d4RUxHdERRVUZuUkR0QlFVTm9SQ3huUTBGQmMwUTdRVUZGZEVRc2MwTkJRV2RFTzBGQlEyaEVMRzFEUVVGeFF6dEJRVU55UXl3MFEwRkJOa003UVVGRE4wTXNjME5CUVhWRE8wRkJRM1pETEdsRFFVRnRRenRCUVVOdVF5eHBRMEZCYlVNN1FVRkRia01zZDBOQlFYbEVPMEZCUTNwRUxIZERRVUZ2UkR0QlFVTndSQ3h2UTBGQmMwUTdRVUZEZEVRc2IwTkJRWE5ETzBGQlEzUkRMR2xEUVVFNFF6dEJRVU01UXl4dFEwRkJhMFU3UVVGRGJFVXNjVU5CUVhGRE8wRkJRM0pETEhWRFFVRm5SRHRCUVVOb1JDeHRSRUZCZFVzN1FVRkZka3M3TzBkQlJVYzdRVUZEU0R0SlFVRXJRaXh4UTBGQll6dEpRVFpDTTBNc2JVSkJRVmtzU1VGQll5eEZRVUZGTEUxQlFXRXNSVUZCUlN4bFFVRjFRaXhGUVVOb1JTeGpRVUUyUWl4RlFVRkZMRkZCUVhWQ0xFVkJRVVVzVFVGQll6dFJRVUYwUlN3clFrRkJRU3hGUVVGQkxHMUNRVUUyUWp0UlFVUXZRaXhaUVVWRkxHdENRVUZOTEVsQlFVa3NSVUZCUlN4TlFVRk5MRVZCUVVVc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eFRRV2RETjBNN1VVRTNRMU1zV1VGQlRTeEhRVUZuUWl4RlFVRkZMRU5CUVVNN1VVRkpla0lzVlVGQlNTeEhRVUZsTEVWQlFVVXNRMEZCUXp0UlFVVjBRaXhoUVVGUExFZEJRV2xDTEVWQlFVVXNRMEZCUXp0UlFVVnlRaXhsUVVGVExFZEJRWFZDTEVWQlFVVXNRMEZCUXp0UlFVTTFReXhqUVVGUkxFZEJRVmtzUlVGQlJTeERRVUZETzFGQlRUVkNMSE5IUVVGelJ6dFJRVU4wUnl4TFFVRkpMRU5CUVVNc2JVSkJRVzFDTEVWQlFVVXNRMEZCUXp0UlFVVXpRaXcwUkVGQk5FUTdVVUZETlVRc1NVRkJUU3hoUVVGaExFZEJRVWNzU1VGQlNTeERRVUZETEV0QlFVc3NTVUZCU1N4alFVRmpMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRM3BFTEVsQlFVMHNZMEZCWXl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFbEJRVWtzWTBGQll5eERRVUZETEUxQlFVMHNRMEZCUXp0UlFVVTFSQ3hKUVVGTkxFbEJRVWtzUjBGQlJ5eG5Ra0ZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlF5OUVMRWxCUVUwc1VVRkJVU3hIUVVGSExFdEJRVWtzUTBGQlF5eFJRVUZSTEVkQlFVY3NORUpCUVdsQ0xFTkJRVU1zYTBOQlFYbENMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzU1VGQlNTeEZRVUZGTEVWQlFVVXNVVUZCVVN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRmJrZ3NOa0pCUVRaQ08xRkJRemRDTEV0QlFVa3NRMEZCUXl4TFFVRkxMRWRCUVVjc1lVRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFJRVUZSTEVWQlFVVXNTMEZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU4wUkN4TFFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFdEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRkZCUVZFc1JVRkJSU3hoUVVGaExFVkJRVVVzWTBGQll5eERRVUZETEVOQlFVTTdVVUZGTjBVc1MwRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eHJRa0ZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFVkJRVVVzVVVGQlVTeEZRVUZGTEV0QlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlF6RkZMRXRCUVVrc1EwRkJReXhSUVVGUkxFZEJRVWNzYlVKQlFWa3NRMEZCUXl4SlFVRkpMRVZCUVVVc1VVRkJVU3hGUVVGRkxFdEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJSWFJGTEV0QlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1MwRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVTndReXhMUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEV0QlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRmVrTXNOa05CUVRaRE8xRkJRemRETEV0QlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF6dFJRVVZvUXl4cFFrRkJhVUk3VVVGRFdDeEpRVUZCTEhORlFVZE1MRVZCU0Uwc1lVRkJhMElzUlVGQmJFSXNkME5CUVd0Q0xFVkJRVVVzWTBGQmIwSXNSVUZCY0VJc01FTkJRVzlDTEVOQlJ6ZERPMUZCUTBZc1MwRkJTU3hEUVVGRExFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZEYmtJc1MwRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTTdPMGxCUTNaQ0xFTkJRVU03U1VGRlRTeDVRa0ZCU3l4SFFVRmFMRlZCUVdFc1QwRkJaMEk3VVVGRE0wSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZET1VJc1EwRkJRenRKUVVWTkxIRkRRVUZwUWl4SFFVRjRRaXhWUVVGNVFpeFBRVUZuUWp0UlFVTjJReXhKUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRMnhETEUxQlFVMHNRMEZCUXl4TFFVRkxMRWxCUVVrc2VVSkJRV2xDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRMmhFTEVOQlFVTTdTVUZIVFN4M1FrRkJTU3hIUVVGWUxGVkJRVmtzVDBGQlowSTdVVUZETVVJc1RVRkJUU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTnFSQ3hEUVVGRE8wbEJSVTBzZDBKQlFVa3NSMEZCV0N4VlFVRlpMRTlCUVdkQ08xRkJRekZDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlF6VkNMRU5CUVVNN1NVRkZUU3d3UWtGQlRTeEhRVUZpTEZWQlFXTXNUMEZCWjBJN1VVRkROVUlzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGREwwSXNRMEZCUXp0SlFVTlBMSFZEUVVGdFFpeEhRVUV6UWp0UlFVTkZMRWxCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZETTBJc1NVRkJTU3hSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTXpRaXhKUVVGSkxHZENRVUZuUWl4SFFVRkhMRXRCUVVzc1EwRkJRenRSUVVNM1FpeFBRVUZQTEZGQlFWRXNTMEZCU3l4SlFVRkpMRVZCUVVVc1EwRkJRenRaUVVONlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRmxCUVZrc2EwSkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTI1RExHZENRVUZuUWl4SFFVRkhMRWxCUVVrc1EwRkJRenRuUWtGRGVFSXNTMEZCU3l4RFFVRkRPMWxCUTFJc1EwRkJRenRaUVVORUxGRkJRVkVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUXpkQ0xFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tJc1RVRkJUU3hEUVVGRExFbEJRVWtzUjBGQlJ5eGhRVUZOTEVOQlFVTXNSVUZCUlN4RlFVRkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFVkJRVVVzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVNelJDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVlBMRGhDUVVGVkxFZEJRV3hDTEZWQlFXMUNMRWxCUVZVc1JVRkJSU3hSUVVFd1FpeEZRVUZGTEdGQlFXOUNMRVZCUVVVc1kwRkJjMEk3VVVGQmRrY3NhVUpCYzBKRE8xRkJja0pETEVsQlFVMHNXVUZCV1N4SFFVRmhMRVZCUVVVc1EwRkJRenRSUVVWc1F5eE5RVUZOTEVOQlFVTXNOa0pCUVcxQ0xFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFVTXNUVUZCVFN4RlFVRkZMRTlCUVU4N1dVRkRhRVFzUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVdVc1EwRkJReXhSUVVGUkxFVkJRVVVzVDBGQlR5eERRVUZETzJkQ1FVTTNReXhEUVVGRExFOUJRVThzUzBGQlN5eFhRVUZETEVsQlFVa3NWVUZCVlN4RFFVRkRMR1ZCUVdVc1EwRkJReXhSUVVGUkxFVkJRVVVzV1VGQlJTeERRVUZETEVOQlFVTTdaMEpCUXpORUxFTkJRVU1zVDBGQlR5eExRVUZMTEZkQlFVTXNTVUZCU1N4VlFVRlZMRU5CUVVNc1pVRkJaU3hEUVVGRExGRkJRVkVzUlVGQlJTeFpRVUZGTEVOQlFVTXNRMEZETlVRc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEwZ3NTVUZCVFN4TFFVRkxMRWRCUVVjc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEdOQlFWTXNRMEZEZGtNc1QwRkJUeXhGUVVGRkxGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlN4TFFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFbEJRVWtzUlVGRE4wTXNUMEZCVHl4TFFVRkxMRmRCUVVNc1IwRkJSeXhoUVVGaExFZEJRVWNzVDBGQlR5eExRVUZMTEZkQlFVTXNSMEZCUnl4alFVRmpMRWRCUVVjc1UwRkJVeXhGUVVNeFJTeFpRVUZaTEVOQlFVTXNhVU5CUVdsRE8ybENRVU12UXl4RFFVRkRPMmRDUVVWR0xFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWxCUVVrc1QwRkJUeXhMUVVGTExGZEJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTI1RExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU53UWl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXp0dlFrRkRja01zUTBGQlF6dG5Ra0ZEU0N4RFFVRkRPMWxCUTBnc1EwRkJRenRaUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZEYUVJc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzBsQlExUXNRMEZCUXp0SlFVVkVMRzlHUVVGdlJqdEpRVU53Uml3MFJFRkJORVE3U1VGRE5VUXNLME5CUVN0RE8wbEJRM1pETERSQ1FVRlJMRWRCUVdoQ0xGVkJRV2xDTEVsQlFWVXNSVUZCUlN4TFFVRnJRaXhGUVVGRkxFdEJRV0VzUlVGQlJTeE5RVUZqTzFGQlF6VkZMRWxCUVUwc1ZVRkJWU3hIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTNCRExFbEJRVTBzVjBGQlZ5eEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJSWFJETEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaENMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMklzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4NVFrRkJhVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZETjBRc1MwRkJTeXhIUVVGSExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTTdaMEpCUXpOQ0xFTkJRVU1zUTBGQlF5eDFRMEZCZFVNN1dVRkRNME1zUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4WFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU4yUWl3eVJFRkJNa1E3YjBKQlF6TkVMRXRCUVVzc1IwRkJSeXhYUVVGWExFTkJRVU1zWTBGQll5eERRVUZETzJkQ1FVTnlReXhEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMjlDUVVOT0xFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNWMEZCVnl4RFFVRkRMRk5CUVZNc1MwRkJTeXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzNkQ1FVTTVReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERaRFFVRTJReXhEUVVGRExFTkJRVU03YjBKQlEycEZMRU5CUVVNN2IwSkJRMFFzUzBGQlN5eEhRVUZITEZkQlFWY3NRMEZCUXl4VFFVRlRMRU5CUVVNN1owSkJRMmhETEVOQlFVTTdXVUZEU0N4RFFVRkRPMUZCUTBnc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM3BDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhYUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eDVRa0ZCYVVJc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRE4wUXNUVUZCVFN4SFFVRkhMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU03WjBKQlF6ZENMRU5CUVVNc1EwRkJReXg1UTBGQmVVTTdXVUZETjBNc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzVjBGQlZ5eERRVUZETEZOQlFWTXNTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU01UXl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExEWkRRVUUyUXl4RFFVRkRMRU5CUVVNN1owSkJRMnBGTEVOQlFVTTdaMEpCUTBRc1RVRkJUU3hIUVVGSExGZEJRVmNzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZEYWtNc1EwRkJRenRSUVVOSUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRTlCUVVFc1JVRkJSU3hOUVVGTkxGRkJRVUVzUlVGQlF5eERRVUZETzBsQlEzcENMRU5CUVVNN1NVRkZUeXcwUWtGQlVTeEhRVUZvUWl4VlFVRnBRaXhSUVVFd1FqdFJRVU42UXl4TlFVRk5MRU5CUVVNc1EwRkJReXhYUVVGRExFVkJRVVVzVjBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZNc1MwRkJTeXhGUVVGRkxFOUJRVTg3V1VGRE1VTXNaMEpCUVdkQ08xbEJSV2hDTEVsQlFVMHNWVUZCVlN4SFFVRkhMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU55UXl4RlFVRkZMRU5CUVVNc1EwRkJReXh4UWtGQlZTeERRVUZETEZWQlFWVXNRMEZCUXp0blFrRkRkRUlzUTBGQlF5eFBRVUZQTEV0QlFVc3NWMEZCUXl4SlFVRkpMSEZDUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVNeFF5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWxCUVVrc2NVSkJRVlVzUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlJTOURMRWxCUVUwc1VVRkJVU3hIUVVGSExIRkNRVUZWTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWRCUVVjc1ZVRkJWU3hEUVVGRExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTTdaMEpCUldwRkxDdEdRVUVyUmp0blFrRkRMMFlzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4TFFVRkxMRWxCUVVrc1NVRkJTU3hSUVVGUkxFdEJRVXNzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkROVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4M1FrRkRWQ3hSUVVGUkxFTkJRMW9zUTBGQlF6dG5Ra0ZEU2l4RFFVRkRPMWxCUTBnc1EwRkJRenRaUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZEWml4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRFZDeERRVUZETzBsQlJVOHNPRUpCUVZVc1IwRkJiRUlzVlVGQmJVSXNVVUZCTUVJN1VVRkRNME1zVFVGQlRTeERRVUZETEcxRFFVRjVRaXhEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZUTEU5QlFVOHNSVUZCUlN4UFFVRlBPMWxCUXk5RUxFbEJRVTBzVlVGQlZTeEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRNMElzU1VGQlRTeFZRVUZWTEVkQlFVY3NWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJRenRuUWtGRGNrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hMUVVGTExFbEJRVWtzU1VGQlNTeFZRVUZWTEV0QlFVc3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGFFUXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXgzUWtGQlR5eFZRVUZWTEVOQlFVTXNRMEZCUXp0blFrRkRja01zUTBGQlF6dFpRVU5JTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8xRkJRMnBDTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOVUxFTkJRVU03U1VGRlRTdzJRa0ZCVXl4SFFVRm9RanRSUVVORkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4SFFVRkhMR2xDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEZUVNc1EwRkJRenRKUVVWTkxHdERRVUZqTEVkQlFYSkNPMUZCUTBVc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVkQlFVY3NPRUpCUVd0Q0xFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRKUVVOMFJTeERRVUZETzBsQlJVMHNPRUpCUVZVc1IwRkJha0k3VVVGRFJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhsUVVGdFFpeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTNCRUxFTkJRVU03U1VGRlRTdzJRa0ZCVXl4SFFVRm9RanRSUVVORkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4SFFVRkhMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEZUVNc1EwRkJRenRKUVVWTkxITkRRVUZyUWl4SFFVRjZRanRSUVVORkxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4SFFVRkhMREJDUVVGclFpeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRmRCUVVNc1JVRkJSU3hYUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzcEVMRU5CUVVNN1NVRkZUU3dyUWtGQlZ5eEhRVUZzUWp0UlFVTkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eEhRVUZITERSQ1FVRnZRaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlEzUkVMRU5CUVVNN1NVRkZUU3huUTBGQldTeEhRVUZ1UWp0UlFVTkhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRiRUlzYVVOQlFXbERPMWxCUTJwRExFMUJRVTBzUTBGQlF5eDFRa0ZCV1N4RFFVRkRMRmRCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM3BFTEVOQlFVTTdVVUZEUkN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZOTEc5RVFVRm5ReXhIUVVGMlF5eFZRVUYzUXl4UFFVRmpPMUZCUTNCRUxFMUJRVTBzUTBGQlF5eHRRMEZCZFVJc1EwRkJReXhKUVVGSkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdTVUZEYUVRc1EwRkJRenRKUVVWTkxEUkRRVUYzUWl4SFFVRXZRanRSUVVORkxFMUJRVTBzUTBGQlF5eDNRMEZCTkVJc1EwRkJReXhKUVVGSkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEYUVRc1EwRkJRenRKUVVWTkxIbERRVUZ4UWl4SFFVRTFRaXhWUVVFMlFpeEpRVUZqTzFGQlEzcERMRTFCUVUwc1EwRkJReXh4UTBGQmVVSXNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGREwwTXNRMEZCUXp0SlFVVk5MR3REUVVGakxFZEJRWEpDTzFGQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRlRTeDVRMEZCY1VJc1IwRkJOVUk3VVVGRFJTeE5RVUZOTEVOQlFVTXNhVU5CUVhsQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEZWtNc1EwRkJRenRKUVVWTkxHbERRVUZoTEVkQlFYQkNPMUZCUTBVc1NVRkJTU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJSWFJETERaRVFVRTJSRHRSUVVNM1JDd3dSRUZCTUVRN1VVRkRNVVFzT0VSQlFUaEVPMUZCUXpsRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1NVRkJTU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNXVUZCV1N4clFrRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcEVMRXRCUVVzc1IwRkJSeXh6UTBGQk1FSXNRMEZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGJFUXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZUU3hwUkVGQk5rSXNSMEZCY0VNN1VVRkRSU3hOUVVGTkxHOUNRVU5LTEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUTNKRExFMUJRVTBzUlVGQlJTeEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVVVGQlVTeERRVUZETEVsQlEzQkRMRzlDUVVGWExFTkJRVU1zUlVGQlJTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hGUVVGRkxIbENRVUZyUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZEZWtVN1NVRkRTaXhEUVVGRE8wbEJSVTBzTkVKQlFWRXNSMEZCWmp0UlFVTkZMRTFCUVUwc1EwRkJReXgxUWtGQllTeERRVUZETzBsQlEzWkNMRU5CUVVNN1NVRkZVeXc0UWtGQlZTeEhRVUZ3UWp0UlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETzBsQlEzWkNMRU5CUVVNN1NVRkZUU3d3UWtGQlRTeEhRVUZpTEZWQlFXTXNZVUZCYlVJc1JVRkJSU3hYUVVGcFFqdFJRVU5zUkN4SlFVRk5MRkZCUVZFc1IwRkJSeXhuUWtGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVNeFF5eEpRVUZKTEVsQlFWTXNRMEZCUXp0UlFVVmtMRWxCUVVrc1IwRkJSenRaUVVOTUxFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNUMEZCVHp0WlFVTnNRaXhSUVVGUkxFVkJRVVVzVVVGQlVUdFRRVU51UWl4RFFVRkRPMUZCUlVZc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NaMEpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEZGtNc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOcVFpeEpRVUZKTEVOQlFVTXNTVUZCU1N4SFFVRkhMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTI1RExFTkJRVU03VVVGRlJDeHJRa0ZCYTBJN1VVRkRiRUlzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTmtMRU5CUVVNN1NVRkZUU3gzUWtGQlNTeEhRVUZZTzFGQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETzBsQlF6TkNMRU5CUVVNN1NVRkZUU3h0UTBGQlpTeEhRVUYwUWl4VlFVRjFRaXhQUVVGblFqdFJRVU55UXl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExHVkJRV1VzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRelZFTEVOQlFVTTdTVUZGVFN3MFFrRkJVU3hIUVVGbUxGVkJRV2RDTEU5QlFXZENPMUZCUXpsQ0xEQkNRVUV3UWp0UlFVTXhRaXd3UkVGQk1FUTdVVUZETVVRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8wbEJRM1JETEVOQlFVTTdTVUZGUkN4eFEwRkJjVU03U1VGRE9VSXNlVUpCUVVzc1IwRkJXaXhWUVVGaExFOUJRV2RDTEVWQlFVVXNSMEZCZDBJN1VVRkJlRUlzYjBKQlFVRXNSVUZCUVN4UlFVRjNRanRSUVVOeVJDeEpRVUZOTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzFGQlJYaERMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xFZEJRVWNzUjBGQlJ5eGhRVUZOTEVOQlFVTTdaMEpCUTFnc1UwRkJVeXhGUVVGRkxIbENRVUZwUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1QwRkJUeXhIUVVGSExFOUJRVTg3WVVGRE0wVXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVOV0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNaMEpCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZET1VJc1EwRkJRenRKUVVOSUxHZENRVUZETzBGQlFVUXNRMEZCUXl4QlFUTlZSQ3hEUVVFclFpeHpRa0ZCWXl4SFFUSlZOVU03UVVFelZWa3NPRUpCUVZNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi8uLi9maWVsZGRlZlwiKTtcbmV4cG9ydHMuQk9YUExPVCA9ICdib3gtcGxvdCc7XG5mdW5jdGlvbiBub3JtYWxpemVCb3hQbG90KHNwZWMsIGNvbmZpZykge1xuICAgIHZhciBfbSA9IHNwZWMubWFyaywgZW5jb2RpbmcgPSBzcGVjLmVuY29kaW5nLCBvdXRlclNwZWMgPSB0c2xpYl8xLl9fcmVzdChzcGVjLCBbXCJtYXJrXCIsIFwiZW5jb2RpbmdcIl0pO1xuICAgIHZhciBfeCA9IGVuY29kaW5nLngsIF95ID0gZW5jb2RpbmcueSwgbm9uUG9zaXRpb25FbmNvZGluZyA9IHRzbGliXzEuX19yZXN0KGVuY29kaW5nLCBbXCJ4XCIsIFwieVwiXSk7XG4gICAgdmFyIHNpemUgPSBub25Qb3NpdGlvbkVuY29kaW5nLnNpemUsIG5vblBvc2l0aW9uRW5jb2RpbmdXaXRob3V0U2l6ZSA9IHRzbGliXzEuX19yZXN0KG5vblBvc2l0aW9uRW5jb2RpbmcsIFtcInNpemVcIl0pO1xuICAgIHZhciBfY29sb3IgPSBub25Qb3NpdGlvbkVuY29kaW5nV2l0aG91dFNpemUuY29sb3IsIG5vblBvc2l0aW9uRW5jb2RpbmdXaXRob3V0Q29sb3JTaXplID0gdHNsaWJfMS5fX3Jlc3Qobm9uUG9zaXRpb25FbmNvZGluZ1dpdGhvdXRTaXplLCBbXCJjb2xvclwiXSk7XG4gICAgdmFyIG1pZFRpY2tBbmRCYXJTaXplQ2hhbm5lbERlZiA9IHNpemUgPyB7IHNpemU6IHNpemUgfSA6IHsgc2l6ZTogeyB2YWx1ZTogY29uZmlnLmJveC5zaXplIH0gfTtcbiAgICB2YXIgZGlzY3JldGVBeGlzRmllbGREZWYsIGNvbnRpbnVvdXNBeGlzQ2hhbm5lbERlZjtcbiAgICB2YXIgZGlzY3JldGVBeGlzLCBjb250aW51b3VzQXhpcztcbiAgICBpZiAoZW5jb2RpbmcueCAmJiBlbmNvZGluZy55KSB7XG4gICAgICAgIC8vIDJEXG4gICAgICAgIGlmIChmaWVsZGRlZl8xLmlzRGlzY3JldGUoZW5jb2RpbmcueCkgJiYgZmllbGRkZWZfMS5pc0NvbnRpbnVvdXMoZW5jb2RpbmcueSkpIHtcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsXG4gICAgICAgICAgICBkaXNjcmV0ZUF4aXMgPSAneCc7XG4gICAgICAgICAgICBjb250aW51b3VzQXhpcyA9ICd5JztcbiAgICAgICAgICAgIGNvbnRpbnVvdXNBeGlzQ2hhbm5lbERlZiA9IGVuY29kaW5nLnk7XG4gICAgICAgICAgICBkaXNjcmV0ZUF4aXNGaWVsZERlZiA9IGVuY29kaW5nLng7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRkZWZfMS5pc0Rpc2NyZXRlKGVuY29kaW5nLnkpICYmIGZpZWxkZGVmXzEuaXNDb250aW51b3VzKGVuY29kaW5nLngpKSB7XG4gICAgICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICBkaXNjcmV0ZUF4aXMgPSAneSc7XG4gICAgICAgICAgICBjb250aW51b3VzQXhpcyA9ICd4JztcbiAgICAgICAgICAgIGNvbnRpbnVvdXNBeGlzQ2hhbm5lbERlZiA9IGVuY29kaW5nLng7XG4gICAgICAgICAgICBkaXNjcmV0ZUF4aXNGaWVsZERlZiA9IGVuY29kaW5nLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgb25lIGNvbnRpbnVvdXMgYW5kIG9uZSBkaXNjcmV0ZSBheGlzIGZvciAyRCBib3hwbG90cycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuY29kaW5nLnggJiYgZmllbGRkZWZfMS5pc0NvbnRpbnVvdXMoZW5jb2RpbmcueCkgJiYgZW5jb2RpbmcueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIDFEIGhvcml6b250YWxcbiAgICAgICAgY29udGludW91c0F4aXMgPSAneCc7XG4gICAgICAgIGNvbnRpbnVvdXNBeGlzQ2hhbm5lbERlZiA9IGVuY29kaW5nLng7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuY29kaW5nLnggPT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZy55ICYmIGZpZWxkZGVmXzEuaXNDb250aW51b3VzKGVuY29kaW5nLnkpKSB7XG4gICAgICAgIC8vIDFEIHZlcnRpY2FsXG4gICAgICAgIGNvbnRpbnVvdXNBeGlzID0gJ3knO1xuICAgICAgICBjb250aW51b3VzQXhpc0NoYW5uZWxEZWYgPSBlbmNvZGluZy55O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGEgY29udGludW91cyBheGlzIGZvciAxRCBib3hwbG90cycpO1xuICAgIH1cbiAgICBpZiAoY29udGludW91c0F4aXNDaGFubmVsRGVmLmFnZ3JlZ2F0ZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRpbnVvdXNBeGlzQ2hhbm5lbERlZi5hZ2dyZWdhdGUgIT09IGV4cG9ydHMuQk9YUExPVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRpbnVvdXMgYXhpcyBzaG91bGQgbm90IGJlIGFnZ3JlZ2F0ZWQnKTtcbiAgICB9XG4gICAgdmFyIGJhc2VDb250aW51b3VzRmllbGREZWYgPSB7XG4gICAgICAgIGZpZWxkOiBjb250aW51b3VzQXhpc0NoYW5uZWxEZWYuZmllbGQsXG4gICAgICAgIHR5cGU6IGNvbnRpbnVvdXNBeGlzQ2hhbm5lbERlZi50eXBlXG4gICAgfTtcbiAgICB2YXIgbWluRmllbGREZWYgPSB0c2xpYl8xLl9fYXNzaWduKHsgYWdncmVnYXRlOiAnbWluJyB9LCBiYXNlQ29udGludW91c0ZpZWxkRGVmKTtcbiAgICB2YXIgbWluV2l0aEF4aXNGaWVsZERlZiA9IHRzbGliXzEuX19hc3NpZ24oeyBheGlzOiBjb250aW51b3VzQXhpc0NoYW5uZWxEZWYuYXhpcyB9LCBtaW5GaWVsZERlZik7XG4gICAgdmFyIHExRmllbGREZWYgPSB0c2xpYl8xLl9fYXNzaWduKHsgYWdncmVnYXRlOiAncTEnIH0sIGJhc2VDb250aW51b3VzRmllbGREZWYpO1xuICAgIHZhciBtZWRpYW5GaWVsZERlZiA9IHRzbGliXzEuX19hc3NpZ24oeyBhZ2dyZWdhdGU6ICdtZWRpYW4nIH0sIGJhc2VDb250aW51b3VzRmllbGREZWYpO1xuICAgIHZhciBxM0ZpZWxkRGVmID0gdHNsaWJfMS5fX2Fzc2lnbih7IGFnZ3JlZ2F0ZTogJ3EzJyB9LCBiYXNlQ29udGludW91c0ZpZWxkRGVmKTtcbiAgICB2YXIgbWF4RmllbGREZWYgPSB0c2xpYl8xLl9fYXNzaWduKHsgYWdncmVnYXRlOiAnbWF4JyB9LCBiYXNlQ29udGludW91c0ZpZWxkRGVmKTtcbiAgICB2YXIgZGlzY3JldGVBeGlzRW5jb2RpbmdNaXhpbiA9IGRpc2NyZXRlQXhpc0ZpZWxkRGVmICE9PSB1bmRlZmluZWQgPyAoX2EgPSB7fSwgX2FbZGlzY3JldGVBeGlzXSA9IGRpc2NyZXRlQXhpc0ZpZWxkRGVmLCBfYSkgOiB7fTtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgb3V0ZXJTcGVjLCB7IGxheWVyOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFyazoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncnVsZScsXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdib3hXaGlza2VyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHRzbGliXzEuX19hc3NpZ24oe30sIGRpc2NyZXRlQXhpc0VuY29kaW5nTWl4aW4sIChfYiA9IHt9LCBfYltjb250aW51b3VzQXhpc10gPSBtaW5XaXRoQXhpc0ZpZWxkRGVmLCBfYltjb250aW51b3VzQXhpcyArICcyJ10gPSBxMUZpZWxkRGVmLCBfYiksIG5vblBvc2l0aW9uRW5jb2RpbmdXaXRob3V0Q29sb3JTaXplKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1hcms6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3J1bGUnLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiAnYm94V2hpc2tlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBkaXNjcmV0ZUF4aXNFbmNvZGluZ01peGluLCAoX2MgPSB7fSwgX2NbY29udGludW91c0F4aXNdID0gcTNGaWVsZERlZiwgX2NbY29udGludW91c0F4aXMgKyAnMiddID0gbWF4RmllbGREZWYsIF9jKSwgbm9uUG9zaXRpb25FbmNvZGluZ1dpdGhvdXRDb2xvclNpemUpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbWFyazoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2JveCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBkaXNjcmV0ZUF4aXNFbmNvZGluZ01peGluLCAoX2QgPSB7fSwgX2RbY29udGludW91c0F4aXNdID0gcTFGaWVsZERlZiwgX2RbY29udGludW91c0F4aXMgKyAnMiddID0gcTNGaWVsZERlZiwgX2QpLCBub25Qb3NpdGlvbkVuY29kaW5nV2l0aG91dFNpemUsIG1pZFRpY2tBbmRCYXJTaXplQ2hhbm5lbERlZilcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtYXJrOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0aWNrJyxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2JveE1pZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBkaXNjcmV0ZUF4aXNFbmNvZGluZ01peGluLCAoX2UgPSB7fSwgX2VbY29udGludW91c0F4aXNdID0gbWVkaWFuRmllbGREZWYsIF9lKSwgbm9uUG9zaXRpb25FbmNvZGluZywgbWlkVGlja0FuZEJhclNpemVDaGFubmVsRGVmLCB7ICdjb2xvcic6IHsgJ3ZhbHVlJzogJ3doaXRlJyB9IH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIF0gfSk7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbn1cbmV4cG9ydHMubm9ybWFsaXplQm94UGxvdCA9IG5vcm1hbGl6ZUJveFBsb3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZbTk0Y0d4dmRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YjNOcGRHVnRZWEpyTDJKdmVIQnNiM1F1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJSMEVzTUVOQlFYbEZPMEZCU1RWRUxGRkJRVUVzVDBGQlR5eEhRVUZsTEZWQlFWVXNRMEZCUXp0QlFWTTVReXd3UWtGQmFVTXNTVUZCSzBNc1JVRkJSU3hOUVVGak8wbEJRM1pHTEVsQlFVRXNZMEZCVVN4RlFVRkZMSGRDUVVGclFpeEZRVUZGTEhORVFVRlpMRU5CUVZNN1NVRkRia1FzU1VGQlFTeGxRVUZMTEVWQlFVVXNaVUZCU3l4RlFVRkZMREJFUVVGelFpeERRVUZoTzBsQlEycEVMRWxCUVVFc0swSkJRVlVzUlVGQlJTdzRSVUZCYVVNc1EwRkJkMEk3U1VGRGNrVXNTVUZCUVN3MlEwRkJZU3hGUVVGRkxDdEdRVUZ6UXl4RFFVRnRRenRKUVVNdlJpeEpRVUZOTERKQ1FVRXlRaXhIUVVGSExFbEJRVWtzUjBGQlJ5eEZRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVNc1IwRkJSeXhGUVVGRExFbEJRVWtzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUlVGQlF5eEZRVUZETEVOQlFVTTdTVUZGTTBZc1NVRkJTU3h2UWtGQmIwSXNSVUZCUlN4M1FrRkJhVVFzUTBGQlF6dEpRVU0xUlN4SlFVRkpMRmxCUVZrc1JVRkJSU3hqUVVGakxFTkJRVU03U1VGRmFrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zU1VGQlNTeFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNM1FpeExRVUZMTzFGQlEwd3NSVUZCUlN4RFFVRkRMRU5CUVVNc2NVSkJRVlVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc2RVSkJRVmtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1pFTEZkQlFWYzdXVUZEV0N4WlFVRlpMRWRCUVVjc1IwRkJSeXhEUVVGRE8xbEJRMjVDTEdOQlFXTXNSMEZCUnl4SFFVRkhMRU5CUVVNN1dVRkRja0lzZDBKQlFYZENMRWRCUVVjc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVYwUXl4dlFrRkJiMElzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCRExFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2NVSkJRVlVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc2RVSkJRVmtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxFTEdGQlFXRTdXVUZEWWl4WlFVRlpMRWRCUVVjc1IwRkJSeXhEUVVGRE8xbEJRMjVDTEdOQlFXTXNSMEZCUnl4SFFVRkhMRU5CUVVNN1dVRkRja0lzZDBKQlFYZENMRWRCUVVjc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVVYwUXl4dlFrRkJiMElzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCRExFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zTWtSQlFUSkVMRU5CUVVNc1EwRkJRenRSUVVNdlJTeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4SlFVRkpMSFZDUVVGWkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRkZCUVZFc1EwRkJReXhEUVVGRExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTTVSU3huUWtGQlowSTdVVUZEYUVJc1kwRkJZeXhIUVVGSExFZEJRVWNzUTBGQlF6dFJRVU55UWl4M1FrRkJkMElzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNoRExFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUzBGQlN5eFRRVUZUTEVsQlFVa3NVVUZCVVN4RFFVRkRMRU5CUVVNc1NVRkJTU3gxUWtGQldTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VVXNZMEZCWXp0UlFVTmtMR05CUVdNc1IwRkJSeXhIUVVGSExFTkJRVU03VVVGRGNrSXNkMEpCUVhkQ0xFZEJRVWNzVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjRReXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExIZERRVUYzUXl4RFFVRkRMRU5CUVVNN1NVRkROVVFzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGRDUVVGM1FpeERRVUZETEZOQlFWTXNTMEZCU3l4VFFVRlRMRWxCUVVrc2QwSkJRWGRDTEVOQlFVTXNVMEZCVXl4TFFVRkxMR1ZCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRrY3NUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXd3UTBGQk1FTXNRMEZCUXl4RFFVRkRPMGxCUXpsRUxFTkJRVU03U1VGRlJDeEpRVUZOTEhOQ1FVRnpRaXhIUVVGSE8xRkJRek5DTEV0QlFVc3NSVUZCUlN4M1FrRkJkMElzUTBGQlF5eExRVUZMTzFGQlEzSkRMRWxCUVVrc1JVRkJSU3gzUWtGQmQwSXNRMEZCUXl4SlFVRkpPMHRCUTNSRExFTkJRVU03U1VGRlJpeEpRVUZOTEZkQlFWY3NjMEpCUTJZc1UwRkJVeXhGUVVGRkxFdEJRVXNzU1VGRFlpeHpRa0ZCYzBJc1EwRkRNVUlzUTBGQlF6dEpRVU5HTEVsQlFVMHNiVUpCUVcxQ0xITkNRVU4yUWl4SlFVRkpMRVZCUVVVc2QwSkJRWGRDTEVOQlFVTXNTVUZCU1N4SlFVTm9ReXhYUVVGWExFTkJRMllzUTBGQlF6dEpRVU5HTEVsQlFVMHNWVUZCVlN4elFrRkRaQ3hUUVVGVExFVkJRVVVzU1VGQlNTeEpRVU5hTEhOQ1FVRnpRaXhEUVVNeFFpeERRVUZETzBsQlEwWXNTVUZCVFN4alFVRmpMSE5DUVVOc1FpeFRRVUZUTEVWQlFVVXNVVUZCVVN4SlFVTm9RaXh6UWtGQmMwSXNRMEZETVVJc1EwRkJRenRKUVVOR0xFbEJRVTBzVlVGQlZTeHpRa0ZEWkN4VFFVRlRMRVZCUVVVc1NVRkJTU3hKUVVOYUxITkNRVUZ6UWl4RFFVTXhRaXhEUVVGRE8wbEJRMFlzU1VGQlRTeFhRVUZYTEhOQ1FVTm1MRk5CUVZNc1JVRkJSU3hMUVVGTExFbEJRMklzYzBKQlFYTkNMRU5CUXpGQ0xFTkJRVU03U1VGRlJpeEpRVUZOTEhsQ1FVRjVRaXhIUVVGSExHOUNRVUZ2UWl4TFFVRkxMRk5CUVZNc1lVRkJTU3hIUVVGRExGbEJRVmtzU1VGQlJ5eHZRa0ZCYjBJc1VVRkJTU3hGUVVGRkxFTkJRVU03U1VGRmJrZ3NUVUZCVFN4elFrRkRSQ3hUUVVGVExFbEJRMW9zUzBGQlN5eEZRVUZGTzFsQlEwdzdaMEpCUTBVc1NVRkJTU3hGUVVGRk8yOUNRVU5LTEVsQlFVa3NSVUZCUlN4TlFVRk5PMjlDUVVOYUxFbEJRVWtzUlVGQlJTeFpRVUZaTzJsQ1FVTnVRanRuUWtGRFJDeFJRVUZSTEhWQ1FVTklMSGxDUVVGNVFpeGxRVU16UWl4alFVRmpMRWxCUVVjc2JVSkJRVzFDTEV0QlEzQkRMR05CUVdNc1IwRkJSeXhIUVVGSExFbEJRVWNzVlVGQlZTeFBRVU12UWl4dFEwRkJiVU1zUTBGRGRrTTdZVUZEUml4RlFVRkZPMmRDUVVORUxFbEJRVWtzUlVGQlJUdHZRa0ZEU2l4SlFVRkpMRVZCUVVVc1RVRkJUVHR2UWtGRFdpeEpRVUZKTEVWQlFVVXNXVUZCV1R0cFFrRkRia0k3WjBKQlEwUXNVVUZCVVN4MVFrRkRTQ3g1UWtGQmVVSXNaVUZETTBJc1kwRkJZeXhKUVVGSExGVkJRVlVzUzBGRE0wSXNZMEZCWXl4SFFVRkhMRWRCUVVjc1NVRkJSeXhYUVVGWExFOUJRMmhETEcxRFFVRnRReXhEUVVOMlF6dGhRVU5HTEVWQlFVVTdaMEpCUTBRc1NVRkJTU3hGUVVGRk8yOUNRVU5LTEVsQlFVa3NSVUZCUlN4TFFVRkxPMjlDUVVOWUxFbEJRVWtzUlVGQlJTeExRVUZMTzJsQ1FVTmFPMmRDUVVORUxGRkJRVkVzZFVKQlEwZ3NlVUpCUVhsQ0xHVkJRek5DTEdOQlFXTXNTVUZCUnl4VlFVRlZMRXRCUXpOQ0xHTkJRV01zUjBGQlJ5eEhRVUZITEVsQlFVY3NWVUZCVlN4UFFVTXZRaXc0UWtGQk9FSXNSVUZET1VJc01rSkJRVEpDTEVOQlF5OUNPMkZCUTBZc1JVRkJSVHRuUWtGRFJDeEpRVUZKTEVWQlFVVTdiMEpCUTBvc1NVRkJTU3hGUVVGRkxFMUJRVTA3YjBKQlExb3NTVUZCU1N4RlFVRkZMRkZCUVZFN2FVSkJRMlk3WjBKQlEwUXNVVUZCVVN4MVFrRkRTQ3g1UWtGQmVVSXNaVUZETTBJc1kwRkJZeXhKUVVGSExHTkJRV01zVDBGRE4wSXNiVUpCUVcxQ0xFVkJRMjVDTERKQ1FVRXlRaXhKUVVNNVFpeFBRVUZQTEVWQlFVVXNSVUZCUXl4UFFVRlBMRVZCUVVjc1QwRkJUeXhGUVVGRExFZEJRemRDTzJGQlEwWTdVMEZEUml4SlFVTkVPenRCUVVOS0xFTkJRVU03UVVGcVNVUXNORU5CYVVsREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuZXhwb3J0cy5FUlJPUkJBUiA9ICdlcnJvci1iYXInO1xuZnVuY3Rpb24gbm9ybWFsaXplRXJyb3JCYXIoc3BlYykge1xuICAgIHZhciBfbSA9IHNwZWMubWFyaywgZW5jb2RpbmcgPSBzcGVjLmVuY29kaW5nLCBvdXRlclNwZWMgPSB0c2xpYl8xLl9fcmVzdChzcGVjLCBbXCJtYXJrXCIsIFwiZW5jb2RpbmdcIl0pO1xuICAgIHZhciBfcyA9IGVuY29kaW5nLnNpemUsIGVuY29kaW5nV2l0aG91dFNpemUgPSB0c2xpYl8xLl9fcmVzdChlbmNvZGluZywgW1wic2l6ZVwiXSk7XG4gICAgdmFyIF94MiA9IGVuY29kaW5nLngyLCBfeTIgPSBlbmNvZGluZy55MiwgZW5jb2RpbmdXaXRob3V0WDJZMiA9IHRzbGliXzEuX19yZXN0KGVuY29kaW5nLCBbXCJ4MlwiLCBcInkyXCJdKTtcbiAgICB2YXIgX3ggPSBlbmNvZGluZ1dpdGhvdXRYMlkyLngsIF95ID0gZW5jb2RpbmdXaXRob3V0WDJZMi55LCBlbmNvZGluZ1dpdGhvdXRYX1gyX1lfWTIgPSB0c2xpYl8xLl9fcmVzdChlbmNvZGluZ1dpdGhvdXRYMlkyLCBbXCJ4XCIsIFwieVwiXSk7XG4gICAgaWYgKCFlbmNvZGluZy54MiAmJiAhZW5jb2RpbmcueTIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIHgyIG9yIHkyIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBvdXRlclNwZWMsIHsgbGF5ZXI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrOiAncnVsZScsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nV2l0aG91dFNpemVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtYXJrOiAndGljaycsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nV2l0aG91dFgyWTJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtYXJrOiAndGljaycsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLngyID8gdHNsaWJfMS5fX2Fzc2lnbih7IHg6IGVuY29kaW5nLngyLCB5OiBlbmNvZGluZy55IH0sIGVuY29kaW5nV2l0aG91dFhfWDJfWV9ZMikgOiB0c2xpYl8xLl9fYXNzaWduKHsgeDogZW5jb2RpbmcueCwgeTogZW5jb2RpbmcueTIgfSwgZW5jb2RpbmdXaXRob3V0WF9YMl9ZX1kyKVxuICAgICAgICAgICAgfVxuICAgICAgICBdIH0pO1xufVxuZXhwb3J0cy5ub3JtYWxpemVFcnJvckJhciA9IG5vcm1hbGl6ZUVycm9yQmFyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWlhKeWIzSmlZWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOXpjbU12WTI5dGNHOXphWFJsYldGeWF5OWxjbkp2Y21KaGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGSllTeFJRVUZCTEZGQlFWRXNSMEZCWjBJc1YwRkJWeXhEUVVGRE8wRkJSMnBFTERKQ1FVRnJReXhKUVVGblJEdEpRVU42UlN4SlFVRkJMR05CUVZFc1JVRkJSU3gzUWtGQmEwSXNSVUZCUlN4elJFRkJXU3hEUVVGVE8wbEJRMjVFTEVsQlFVRXNhMEpCUVZFc1JVRkJSU3gzUkVGQmMwSXNRMEZCWVR0SlFVTTNReXhKUVVGQkxHbENRVUZQTEVWQlFVVXNhVUpCUVU4c1JVRkJSU3cwUkVGQmMwSXNRMEZCWVR0SlFVTnlSQ3hKUVVGQkxEQkNRVUZMTEVWQlFVVXNNRUpCUVVzc1JVRkJSU3d3UlVGQk1rSXNRMEZCZDBJN1NVRkZlRVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha01zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl3eVFrRkJNa0lzUTBGQlF5eERRVUZETzBsQlF5OURMRU5CUVVNN1NVRkZSQ3hOUVVGTkxITkNRVU5FTEZOQlFWTXNTVUZEV2l4TFFVRkxMRVZCUVVVN1dVRkRURHRuUWtGRFJTeEpRVUZKTEVWQlFVVXNUVUZCVFR0blFrRkRXaXhSUVVGUkxFVkJRVVVzYlVKQlFXMUNPMkZCUXpsQ0xFVkJRVU03WjBKQlEwRXNTVUZCU1N4RlFVRkZMRTFCUVUwN1owSkJRMW9zVVVGQlVTeEZRVUZGTEcxQ1FVRnRRanRoUVVNNVFpeEZRVUZGTzJkQ1FVTkVMRWxCUVVrc1JVRkJSU3hOUVVGTk8yZENRVU5hTEZGQlFWRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1JVRkJSU3h6UWtGRGJrSXNRMEZCUXl4RlFVRkZMRkZCUVZFc1EwRkJReXhGUVVGRkxFVkJRMlFzUTBGQlF5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRMRWxCUTFZc2QwSkJRWGRDTEhWQ1FVVXpRaXhEUVVGRExFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTXNSVUZEWWl4RFFVRkRMRVZCUVVVc1VVRkJVU3hEUVVGRExFVkJRVVVzU1VGRFdDeDNRa0ZCZDBJc1EwRkROVUk3WVVGRFJqdFRRVU5HTEVsQlEwUTdRVUZEU2l4RFFVRkRPMEZCYWtORUxEaERRV2xEUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLy4uL21hcmtcIik7XG52YXIgYm94cGxvdF8xID0gcmVxdWlyZShcIi4vYm94cGxvdFwiKTtcbnZhciBlcnJvcmJhcl8xID0gcmVxdWlyZShcIi4vZXJyb3JiYXJcIik7XG4vKipcbiAqIFJlZ2lzdHJ5IGluZGV4IGZvciBhbGwgY29tcG9zaXRlIG1hcmsncyBub3JtYWxpemVyXG4gKi9cbnZhciBub3JtYWxpemVyUmVnaXN0cnkgPSB7fTtcbmZ1bmN0aW9uIGFkZChtYXJrLCBub3JtYWxpemVyKSB7XG4gICAgbm9ybWFsaXplclJlZ2lzdHJ5W21hcmtdID0gbm9ybWFsaXplcjtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuZnVuY3Rpb24gcmVtb3ZlKG1hcmspIHtcbiAgICBkZWxldGUgbm9ybWFsaXplclJlZ2lzdHJ5W21hcmtdO1xufVxuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5hZGQoYm94cGxvdF8xLkJPWFBMT1QsIGJveHBsb3RfMS5ub3JtYWxpemVCb3hQbG90KTtcbmFkZChlcnJvcmJhcl8xLkVSUk9SQkFSLCBlcnJvcmJhcl8xLm5vcm1hbGl6ZUVycm9yQmFyKTtcbi8qKlxuICogVHJhbnNmb3JtIGEgdW5pdCBzcGVjIHdpdGggY29tcG9zaXRlIG1hcmsgaW50byBhIG5vcm1hbCBsYXllciBzcGVjLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoXG4gICAgLy8gVGhpcyBHZW5lcmljVW5pdFNwZWMgaGFzIGFueSBhcyBFbmNvZGluZyBiZWNhdXNlIHVuaXQgc3BlY3Mgd2l0aCBjb21wb3NpdGUgbWFyayBjYW4gaGF2ZSBhZGRpdGlvbmFsIGVuY29kaW5nIGNoYW5uZWxzLlxuICAgIHNwZWMsIGNvbmZpZykge1xuICAgIHZhciBtYXJrID0gbWFya18xLmlzTWFya0RlZihzcGVjLm1hcmspID8gc3BlYy5tYXJrLnR5cGUgOiBzcGVjLm1hcms7XG4gICAgdmFyIG5vcm1hbGl6ZXIgPSBub3JtYWxpemVyUmVnaXN0cnlbbWFya107XG4gICAgaWYgKG5vcm1hbGl6ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZXIoc3BlYywgY29uZmlnKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWdpc3RlcmVkIGNvbXBvc2l0ZSBtYXJrIFwiICsgbWFyayk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOXpjbU12WTI5dGNHOXphWFJsYldGeWF5OXBibVJsZUM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEd0RFFVRTJRenRCUVVVM1F5eHhRMEZCYjBRN1FVRkRjRVFzZFVOQlFYVkVPMEZCUzNaRU96dEhRVVZITzBGQlEwZ3NTVUZCVFN4clFrRkJhMElzUjBGQmNVTXNSVUZCUlN4RFFVRkRPMEZCUldoRkxHRkJRVzlDTEVsQlFWa3NSVUZCUlN4VlFVRXdRanRKUVVNeFJDeHJRa0ZCYTBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eFZRVUZWTEVOQlFVTTdRVUZEZUVNc1EwRkJRenRCUVVaRUxHdENRVVZETzBGQlJVUXNaMEpCUVhWQ0xFbEJRVms3U1VGRGFrTXNUMEZCVHl4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0QlFVTnNReXhEUVVGRE8wRkJSa1FzZDBKQlJVTTdRVUZMUkN4SFFVRkhMRU5CUVVNc2FVSkJRVThzUlVGQlJTd3dRa0ZCWjBJc1EwRkJReXhEUVVGRE8wRkJReTlDTEVkQlFVY3NRMEZCUXl4dFFrRkJVU3hGUVVGRkxEUkNRVUZwUWl4RFFVRkRMRU5CUVVNN1FVRkZha003TzBkQlJVYzdRVUZEU0R0SlFVTkpMSGxJUVVGNVNEdEpRVU42U0N4SlFVRTBReXhGUVVNMVF5eE5RVUZqTzBsQlIyaENMRWxCUVUwc1NVRkJTU3hIUVVGSExHZENRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03U1VGREwwUXNTVUZCVFN4VlFVRlZMRWRCUVVjc2EwSkJRV3RDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkROVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVObUxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8wbEJRMnhETEVOQlFVTTdTVUZGUkN4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExHbERRVUVyUWl4SlFVRk5MRU5CUVVNc1EwRkJRenRCUVVONlJDeERRVUZETzBGQllrUXNPRUpCWVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsZWdlbmRfMSA9IHJlcXVpcmUoXCIuL2xlZ2VuZFwiKTtcbnZhciBtYXJrID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4vc2NhbGVcIik7XG52YXIgc2VsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMuZGVmYXVsdENlbGxDb25maWcgPSB7XG4gICAgd2lkdGg6IDIwMCxcbiAgICBoZWlnaHQ6IDIwMCxcbiAgICBmaWxsOiAndHJhbnNwYXJlbnQnXG59O1xuZXhwb3J0cy5kZWZhdWx0RmFjZXRDZWxsQ29uZmlnID0ge1xuICAgIHN0cm9rZTogJyNjY2MnLFxuICAgIHN0cm9rZVdpZHRoOiAxXG59O1xuZXhwb3J0cy5kZWZhdWx0RmFjZXRDb25maWcgPSB7XG4gICAgY2VsbDogZXhwb3J0cy5kZWZhdWx0RmFjZXRDZWxsQ29uZmlnXG59O1xuZXhwb3J0cy5kZWZhdWx0T3ZlcmxheUNvbmZpZyA9IHtcbiAgICBsaW5lOiBmYWxzZVxufTtcbmV4cG9ydHMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwYWRkaW5nOiA1LFxuICAgIG51bWJlckZvcm1hdDogJ3MnLFxuICAgIHRpbWVGb3JtYXQ6ICclYiAlZCwgJVknLFxuICAgIGNvdW50VGl0bGU6ICdOdW1iZXIgb2YgUmVjb3JkcycsXG4gICAgY2VsbDogZXhwb3J0cy5kZWZhdWx0Q2VsbENvbmZpZyxcbiAgICBtYXJrOiBtYXJrLmRlZmF1bHRNYXJrQ29uZmlnLFxuICAgIGFyZWE6IHt9LFxuICAgIGJhcjogbWFyay5kZWZhdWx0QmFyQ29uZmlnLFxuICAgIGNpcmNsZToge30sXG4gICAgbGluZToge30sXG4gICAgcG9pbnQ6IHt9LFxuICAgIHJlY3Q6IHt9LFxuICAgIHJ1bGU6IHt9LFxuICAgIHNxdWFyZToge30sXG4gICAgdGV4dDogbWFyay5kZWZhdWx0VGV4dENvbmZpZyxcbiAgICB0aWNrOiBtYXJrLmRlZmF1bHRUaWNrQ29uZmlnLFxuICAgIGJveDogeyBzaXplOiAxNCB9LFxuICAgIGJveFdoaXNrZXI6IHt9LFxuICAgIGJveE1pZDoge30sXG4gICAgb3ZlcmxheTogZXhwb3J0cy5kZWZhdWx0T3ZlcmxheUNvbmZpZyxcbiAgICBzY2FsZTogc2NhbGVfMS5kZWZhdWx0U2NhbGVDb25maWcsXG4gICAgYXhpczoge30sXG4gICAgYXhpc1g6IHt9LFxuICAgIGF4aXNZOiB7fSxcbiAgICBheGlzTGVmdDoge30sXG4gICAgYXhpc1JpZ2h0OiB7fSxcbiAgICBheGlzVG9wOiB7fSxcbiAgICBheGlzQm90dG9tOiB7fSxcbiAgICBheGlzQmFuZDoge30sXG4gICAgbGVnZW5kOiBsZWdlbmRfMS5kZWZhdWx0TGVnZW5kQ29uZmlnLFxuICAgIGZhY2V0OiBleHBvcnRzLmRlZmF1bHRGYWNldENvbmZpZyxcbiAgICBzZWxlY3Rpb246IHNlbGVjdGlvbl8xLmRlZmF1bHRDb25maWcsXG59O1xuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4gdXRpbF8xLm1lcmdlRGVlcCh1dGlsXzEuZHVwbGljYXRlKGV4cG9ydHMuZGVmYXVsdENvbmZpZyksIGNvbmZpZyk7XG59XG5leHBvcnRzLmluaXRDb25maWcgPSBpbml0Q29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTI5dVptbG5MbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyTnZibVpwWnk1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVVZCTEcxRFFVRXlSRHRCUVVVelJDdzJRa0ZCSzBJN1FVRkRMMElzYVVOQlFYZEVPMEZCUTNoRUxIbERRVUZ4Ump0QlFVZHlSaXdyUWtGQk5FTTdRVUZ0Umk5Q0xGRkJRVUVzYVVKQlFXbENMRWRCUVdVN1NVRkRNME1zUzBGQlN5eEZRVUZGTEVkQlFVYzdTVUZEVml4TlFVRk5MRVZCUVVVc1IwRkJSenRKUVVOWUxFbEJRVWtzUlVGQlJTeGhRVUZoTzBOQlEzQkNMRU5CUVVNN1FVRkZWeXhSUVVGQkxITkNRVUZ6UWl4SFFVRmxPMGxCUTJoRUxFMUJRVTBzUlVGQlJTeE5RVUZOTzBsQlEyUXNWMEZCVnl4RlFVRkZMRU5CUVVNN1EwRkRaaXhEUVVGRE8wRkJVVmNzVVVGQlFTeHJRa0ZCYTBJc1IwRkJaMEk3U1VGRE4wTXNTVUZCU1N4RlFVRkZMRGhDUVVGelFqdERRVU0zUWl4RFFVRkRPMEZCYTBKWExGRkJRVUVzYjBKQlFXOUNMRWRCUVd0Q08wbEJRMnBFTEVsQlFVa3NSVUZCUlN4TFFVRkxPME5CUTFvc1EwRkJRenRCUVdsTFZ5eFJRVUZCTEdGQlFXRXNSMEZCVnp0SlFVTnVReXhQUVVGUExFVkJRVVVzUTBGQlF6dEpRVU5XTEZsQlFWa3NSVUZCUlN4SFFVRkhPMGxCUTJwQ0xGVkJRVlVzUlVGQlJTeFhRVUZYTzBsQlEzWkNMRlZCUVZVc1JVRkJSU3h0UWtGQmJVSTdTVUZGTDBJc1NVRkJTU3hGUVVGRkxIbENRVUZwUWp0SlFVVjJRaXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEdsQ1FVRnBRanRKUVVNMVFpeEpRVUZKTEVWQlFVVXNSVUZCUlR0SlFVTlNMRWRCUVVjc1JVRkJSU3hKUVVGSkxFTkJRVU1zWjBKQlFXZENPMGxCUXpGQ0xFMUJRVTBzUlVGQlJTeEZRVUZGTzBsQlExWXNTVUZCU1N4RlFVRkZMRVZCUVVVN1NVRkRVaXhMUVVGTExFVkJRVVVzUlVGQlJUdEpRVU5VTEVsQlFVa3NSVUZCUlN4RlFVRkZPMGxCUTFJc1NVRkJTU3hGUVVGRkxFVkJRVVU3U1VGRFVpeE5RVUZOTEVWQlFVVXNSVUZCUlR0SlFVTldMRWxCUVVrc1JVRkJSU3hKUVVGSkxFTkJRVU1zYVVKQlFXbENPMGxCUXpWQ0xFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNhVUpCUVdsQ08wbEJSVFZDTEVkQlFVY3NSVUZCUlN4RlFVRkRMRWxCUVVrc1JVRkJSU3hGUVVGRkxFVkJRVU03U1VGRFppeFZRVUZWTEVWQlFVVXNSVUZCUlR0SlFVTmtMRTFCUVUwc1JVRkJSU3hGUVVGRk8wbEJSVllzVDBGQlR5eEZRVUZGTERSQ1FVRnZRanRKUVVNM1FpeExRVUZMTEVWQlFVVXNNRUpCUVd0Q08wbEJRM3BDTEVsQlFVa3NSVUZCUlN4RlFVRkZPMGxCUTFJc1MwRkJTeXhGUVVGRkxFVkJRVVU3U1VGRFZDeExRVUZMTEVWQlFVVXNSVUZCUlR0SlFVTlVMRkZCUVZFc1JVRkJSU3hGUVVGRk8wbEJRMW9zVTBGQlV5eEZRVUZGTEVWQlFVVTdTVUZEWWl4UFFVRlBMRVZCUVVVc1JVRkJSVHRKUVVOWUxGVkJRVlVzUlVGQlJTeEZRVUZGTzBsQlEyUXNVVUZCVVN4RlFVRkZMRVZCUVVVN1NVRkRXaXhOUVVGTkxFVkJRVVVzTkVKQlFXMUNPMGxCUlROQ0xFdEJRVXNzUlVGQlJTd3dRa0ZCYTBJN1NVRkZla0lzVTBGQlV5eEZRVUZGTEhsQ1FVRnpRanREUVVOc1F5eERRVUZETzBGQlJVWXNiMEpCUVRKQ0xFMUJRV003U1VGRGRrTXNUVUZCVFN4RFFVRkRMR2RDUVVGVExFTkJRVU1zWjBKQlFWTXNRMEZCUXl4eFFrRkJZU3hEUVVGRExFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdRVUZEY2tRc1EwRkJRenRCUVVaRUxHZERRVVZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvbnN0YW50cyBhbmQgdXRpbGl0aWVzIGZvciBkYXRhLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc1VybERhdGEoZGF0YSkge1xuICAgIHJldHVybiAhIWRhdGFbJ3VybCddO1xufVxuZXhwb3J0cy5pc1VybERhdGEgPSBpc1VybERhdGE7XG5mdW5jdGlvbiBpc0lubGluZURhdGEoZGF0YSkge1xuICAgIHJldHVybiAhIWRhdGFbJ3ZhbHVlcyddO1xufVxuZXhwb3J0cy5pc0lubGluZURhdGEgPSBpc0lubGluZURhdGE7XG5mdW5jdGlvbiBpc05hbWVkRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuICEhZGF0YVsnbmFtZSddO1xufVxuZXhwb3J0cy5pc05hbWVkRGF0YSA9IGlzTmFtZWREYXRhO1xuZXhwb3J0cy5NQUlOID0gJ21haW4nO1xuZXhwb3J0cy5SQVcgPSAncmF3Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpHRjBZUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtZWFJoTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6czdRVUVyUlVnc2JVSkJRVEJDTEVsQlFXMUNPMGxCUXpORExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wRkJRM1pDTEVOQlFVTTdRVUZHUkN3NFFrRkZRenRCUVVWRUxITkNRVUUyUWl4SlFVRnRRanRKUVVNNVF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU14UWl4RFFVRkRPMEZCUmtRc2IwTkJSVU03UVVGRlJDeHhRa0ZCTkVJc1NVRkJiVUk3U1VGRE4wTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdRVUZEZUVJc1EwRkJRenRCUVVaRUxHdERRVVZETzBGQlNWa3NVVUZCUVN4SlFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wRkJRM1JDTEZGQlFVRXNSMEZCUnl4SFFVRlZMRXRCUVVzc1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBEYXRlVGltZSBkZWZpbml0aW9uIG9iamVjdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuLypcbiAqIEEgZGVzaWduYXRlZCB5ZWFyIHRoYXQgc3RhcnRzIG9uIFN1bmRheS5cbiAqL1xudmFyIFNVTkRBWV9ZRUFSID0gMjAwNjtcbmZ1bmN0aW9uIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAhIW8gJiYgKCEhby55ZWFyIHx8ICEhby5xdWFydGVyIHx8ICEhby5tb250aCB8fCAhIW8uZGF0ZSB8fCAhIW8uZGF5IHx8XG4gICAgICAgICEhby5ob3VycyB8fCAhIW8ubWludXRlcyB8fCAhIW8uc2Vjb25kcyB8fCAhIW8ubWlsbGlzZWNvbmRzKTtcbn1cbmV4cG9ydHMuaXNEYXRlVGltZSA9IGlzRGF0ZVRpbWU7XG5leHBvcnRzLk1PTlRIUyA9IFsnamFudWFyeScsICdmZWJydWFyeScsICdtYXJjaCcsICdhcHJpbCcsICdtYXknLCAnanVuZScsICdqdWx5JywgJ2F1Z3VzdCcsICdzZXB0ZW1iZXInLCAnb2N0b2JlcicsICdub3ZlbWJlcicsICdkZWNlbWJlciddO1xuZXhwb3J0cy5TSE9SVF9NT05USFMgPSBleHBvcnRzLk1PTlRIUy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc3Vic3RyKDAsIDMpOyB9KTtcbmV4cG9ydHMuREFZUyA9IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknXTtcbmV4cG9ydHMuU0hPUlRfREFZUyA9IGV4cG9ydHMuREFZUy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuc3Vic3RyKDAsIDMpOyB9KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVF1YXJ0ZXIocSkge1xuICAgIGlmICh1dGlsXzEuaXNOdW1iZXIocSkpIHtcbiAgICAgICAgaWYgKHEgPiA0KSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5pbnZhbGlkVGltZVVuaXQoJ3F1YXJ0ZXInLCBxKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYWNjZXB0IDEtYmFzZWQgcXVhcnRlciwgc28gbmVlZCB0byByZWFkanVzdCB0byAwLWJhc2VkIHF1YXJ0ZXJcbiAgICAgICAgcmV0dXJuIChxIC0gMSkgKyAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEludmFsaWQgcXVhcnRlclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW52YWxpZFRpbWVVbml0KCdxdWFydGVyJywgcSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vbnRoKG0pIHtcbiAgICBpZiAodXRpbF8xLmlzTnVtYmVyKG0pKSB7XG4gICAgICAgIC8vIFdlIGFjY2VwdCAxLWJhc2VkIG1vbnRoLCBzbyBuZWVkIHRvIHJlYWRqdXN0IHRvIDAtYmFzZWQgbW9udGhcbiAgICAgICAgcmV0dXJuIChtIC0gMSkgKyAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBsb3dlck0gPSBtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBtb250aEluZGV4ID0gZXhwb3J0cy5NT05USFMuaW5kZXhPZihsb3dlck0pO1xuICAgICAgICBpZiAobW9udGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aEluZGV4ICsgJyc7IC8vIDAgZm9yIGphbnVhcnksIC4uLlxuICAgICAgICB9XG4gICAgICAgIHZhciBzaG9ydE0gPSBsb3dlck0uc3Vic3RyKDAsIDMpO1xuICAgICAgICB2YXIgc2hvcnRNb250aEluZGV4ID0gZXhwb3J0cy5TSE9SVF9NT05USFMuaW5kZXhPZihzaG9ydE0pO1xuICAgICAgICBpZiAoc2hvcnRNb250aEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0TW9udGhJbmRleCArICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludmFsaWQgbW9udGhcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLmludmFsaWRUaW1lVW5pdCgnbW9udGgnLCBtKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRGF5KGQpIHtcbiAgICBpZiAodXRpbF8xLmlzTnVtYmVyKGQpKSB7XG4gICAgICAgIC8vIG1vZCBzbyB0aGF0IHRoaXMgY2FuIGJlIGJvdGggMC1iYXNlZCB3aGVyZSAwID0gc3VuZGF5XG4gICAgICAgIC8vIGFuZCAxLWJhc2VkIHdoZXJlIDc9c3VuZGF5XG4gICAgICAgIHJldHVybiAoZCAlIDcpICsgJyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbG93ZXJEID0gZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZGF5SW5kZXggPSBleHBvcnRzLkRBWVMuaW5kZXhPZihsb3dlckQpO1xuICAgICAgICBpZiAoZGF5SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kZXggKyAnJzsgLy8gMCBmb3IgamFudWFyeSwgLi4uXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3J0RCA9IGxvd2VyRC5zdWJzdHIoMCwgMyk7XG4gICAgICAgIHZhciBzaG9ydERheUluZGV4ID0gZXhwb3J0cy5TSE9SVF9EQVlTLmluZGV4T2Yoc2hvcnREKTtcbiAgICAgICAgaWYgKHNob3J0RGF5SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvcnREYXlJbmRleCArICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludmFsaWQgZGF5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5pbnZhbGlkVGltZVVuaXQoJ2RheScsIGQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aW1lc3RhbXAoZCwgbm9ybWFsaXplKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwLCAwLCAxLCAwLCAwLCAwLCAwKTsgLy8gc3RhcnQgd2l0aCB1bmlmb3JtIGRhdGVcbiAgICAvLyBGSVhNRSBzdXBwb3J0IFVUQ1xuICAgIGlmIChkLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1dGlsXzEua2V5cyhkKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5kcm9wcGVkRGF5KGQpKTtcbiAgICAgICAgICAgIGQgPSB1dGlsXzEuZHVwbGljYXRlKGQpO1xuICAgICAgICAgICAgZGVsZXRlIGQuZGF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGEgeWVhciB0aGF0IGhhcyAxLzEgYXMgU3VuZGF5IHNvIHdlIGNhbiBzZXREYXRlIGJlbG93XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKFNVTkRBWV9ZRUFSKTtcbiAgICAgICAgICAgIHZhciBkYXkgPSBub3JtYWxpemUgPyBub3JtYWxpemVEYXkoZC5kYXkpIDogZC5kYXk7XG4gICAgICAgICAgICBkYXRlLnNldERhdGUoK2RheSArIDEpOyAvLyArMSBzaW5jZSBkYXRlIHN0YXJ0IGF0IDEgaW4gSlNcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZC55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnllYXIpO1xuICAgIH1cbiAgICBpZiAoZC5xdWFydGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHF1YXJ0ZXIgPSBub3JtYWxpemUgPyBub3JtYWxpemVRdWFydGVyKGQucXVhcnRlcikgOiBkLnF1YXJ0ZXI7XG4gICAgICAgIGRhdGUuc2V0TW9udGgoK3F1YXJ0ZXIgKiAzKTtcbiAgICB9XG4gICAgaWYgKGQubW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbW9udGggPSBub3JtYWxpemUgPyBub3JtYWxpemVNb250aChkLm1vbnRoKSA6IGQubW9udGg7XG4gICAgICAgIGRhdGUuc2V0TW9udGgoK21vbnRoKTtcbiAgICB9XG4gICAgaWYgKGQuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGUuc2V0RGF0ZShkLmRhdGUpO1xuICAgIH1cbiAgICBpZiAoZC5ob3VycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoZC5ob3Vycyk7XG4gICAgfVxuICAgIGlmIChkLm1pbnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoZC5taW51dGVzKTtcbiAgICB9XG4gICAgaWYgKGQuc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyhkLnNlY29uZHMpO1xuICAgIH1cbiAgICBpZiAoZC5taWxsaXNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcyhkLm1pbGxpc2Vjb25kcyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcbn1cbmV4cG9ydHMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuLyoqXG4gKiBSZXR1cm4gVmVnYSBFeHByZXNzaW9uIGZvciBhIHBhcnRpY3VsYXIgZGF0ZSB0aW1lLlxuICogQHBhcmFtIGRcbiAqIEBwYXJhbSBub3JtYWxpemUgd2hldGhlciB0byBub3JtYWxpemUgcXVhcnRlciwgbW9udGgsIGRheS5cbiAqL1xuZnVuY3Rpb24gZGF0ZVRpbWVFeHByKGQsIG5vcm1hbGl6ZSkge1xuICAgIGlmIChub3JtYWxpemUgPT09IHZvaWQgMCkgeyBub3JtYWxpemUgPSBmYWxzZTsgfVxuICAgIHZhciB1bml0cyA9IFtdO1xuICAgIGlmIChub3JtYWxpemUgJiYgZC5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodXRpbF8xLmtleXMoZCkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuZHJvcHBlZERheShkKSk7XG4gICAgICAgICAgICBkID0gdXRpbF8xLmR1cGxpY2F0ZShkKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkLmRheTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZC55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdW5pdHMucHVzaChkLnllYXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFNldCB5ZWFyIHRvIDIwMDYgZm9yIHdvcmtpbmcgd2l0aCBkYXkgc2luY2UgSmFudWFyeSAxIDIwMDYgaXMgYSBTdW5kYXlcbiAgICAgICAgdW5pdHMucHVzaChTVU5EQVlfWUVBUik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bml0cy5wdXNoKDApO1xuICAgIH1cbiAgICBpZiAoZC5tb250aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtb250aCA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZU1vbnRoKGQubW9udGgpIDogZC5tb250aDtcbiAgICAgICAgdW5pdHMucHVzaChtb250aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGQucXVhcnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBxdWFydGVyID0gbm9ybWFsaXplID8gbm9ybWFsaXplUXVhcnRlcihkLnF1YXJ0ZXIpIDogZC5xdWFydGVyO1xuICAgICAgICB1bml0cy5wdXNoKHF1YXJ0ZXIgKyAnKjMnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVuaXRzLnB1c2goMCk7IC8vIG1vbnRocyBzdGFydCBhdCB6ZXJvIGluIEpTXG4gICAgfVxuICAgIGlmIChkLmRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1bml0cy5wdXNoKGQuZGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGQuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSEFDSzogRGF5IG9ubHkgd29ya3MgYXMgYSBzdGFuZGFsb25lIHVuaXRcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGNvcnJlY3QgYmVjYXVzZSB3ZSBhbHdheXMgc2V0IHllYXIgdG8gMjAwNiBmb3IgZGF5XG4gICAgICAgIHZhciBkYXkgPSBub3JtYWxpemUgPyBub3JtYWxpemVEYXkoZC5kYXkpIDogZC5kYXk7XG4gICAgICAgIHVuaXRzLnB1c2goZGF5ICsgJysxJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bml0cy5wdXNoKDEpOyAvLyBEYXRlIHN0YXJ0cyBhdCAxIGluIEpTXG4gICAgfVxuICAgIC8vIE5vdGU6IGNhbid0IHVzZSBUaW1lVW5pdCBlbnVtIGhlcmUgYXMgaW1wb3J0aW5nIGl0IHdpbGwgY3JlYXRlXG4gICAgLy8gY2lyY3VsYXIgZGVwZW5kZW5jeSBwcm9ibGVtIVxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycsICdtaWxsaXNlY29uZHMnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRpbWVVbml0ID0gX2FbX2ldO1xuICAgICAgICBpZiAoZFt0aW1lVW5pdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdW5pdHMucHVzaChkW3RpbWVVbml0XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bml0cy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnZGF0ZXRpbWUoJyArIHVuaXRzLmpvaW4oJywgJykgKyAnKSc7XG59XG5leHBvcnRzLmRhdGVUaW1lRXhwciA9IGRhdGVUaW1lRXhwcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpHRjBaWFJwYldVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFpYUnBiV1V1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFpDUVVFMlFqczdRVUZGTjBJc01rSkJRVFpDTzBGQlF6ZENMQ3RDUVVGcFJEdEJRVVZxUkRzN1IwRkZSenRCUVVOSUxFbEJRVTBzVjBGQlZ5eEhRVUZITEVsQlFVa3NRMEZCUXp0QlFYZEhla0lzYjBKQlFUSkNMRU5CUVUwN1NVRkRMMElzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWM3VVVGRGVFVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF6dEJRVU5xUlN4RFFVRkRPMEZCU0VRc1owTkJSME03UVVGRldTeFJRVUZCTEUxQlFVMHNSMEZCUnl4RFFVRkRMRk5CUVZNc1JVRkJSU3hWUVVGVkxFVkJRVVVzVDBGQlR5eEZRVUZGTEU5QlFVOHNSVUZCUlN4TFFVRkxMRVZCUVVVc1RVRkJUU3hGUVVGRkxFMUJRVTBzUlVGQlJTeFJRVUZSTEVWQlFVVXNWMEZCVnl4RlFVRkZMRk5CUVZNc1JVRkJSU3hWUVVGVkxFVkJRVVVzVlVGQlZTeERRVUZETEVOQlFVTTdRVUZEY0Vrc1VVRkJRU3haUVVGWkxFZEJRVWNzWTBGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkRMRU5CUVVNc1NVRkJTeXhQUVVGQkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGa0xFTkJRV01zUTBGQlF5eERRVUZETzBGQlJXcEVMRkZCUVVFc1NVRkJTU3hIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEZGQlFWRXNSVUZCUlN4VFFVRlRMRVZCUVVVc1YwRkJWeXhGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1FVRkRkRVlzVVVGQlFTeFZRVUZWTEVkQlFVY3NXVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGRExFTkJRVU1zU1VGQlN5eFBRVUZCTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhGUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZpTEVOQlFXRXNRMEZCUXl4RFFVRkRPMEZCUlhwRUxEQkNRVUV3UWl4RFFVRnJRanRKUVVNeFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTFZc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR1ZCUVdVc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBSQ3hEUVVGRE8xRkJRMFFzYjBWQlFXOUZPMUZCUTNCRkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU03U1VGRGRFSXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzYTBKQlFXdENPMUZCUTJ4Q0xFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXhsUVVGbExFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkROMFFzUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZGUkN4M1FrRkJkMElzUTBGQmEwSTdTVUZEZUVNc1JVRkJSU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOb1FpeG5SVUZCWjBVN1VVRkRhRVVzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF6dEpRVU4wUWl4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeEpRVUZOTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU03VVVGREwwSXNTVUZCVFN4VlFVRlZMRWRCUVVjc1kwRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTXhReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1JDTEUxQlFVMHNRMEZCUXl4VlFVRlZMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU1zY1VKQlFYRkNPMUZCUXk5RExFTkJRVU03VVVGRFJDeEpRVUZOTEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVReXhKUVVGTkxHVkJRV1VzUjBGQlJ5eHZRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU55UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhsUVVGbExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFMUJRVTBzUTBGQlF5eGxRVUZsTEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUXpsQ0xFTkJRVU03VVVGRFJDeG5Ra0ZCWjBJN1VVRkRhRUlzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExHVkJRV1VzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNelJDeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVVkVMSE5DUVVGelFpeERRVUZyUWp0SlFVTjBReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEhkRVFVRjNSRHRSUVVONFJDdzJRa0ZCTmtJN1VVRkROMElzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF6dEpRVU4wUWl4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeEpRVUZOTEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU03VVVGREwwSXNTVUZCVFN4UlFVRlJMRWRCUVVjc1dVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTjBReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JDTEUxQlFVMHNRMEZCUXl4UlFVRlJMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU1zY1VKQlFYRkNPMUZCUXpkRExFTkJRVU03VVVGRFJDeEpRVUZOTEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVReXhKUVVGTkxHRkJRV0VzUjBGQlJ5eHJRa0ZCVlN4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhoUVVGaExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwQ0xFMUJRVTBzUTBGQlF5eGhRVUZoTEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUXpWQ0xFTkJRVU03VVVGRFJDeGpRVUZqTzFGQlEyUXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdWQlFXVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UkN4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxHMUNRVUV3UWl4RFFVRlhMRVZCUVVVc1UwRkJhMEk3U1VGRGRrUXNTVUZCVFN4SlFVRkpMRWRCUVVjc1NVRkJTU3hKUVVGSkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXd3UWtGQk1FSTdTVUZGZEVVc2IwSkJRVzlDTzBsQlJYQkNMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRka0lzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFTkJRVU1zUjBGQlJ5eG5Ra0ZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBDTEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJRenRSUVVObUxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRFJFUVVFMFJEdFpRVU0xUkN4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzFsQlJUbENMRWxCUVUwc1IwRkJSeXhIUVVGSExGTkJRVk1zUjBGQlJ5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTTdXVUZEY0VRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExHbERRVUZwUXp0UlFVTXpSQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNelFpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpWQ0xFbEJRVTBzVDBGQlR5eEhRVUZITEZOQlFWTXNSMEZCUnl4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF6dFJRVU53UlN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVDBGQlR5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETVVJc1NVRkJUU3hMUVVGTExFZEJRVWNzVTBGQlV5eEhRVUZITEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTTFSQ3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRlRUlzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVOMlFpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpGQ0xFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRM3BDTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkROVUlzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRE4wSXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNMVFpeEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU0zUWl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZsQlFWa3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBETEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJReXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETzBsQlEzWkRMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMEZCUTNoQ0xFTkJRVU03UVVGMFJFUXNPRUpCYzBSRE8wRkJSVVE3T3pzN1IwRkpSenRCUVVOSUxITkNRVUUyUWl4RFFVRXdRaXhGUVVGRkxGTkJRV2xDTzBsQlFXcENMREJDUVVGQkxFVkJRVUVzYVVKQlFXbENPMGxCUTNoRkxFbEJRVTBzUzBGQlN5eEhRVUYzUWl4RlFVRkZMRU5CUVVNN1NVRkZkRU1zUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZGtJc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkRMRU5CUVVNc1IwRkJSeXhuUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXp0UlFVTm1MRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzcENMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTNKQ0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xIbEZRVUY1UlR0UlFVTjZSU3hMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMGxCUXpGQ0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEYUVJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14UWl4SlFVRk5MRXRCUVVzc1IwRkJSeXhUUVVGVExFZEJRVWNzWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETzFGQlF6VkVMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZEY0VJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYmtNc1NVRkJUU3hQUVVGUExFZEJRVWNzVTBGQlV5eEhRVUZITEdkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRE8xRkJRM0JGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlF6ZENMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5dzJRa0ZCTmtJN1NVRkRPVU1zUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVOeVFpeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlFpdzBRMEZCTkVNN1VVRkROVU1zYTBWQlFXdEZPMUZCUTJ4RkxFbEJRVTBzUjBGQlJ5eEhRVUZITEZOQlFWTXNSMEZCUnl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNN1VVRkRjRVFzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRWRCUVVjc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRGVrSXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExIbENRVUY1UWp0SlFVTXhReXhEUVVGRE8wbEJSVVFzYVVWQlFXbEZPMGxCUTJwRkxDdENRVUVyUWp0SlFVTXZRaXhIUVVGSExFTkJRVU1zUTBGQmJVSXNWVUZCSzBNc1JVRkJMME1zVFVGQlF5eFBRVUZQTEVWQlFVVXNVMEZCVXl4RlFVRkZMRk5CUVZNc1JVRkJSU3hqUVVGakxFTkJRVU1zUlVGQkwwTXNZMEZCSzBNc1JVRkJMME1zU1VGQkswTTdVVUZCYWtVc1NVRkJUU3hSUVVGUkxGTkJRVUU3VVVGRGFrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRPVUlzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14UWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEVOQlFVTTdTMEZEUmp0SlFVVkVMRTFCUVUwc1EwRkJReXhYUVVGWExFZEJRVWNzUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhIUVVGSExFTkJRVU03UVVGRE9VTXNRMEZCUXp0QlFYQkVSQ3h2UTBGdlJFTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4vZmllbGRkZWZcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBjaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWwpIHtcbiAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nICYmIGVuY29kaW5nW2NoYW5uZWxdO1xuICAgIGlmIChjaGFubmVsRGVmKSB7XG4gICAgICAgIGlmICh1dGlsXzEuaXNBcnJheShjaGFubmVsRGVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5zb21lKGNoYW5uZWxEZWYsIGZ1bmN0aW9uIChmaWVsZERlZikgeyByZXR1cm4gISFmaWVsZERlZi5maWVsZDsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuY2hhbm5lbEhhc0ZpZWxkID0gY2hhbm5lbEhhc0ZpZWxkO1xuZnVuY3Rpb24gaXNBZ2dyZWdhdGUoZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gdXRpbF8xLnNvbWUoY2hhbm5lbF8xLkNIQU5ORUxTLCBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICBpZiAoY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxEZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuaXNBcnJheShjaGFubmVsRGVmKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuc29tZShjaGFubmVsRGVmLCBmdW5jdGlvbiAoZmllbGREZWYpIHsgcmV0dXJuICEhZmllbGREZWYuYWdncmVnYXRlOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZikgJiYgISFjaGFubmVsRGVmLmFnZ3JlZ2F0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5leHBvcnRzLmlzQWdncmVnYXRlID0gaXNBZ2dyZWdhdGU7XG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZywgbWFyaykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlbmNvZGluZykucmVkdWNlKGZ1bmN0aW9uIChub3JtYWxpemVkRW5jb2RpbmcsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsXzEuc3VwcG9ydE1hcmsoY2hhbm5lbCwgbWFyaykpIHtcbiAgICAgICAgICAgIC8vIERyb3AgdW5zdXBwb3J0ZWQgY2hhbm5lbFxuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbChjaGFubmVsLCBtYXJrKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIERyb3AgbGluZSdzIHNpemUgaWYgdGhlIGZpZWxkIGlzIGFnZ3JlZ2F0ZWQuXG4gICAgICAgIGlmIChjaGFubmVsID09PSAnc2l6ZScgJiYgbWFyayA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgICAgICAgICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZihjaGFubmVsRGVmKSAmJiBjaGFubmVsRGVmLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmluY29tcGF0aWJsZUNoYW5uZWwoY2hhbm5lbCwgbWFyaywgJ3doZW4gdGhlIGZpZWxkIGlzIGFnZ3JlZ2F0ZWQuJykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxfMS5pc0FycmF5KGVuY29kaW5nW2NoYW5uZWxdKSkge1xuICAgICAgICAgICAgLy8gQXJyYXkgb2YgZmllbGREZWZzIGZvciBkZXRhaWwgY2hhbm5lbCAob3IgcHJvZHVjdGlvbiBydWxlKVxuICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nW2NoYW5uZWxdID0gZW5jb2RpbmdbY2hhbm5lbF0ucmVkdWNlKGZ1bmN0aW9uIChjaGFubmVsRGVmcywgY2hhbm5lbERlZikge1xuICAgICAgICAgICAgICAgIGlmICghZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICFmaWVsZGRlZl8xLmlzVmFsdWVEZWYoY2hhbm5lbERlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuZW1wdHlGaWVsZERlZihjaGFubmVsRGVmLCBjaGFubmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsRGVmcy5wdXNoKGZpZWxkZGVmXzEubm9ybWFsaXplKGNoYW5uZWxEZWYsIGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxEZWZzO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxEZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgIGlmICghZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICFmaWVsZGRlZl8xLmlzVmFsdWVEZWYoY2hhbm5lbERlZikpIHtcbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5lbXB0eUZpZWxkRGVmKGNoYW5uZWxEZWYsIGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEVuY29kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nW2NoYW5uZWxdID0gZmllbGRkZWZfMS5ub3JtYWxpemUoY2hhbm5lbERlZiwgY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFbmNvZGluZztcbiAgICB9LCB7fSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUVuY29kaW5nID0gbm9ybWFsaXplRW5jb2Rpbmc7XG5mdW5jdGlvbiBpc1JhbmdlZChlbmNvZGluZykge1xuICAgIHJldHVybiBlbmNvZGluZyAmJiAoKCEhZW5jb2RpbmcueCAmJiAhIWVuY29kaW5nLngyKSB8fCAoISFlbmNvZGluZy55ICYmICEhZW5jb2RpbmcueTIpKTtcbn1cbmV4cG9ydHMuaXNSYW5nZWQgPSBpc1JhbmdlZDtcbmZ1bmN0aW9uIGZpZWxkRGVmcyhlbmNvZGluZykge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBjaGFubmVsXzEuQ0hBTk5FTFMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICBpZiAoY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxEZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgICh1dGlsXzEuaXNBcnJheShjaGFubmVsRGVmKSA/IGNoYW5uZWxEZWYgOiBbY2hhbm5lbERlZl0pLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkRGVmKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goZmllbGREZWYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5maWVsZERlZnMgPSBmaWVsZERlZnM7XG5mdW5jdGlvbiBmb3JFYWNoKG1hcHBpbmcsIGYsIHRoaXNBcmcpIHtcbiAgICBpZiAoIW1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhtYXBwaW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gYztcbiAgICAgICAgaWYgKHV0aWxfMS5pc0FycmF5KG1hcHBpbmdbY2hhbm5lbF0pKSB7XG4gICAgICAgICAgICBtYXBwaW5nW2NoYW5uZWxdLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWxEZWYpIHtcbiAgICAgICAgICAgICAgICBmLmNhbGwodGhpc0FyZywgY2hhbm5lbERlZiwgY2hhbm5lbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGYuY2FsbCh0aGlzQXJnLCBtYXBwaW5nW2NoYW5uZWxdLCBjaGFubmVsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDtcbmZ1bmN0aW9uIHJlZHVjZShtYXBwaW5nLCBmLCBpbml0LCB0aGlzQXJnKSB7XG4gICAgaWYgKCFtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBpbml0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwcGluZykucmVkdWNlKGZ1bmN0aW9uIChyLCBjKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gYztcbiAgICAgICAgaWYgKHV0aWxfMS5pc0FycmF5KG1hcHBpbmdbY2hhbm5lbF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZ1tjaGFubmVsXS5yZWR1Y2UoZnVuY3Rpb24gKHIxLCBjaGFubmVsRGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYuY2FsbCh0aGlzQXJnLCByMSwgY2hhbm5lbERlZiwgY2hhbm5lbCk7XG4gICAgICAgICAgICB9LCByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmLmNhbGwodGhpc0FyZywgciwgbWFwcGluZ1tjaGFubmVsXSwgY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICB9LCBpbml0KTtcbn1cbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWlc1amIyUnBibWN1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZaVzVqYjJScGJtY3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGRlFTeHhRMEZCZVVRN1FVRkhla1FzZFVOQllXOUNPMEZCUTNCQ0xESkNRVUUyUWp0QlFVVTNRaXdyUWtGQmNVTTdRVUZ2Um5KRExIbENRVUZuUXl4UlFVRnJReXhGUVVGRkxFOUJRV2RDTzBsQlEyeEdMRWxCUVUwc1ZVRkJWU3hIUVVGSExGRkJRVkVzU1VGQlNTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRha1FzUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVObUxFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVFSXNUVUZCVFN4RFFVRkRMRmRCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzVlVGQlF5eFJRVUZSTEVsQlFVc3NUMEZCUVN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUlVGQmFFSXNRMEZCWjBJc1EwRkJReXhEUVVGRE8xRkJRekZFTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFMUJRVTBzUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xRkJRMmhETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU5tTEVOQlFVTTdRVUZXUkN3d1EwRlZRenRCUVVWRUxIRkNRVUUwUWl4UlFVRnJRenRKUVVNMVJDeE5RVUZOTEVOQlFVTXNWMEZCU1N4RFFVRkRMR3RDUVVGUkxFVkJRVVVzVlVGQlF5eFBRVUZQTzFGQlF6VkNMRVZCUVVVc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eFJRVUZSTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1pETEVsQlFVMHNWVUZCVlN4SFFVRkhMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU55UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhqUVVGUExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVONFFpeE5RVUZOTEVOQlFVTXNWMEZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSU3hWUVVGRExGRkJRVkVzU1VGQlN5eFBRVUZCTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhGUVVGd1FpeERRVUZ2UWl4RFFVRkRMRU5CUVVNN1dVRkRPVVFzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xFMUJRVTBzUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNVMEZCVXl4RFFVRkRPMWxCUXpGRUxFTkJRVU03VVVGRFNDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVObUxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlEwd3NRMEZCUXp0QlFWcEVMR3REUVZsRE8wRkJSVVFzTWtKQlFXdERMRkZCUVRCQ0xFVkJRVVVzU1VGQlZUdEpRVU4wUlN4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJReXhyUWtGQmIwTXNSVUZCUlN4UFFVRm5RanRSUVVONlJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSEZDUVVGWExFTkJRVU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5d3lRa0ZCTWtJN1dVRkZNMElzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcEVMRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNRMEZCUXp0UlFVTTFRaXhEUVVGRE8xRkJSVVFzSzBOQlFTdERPMUZCUXk5RExFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4TlFVRk5MRWxCUVVrc1NVRkJTU3hMUVVGTExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETVVNc1NVRkJUU3hWUVVGVkxFZEJRVWNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUTNKRExFVkJRVVVzUTBGQlF5eERRVUZETEhGQ1FVRlZMRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzVlVGQlZTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMjVFTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhQUVVGUExFVkJRVVVzU1VGQlNTeEZRVUZGTEN0Q1FVRXJRaXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETVVZc1RVRkJUU3hEUVVGRExHdENRVUZyUWl4RFFVRkRPMWxCUXpWQ0xFTkJRVU03VVVGRFNDeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1kwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlFpdzJSRUZCTmtRN1dVRkROMFFzYTBKQlFXdENMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGRExGZEJRV2xETEVWQlFVVXNWVUZCT0VJN1owSkJRM1pJTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2NVSkJRVlVzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMSEZDUVVGVkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOMlJDeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zWVVGQllTeERRVUZETEZWQlFWVXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU16UkN4RFFVRkRPMmRDUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzI5Q1FVTk9MRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zYjBKQlFWTXNRMEZCUXl4VlFVRlZMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYmtRc1EwRkJRenRuUWtGRFJDeE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRPMWxCUTNKQ0xFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTlVMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEVsQlFVMHNWVUZCVlN4SFFVRkhMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU55UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExIRkNRVUZWTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXh4UWtGQlZTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGRrUXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdGQlFXRXNRMEZCUXl4VlFVRlZMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZWtRc1RVRkJUU3hEUVVGRExHdENRVUZyUWl4RFFVRkRPMWxCUXpWQ0xFTkJRVU03V1VGRFJDeHJRa0ZCYTBJc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eHZRa0ZCVXl4RFFVRkRMRlZCUVZVc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU12UkN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExHdENRVUZyUWl4RFFVRkRPMGxCUXpWQ0xFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0QlFVTlVMRU5CUVVNN1FVRjBRMFFzT0VOQmMwTkRPMEZCUjBRc2EwSkJRWGxDTEZGQlFXZERPMGxCUTNaRUxFMUJRVTBzUTBGQlF5eFJRVUZSTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkRNVVlzUTBGQlF6dEJRVVpFTERSQ1FVVkRPMEZCUlVRc2JVSkJRVEJDTEZGQlFXdERPMGxCUXpGRUxFbEJRVTBzUjBGQlJ5eEhRVUZ6UWl4RlFVRkZMRU5CUVVNN1NVRkRiRU1zYTBKQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJVeXhQUVVGUE8xRkJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhSUVVGUkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNaRExFbEJRVTBzVlVGQlZTeEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVOeVF5eERRVUZETEdOQlFVOHNRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhWUVVGVkxFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGRExGRkJRVkU3WjBKQlEycEZMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdXVUZEY2tJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFRDeERRVUZETzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRTQ3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETzBGQlEySXNRMEZCUXp0QlFWaEVMRGhDUVZkRE8wRkJSVVFzYVVKQlFYZENMRTlCUVZrc1JVRkRhRU1zUTBGQk5rTXNSVUZETjBNc1QwRkJZVHRKUVVObUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOaUxFMUJRVTBzUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkRMRU5CUVUwN1VVRkRiRU1zU1VGQlRTeFBRVUZQTEVkQlFWa3NRMEZCUXl4RFFVRkRPMUZCUXpOQ0xFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VJc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRlRMRlZCUVRoQ08yZENRVU01UkN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRka01zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkROME1zUTBGQlF6dEpRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTB3c1EwRkJRenRCUVdwQ1JDd3dRa0ZwUWtNN1FVRkZSQ3huUWtGQk5rSXNUMEZCVlN4RlFVTnVReXhEUVVGdlJDeEZRVU53UkN4SlFVRlBMRVZCUVVVc1QwRkJZVHRKUVVONFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFlpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZETEVOQlFVa3NSVUZCUlN4RFFVRk5PMUZCUXpsRExFbEJRVTBzVDBGQlR5eEhRVUZaTEVOQlFVTXNRMEZCUXp0UlFVTXpRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eGpRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bENMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZNc1JVRkJTeXhGUVVGRkxGVkJRVGhDTzJkQ1FVTXpSU3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRVZCUVVVc1JVRkJSU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTnNSQ3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF5eEZRVUZGTEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU4yUkN4RFFVRkRPMGxCUTBnc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzBGQlExZ3NRMEZCUXp0QlFXcENSQ3gzUWtGcFFrTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqWlhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12Wm1GalpYUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJaUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB1dGlsaXR5IGZvciBhIGZpZWxkIGRlZmluaXRpb24gb2JqZWN0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBhZ2dyZWdhdGVfMSA9IHJlcXVpcmUoXCIuL2FnZ3JlZ2F0ZVwiKTtcbnZhciBiaW5fMSA9IHJlcXVpcmUoXCIuL2JpblwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbnZhciB0aW1ldW5pdF8xID0gcmVxdWlyZShcIi4vdGltZXVuaXRcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gaXNSZXBlYXRSZWYoZmllbGQpIHtcbiAgICByZXR1cm4gZmllbGQgJiYgIXV0aWxfMS5pc1N0cmluZyhmaWVsZCkgJiYgJ3JlcGVhdCcgaW4gZmllbGQ7XG59XG5leHBvcnRzLmlzUmVwZWF0UmVmID0gaXNSZXBlYXRSZWY7XG5mdW5jdGlvbiBpc0ZpZWxkRGVmKGNoYW5uZWxEZWYpIHtcbiAgICByZXR1cm4gISFjaGFubmVsRGVmICYmICghIWNoYW5uZWxEZWZbJ2ZpZWxkJ10gfHwgY2hhbm5lbERlZlsnYWdncmVnYXRlJ10gPT09ICdjb3VudCcpO1xufVxuZXhwb3J0cy5pc0ZpZWxkRGVmID0gaXNGaWVsZERlZjtcbmZ1bmN0aW9uIGlzVmFsdWVEZWYoY2hhbm5lbERlZikge1xuICAgIHJldHVybiBjaGFubmVsRGVmICYmICd2YWx1ZScgaW4gY2hhbm5lbERlZiAmJiBjaGFubmVsRGVmWyd2YWx1ZSddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzVmFsdWVEZWYgPSBpc1ZhbHVlRGVmO1xuZnVuY3Rpb24gZmllbGQoZmllbGREZWYsIG9wdCkge1xuICAgIGlmIChvcHQgPT09IHZvaWQgMCkgeyBvcHQgPSB7fTsgfVxuICAgIHZhciBmaWVsZCA9IGZpZWxkRGVmLmZpZWxkO1xuICAgIHZhciBwcmVmaXggPSBvcHQucHJlZml4O1xuICAgIHZhciBzdWZmaXggPSBvcHQuc3VmZml4O1xuICAgIGlmIChpc0NvdW50KGZpZWxkRGVmKSkge1xuICAgICAgICBmaWVsZCA9ICdjb3VudF8qJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFvcHQubm9mbikge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgICAgIGZuID0gYmluXzEuYmluVG9TdHJpbmcoZmllbGREZWYuYmluKTtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBvcHQuYmluU3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgZm4gPSBTdHJpbmcob3B0LmFnZ3JlZ2F0ZSB8fCBmaWVsZERlZi5hZ2dyZWdhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGREZWYudGltZVVuaXQpIHtcbiAgICAgICAgICAgICAgICBmbiA9IFN0cmluZyhmaWVsZERlZi50aW1lVW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICBmaWVsZCA9IGZuICsgXCJfXCIgKyBmaWVsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgIGZpZWxkID0gZmllbGQgKyBcIl9cIiArIHN1ZmZpeDtcbiAgICB9XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICBmaWVsZCA9IHByZWZpeCArIFwiX1wiICsgZmllbGQ7XG4gICAgfVxuICAgIGlmIChvcHQuZXhwcikge1xuICAgICAgICBmaWVsZCA9IG9wdC5leHByICsgXCJbXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUoZmllbGQpICsgXCJdXCI7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZDtcbn1cbmV4cG9ydHMuZmllbGQgPSBmaWVsZDtcbmZ1bmN0aW9uIGlzRGlzY3JldGUoZmllbGREZWYpIHtcbiAgICBzd2l0Y2ggKGZpZWxkRGVmLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbm9taW5hbCc6XG4gICAgICAgIGNhc2UgJ29yZGluYWwnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ3F1YW50aXRhdGl2ZSc6XG4gICAgICAgICAgICByZXR1cm4gISFmaWVsZERlZi5iaW47XG4gICAgICAgIGNhc2UgJ3RlbXBvcmFsJzpcbiAgICAgICAgICAgIC8vIFRPRE86IGRlYWwgd2l0aCBjdXN0b20gc2NhbGUgdHlwZSBjYXNlLlxuICAgICAgICAgICAgcmV0dXJuIHRpbWV1bml0XzEuaXNEaXNjcmV0ZUJ5RGVmYXVsdChmaWVsZERlZi50aW1lVW5pdCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5pbnZhbGlkRmllbGRUeXBlKGZpZWxkRGVmLnR5cGUpKTtcbn1cbmV4cG9ydHMuaXNEaXNjcmV0ZSA9IGlzRGlzY3JldGU7XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXMoZmllbGREZWYpIHtcbiAgICByZXR1cm4gIWlzRGlzY3JldGUoZmllbGREZWYpO1xufVxuZXhwb3J0cy5pc0NvbnRpbnVvdXMgPSBpc0NvbnRpbnVvdXM7XG5mdW5jdGlvbiBpc0NvdW50KGZpZWxkRGVmKSB7XG4gICAgcmV0dXJuIGZpZWxkRGVmLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jztcbn1cbmV4cG9ydHMuaXNDb3VudCA9IGlzQ291bnQ7XG5mdW5jdGlvbiB0aXRsZShmaWVsZERlZiwgY29uZmlnKSB7XG4gICAgaWYgKGlzQ291bnQoZmllbGREZWYpKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY291bnRUaXRsZTtcbiAgICB9XG4gICAgdmFyIGZuID0gZmllbGREZWYuYWdncmVnYXRlIHx8IGZpZWxkRGVmLnRpbWVVbml0IHx8IChmaWVsZERlZi5iaW4gJiYgJ2JpbicpO1xuICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gZm4udG9VcHBlckNhc2UoKSArICcoJyArIGZpZWxkRGVmLmZpZWxkICsgJyknO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkRGVmLmZpZWxkO1xuICAgIH1cbn1cbmV4cG9ydHMudGl0bGUgPSB0aXRsZTtcbmZ1bmN0aW9uIGRlZmF1bHRUeXBlKGZpZWxkRGVmLCBjaGFubmVsKSB7XG4gICAgaWYgKGZpZWxkRGVmLnRpbWVVbml0KSB7XG4gICAgICAgIHJldHVybiAndGVtcG9yYWwnO1xuICAgIH1cbiAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgIHJldHVybiAncXVhbnRpdGF0aXZlJztcbiAgICB9XG4gICAgc3dpdGNoIChjaGFubmVsXzEucmFuZ2VUeXBlKGNoYW5uZWwpKSB7XG4gICAgICAgIGNhc2UgJ2NvbnRpbnVvdXMnOlxuICAgICAgICAgICAgcmV0dXJuICdxdWFudGl0YXRpdmUnO1xuICAgICAgICBjYXNlICdkaXNjcmV0ZSc6XG4gICAgICAgICAgICByZXR1cm4gJ25vbWluYWwnO1xuICAgICAgICBjYXNlICdmbGV4aWJsZSc6XG4gICAgICAgICAgICByZXR1cm4gJ25vbWluYWwnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdxdWFudGl0YXRpdmUnO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdFR5cGUgPSBkZWZhdWx0VHlwZTtcbi8qKlxuICogQ29udmVydCB0eXBlIHRvIGZ1bGwsIGxvd2VyY2FzZSB0eXBlLCBvciBhdWdtZW50IHRoZSBmaWVsZERlZiB3aXRoIGEgZGVmYXVsdCB0eXBlIGlmIG1pc3NpbmcuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShjaGFubmVsRGVmLCBjaGFubmVsKSB7XG4gICAgLy8gSWYgYSBmaWVsZERlZiBjb250YWlucyBhIGZpZWxkLCB3ZSBuZWVkIHR5cGUuXG4gICAgaWYgKGlzRmllbGREZWYoY2hhbm5lbERlZikpIHtcbiAgICAgICAgdmFyIGZpZWxkRGVmID0gY2hhbm5lbERlZjtcbiAgICAgICAgLy8gRHJvcCBpbnZhbGlkIGFnZ3JlZ2F0ZVxuICAgICAgICBpZiAoZmllbGREZWYuYWdncmVnYXRlICYmICFhZ2dyZWdhdGVfMS5BR0dSRUdBVEVfT1BfSU5ERVhbZmllbGREZWYuYWdncmVnYXRlXSkge1xuICAgICAgICAgICAgdmFyIGFnZ3JlZ2F0ZSA9IGZpZWxkRGVmLmFnZ3JlZ2F0ZSwgZmllbGREZWZXaXRob3V0QWdncmVnYXRlID0gdHNsaWJfMS5fX3Jlc3QoZmllbGREZWYsIFtcImFnZ3JlZ2F0ZVwiXSk7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5pbnZhbGlkQWdncmVnYXRlKGZpZWxkRGVmLmFnZ3JlZ2F0ZSkpO1xuICAgICAgICAgICAgZmllbGREZWYgPSBmaWVsZERlZldpdGhvdXRBZ2dyZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIGJpblxuICAgICAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgICAgICB2YXIgYmluID0gZmllbGREZWYuYmluO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0Jvb2xlYW4oYmluKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkRGVmID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZmllbGREZWYsIHsgYmluOiB7IG1heGJpbnM6IGJpbl8xLmF1dG9NYXhCaW5zKGNoYW5uZWwpIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghYmluLm1heGJpbnMgJiYgIWJpbi5zdGVwKSB7XG4gICAgICAgICAgICAgICAgZmllbGREZWYgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBmaWVsZERlZiwgeyBiaW46IHRzbGliXzEuX19hc3NpZ24oe30sIGJpbiwgeyBtYXhiaW5zOiBiaW5fMS5hdXRvTWF4QmlucyhjaGFubmVsKSB9KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgVHlwZVxuICAgICAgICBpZiAoZmllbGREZWYudHlwZSkge1xuICAgICAgICAgICAgdmFyIGZ1bGxUeXBlID0gdHlwZV8xLmdldEZ1bGxOYW1lKGZpZWxkRGVmLnR5cGUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkRGVmLnR5cGUgIT09IGZ1bGxUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBzaG9ydCB0eXBlIHRvIGZ1bGwgdHlwZVxuICAgICAgICAgICAgICAgIGZpZWxkRGVmID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZmllbGREZWYsIHsgdHlwZTogZnVsbFR5cGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0eXBlIGlzIGVtcHR5IC8gaW52YWxpZCwgdGhlbiBhdWdtZW50IHdpdGggZGVmYXVsdCB0eXBlXG4gICAgICAgICAgICB2YXIgbmV3VHlwZSA9IGRlZmF1bHRUeXBlKGZpZWxkRGVmLCBjaGFubmVsKTtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmVtcHR5T3JJbnZhbGlkRmllbGRUeXBlKGZpZWxkRGVmLnR5cGUsIGNoYW5uZWwsIG5ld1R5cGUpKTtcbiAgICAgICAgICAgIGZpZWxkRGVmID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZmllbGREZWYsIHsgdHlwZTogbmV3VHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBjaGFubmVsQ29tcGF0aWJpbGl0eShmaWVsZERlZiwgY2hhbm5lbCksIGNvbXBhdGlibGUgPSBfYS5jb21wYXRpYmxlLCB3YXJuaW5nID0gX2Eud2FybmluZztcbiAgICAgICAgaWYgKCFjb21wYXRpYmxlKSB7XG4gICAgICAgICAgICBsb2cud2Fybih3YXJuaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGREZWY7XG4gICAgfVxuICAgIHJldHVybiBjaGFubmVsRGVmO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG52YXIgQ09NUEFUSUJMRSA9IHsgY29tcGF0aWJsZTogdHJ1ZSB9O1xuZnVuY3Rpb24gY2hhbm5lbENvbXBhdGliaWxpdHkoZmllbGREZWYsIGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgY2FzZSAnY29sdW1uJzpcbiAgICAgICAgICAgIGlmIChpc0NvbnRpbnVvdXMoZmllbGREZWYpICYmICFmaWVsZERlZi50aW1lVW5pdCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86KGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtbGl0ZS9pc3N1ZXMvMjAxMSk6XG4gICAgICAgICAgICAgICAgLy8gd2l0aCB0aW1lVW5pdCBpdCdzIG5vdCBhbHdheXMgc3RyaWN0bHkgY29udGludW91c1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdGlibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiBsb2cubWVzc2FnZS5mYWNldENoYW5uZWxTaG91bGRCZURpc2NyZXRlKGNoYW5uZWwpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDT01QQVRJQkxFO1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGNhc2UgJ2RldGFpbCc6XG4gICAgICAgIGNhc2UgJ3Rvb2x0aXAnOlxuICAgICAgICAgICAgcmV0dXJuIENPTVBBVElCTEU7XG4gICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgY2FzZSAneDInOlxuICAgICAgICBjYXNlICd5Mic6XG4gICAgICAgICAgICBpZiAoaXNEaXNjcmV0ZShmaWVsZERlZikgJiYgIWZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdGlibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiBcIkNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggZGlzY3JldGUgZmllbGQuXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENPTVBBVElCTEU7XG4gICAgICAgIGNhc2UgJ3NoYXBlJzpcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlICE9PSAnbm9taW5hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogJ1NoYXBlIGNoYW5uZWwgc2hvdWxkIGJlIHVzZWQgd2l0aCBub21pbmFsIGRhdGEgb25seSdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENPTVBBVElCTEU7XG4gICAgICAgIGNhc2UgJ29yZGVyJzpcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlID09PSAnbm9taW5hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogXCJDaGFubmVsIG9yZGVyIGlzIGluYXBwcm9wcmlhdGUgZm9yIG5vbWluYWwgZmllbGQsIHdoaWNoIGhhcyBubyBpbmhlcmVudCBvcmRlci5cIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ09NUEFUSUJMRTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjaGFubmVsQ29tcGF0YWJpbGl0eSBub3QgaW1wbGVtZW50ZWQgZm9yIGNoYW5uZWwgJyArIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5jaGFubmVsQ29tcGF0aWJpbGl0eSA9IGNoYW5uZWxDb21wYXRpYmlsaXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWm1sbGJHUmtaV1l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZabWxsYkdSa1pXWXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxIZERRVUYzUXpzN08wRkJSWGhETEhsRFFVRTBSRHRCUVVVMVJDdzJRa0ZCYjBRN1FVRkRjRVFzY1VOQlFUWkRPMEZCU3pkRExESkNRVUUyUWp0QlFVazNRaXgxUTBGQmVVUTdRVUZEZWtRc0swSkJRWGxETzBGQlEzcERMQ3RDUVVGM1JEdEJRWGxDZUVRc2NVSkJRVFJDTEV0QlFWazdTVUZEZEVNc1RVRkJUU3hEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEdWQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hSUVVGUkxFbEJRVWtzUzBGQlN5eERRVUZETzBGQlEzaEVMRU5CUVVNN1FVRkdSQ3hyUTBGRlF6dEJRVEpIUkN4dlFrRkJNa0lzVlVGQk1rSTdTVUZEY0VRc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEZWQlFWVXNRMEZCUXl4WFFVRlhMRU5CUVVNc1MwRkJTeXhQUVVGUExFTkJRVU1zUTBGQlF6dEJRVU40Uml4RFFVRkRPMEZCUmtRc1owTkJSVU03UVVGRlJDeHZRa0ZCTWtJc1ZVRkJNa0k3U1VGRGNFUXNUVUZCVFN4RFFVRkRMRlZCUVZVc1NVRkJTU3hQUVVGUExFbEJRVWtzVlVGQlZTeEpRVUZKTEZWQlFWVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU03UVVGRGJFWXNRMEZCUXp0QlFVWkVMR2REUVVWRE8wRkJhVUpFTEdWQlFYTkNMRkZCUVRCQ0xFVkJRVVVzUjBGQmQwSTdTVUZCZUVJc2IwSkJRVUVzUlVGQlFTeFJRVUYzUWp0SlFVTjRSU3hKUVVGSkxFdEJRVXNzUjBGQlJ5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUXpOQ0xFbEJRVTBzVFVGQlRTeEhRVUZITEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzU1VGQlNTeE5RVUZOTEVkQlFVY3NSMEZCUnl4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVWNFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRXRCUVVzc1IwRkJSeXhUUVVGVExFTkJRVU03U1VGRGNFSXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzU1VGQlNTeEZRVUZGTEVkQlFWY3NVMEZCVXl4RFFVRkRPMUZCUlROQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFpDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYWtJc1JVRkJSU3hIUVVGSExHbENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8yZENRVU12UWl4TlFVRk5MRWRCUVVjc1IwRkJSeXhEUVVGRExGTkJRVk1zUTBGQlF6dFpRVU42UWl4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU01UWl4RlFVRkZMRWRCUVVjc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eFRRVUZUTEVsQlFVa3NVVUZCVVN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8xbEJRMjVFTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRemRDTEVWQlFVVXNSMEZCUnl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzFsQlEycERMRU5CUVVNN1VVRkRTQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOUUxFdEJRVXNzUjBGQlRTeEZRVUZGTEZOQlFVa3NTMEZCVHl4RFFVRkRPMUZCUXpOQ0xFTkJRVU03U1VGRFNDeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5ZTEV0QlFVc3NSMEZCVFN4TFFVRkxMRk5CUVVrc1RVRkJVU3hEUVVGRE8wbEJReTlDTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlExZ3NTMEZCU3l4SFFVRk5MRTFCUVUwc1UwRkJTU3hMUVVGUExFTkJRVU03U1VGREwwSXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJJc1MwRkJTeXhIUVVGTkxFZEJRVWNzUTBGQlF5eEpRVUZKTEZOQlFVa3NhMEpCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlJ5eERRVUZETzBsQlF5OURMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBGQlEyWXNRMEZCUXp0QlFYWkRSQ3h6UWtGMVEwTTdRVUZGUkN4dlFrRkJNa0lzVVVGQmVVSTdTVUZEYkVRc1RVRkJUU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRkRUlzUzBGQlN5eFRRVUZUTEVOQlFVTTdVVUZEWml4TFFVRkxMRk5CUVZNN1dVRkRXaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlEyUXNTMEZCU3l4alFVRmpPMWxCUTJwQ0xFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJRenRSUVVONFFpeExRVUZMTEZWQlFWVTdXVUZEWWl3d1EwRkJNRU03V1VGRE1VTXNUVUZCVFN4RFFVRkRMRGhDUVVGdFFpeERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVOc1JDeERRVUZETzBsQlEwUXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUXk5RUxFTkJRVU03UVVGYVJDeG5RMEZaUXp0QlFVVkVMSE5DUVVFMlFpeFJRVUY1UWp0SlFVTndSQ3hOUVVGTkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRMMElzUTBGQlF6dEJRVVpFTEc5RFFVVkRPMEZCUlVRc2FVSkJRWGRDTEZGQlFYbENPMGxCUXk5RExFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4TFFVRkxMRTlCUVU4c1EwRkJRenRCUVVONFF5eERRVUZETzBGQlJrUXNNRUpCUlVNN1FVRkZSQ3hsUVVGelFpeFJRVUV3UWl4RlFVRkZMRTFCUVdNN1NVRkRPVVFzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUWl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF6dEpRVU16UWl4RFFVRkRPMGxCUTBRc1NVRkJUU3hGUVVGRkxFZEJRVWNzVVVGQlVTeERRVUZETEZOQlFWTXNTVUZCU1N4UlFVRlJMRU5CUVVNc1VVRkJVU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NTVUZCU1N4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVNNVJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMUFzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXl4WFFVRlhMRVZCUVVVc1IwRkJSeXhIUVVGSExFZEJRVWNzVVVGQlVTeERRVUZETEV0QlFVc3NSMEZCUnl4SFFVRkhMRU5CUVVNN1NVRkRka1FzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTA0c1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTTdTVUZEZUVJc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGV1JDeHpRa0ZWUXp0QlFVVkVMSEZDUVVFMFFpeFJRVUY1UWl4RlFVRkZMRTlCUVdkQ08wbEJRM0pGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU03U1VGRGNFSXNRMEZCUXp0SlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwQ0xFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTTdTVUZEZUVJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eERRVUZETEcxQ1FVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6TkNMRXRCUVVzc1dVRkJXVHRaUVVObUxFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTTdVVUZEZUVJc1MwRkJTeXhWUVVGVk8xbEJRMklzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0UlFVTnVRaXhMUVVGTExGVkJRVlU3V1VGRFlpeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTI1Q08xbEJRMFVzVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXp0SlFVTXhRaXhEUVVGRE8wRkJRMGdzUTBGQlF6dEJRV3BDUkN4clEwRnBRa003UVVGRlJEczdSMEZGUnp0QlFVTklMRzFDUVVFd1FpeFZRVUU0UWl4RlFVRkZMRTlCUVdkQ08wbEJRM2hGTEdkRVFVRm5SRHRKUVVOb1JDeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6TkNMRWxCUVVrc1VVRkJVU3hIUVVGdlFpeFZRVUZWTEVOQlFVTTdVVUZGTTBNc2VVSkJRWGxDTzFGQlEzcENMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVsQlFVa3NRMEZCUXl3NFFrRkJhMElzUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRek5FTEVsQlFVRXNPRUpCUVZNc1JVRkJSU3hyUlVGQk1rSXNRMEZCWVR0WlFVTXhSQ3hIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNVVUZCVVN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE0wUXNVVUZCVVN4SFFVRkhMSGRDUVVGM1FpeERRVUZETzFGQlEzUkRMRU5CUVVNN1VVRkZSQ3huUWtGQlowSTdVVUZEYUVJc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha0lzU1VGQlRTeEhRVUZITEVkQlFVY3NVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJRenRaUVVONlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRia0lzVVVGQlVTeDNRa0ZEU0N4UlFVRlJMRWxCUTFnc1IwRkJSeXhGUVVGRkxFVkJRVU1zVDBGQlR5eEZRVUZGTEdsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVU1zUjBGRGNrTXNRMEZCUXp0WlFVTktMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM0pETEZGQlFWRXNkMEpCUTBnc1VVRkJVU3hKUVVOWUxFZEJRVWNzZFVKQlEwVXNSMEZCUnl4SlFVTk9MRTlCUVU4c1JVRkJSU3hwUWtGQlZ5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVVm9ReXhEUVVGRE8xbEJRMG9zUTBGQlF6dFJRVU5JTEVOQlFVTTdVVUZGUkN4cFFrRkJhVUk3VVVGRGFrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYkVJc1NVRkJUU3hSUVVGUkxFZEJRVWNzYTBKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRE5VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNdlFpeHJRMEZCYTBNN1owSkJRMnhETEZGQlFWRXNkMEpCUTBnc1VVRkJVU3hKUVVOWUxFbEJRVWtzUlVGQlJTeFJRVUZSTEVkQlEyWXNRMEZCUXp0WlFVTktMRU5CUVVNN1VVRkRTQ3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl3MlJFRkJOa1E3V1VGRE4wUXNTVUZCVFN4UFFVRlBMRWRCUVVjc1YwRkJWeXhEUVVGRExGRkJRVkVzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTXZReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc2RVSkJRWFZDTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1JVRkJSU3hQUVVGUExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXZSU3hSUVVGUkxIZENRVU5FTEZGQlFWRXNTVUZEWWl4SlFVRkpMRVZCUVVVc1QwRkJUeXhIUVVOa0xFTkJRVU03VVVGRFNpeERRVUZETzFGQlJVc3NTVUZCUVN3MFEwRkJLMFFzUlVGQk9VUXNNRUpCUVZVc1JVRkJSU3h2UWtGQlR5eERRVUUwUXp0UlFVTjBSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRUlzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVOd1FpeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJRenRCUVVOd1FpeERRVUZETzBGQk1VUkVMRGhDUVRCRVF6dEJRVVZFTEVsQlFVMHNWVUZCVlN4SFFVRkhMRVZCUVVNc1ZVRkJWU3hGUVVGRkxFbEJRVWtzUlVGQlF5eERRVUZETzBGQlEzUkRMRGhDUVVGeFF5eFJRVUY1UWl4RlFVRkZMRTlCUVdkQ08wbEJRemxGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFSXNTMEZCU3l4TFFVRkxMRU5CUVVNN1VVRkRXQ3hMUVVGTExGRkJRVkU3V1VGRFdDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGFrUXNkMFJCUVhkRU8yZENRVU40UkN4dlJFRkJiMFE3WjBKQlEzQkVMRTFCUVUwc1EwRkJRenR2UWtGRFRDeFZRVUZWTEVWQlFVVXNTMEZCU3p0dlFrRkRha0lzVDBGQlR5eEZRVUZGTEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc05FSkJRVFJDTEVOQlFVTXNUMEZCVHl4RFFVRkRPMmxDUVVNelJDeERRVUZETzFsQlEwb3NRMEZCUXp0WlFVTkVMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU03VVVGRmNFSXNTMEZCU3l4SFFVRkhMRU5CUVVNN1VVRkRWQ3hMUVVGTExFZEJRVWNzUTBGQlF6dFJRVU5VTEV0QlFVc3NUMEZCVHl4RFFVRkRPMUZCUTJJc1MwRkJTeXhOUVVGTkxFTkJRVU03VVVGRFdpeExRVUZMTEZGQlFWRXNRMEZCUXp0UlFVTmtMRXRCUVVzc1UwRkJVenRaUVVOYUxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdVVUZGY0VJc1MwRkJTeXhUUVVGVExFTkJRVU03VVVGRFppeExRVUZMTEUxQlFVMHNRMEZCUXp0UlFVTmFMRXRCUVVzc1NVRkJTU3hEUVVGRE8xRkJRMVlzUzBGQlN5eEpRVUZKTzFsQlExQXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6RkRMRTFCUVUwc1EwRkJRenR2UWtGRFRDeFZRVUZWTEVWQlFVVXNTMEZCU3p0dlFrRkRha0lzVDBGQlR5eEZRVUZGTEdGQlFWY3NUMEZCVHl3MlEwRkJNRU03YVVKQlEzUkZMRU5CUVVNN1dVRkRTaXhEUVVGRE8xbEJRMFFzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0UlFVVndRaXhMUVVGTExFOUJRVTg3V1VGRFZpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJoRExFMUJRVTBzUTBGQlF6dHZRa0ZEVEN4VlFVRlZMRVZCUVVVc1MwRkJTenR2UWtGRGFrSXNUMEZCVHl4RlFVRkZMSEZFUVVGeFJEdHBRa0ZETDBRc1EwRkJRenRaUVVOS0xFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRPMUZCUlhCQ0xFdEJRVXNzVDBGQlR6dFpRVU5XTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRhRU1zVFVGQlRTeERRVUZETzI5Q1FVTk1MRlZCUVZVc1JVRkJSU3hMUVVGTE8yOUNRVU5xUWl4UFFVRlBMRVZCUVVVc1owWkJRV2RHTzJsQ1FVTXhSaXhEUVVGRE8xbEJRMG9zUTBGQlF6dFpRVU5FTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1NVRkRkRUlzUTBGQlF6dEpRVU5FTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2JVUkJRVzFFTEVkQlFVY3NUMEZCVHl4RFFVRkRMRU5CUVVNN1FVRkRha1lzUTBGQlF6dEJRWEpFUkN4dlJFRnhSRU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9zZWxlY3Rpb24vc2VsZWN0aW9uXCIpO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi9kYXRldGltZVwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4vZmllbGRkZWZcIik7XG52YXIgdGltZXVuaXRfMSA9IHJlcXVpcmUoXCIuL3RpbWV1bml0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBpc1NlbGVjdGlvbkZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gZmlsdGVyICYmIGZpbHRlclsnc2VsZWN0aW9uJ107XG59XG5leHBvcnRzLmlzU2VsZWN0aW9uRmlsdGVyID0gaXNTZWxlY3Rpb25GaWx0ZXI7XG5mdW5jdGlvbiBpc0VxdWFsRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBmaWx0ZXIgJiYgISFmaWx0ZXIuZmllbGQgJiYgZmlsdGVyLmVxdWFsICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzRXF1YWxGaWx0ZXIgPSBpc0VxdWFsRmlsdGVyO1xuZnVuY3Rpb24gaXNSYW5nZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5maWVsZCkge1xuICAgICAgICBpZiAodXRpbF8xLmlzQXJyYXkoZmlsdGVyLnJhbmdlKSAmJiBmaWx0ZXIucmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzUmFuZ2VGaWx0ZXIgPSBpc1JhbmdlRmlsdGVyO1xuZnVuY3Rpb24gaXNPbmVPZkZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gZmlsdGVyICYmICEhZmlsdGVyLmZpZWxkICYmICh1dGlsXzEuaXNBcnJheShmaWx0ZXIub25lT2YpIHx8XG4gICAgICAgIHV0aWxfMS5pc0FycmF5KGZpbHRlci5pbikgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICk7XG59XG5leHBvcnRzLmlzT25lT2ZGaWx0ZXIgPSBpc09uZU9mRmlsdGVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGZpbHRlciBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKi9cbi8vIG1vZGVsIGlzIG9ubHkgdXNlZCBmb3Igc2VsZWN0aW9uIGZpbHRlcnMuXG5mdW5jdGlvbiBleHByZXNzaW9uKG1vZGVsLCBmaWx0ZXIpIHtcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZWxlY3Rpb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gbW9kZWwuZ2V0Q29tcG9uZW50KCdzZWxlY3Rpb24nLCBmaWx0ZXIuc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbl8xLnByZWRpY2F0ZShmaWx0ZXIuc2VsZWN0aW9uLCBzZWxlY3Rpb24udHlwZSwgc2VsZWN0aW9uLnJlc29sdmUsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGZpZWxkRXhwciA9IGZpbHRlci50aW1lVW5pdCA/XG4gICAgICAgICAgICAvLyBGb3IgdGltZVVuaXQsIGNhc3QgaW50byBpbnRlZ2VyIHdpdGggdGltZSgpIHNvIHdlIGNhbiB1c2UgPT09LCBpbnJhbmdlLCBpbmRleE9mIHRvIGNvbXBhcmUgdmFsdWVzIGRpcmVjdGx5LlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY2FsY3VsYXRlIHRpbWVVbml0IG9uIHRoZSBmbHkgaGVyZS4gQ29uc2lkZXIgaWYgd2Ugd291bGQgbGlrZSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGggdGltZVVuaXQgcGlwZWxpbmVcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgdXRjXG4gICAgICAgICAgICAoJ3RpbWUoJyArIHRpbWV1bml0XzEuZmllbGRFeHByKGZpbHRlci50aW1lVW5pdCwgZmlsdGVyLmZpZWxkKSArICcpJykgOlxuICAgICAgICAgICAgZmllbGRkZWZfMS5maWVsZChmaWx0ZXIsIHsgZXhwcjogJ2RhdHVtJyB9KTtcbiAgICAgICAgaWYgKGlzRXF1YWxGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkRXhwciArICc9PT0nICsgdmFsdWVFeHByKGZpbHRlci5lcXVhbCwgZmlsdGVyLnRpbWVVbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09uZU9mRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgICAgIC8vIFwib25lT2ZcIiB3YXMgZm9ybWVybHkgXCJpblwiIC0tIHNvIHdlIG5lZWQgdG8gYWRkIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIHZhciBvbmVPZiA9IGZpbHRlci5vbmVPZiB8fCBmaWx0ZXJbJ2luJ107XG4gICAgICAgICAgICByZXR1cm4gJ2luZGV4b2YoWycgK1xuICAgICAgICAgICAgICAgIG9uZU9mLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWVFeHByKHYsIGZpbHRlci50aW1lVW5pdCk7IH0pLmpvaW4oJywnKSArXG4gICAgICAgICAgICAgICAgJ10sICcgKyBmaWVsZEV4cHIgKyAnKSAhPT0gLTEnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmFuZ2VGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICAgICAgdmFyIGxvd2VyID0gZmlsdGVyLnJhbmdlWzBdO1xuICAgICAgICAgICAgdmFyIHVwcGVyID0gZmlsdGVyLnJhbmdlWzFdO1xuICAgICAgICAgICAgaWYgKGxvd2VyICE9PSBudWxsICYmIHVwcGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbnJhbmdlKCcgKyBmaWVsZEV4cHIgKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVFeHByKGxvd2VyLCBmaWx0ZXIudGltZVVuaXQpICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRXhwcih1cHBlciwgZmlsdGVyLnRpbWVVbml0KSArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRXhwciArICcgPj0gJyArIGxvd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXBwZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRFeHByICsgJyA8PSAnICsgdXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG5mdW5jdGlvbiB2YWx1ZUV4cHIodiwgdGltZVVuaXQpIHtcbiAgICBpZiAoZGF0ZXRpbWVfMS5pc0RhdGVUaW1lKHYpKSB7XG4gICAgICAgIHZhciBleHByID0gZGF0ZXRpbWVfMS5kYXRlVGltZUV4cHIodiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAndGltZSgnICsgZXhwciArICcpJztcbiAgICB9XG4gICAgaWYgKHRpbWV1bml0XzEuaXNTaW5nbGVUaW1lVW5pdCh0aW1lVW5pdCkpIHtcbiAgICAgICAgdmFyIGRhdGV0aW1lID0ge307XG4gICAgICAgIGRhdGV0aW1lW3RpbWVVbml0XSA9IHY7XG4gICAgICAgIHZhciBleHByID0gZGF0ZXRpbWVfMS5kYXRlVGltZUV4cHIoZGF0ZXRpbWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gJ3RpbWUoJyArIGV4cHIgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVptbHNkR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlpwYkhSbGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVVOQkxESkVRVUYzUkR0QlFVTjRSQ3gxUTBGQk9FUTdRVUZET1VRc2RVTkJRV2xETzBGQlEycERMSFZEUVVGelJqdEJRVU4wUml3clFrRkJlVU03UVVGWGVrTXNNa0pCUVd0RExFMUJRV003U1VGRE9VTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1NVRkJTU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdRVUZEZGtNc1EwRkJRenRCUVVaRUxEaERRVVZETzBGQmMwSkVMSFZDUVVFNFFpeE5RVUZYTzBsQlEzWkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRWxCUVVrc1RVRkJUU3hEUVVGRExFdEJRVXNzUzBGQlJ5eFRRVUZUTEVOQlFVTTdRVUZET1VRc1EwRkJRenRCUVVaRUxITkRRVVZETzBGQmVVSkVMSFZDUVVFNFFpeE5RVUZYTzBsQlEzWkRMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzU1VGQlNTeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNelFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4alFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZGtRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU5rTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU5tTEVOQlFVTTdRVUZRUkN4elEwRlBRenRCUVhWQ1JDeDFRa0ZCT0VJc1RVRkJWenRKUVVOMlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4SlFVRkpMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlEycERMR05CUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlEzSkNMR05CUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNlVUpCUVhsQ08wdEJRemRETEVOQlFVTTdRVUZEU2l4RFFVRkRPMEZCVEVRc2MwTkJTME03UVVGRlJEczdSMEZGUnp0QlFVTklMRFJEUVVFMFF6dEJRVU0xUXl4dlFrRkJNa0lzUzBGQldTeEZRVUZGTEUxQlFXTTdTVUZEY2tRc1JVRkJSU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVFpeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTJoQ0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pETEVsQlFVMHNVMEZCVXl4SFFVRkhMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVOd1JTeE5RVUZOTEVOQlFVTXNjVUpCUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eEZRVUZGTEZOQlFWTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1UwRkJVeXhEUVVGRExFOUJRVThzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRjRVlzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTA0c1NVRkJUU3hUUVVGVExFZEJRVWNzVFVGQlRTeERRVUZETEZGQlFWRTdXVUZETDBJc09FZEJRVGhITzFsQlF6VkhMRzlJUVVGdlNEdFpRVU53U0N4dlFrRkJiMEk3V1VGRGRFSXNRMEZCUXl4UFFVRlBMRWRCUVVjc2IwSkJRV2xDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRPMWxCUTJ4RkxHZENRVUZMTEVOQlFVTXNUVUZCVFN4RlFVRkZMRVZCUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUlVGQlF5eERRVUZETEVOQlFVTTdVVUZGYWtNc1JVRkJSU3hEUVVGRExFTkJRVU1zWVVGQllTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNeFFpeE5RVUZOTEVOQlFVTXNVMEZCVXl4SFFVRkhMRXRCUVVzc1IwRkJSeXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRGRFVXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGhRVUZoTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBETEhkRlFVRjNSVHRaUVVONFJTeEpRVUZOTEV0QlFVc3NSMEZCYTBJc1RVRkJUU3hEUVVGRExFdEJRVXNzU1VGQlNTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRNVVFzVFVGQlRTeERRVUZETEZkQlFWYzdaMEpCUTJoQ0xFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUXl4RFFVRkRMRWxCUVVzc1QwRkJRU3hUUVVGVExFTkJRVU1zUTBGQlF5eEZRVUZGTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJOMElzUTBGQk5rSXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU03WjBKQlEzcEVMRXRCUVVzc1IwRkJSeXhUUVVGVExFZEJRVWNzVlVGQlZTeERRVUZETzFGQlEyNURMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUXl4SlFVRk5MRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsQ0xFbEJRVTBzUzBGQlN5eEhRVUZITEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRk9VSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExFbEJRVWtzU1VGQlN5eExRVUZMTEV0QlFVc3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGRFTXNUVUZCVFN4RFFVRkRMRlZCUVZVc1IwRkJSeXhUUVVGVExFZEJRVWNzU1VGQlNUdHZRa0ZEYkVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1NVRkJTVHR2UWtGRGVFTXNVMEZCVXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRPMWxCUXpWRExFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpGQ0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVkQlFVY3NUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJRenRaUVVOd1F5eERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNeFFpeE5RVUZOTEVOQlFVTXNVMEZCVXl4SFFVRkhMRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU03V1VGRGNFTXNRMEZCUXp0UlFVTklMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0QlFVTnVRaXhEUVVGRE8wRkJkRU5FTEdkRFFYTkRRenRCUVVWRUxHMUNRVUZ0UWl4RFFVRk5MRVZCUVVVc1VVRkJhMEk3U1VGRE0wTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2NVSkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRiRUlzU1VGQlRTeEpRVUZKTEVkQlFVY3NkVUpCUVZrc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEYmtNc1RVRkJUU3hEUVVGRExFOUJRVThzUjBGQlJ5eEpRVUZKTEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl3eVFrRkJaMElzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMMElzU1VGQlRTeFJRVUZSTEVkQlFXRXNSVUZCUlN4RFFVRkRPMUZCUXpsQ0xGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRka0lzU1VGQlRTeEpRVUZKTEVkQlFVY3NkVUpCUVZrc1EwRkJReXhSUVVGUkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdVVUZETVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUjBGQlJ5eEpRVUZKTEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU16UWl4RFFVRkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRMZWdlbmRDb25maWcgPSB7XG4gICAgb3JpZW50OiB1bmRlZmluZWQsXG59O1xuZXhwb3J0cy5MRUdFTkRfUFJPUEVSVElFUyA9IFsnZW50cnlQYWRkaW5nJywgJ2Zvcm1hdCcsICdvZmZzZXQnLCAnb3JpZW50JywgJ3RpY2tDb3VudCcsICd0aXRsZScsICd0eXBlJywgJ3ZhbHVlcycsICd6aW5kZXgnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJHVm5aVzVrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMnhsWjJWdVpDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVN0RFlTeFJRVUZCTEcxQ1FVRnRRaXhIUVVGcFFqdEpRVU12UXl4TlFVRk5MRVZCUVVVc1UwRkJVenREUVVOc1FpeERRVUZETzBGQlJWY3NVVUZCUVN4cFFrRkJhVUlzUjBGQmIwSXNRMEZCUXl4alFVRmpMRVZCUVVVc1VVRkJVU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFJRVUZSTEVWQlFVVXNWMEZCVnl4RlFVRkZMRTlCUVU4c1JVRkJSU3hOUVVGTkxFVkJRVVVzVVVGQlVTeEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLy88cmVmZXJlbmNlIHBhdGg9XCIuLi90eXBpbmdzL3ZlZ2EtdXRpbC5kLnRzXCIgLz5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVmVnYS1MaXRlJ3Mgc2luZ2xldG9uIGxvZ2dlciB1dGlsaXR5LlxuICovXG52YXIgdmVnYV91dGlsXzEgPSByZXF1aXJlKFwidmVnYS11dGlsXCIpO1xuLyoqXG4gKiBNYWluIChkZWZhdWx0KSBWZWdhIExvZ2dlciBpbnN0YW5jZSBmb3IgVmVnYS1MaXRlXG4gKi9cbnZhciBtYWluID0gdmVnYV91dGlsXzEubG9nZ2VyKHZlZ2FfdXRpbF8xLldhcm4pO1xudmFyIGN1cnJlbnQgPSBtYWluO1xuLyoqXG4gKiBMb2dnZXIgdG9vbCBmb3IgY2hlY2tpbmcgaWYgdGhlIGNvZGUgdGhyb3dzIGNvcnJlY3Qgd2FybmluZ1xuICovXG52YXIgTG9jYWxMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2FsTG9nZ2VyKCkge1xuICAgICAgICB0aGlzLndhcm5zID0gW107XG4gICAgICAgIHRoaXMuaW5mb3MgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJ1Z3MgPSBbXTtcbiAgICB9XG4gICAgTG9jYWxMb2dnZXIucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExvY2FsTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMud2FybnMpLnB1c2guYXBwbHkoX2EsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgTG9jYWxMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5pbmZvcykucHVzaC5hcHBseShfYSwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBMb2NhbExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5kZWJ1Z3MpLnB1c2guYXBwbHkoX2EsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuTG9jYWxMb2dnZXIgPSBMb2NhbExvZ2dlcjtcbmZ1bmN0aW9uIHJ1bkxvY2FsTG9nZ2VyKGYpIHtcbiAgICB2YXIgbG9jYWxMb2dnZXIgPSBjdXJyZW50ID0gbmV3IExvY2FsTG9nZ2VyKCk7XG4gICAgZihsb2NhbExvZ2dlcik7XG4gICAgcmVzZXQoKTtcbn1cbmV4cG9ydHMucnVuTG9jYWxMb2dnZXIgPSBydW5Mb2NhbExvZ2dlcjtcbmZ1bmN0aW9uIHdyYXAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBjdXJyZW50ID0gbmV3IExvY2FsTG9nZ2VyKCk7XG4gICAgICAgIGYobG9nZ2VyKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xufVxuZXhwb3J0cy53cmFwID0gd3JhcDtcbi8qKlxuICogU2V0IHRoZSBzaW5nbGV0b24gbG9nZ2VyIHRvIGJlIGEgY3VzdG9tIGxvZ2dlclxuICovXG5mdW5jdGlvbiBzZXQobG9nZ2VyKSB7XG4gICAgY3VycmVudCA9IGxvZ2dlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmV4cG9ydHMuc2V0ID0gc2V0O1xuLyoqXG4gKiBSZXNldCB0aGUgbWFpbiBsb2dnZXIgdG8gdXNlIHRoZSBkZWZhdWx0IFZlZ2EgTG9nZ2VyXG4gKi9cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGN1cnJlbnQgPSBtYWluO1xuICAgIHJldHVybiBjdXJyZW50O1xufVxuZXhwb3J0cy5yZXNldCA9IHJlc2V0O1xuZnVuY3Rpb24gd2FybigpIHtcbiAgICB2YXIgXyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIF9bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY3VycmVudC53YXJuLmFwcGx5KGN1cnJlbnQsIGFyZ3VtZW50cyk7XG59XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuZnVuY3Rpb24gaW5mbygpIHtcbiAgICB2YXIgXyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIF9bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY3VycmVudC5pbmZvLmFwcGx5KGN1cnJlbnQsIGFyZ3VtZW50cyk7XG59XG5leHBvcnRzLmluZm8gPSBpbmZvO1xuZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgdmFyIF8gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGN1cnJlbnQuZGVidWcuYXBwbHkoY3VycmVudCwgYXJndW1lbnRzKTtcbn1cbmV4cG9ydHMuZGVidWcgPSBkZWJ1Zztcbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhbGwgVmVnYS1MaXRlIEVycm9yIE1lc3NhZ2VzXG4gKi9cbnZhciBtZXNzYWdlO1xuKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgbWVzc2FnZS5JTlZBTElEX1NQRUMgPSAnSW52YWxpZCBzcGVjJztcbiAgICAvLyBSRVBFQVRcbiAgICBmdW5jdGlvbiBub1N1Y2hSZXBlYXRlZFZhbHVlKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBcIlVua25vd24gcmVwZWF0ZWQgdmFsdWUgXFxcIlwiICsgZmllbGQgKyBcIlxcXCIuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2Uubm9TdWNoUmVwZWF0ZWRWYWx1ZSA9IG5vU3VjaFJlcGVhdGVkVmFsdWU7XG4gICAgLy8gREFUQVxuICAgIGZ1bmN0aW9uIHVucmVjb2duaXplZFBhcnNlKHApIHtcbiAgICAgICAgcmV0dXJuIFwiVW5yZWNvZ25pemVkIHBhcnNlIFwiICsgcCArIFwiLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnVucmVjb2duaXplZFBhcnNlID0gdW5yZWNvZ25pemVkUGFyc2U7XG4gICAgLy8gVFJBTlNGT1JNU1xuICAgIGZ1bmN0aW9uIGludmFsaWRUcmFuc2Zvcm1JZ25vcmVkKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gXCJJZ25vcmluZyBhbiBpbnZhbGlkIHRyYW5zZm9ybTogXCIgKyBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm0pICsgXCIuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuaW52YWxpZFRyYW5zZm9ybUlnbm9yZWQgPSBpbnZhbGlkVHJhbnNmb3JtSWdub3JlZDtcbiAgICAvLyBFTkNPRElORyAmIEZBQ0VUXG4gICAgZnVuY3Rpb24gaW52YWxpZEZpZWxkVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgZmllbGQgdHlwZSBcXFwiXCIgKyB0eXBlICsgXCJcXFwiXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuaW52YWxpZEZpZWxkVHlwZSA9IGludmFsaWRGaWVsZFR5cGU7XG4gICAgZnVuY3Rpb24gaW52YWxpZEFnZ3JlZ2F0ZShhZ2dyZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiSW52YWxpZCBhZ2dyZWdhdGlvbiBvcGVyYXRvciBcXFwiXCIgKyBhZ2dyZWdhdGUgKyBcIlxcXCJcIjtcbiAgICB9XG4gICAgbWVzc2FnZS5pbnZhbGlkQWdncmVnYXRlID0gaW52YWxpZEFnZ3JlZ2F0ZTtcbiAgICBmdW5jdGlvbiBlbXB0eU9ySW52YWxpZEZpZWxkVHlwZSh0eXBlLCBjaGFubmVsLCBuZXdUeXBlKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgZmllbGQgdHlwZSAoXCIgKyB0eXBlICsgXCIpIGZvciBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiLCB1c2luZyBcIiArIG5ld1R5cGUgKyBcIiBpbnN0ZWFkLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmVtcHR5T3JJbnZhbGlkRmllbGRUeXBlID0gZW1wdHlPckludmFsaWRGaWVsZFR5cGU7XG4gICAgZnVuY3Rpb24gZW1wdHlGaWVsZERlZihmaWVsZERlZiwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gXCJEcm9wcGluZyBcIiArIEpTT04uc3RyaW5naWZ5KGZpZWxkRGVmKSArIFwiIGZyb20gY2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiBzaW5jZSBpdCBkb2VzIG5vdCBjb250YWluIGRhdGEgZmllbGQgb3IgdmFsdWUuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuZW1wdHlGaWVsZERlZiA9IGVtcHR5RmllbGREZWY7XG4gICAgZnVuY3Rpb24gaW5jb21wYXRpYmxlQ2hhbm5lbChjaGFubmVsLCBtYXJrT3JGYWNldCwgd2hlbikge1xuICAgICAgICByZXR1cm4gY2hhbm5lbCArIFwiIGRyb3BwZWQgYXMgaXQgaXMgaW5jb21wYXRpYmxlIHdpdGggXCIgKyBtYXJrT3JGYWNldCArICh3aGVuID8gXCIgd2hlbiBcIiArIHdoZW4gOiAnJykgKyBcIi5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5pbmNvbXBhdGlibGVDaGFubmVsID0gaW5jb21wYXRpYmxlQ2hhbm5lbDtcbiAgICBmdW5jdGlvbiBmYWNldENoYW5uZWxTaG91bGRCZURpc2NyZXRlKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgKyBcIiBlbmNvZGluZyBzaG91bGQgYmUgZGlzY3JldGUgKG9yZGluYWwgLyBub21pbmFsIC8gYmlubmVkKS5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5mYWNldENoYW5uZWxTaG91bGRCZURpc2NyZXRlID0gZmFjZXRDaGFubmVsU2hvdWxkQmVEaXNjcmV0ZTtcbiAgICBmdW5jdGlvbiBkaXNjcmV0ZUNoYW5uZWxDYW5ub3RFbmNvZGUoY2hhbm5lbCwgdHlwZSkge1xuICAgICAgICByZXR1cm4gXCJVc2luZyBkaXNjcmV0ZSBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIHRvIGVuY29kZSBcIiArIHR5cGUgKyBcIiBmaWVsZCBjYW4gYmUgbWlzbGVhZGluZyBhcyBpdCBkb2VzIG5vdCBlbmNvZGUgXCIgKyAodHlwZSA9PT0gJ29yZGluYWwnID8gJ29yZGVyJyA6ICdtYWduaXR1ZGUnKSArIFwiLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZSA9IGRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZTtcbiAgICAvLyBNYXJrXG4gICAgbWVzc2FnZS5CQVJfV0lUSF9QT0lOVF9TQ0FMRV9BTkRfUkFOR0VTVEVQX05VTEwgPSAnQmFyIG1hcmsgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggcG9pbnQgc2NhbGUgd2hlbiByYW5nZVN0ZXAgaXMgbnVsbC4gUGxlYXNlIHVzZSBiYW5kIHNjYWxlIGluc3RlYWQuJztcbiAgICBmdW5jdGlvbiB1bmNsZWFyT3JpZW50Q29udGludW91cyhtYXJrKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBjbGVhcmx5IGRldGVybWluZSBvcmllbnRhdGlvbiBmb3IgXCIgKyBtYXJrICsgXCIgc2luY2UgYm90aCB4IGFuZCB5IGNoYW5uZWwgZW5jb2RlIGNvbnRpbm91cyBmaWVsZHMuIEluIHRoaXMgY2FzZSwgd2UgdXNlIHZlcnRpY2FsIGJ5IGRlZmF1bHRcIjtcbiAgICB9XG4gICAgbWVzc2FnZS51bmNsZWFyT3JpZW50Q29udGludW91cyA9IHVuY2xlYXJPcmllbnRDb250aW51b3VzO1xuICAgIGZ1bmN0aW9uIHVuY2xlYXJPcmllbnREaXNjcmV0ZU9yRW1wdHkobWFyaykge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgY2xlYXJseSBkZXRlcm1pbmUgb3JpZW50YXRpb24gZm9yIFwiICsgbWFyayArIFwiIHNpbmNlIGJvdGggeCBhbmQgeSBjaGFubmVsIGVuY29kZSBkaXNjcmV0ZSBvciBlbXB0eSBmaWVsZHMuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UudW5jbGVhck9yaWVudERpc2NyZXRlT3JFbXB0eSA9IHVuY2xlYXJPcmllbnREaXNjcmV0ZU9yRW1wdHk7XG4gICAgZnVuY3Rpb24gb3JpZW50T3ZlcnJpZGRlbihvcmlnaW5hbCwgYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiBcIlNwZWNpZmllZCBvcmllbnQgXCIgKyBvcmlnaW5hbCArIFwiIG92ZXJyaWRkZW4gd2l0aCBcIiArIGFjdHVhbDtcbiAgICB9XG4gICAgbWVzc2FnZS5vcmllbnRPdmVycmlkZGVuID0gb3JpZW50T3ZlcnJpZGRlbjtcbiAgICAvLyBTQ0FMRVxuICAgIG1lc3NhZ2UuQ0FOTk9UX1VOSU9OX0NVU1RPTV9ET01BSU5fV0lUSF9GSUVMRF9ET01BSU4gPSAnY3VzdG9tIGRvbWFpbiBzY2FsZSBjYW5ub3QgYmUgdW5pb25lZCB3aXRoIGRlZmF1bHQgZmllbGQtYmFzZWQgZG9tYWluJztcbiAgICBmdW5jdGlvbiBjYW5ub3RVc2VTY2FsZVByb3BlcnR5V2l0aE5vbkNvbG9yKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBcIiArIHByb3AgKyBcIiB3aXRoIG5vbi1jb2xvciBjaGFubmVsLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmNhbm5vdFVzZVNjYWxlUHJvcGVydHlXaXRoTm9uQ29sb3IgPSBjYW5ub3RVc2VTY2FsZVByb3BlcnR5V2l0aE5vbkNvbG9yO1xuICAgIGZ1bmN0aW9uIHVuYWdncmVnYXRlRG9tYWluSGFzTm9FZmZlY3RGb3JSYXdGaWVsZChmaWVsZERlZikge1xuICAgICAgICByZXR1cm4gXCJVc2luZyB1bmFnZ3JlZ2F0ZWQgZG9tYWluIHdpdGggcmF3IGZpZWxkIGhhcyBubyBlZmZlY3QgKFwiICsgSlNPTi5zdHJpbmdpZnkoZmllbGREZWYpICsgXCIpLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnVuYWdncmVnYXRlRG9tYWluSGFzTm9FZmZlY3RGb3JSYXdGaWVsZCA9IHVuYWdncmVnYXRlRG9tYWluSGFzTm9FZmZlY3RGb3JSYXdGaWVsZDtcbiAgICBmdW5jdGlvbiB1bmFnZ3JlZ2F0ZURvbWFpbldpdGhOb25TaGFyZWREb21haW5PcChhZ2dyZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5hZ2dyZWdhdGVkIGRvbWFpbiBub3QgYXBwbGljYWJsZSBmb3IgXCIgKyBhZ2dyZWdhdGUgKyBcIiBzaW5jZSBpdCBwcm9kdWNlcyB2YWx1ZXMgb3V0c2lkZSB0aGUgb3JpZ2luIGRvbWFpbiBvZiB0aGUgc291cmNlIGRhdGEuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UudW5hZ2dyZWdhdGVEb21haW5XaXRoTm9uU2hhcmVkRG9tYWluT3AgPSB1bmFnZ3JlZ2F0ZURvbWFpbldpdGhOb25TaGFyZWREb21haW5PcDtcbiAgICBmdW5jdGlvbiB1bmFnZ3JlZ2F0ZWREb21haW5XaXRoTG9nU2NhbGUoZmllbGREZWYpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5hZ2dyZWdhdGVkIGRvbWFpbiBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQgZm9yIGxvZyBzY2FsZSAoXCIgKyBKU09OLnN0cmluZ2lmeShmaWVsZERlZikgKyBcIikuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UudW5hZ2dyZWdhdGVkRG9tYWluV2l0aExvZ1NjYWxlID0gdW5hZ2dyZWdhdGVkRG9tYWluV2l0aExvZ1NjYWxlO1xuICAgIG1lc3NhZ2UuQ0FOTk9UX1VTRV9SQU5HRV9XSVRIX1BPU0lUSU9OID0gJ0Nhbm5vdCB1c2UgY3VzdG9tIHJhbmdlIHdpdGggeCBvciB5IGNoYW5uZWwuICBQbGVhc2UgY3VzdG9taXplIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIG9yIHJhbmdlU3RlcCBpbnN0ZWFkLic7XG4gICAgbWVzc2FnZS5DQU5OT1RfVVNFX1BBRERJTkdfV0lUSF9GQUNFVCA9ICdDYW5ub3QgdXNlIHBhZGRpbmcgd2l0aCBmYWNldFxcJ3Mgc2NhbGUuICBQbGVhc2UgdXNlIHNwYWNpbmcgaW5zdGVhZC4nO1xuICAgIGZ1bmN0aW9uIGNhbm5vdFVzZVJhbmdlUHJvcGVydHlXaXRoRmFjZXQocHJvcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBjdXN0b20gXCIgKyBwcm9wTmFtZSArIFwiIHdpdGggcm93IG9yIGNvbHVtbiBjaGFubmVsLiBQbGVhc2UgdXNlIHdpZHRoLCBoZWlnaHQsIG9yIHNwYWNpbmcgaW5zdGVhZC5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5jYW5ub3RVc2VSYW5nZVByb3BlcnR5V2l0aEZhY2V0ID0gY2Fubm90VXNlUmFuZ2VQcm9wZXJ0eVdpdGhGYWNldDtcbiAgICBmdW5jdGlvbiByYW5nZVN0ZXBEcm9wcGVkKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIFwicmFuZ2VTdGVwIGZvciBcIiArIGNoYW5uZWwgKyBcIiBpcyBkcm9wcGVkIGFzIHRvcC1sZXZlbCBcIiArIChjaGFubmVsID09PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCcpICsgXCIgaXMgcHJvdmlkZWQuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UucmFuZ2VTdGVwRHJvcHBlZCA9IHJhbmdlU3RlcERyb3BwZWQ7XG4gICAgZnVuY3Rpb24gc2NhbGVUeXBlTm90V29ya1dpdGhDaGFubmVsKGNoYW5uZWwsIHNjYWxlVHlwZSwgZGVmYXVsdFNjYWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gXCJDaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGRvZXMgbm90IHdvcmsgd2l0aCBcIiArIHNjYWxlVHlwZSArIFwiIHNjYWxlLiBXZSBhcmUgdXNpbmcgXCIgKyBkZWZhdWx0U2NhbGVUeXBlICsgXCIgc2NhbGUgaW5zdGVhZC5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aENoYW5uZWwgPSBzY2FsZVR5cGVOb3RXb3JrV2l0aENoYW5uZWw7XG4gICAgZnVuY3Rpb24gc2NhbGVUeXBlTm90V29ya1dpdGhGaWVsZERlZihzY2FsZVR5cGUsIGRlZmF1bHRTY2FsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFwiRmllbGREZWYgZG9lcyBub3Qgd29yayB3aXRoIFwiICsgc2NhbGVUeXBlICsgXCIgc2NhbGUuIFdlIGFyZSB1c2luZyBcIiArIGRlZmF1bHRTY2FsZVR5cGUgKyBcIiBzY2FsZSBpbnN0ZWFkLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnNjYWxlVHlwZU5vdFdvcmtXaXRoRmllbGREZWYgPSBzY2FsZVR5cGVOb3RXb3JrV2l0aEZpZWxkRGVmO1xuICAgIGZ1bmN0aW9uIHNjYWxlUHJvcGVydHlOb3RXb3JrV2l0aFNjYWxlVHlwZShzY2FsZVR5cGUsIHByb3BOYW1lLCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBjaGFubmVsICsgXCItc2NhbGUncyBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBpcyBkcm9wcGVkIGFzIGl0IGRvZXMgbm90IHdvcmsgd2l0aCBcIiArIHNjYWxlVHlwZSArIFwiIHNjYWxlLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnNjYWxlUHJvcGVydHlOb3RXb3JrV2l0aFNjYWxlVHlwZSA9IHNjYWxlUHJvcGVydHlOb3RXb3JrV2l0aFNjYWxlVHlwZTtcbiAgICBmdW5jdGlvbiBzY2FsZVR5cGVOb3RXb3JrV2l0aE1hcmsobWFyaywgc2NhbGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBcIlNjYWxlIHR5cGUgXFxcIlwiICsgc2NhbGVUeXBlICsgXCJcXFwiIGRvZXMgbm90IHdvcmsgd2l0aCBtYXJrIFwiICsgbWFyayArIFwiLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnNjYWxlVHlwZU5vdFdvcmtXaXRoTWFyayA9IHNjYWxlVHlwZU5vdFdvcmtXaXRoTWFyaztcbiAgICBmdW5jdGlvbiBpbmRlcGVuZGVudFNjYWxlTWVhbnNJbmRlcGVuZGVudEd1aWRlKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIFwiU2V0dGluZyB0aGUgc2NhbGUgdG8gYmUgaW5kZXBlbmRlbnQgZm9yIFwiICsgY2hhbm5lbCArIFwiIG1lYW5zIHdlIGFsc28gaGF2ZSB0byBzZXQgdGhlIGd1aWRlIChheGlzIG9yIGxlZ2VuZCkgdG8gYmUgaW5kZXBlbmRlbnQuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuaW5kZXBlbmRlbnRTY2FsZU1lYW5zSW5kZXBlbmRlbnRHdWlkZSA9IGluZGVwZW5kZW50U2NhbGVNZWFuc0luZGVwZW5kZW50R3VpZGU7XG4gICAgbWVzc2FnZS5JTlZBSURfRE9NQUlOID0gJ0ludmFsaWQgc2NhbGUgZG9tYWluJztcbiAgICBtZXNzYWdlLlVOQUJMRV9UT19NRVJHRV9ET01BSU5TID0gJ1VuYWJsZSB0byBtZXJnZSBkb21haW5zJztcbiAgICAvLyBBWElTXG4gICAgbWVzc2FnZS5JTlZBTElEX0NIQU5ORUxfRk9SX0FYSVMgPSAnSW52YWxpZCBjaGFubmVsIGZvciBheGlzLic7XG4gICAgLy8gU1RBQ0tcbiAgICBmdW5jdGlvbiBjYW5ub3RTdGFja1JhbmdlZE1hcmsoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3Qgc3RhY2sgXCIgKyBjaGFubmVsICsgXCIgaWYgdGhlcmUgaXMgYWxyZWFkeSBcIiArIGNoYW5uZWwgKyBcIjJcIjtcbiAgICB9XG4gICAgbWVzc2FnZS5jYW5ub3RTdGFja1JhbmdlZE1hcmsgPSBjYW5ub3RTdGFja1JhbmdlZE1hcms7XG4gICAgZnVuY3Rpb24gY2Fubm90U3RhY2tOb25MaW5lYXJTY2FsZShzY2FsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHN0YWNrIG5vbi1saW5lYXIgc2NhbGUgKFwiICsgc2NhbGVUeXBlICsgXCIpXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuY2Fubm90U3RhY2tOb25MaW5lYXJTY2FsZSA9IGNhbm5vdFN0YWNrTm9uTGluZWFyU2NhbGU7XG4gICAgZnVuY3Rpb24gY2Fubm90U3RhY2tOb25TdW1tYXRpdmVBZ2dyZWdhdGUoYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBzdGFjayB3aGVuIHRoZSBhZ2dyZWdhdGUgZnVuY3Rpb24gaXMgbm9uLXN1bW1hdGl2ZSAoXCIgKyBhZ2dyZWdhdGUgKyBcIilcIjtcbiAgICB9XG4gICAgbWVzc2FnZS5jYW5ub3RTdGFja05vblN1bW1hdGl2ZUFnZ3JlZ2F0ZSA9IGNhbm5vdFN0YWNrTm9uU3VtbWF0aXZlQWdncmVnYXRlO1xuICAgIC8vIFRJTUVVTklUXG4gICAgZnVuY3Rpb24gaW52YWxpZFRpbWVVbml0KHVuaXROYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkIFwiICsgdW5pdE5hbWUgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgbWVzc2FnZS5pbnZhbGlkVGltZVVuaXQgPSBpbnZhbGlkVGltZVVuaXQ7XG4gICAgZnVuY3Rpb24gZGF5UmVwbGFjZWRXaXRoRGF0ZShmdWxsVGltZVVuaXQpIHtcbiAgICAgICAgcmV0dXJuIFwiVGltZSB1bml0IFxcXCJcIiArIGZ1bGxUaW1lVW5pdCArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkLiBXZSBhcmUgcmVwbGFjaW5nIGl0IHdpdGggXCIgKyBmdWxsVGltZVVuaXQucmVwbGFjZSgnZGF5JywgJ2RhdGUnKSArIFwiLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmRheVJlcGxhY2VkV2l0aERhdGUgPSBkYXlSZXBsYWNlZFdpdGhEYXRlO1xuICAgIGZ1bmN0aW9uIGRyb3BwZWREYXkoZCkge1xuICAgICAgICByZXR1cm4gXCJEcm9wcGluZyBkYXkgZnJvbSBkYXRldGltZSBcIiArIEpTT04uc3RyaW5naWZ5KGQpICsgXCIgYXMgZGF5IGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIHVuaXRzLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmRyb3BwZWREYXkgPSBkcm9wcGVkRGF5O1xufSkobWVzc2FnZSA9IGV4cG9ydHMubWVzc2FnZSB8fCAoZXhwb3J0cy5tZXNzYWdlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJHOW5MbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyeHZaeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNhVVJCUVdsRU96dEJRVVZxUkRzN1IwRkZSenRCUVVWSUxIVkRRVUYzUkR0QlFXRjRSRHM3UjBGRlJ6dEJRVU5JTEVsQlFVMHNTVUZCU1N4SFFVRkhMR3RDUVVGTkxFTkJRVU1zWjBKQlFVa3NRMEZCUXl4RFFVRkRPMEZCUXpGQ0xFbEJRVWtzVDBGQlR5eEhRVUZ2UWl4SlFVRkpMRU5CUVVNN1FVRkZjRU03TzBkQlJVYzdRVUZEU0R0SlFVRkJPMUZCUTFNc1ZVRkJTeXhIUVVGVkxFVkJRVVVzUTBGQlF6dFJRVU5zUWl4VlFVRkxMRWRCUVZVc1JVRkJSU3hEUVVGRE8xRkJRMnhDTEZkQlFVMHNSMEZCVlN4RlFVRkZMRU5CUVVNN1NVRnZRalZDTEVOQlFVTTdTVUZzUWxFc01rSkJRVXNzUjBGQldqdFJRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJSVTBzTUVKQlFVa3NSMEZCV0R0UlFVRlpMR05CUVdNN1lVRkJaQ3hWUVVGakxFVkJRV1FzY1VKQlFXTXNSVUZCWkN4SlFVRmpPMWxCUVdRc2VVSkJRV003TzFGQlEzaENMRU5CUVVFc1MwRkJRU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZCTEVOQlFVTXNTVUZCU1N4WFFVRkpMRWxCUVVrc1JVRkJSVHRSUVVONlFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPenRKUVVOa0xFTkJRVU03U1VGRlRTd3dRa0ZCU1N4SFFVRllPMUZCUVZrc1kwRkJZenRoUVVGa0xGVkJRV01zUlVGQlpDeHhRa0ZCWXl4RlFVRmtMRWxCUVdNN1dVRkJaQ3g1UWtGQll6czdVVUZEZUVJc1EwRkJRU3hMUVVGQkxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVRXNRMEZCUXl4SlFVRkpMRmRCUVVrc1NVRkJTU3hGUVVGRk8xRkJRM3BDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN08wbEJRMlFzUTBGQlF6dEpRVVZOTERKQ1FVRkxMRWRCUVZvN1VVRkJZU3hqUVVGak8yRkJRV1FzVlVGQll5eEZRVUZrTEhGQ1FVRmpMRVZCUVdRc1NVRkJZenRaUVVGa0xIbENRVUZqT3p0UlFVTjZRaXhEUVVGQkxFdEJRVUVzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUVN4RFFVRkRMRWxCUVVrc1YwRkJTU3hKUVVGSkxFVkJRVVU3VVVGRE1VSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenM3U1VGRFpDeERRVUZETzBsQlEwZ3NhMEpCUVVNN1FVRkJSQ3hEUVVGRExFRkJka0pFTEVsQmRVSkRPMEZCZGtKWkxHdERRVUZYTzBGQmVVSjRRaXgzUWtGQkswSXNRMEZCY1VNN1NVRkRiRVVzU1VGQlRTeFhRVUZYTEVkQlFVY3NUMEZCVHl4SFFVRkhMRWxCUVVrc1YwRkJWeXhGUVVGRkxFTkJRVU03U1VGRGFFUXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8wbEJRMllzUzBGQlN5eEZRVUZGTEVOQlFVTTdRVUZEVml4RFFVRkRPMEZCU2tRc2QwTkJTVU03UVVGRlJDeGpRVUZ4UWl4RFFVRm5RenRKUVVOdVJDeE5RVUZOTEVOQlFVTTdVVUZEVEN4SlFVRk5MRTFCUVUwc1IwRkJSeXhQUVVGUExFZEJRVWNzU1VGQlNTeFhRVUZYTEVWQlFVVXNRMEZCUXp0UlFVTXpReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEVml4TFFVRkxMRVZCUVVVc1EwRkJRenRKUVVOV0xFTkJRVU1zUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZPUkN4dlFrRk5RenRCUVVWRU96dEhRVVZITzBGQlEwZ3NZVUZCYjBJc1RVRkJkVUk3U1VGRGVrTXNUMEZCVHl4SFFVRkhMRTFCUVUwc1EwRkJRenRKUVVOcVFpeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMEZCUTJwQ0xFTkJRVU03UVVGSVJDeHJRa0ZIUXp0QlFVVkVPenRIUVVWSE8wRkJRMGc3U1VGRFJTeFBRVUZQTEVkQlFVY3NTVUZCU1N4RFFVRkRPMGxCUTJZc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dEJRVU5xUWl4RFFVRkRPMEZCU0VRc2MwSkJSME03UVVGRlJEdEpRVUZ4UWl4WFFVRlhPMU5CUVZnc1ZVRkJWeXhGUVVGWUxIRkNRVUZYTEVWQlFWZ3NTVUZCVnp0UlFVRllMSE5DUVVGWE96dEpRVU01UWl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1FVRkRla01zUTBGQlF6dEJRVVpFTEc5Q1FVVkRPMEZCUlVRN1NVRkJjVUlzVjBGQlZ6dFRRVUZZTEZWQlFWY3NSVUZCV0N4eFFrRkJWeXhGUVVGWUxFbEJRVmM3VVVGQldDeHpRa0ZCVnpzN1NVRkRPVUlzVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzBGQlEzcERMRU5CUVVNN1FVRkdSQ3h2UWtGRlF6dEJRVVZFTzBsQlFYTkNMRmRCUVZjN1UwRkJXQ3hWUVVGWExFVkJRVmdzY1VKQlFWY3NSVUZCV0N4SlFVRlhPMUZCUVZnc2MwSkJRVmM3TzBsQlF5OUNMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRCUVVNeFF5eERRVUZETzBGQlJrUXNjMEpCUlVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEVsQlFXbENMRTlCUVU4c1EwRnRTblpDTzBGQmJrcEVMRmRCUVdsQ0xFOUJRVTg3U1VGRFZDeHZRa0ZCV1N4SFFVRkhMR05CUVdNc1EwRkJRenRKUVVVelF5eFRRVUZUTzBsQlExUXNOa0pCUVc5RExFdEJRV0U3VVVGREwwTXNUVUZCVFN4RFFVRkRMRGhDUVVFeVFpeExRVUZMTEZGQlFVa3NRMEZCUXp0SlFVTTVReXhEUVVGRE8wbEJSbVVzTWtKQlFXMUNMSE5DUVVWc1F5eERRVUZCTzBsQlJVUXNUMEZCVHp0SlFVTlFMREpDUVVGclF5eERRVUZUTzFGQlEzcERMRTFCUVUwc1EwRkJReXgzUWtGQmMwSXNRMEZCUXl4TlFVRkhMRU5CUVVNN1NVRkRjRU1zUTBGQlF6dEpRVVpsTEhsQ1FVRnBRaXh2UWtGRmFFTXNRMEZCUVR0SlFVVkVMR0ZCUVdFN1NVRkRZaXhwUTBGQmQwTXNVMEZCWXp0UlFVTndSQ3hOUVVGTkxFTkJRVU1zYjBOQlFXdERMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVY3NRMEZCUXp0SlFVTjRSU3hEUVVGRE8wbEJSbVVzSzBKQlFYVkNMREJDUVVWMFF5eERRVUZCTzBsQlJVUXNiVUpCUVcxQ08wbEJRMjVDTERCQ1FVRnBReXhKUVVGVk8xRkJRM3BETEUxQlFVMHNRMEZCUXl3d1FrRkJkVUlzU1VGQlNTeFBRVUZITEVOQlFVTTdTVUZEZUVNc1EwRkJRenRKUVVabExIZENRVUZuUWl4dFFrRkZMMElzUTBGQlFUdEpRVU5FTERCQ1FVRnBReXhUUVVFclFqdFJRVU01UkN4TlFVRk5MRU5CUVVNc2IwTkJRV2xETEZOQlFWTXNUMEZCUnl4RFFVRkRPMGxCUTNaRUxFTkJRVU03U1VGR1pTeDNRa0ZCWjBJc2JVSkJSUzlDTEVOQlFVRTdTVUZGUkN4cFEwRkJkME1zU1VGQmJVSXNSVUZCUlN4UFFVRm5RaXhGUVVGRkxFOUJRV0U3VVVGRE1VWXNUVUZCVFN4RFFVRkRMSGxDUVVGMVFpeEpRVUZKTEhOQ1FVRnBRaXhQUVVGUExHZENRVUZYTEU5QlFVOHNZMEZCVnl4RFFVRkRPMGxCUXpGR0xFTkJRVU03U1VGR1pTd3JRa0ZCZFVJc01FSkJSWFJETEVOQlFVRTdTVUZGUkN4MVFrRkJPRUlzVVVGQk1FSXNSVUZCUlN4UFFVRm5RanRSUVVONFJTeE5RVUZOTEVOQlFVTXNZMEZCV1N4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eHpRa0ZCYVVJc1QwRkJUeXh2UkVGQmFVUXNRMEZCUXp0SlFVTjJTQ3hEUVVGRE8wbEJSbVVzY1VKQlFXRXNaMEpCUlRWQ0xFTkJRVUU3U1VGRlJDdzJRa0ZCYjBNc1QwRkJaMElzUlVGQlJTeFhRVUV5UWl4RlFVRkZMRWxCUVdFN1VVRkRPVVlzVFVGQlRTeERRVUZKTEU5QlFVOHNORU5CUVhWRExGZEJRVmNzU1VGQlJ5eEpRVUZKTEVkQlFVY3NWMEZCVXl4SlFVRk5MRWRCUVVjc1JVRkJSU3hQUVVGSExFTkJRVU03U1VGRGRrY3NRMEZCUXp0SlFVWmxMREpDUVVGdFFpeHpRa0ZGYkVNc1EwRkJRVHRKUVVWRUxITkRRVUUyUXl4UFFVRmxPMUZCUXpGRUxFMUJRVTBzUTBGQlNTeFBRVUZQTEN0RVFVRTBSQ3hEUVVGRE8wbEJRMmhHTEVOQlFVTTdTVUZHWlN4dlEwRkJORUlzSzBKQlJUTkRMRU5CUVVFN1NVRkZSQ3h4UTBGQk5FTXNUMEZCWjBJc1JVRkJSU3hKUVVGVk8xRkJRM1JGTEUxQlFVMHNRMEZCUXl3MFFrRkJNRUlzVDBGQlR5eHRRa0ZCWXl4SlFVRkpMSGRFUVVGclJDeEpRVUZKTEV0QlFVc3NVMEZCVXl4SFFVRkhMRTlCUVU4c1IwRkJSeXhYUVVGWExFOUJRVWNzUTBGQlF6dEpRVU0xU2l4RFFVRkRPMGxCUm1Vc2JVTkJRVEpDTERoQ1FVVXhReXhEUVVGQk8wbEJSVVFzVDBGQlR6dEpRVU5OTEN0RFFVRjFReXhIUVVGSExIRkhRVUZ4Unl4RFFVRkRPMGxCUlRkS0xHbERRVUYzUXl4SlFVRlZPMUZCUTJoRUxFMUJRVTBzUTBGQlF5dzRRMEZCTkVNc1NVRkJTU3hyUjBGQkswWXNRMEZCUXp0SlFVTjZTaXhEUVVGRE8wbEJSbVVzSzBKQlFYVkNMREJDUVVWMFF5eERRVUZCTzBsQlJVUXNjME5CUVRaRExFbEJRVlU3VVVGRGNrUXNUVUZCVFN4RFFVRkRMRGhEUVVFMFF5eEpRVUZKTEdsRlFVRTRSQ3hEUVVGRE8wbEJRM2hJTEVOQlFVTTdTVUZHWlN4dlEwRkJORUlzSzBKQlJUTkRMRU5CUVVFN1NVRkZSQ3d3UWtGQmFVTXNVVUZCWjBJc1JVRkJSU3hOUVVGak8xRkJReTlFTEUxQlFVMHNRMEZCUXl4elFrRkJiMElzVVVGQlVTeDVRa0ZCYjBJc1RVRkJVU3hEUVVGRE8wbEJRMnhGTEVOQlFVTTdTVUZHWlN4M1FrRkJaMElzYlVKQlJTOUNMRU5CUVVFN1NVRkZSQ3hSUVVGUk8wbEJRMHNzYjBSQlFUUkRMRWRCUVVjc2RVVkJRWFZGTEVOQlFVTTdTVUZGY0Vrc05FTkJRVzFFTEVsQlFWazdVVUZETjBRc1RVRkJUU3hEUVVGRExHZENRVUZqTEVsQlFVa3NOa0pCUVRCQ0xFTkJRVU03U1VGRGRFUXNRMEZCUXp0SlFVWmxMREJEUVVGclF5eHhRMEZGYWtRc1EwRkJRVHRKUVVWRUxHbEVRVUYzUkN4UlFVRXdRanRSUVVOb1JpeE5RVUZOTEVOQlFVTXNOa1JCUVRKRUxFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVVrc1EwRkJRenRKUVVOcVJ5eERRVUZETzBsQlJtVXNLME5CUVhWRExEQkRRVVYwUkN4RFFVRkJPMGxCUlVRc1owUkJRWFZFTEZOQlFXbENPMUZCUTNSRkxFMUJRVTBzUTBGQlF5dzBRMEZCTUVNc1UwRkJVeXcwUlVGQmVVVXNRMEZCUXp0SlFVTjBTU3hEUVVGRE8wbEJSbVVzT0VOQlFYTkRMSGxEUVVWeVJDeERRVUZCTzBsQlJVUXNkME5CUVN0RExGRkJRVEJDTzFGQlEzWkZMRTFCUVUwc1EwRkJReXhwUlVGQkswUXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlNTeERRVUZETzBsQlEzSkhMRU5CUVVNN1NVRkdaU3h6UTBGQk9FSXNhVU5CUlRkRExFTkJRVUU3U1VGRldTeHpRMEZCT0VJc1IwRkRla01zT0VkQlFUaEhMRU5CUVVNN1NVRkZjRWNzY1VOQlFUWkNMRWRCUVVjc2MwVkJRWE5GTEVOQlFVTTdTVUZGY0Vnc2VVTkJRV2RFTEZGQlFXZENPMUZCUXpsRUxFMUJRVTBzUTBGQlF5eDFRa0ZCY1VJc1VVRkJVU3dyUlVGQk5FVXNRMEZCUXp0SlFVTnVTQ3hEUVVGRE8wbEJSbVVzZFVOQlFTdENMR3REUVVVNVF5eERRVUZCTzBsQlJVUXNNRUpCUVdsRExFOUJRV2RDTzFGQlF5OURMRTFCUVUwc1EwRkJReXh0UWtGQmFVSXNUMEZCVHl4clEwRkROMElzVDBGQlR5eExRVUZMTEVkQlFVY3NSMEZCUnl4UFFVRlBMRWRCUVVjc1VVRkJVU3h0UWtGQlpTeERRVUZETzBsQlEzaEVMRU5CUVVNN1NVRklaU3gzUWtGQlowSXNiVUpCUnk5Q0xFTkJRVUU3U1VGRlJDeHhRMEZCTkVNc1QwRkJaMElzUlVGQlJTeFRRVUZ2UWl4RlFVRkZMR2RDUVVFeVFqdFJRVU0zUnl4TlFVRk5MRU5CUVVNc1lVRkJWeXhQUVVGUExEUkNRVUYxUWl4VFFVRlRMRFpDUVVGM1FpeG5Ra0ZCWjBJc2IwSkJRV2xDTEVOQlFVTTdTVUZEY2tnc1EwRkJRenRKUVVabExHMURRVUV5UWl3NFFrRkZNVU1zUTBGQlFUdEpRVVZFTEhORFFVRTJReXhUUVVGdlFpeEZRVUZGTEdkQ1FVRXlRanRSUVVNMVJpeE5RVUZOTEVOQlFVTXNhVU5CUVN0Q0xGTkJRVk1zTmtKQlFYZENMR2RDUVVGblFpeHZRa0ZCYVVJc1EwRkJRenRKUVVNelJ5eERRVUZETzBsQlJtVXNiME5CUVRSQ0xDdENRVVV6UXl4RFFVRkJPMGxCUlVRc01rTkJRV3RFTEZOQlFXOUNMRVZCUVVVc1VVRkJaMElzUlVGQlJTeFBRVUZuUWp0UlFVTjRSeXhOUVVGTkxFTkJRVWtzVDBGQlR5eHRRa0ZCWVN4UlFVRlJMQ3REUVVGNVF5eFRRVUZUTEZsQlFWTXNRMEZCUXp0SlFVTndSeXhEUVVGRE8wbEJSbVVzZVVOQlFXbERMRzlEUVVWb1JDeERRVUZCTzBsQlJVUXNhME5CUVhsRExFbEJRVlVzUlVGQlJTeFRRVUZ2UWp0UlFVTjJSU3hOUVVGTkxFTkJRVU1zYTBKQlFXVXNVMEZCVXl4dFEwRkJOa0lzU1VGQlNTeE5RVUZITEVOQlFVTTdTVUZEZEVVc1EwRkJRenRKUVVabExHZERRVUYzUWl3eVFrRkZka01zUTBGQlFUdEpRVVZFTEN0RFFVRnpSQ3hQUVVGblFqdFJRVU53UlN4TlFVRk5MRU5CUVVNc05rTkJRVEpETEU5QlFVOHNOa1ZCUVRCRkxFTkJRVU03U1VGRGRFa3NRMEZCUXp0SlFVWmxMRFpEUVVGeFF5eDNRMEZGY0VRc1EwRkJRVHRKUVVWWkxIRkNRVUZoTEVkQlFVY3NjMEpCUVhOQ0xFTkJRVU03U1VGRmRrTXNLMEpCUVhWQ0xFZEJRVWNzZVVKQlFYbENMRU5CUVVNN1NVRkZha1VzVDBGQlR6dEpRVU5OTEdkRFFVRjNRaXhIUVVGSExESkNRVUV5UWl4RFFVRkRPMGxCUlhCRkxGRkJRVkU3U1VGRFVpd3JRa0ZCYzBNc1QwRkJaMEk3VVVGRGNFUXNUVUZCVFN4RFFVRkRMR3RDUVVGblFpeFBRVUZQTERaQ1FVRjNRaXhQUVVGUExFMUJRVWNzUTBGQlF6dEpRVU51UlN4RFFVRkRPMGxCUm1Vc05rSkJRWEZDTEhkQ1FVVndReXhEUVVGQk8wbEJSVVFzYlVOQlFUQkRMRk5CUVc5Q08xRkJRelZFTEUxQlFVMHNRMEZCUXl4dlEwRkJhME1zVTBGQlV5eE5RVUZITEVOQlFVTTdTVUZEZUVRc1EwRkJRenRKUVVabExHbERRVUY1UWl3MFFrRkZlRU1zUTBGQlFUdEpRVVZFTERCRFFVRnBSQ3hUUVVGcFFqdFJRVU5vUlN4TlFVRk5MRU5CUVVNc1owVkJRVGhFTEZOQlFWTXNUVUZCUnl4RFFVRkRPMGxCUTNCR0xFTkJRVU03U1VGR1pTeDNRMEZCWjBNc2JVTkJSUzlETEVOQlFVRTdTVUZGUkN4WFFVRlhPMGxCUTFnc2VVSkJRV2RETEZGQlFXZENMRVZCUVVVc1MwRkJjMEk3VVVGRGRFVXNUVUZCVFN4RFFVRkRMR0ZCUVZjc1VVRkJVU3hWUVVGTExFdEJRVThzUTBGQlF6dEpRVU42UXl4RFFVRkRPMGxCUm1Vc2RVSkJRV1VzYTBKQlJUbENMRU5CUVVFN1NVRkZSQ3cyUWtGQmIwTXNXVUZCYzBJN1VVRkRlRVFzVFVGQlRTeERRVUZETEdsQ1FVRmpMRmxCUVZrc2MwUkJReTlDTEZsQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eE5RVUZITEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVobExESkNRVUZ0UWl4elFrRkhiRU1zUTBGQlFUdEpRVVZFTEc5Q1FVRXlRaXhEUVVFd1FqdFJRVU51UkN4TlFVRk5MRU5CUVVNc1owTkJRVGhDTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExHbEVRVUU0UXl4RFFVRkRPMGxCUTNaSExFTkJRVU03U1VGR1pTeHJRa0ZCVlN4aFFVVjZRaXhEUVVGQk8wRkJRMGdzUTBGQlF5eEZRVzVLWjBJc1QwRkJUeXhIUVVGUUxHVkJRVThzUzBGQlVDeGxRVUZQTEZGQmJVcDJRaUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBNYXJrO1xuKGZ1bmN0aW9uIChNYXJrKSB7XG4gICAgTWFyay5BUkVBID0gJ2FyZWEnO1xuICAgIE1hcmsuQkFSID0gJ2Jhcic7XG4gICAgTWFyay5MSU5FID0gJ2xpbmUnO1xuICAgIE1hcmsuUE9JTlQgPSAncG9pbnQnO1xuICAgIE1hcmsuUkVDVCA9ICdyZWN0JztcbiAgICBNYXJrLlJVTEUgPSAncnVsZSc7XG4gICAgTWFyay5URVhUID0gJ3RleHQnO1xuICAgIE1hcmsuVElDSyA9ICd0aWNrJztcbiAgICBNYXJrLkNJUkNMRSA9ICdjaXJjbGUnO1xuICAgIE1hcmsuU1FVQVJFID0gJ3NxdWFyZSc7XG59KShNYXJrID0gZXhwb3J0cy5NYXJrIHx8IChleHBvcnRzLk1hcmsgPSB7fSkpO1xuZXhwb3J0cy5BUkVBID0gTWFyay5BUkVBO1xuZXhwb3J0cy5CQVIgPSBNYXJrLkJBUjtcbmV4cG9ydHMuTElORSA9IE1hcmsuTElORTtcbmV4cG9ydHMuUE9JTlQgPSBNYXJrLlBPSU5UO1xuZXhwb3J0cy5URVhUID0gTWFyay5URVhUO1xuZXhwb3J0cy5USUNLID0gTWFyay5USUNLO1xuZXhwb3J0cy5SRUNUID0gTWFyay5SRUNUO1xuZXhwb3J0cy5SVUxFID0gTWFyay5SVUxFO1xuZXhwb3J0cy5DSVJDTEUgPSBNYXJrLkNJUkNMRTtcbmV4cG9ydHMuU1FVQVJFID0gTWFyay5TUVVBUkU7XG5leHBvcnRzLlBSSU1JVElWRV9NQVJLUyA9IFtleHBvcnRzLkFSRUEsIGV4cG9ydHMuQkFSLCBleHBvcnRzLkxJTkUsIGV4cG9ydHMuUE9JTlQsIGV4cG9ydHMuVEVYVCwgZXhwb3J0cy5USUNLLCBleHBvcnRzLlJFQ1QsIGV4cG9ydHMuUlVMRSwgZXhwb3J0cy5DSVJDTEUsIGV4cG9ydHMuU1FVQVJFXTtcbmZ1bmN0aW9uIGlzTWFya0RlZihtYXJrKSB7XG4gICAgcmV0dXJuIG1hcmtbJ3R5cGUnXTtcbn1cbmV4cG9ydHMuaXNNYXJrRGVmID0gaXNNYXJrRGVmO1xudmFyIFBSSU1JVElWRV9NQVJLX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuUFJJTUlUSVZFX01BUktTKTtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlTWFyayhtYXJrKSB7XG4gICAgdmFyIG1hcmtUeXBlID0gaXNNYXJrRGVmKG1hcmspID8gbWFyay50eXBlIDogbWFyaztcbiAgICByZXR1cm4gbWFya1R5cGUgaW4gUFJJTUlUSVZFX01BUktfSU5ERVg7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlTWFyayA9IGlzUHJpbWl0aXZlTWFyaztcbmV4cG9ydHMuU1RST0tFX0NPTkZJRyA9IFsnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJyxcbiAgICAnc3Ryb2tlRGFzaCcsICdzdHJva2VEYXNoT2Zmc2V0JywgJ3N0cm9rZU9wYWNpdHknXTtcbmV4cG9ydHMuRklMTF9DT05GSUcgPSBbJ2ZpbGwnLCAnZmlsbE9wYWNpdHknXTtcbmV4cG9ydHMuRklMTF9TVFJPS0VfQ09ORklHID0gW10uY29uY2F0KGV4cG9ydHMuU1RST0tFX0NPTkZJRywgZXhwb3J0cy5GSUxMX0NPTkZJRyk7XG5leHBvcnRzLmRlZmF1bHRNYXJrQ29uZmlnID0ge1xuICAgIGNvbG9yOiAnIzRjNzhhOCcsXG59O1xuZXhwb3J0cy5kZWZhdWx0QmFyQ29uZmlnID0ge1xuICAgIGJpblNwYWNpbmc6IDEsXG4gICAgY29udGludW91c0JhbmRTaXplOiAyXG59O1xuZXhwb3J0cy5kZWZhdWx0VGV4dENvbmZpZyA9IHtcbiAgICBiYXNlbGluZTogJ21pZGRsZScsXG59O1xuZXhwb3J0cy5kZWZhdWx0VGlja0NvbmZpZyA9IHtcbiAgICB0aGlja25lc3M6IDFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liV0Z5YXk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl0WVhKckxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFc0swSkJRVFpDTzBGQlNUZENMRWxCUVdsQ0xFbEJRVWtzUTBGWGNFSTdRVUZZUkN4WFFVRnBRaXhKUVVGSk8wbEJRMDRzVTBGQlNTeEhRVUZYTEUxQlFVMHNRMEZCUXp0SlFVTjBRaXhSUVVGSExFZEJRVlVzUzBGQlN5eERRVUZETzBsQlEyNUNMRk5CUVVrc1IwRkJWeXhOUVVGTkxFTkJRVU03U1VGRGRFSXNWVUZCU3l4SFFVRlpMRTlCUVU4c1EwRkJRenRKUVVONlFpeFRRVUZKTEVkQlFWY3NUVUZCVFN4RFFVRkRPMGxCUTNSQ0xGTkJRVWtzUjBGQlZ5eE5RVUZOTEVOQlFVTTdTVUZEZEVJc1UwRkJTU3hIUVVGWExFMUJRVTBzUTBGQlF6dEpRVU4wUWl4VFFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wbEJRM1JDTEZkQlFVMHNSMEZCWVN4UlFVRlJMRU5CUVVNN1NVRkROVUlzVjBGQlRTeEhRVUZoTEZGQlFWRXNRMEZCUXp0QlFVTXpReXhEUVVGRExFVkJXR2RDTEVsQlFVa3NSMEZCU2l4WlFVRkpMRXRCUVVvc1dVRkJTU3hSUVZkd1FqdEJRVkZaTEZGQlFVRXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRGFrSXNVVUZCUVN4SFFVRkhMRWRCUVVjc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF6dEJRVU5tTEZGQlFVRXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRGFrSXNVVUZCUVN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU51UWl4UlFVRkJMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlEycENMRkZCUVVFc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEYWtJc1VVRkJRU3hKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTnFRaXhSUVVGQkxFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUldwQ0xGRkJRVUVzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1FVRkRja0lzVVVGQlFTeE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRCUVVWeVFpeFJRVUZCTEdWQlFXVXNSMEZCUnl4RFFVRkRMRmxCUVVrc1JVRkJSU3hYUVVGSExFVkJRVVVzV1VGQlNTeEZRVUZGTEdGQlFVc3NSVUZCUlN4WlFVRkpMRVZCUVVVc1dVRkJTU3hGUVVGRkxGbEJRVWtzUlVGQlJTeFpRVUZKTEVWQlFVVXNZMEZCVFN4RlFVRkZMR05CUVUwc1EwRkJReXhEUVVGRE8wRkJORVJvUnl4dFFrRkJNRUlzU1VGQmMwSTdTVUZET1VNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0QlFVTjBRaXhEUVVGRE8wRkJSa1FzT0VKQlJVTTdRVUZGUkN4SlFVRk5MRzlDUVVGdlFpeEhRVUZITEZsQlFVc3NRMEZCUXl4MVFrRkJaU3hEUVVGRExFTkJRVU03UVVGRmNFUXNlVUpCUVdkRExFbEJRWE5DTzBsQlEzQkVMRWxCUVUwc1VVRkJVU3hIUVVGSExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dEpRVU53UkN4TlFVRk5MRU5CUVVNc1VVRkJVU3hKUVVGSkxHOUNRVUZ2UWl4RFFVRkRPMEZCUXpGRExFTkJRVU03UVVGSVJDd3dRMEZIUXp0QlFVVlpMRkZCUVVFc1lVRkJZU3hIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEdGQlFXRTdTVUZEYmtRc1dVRkJXU3hGUVVGRkxHdENRVUZyUWl4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8wRkJSWGhETEZGQlFVRXNWMEZCVnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hGUVVGRkxHRkJRV0VzUTBGQlF5eERRVUZETzBGQlJYUkRMRkZCUVVFc2EwSkJRV3RDTEVkQlFVY3NSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXh4UWtGQllTeEZRVUZGTEcxQ1FVRlhMRU5CUVVNc1EwRkJRenRCUVhkQ00wUXNVVUZCUVN4cFFrRkJhVUlzUjBGQlpUdEpRVU16UXl4TFFVRkxMRVZCUVVVc1UwRkJVenREUVVOcVFpeERRVUZETzBGQk5FSlhMRkZCUVVFc1owSkJRV2RDTEVkQlFXTTdTVUZEZWtNc1ZVRkJWU3hGUVVGRkxFTkJRVU03U1VGRFlpeHJRa0ZCYTBJc1JVRkJSU3hEUVVGRE8wTkJRM1JDTEVOQlFVTTdRVUZUVnl4UlFVRkJMR2xDUVVGcFFpeEhRVUZsTzBsQlF6TkRMRkZCUVZFc1JVRkJSU3hSUVVGUk8wTkJRMjVDTEVOQlFVTTdRVUZ2UWxjc1VVRkJRU3hwUWtGQmFVSXNSMEZCWlR0SlFVTXpReXhUUVVGVExFVkJRVVVzUTBGQlF6dERRVU5pTEVOQlFVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGluaXRMYXllclJlc29sdmUocmVzb2x2ZSkge1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICBjaGFubmVsXzEuVU5JVF9TQ0FMRV9DSEFOTkVMUy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciByZXMgPSByZXNvbHZlW2NoYW5uZWxdIHx8IHsgc2NhbGU6ICdzaGFyZWQnIH07XG4gICAgICAgIHZhciBndWlkZSA9IHV0aWxfMS5jb250YWlucyhjaGFubmVsXzEuU1BBVElBTF9TQ0FMRV9DSEFOTkVMUywgY2hhbm5lbCkgPyAnYXhpcycgOiAnbGVnZW5kJztcbiAgICAgICAgaWYgKHJlcy5zY2FsZSA9PT0gJ2luZGVwZW5kZW50JyAmJiAocmVzWydheGlzJ10gPT09ICdzaGFyZWQnIHx8IHJlc1snbGVnZW5kJ10gPT09ICdzaGFyZWQnKSkge1xuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuaW5kZXBlbmRlbnRTY2FsZU1lYW5zSW5kZXBlbmRlbnRHdWlkZShjaGFubmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0W2NoYW5uZWxdID0gKF9hID0ge1xuICAgICAgICAgICAgICAgIHNjYWxlOiByZXMuc2NhbGUgfHwgJ3NoYXJlZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYVtndWlkZV0gPSByZXMuc2NhbGUgPT09ICdpbmRlcGVuZGVudCcgPyAnaW5kZXBlbmRlbnQnIDogKHJlc1tndWlkZV0gfHwgJ3NoYXJlZCcpLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuaW5pdExheWVyUmVzb2x2ZSA9IGluaXRMYXllclJlc29sdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljbVZ6YjJ4MlpTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5eVpYTnZiSFpsTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzY1VOQlFXMUpPMEZCUTI1SkxESkNRVUUyUWp0QlFVTTNRaXdyUWtGQlowTTdRVUUwUW1oRExEQkNRVUZwUXl4UFFVRjFRanRKUVVOMFJDeEpRVUZOTEVkQlFVY3NSMEZCYlVJc1JVRkJSU3hEUVVGRE8wbEJReTlDTERaQ1FVRnRRaXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEU5QlFVODdVVUZEYWtNc1NVRkJUU3hIUVVGSExFZEJRVmtzVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlF5eERRVUZETzFGQlF6TkVMRWxCUVUwc1MwRkJTeXhIUVVGSExHVkJRVkVzUTBGQlF5eG5RMEZCYzBJc1JVRkJSU3hQUVVGUExFTkJRVU1zUjBGQlJ5eE5RVUZOTEVkQlFVY3NVVUZCVVN4RFFVRkRPMUZCUlRWRkxFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRXRCUVVzc1lVRkJZU3hKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRkZCUVZFc1NVRkJTU3hIUVVGSExFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZHTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eHhRMEZCY1VNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzWkZMRU5CUVVNN1VVRkZSQ3hIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETzJkQ1FVTldMRXRCUVVzc1JVRkJSU3hIUVVGSExFTkJRVU1zUzBGQlN5eEpRVUZKTEZGQlFWRTdPMWxCUXpWQ0xFZEJRVU1zUzBGQlN5eEpRVUZITEVkQlFVY3NRMEZCUXl4TFFVRkxMRXRCUVVzc1lVRkJZU3hIUVVGSExHRkJRV0VzUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hSUVVGUkxFTkJRVU03WlVGRGFFWXNRMEZCUXpzN1NVRkRTaXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZJTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNN1FVRkRZaXhEUVVGRE8wRkJha0pFTERSRFFXbENReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgU2NhbGVUeXBlO1xuKGZ1bmN0aW9uIChTY2FsZVR5cGUpIHtcbiAgICAvLyBDb250aW51b3VzIC0gUXVhbnRpdGF0aXZlXG4gICAgU2NhbGVUeXBlLkxJTkVBUiA9ICdsaW5lYXInO1xuICAgIFNjYWxlVHlwZS5CSU5fTElORUFSID0gJ2Jpbi1saW5lYXInO1xuICAgIFNjYWxlVHlwZS5MT0cgPSAnbG9nJztcbiAgICBTY2FsZVR5cGUuUE9XID0gJ3Bvdyc7XG4gICAgU2NhbGVUeXBlLlNRUlQgPSAnc3FydCc7XG4gICAgLy8gQ29udGludW91cyAtIFRpbWVcbiAgICBTY2FsZVR5cGUuVElNRSA9ICd0aW1lJztcbiAgICBTY2FsZVR5cGUuVVRDID0gJ3V0Yyc7XG4gICAgLy8gc2VxdWVudGlhbFxuICAgIFNjYWxlVHlwZS5TRVFVRU5USUFMID0gJ3NlcXVlbnRpYWwnO1xuICAgIC8vIFF1YW50aWxlLCBRdWFudGl6ZSwgdGhyZXNob2xkXG4gICAgU2NhbGVUeXBlLlFVQU5USUxFID0gJ3F1YW50aWxlJztcbiAgICBTY2FsZVR5cGUuUVVBTlRJWkUgPSAncXVhbnRpemUnO1xuICAgIFNjYWxlVHlwZS5USFJFU0hPTEQgPSAndGhyZXNob2xkJztcbiAgICBTY2FsZVR5cGUuT1JESU5BTCA9ICdvcmRpbmFsJztcbiAgICBTY2FsZVR5cGUuQklOX09SRElOQUwgPSAnYmluLW9yZGluYWwnO1xuICAgIFNjYWxlVHlwZS5QT0lOVCA9ICdwb2ludCc7XG4gICAgU2NhbGVUeXBlLkJBTkQgPSAnYmFuZCc7XG59KShTY2FsZVR5cGUgPSBleHBvcnRzLlNjYWxlVHlwZSB8fCAoZXhwb3J0cy5TY2FsZVR5cGUgPSB7fSkpO1xuZXhwb3J0cy5TQ0FMRV9UWVBFUyA9IFtcbiAgICAvLyBDb250aW51b3VzIC0gUXVhbnRpdGF0aXZlXG4gICAgJ2xpbmVhcicsICdiaW4tbGluZWFyJywgJ2xvZycsICdwb3cnLCAnc3FydCcsXG4gICAgLy8gQ29udGludW91cyAtIFRpbWVcbiAgICAndGltZScsICd1dGMnLFxuICAgIC8vIFNlcXVlbnRpYWxcbiAgICAnc2VxdWVudGlhbCcsXG4gICAgLy8gRGlzY3JldGVcbiAgICAnb3JkaW5hbCcsICdiaW4tb3JkaW5hbCcsICdwb2ludCcsICdiYW5kJyxcbl07XG5leHBvcnRzLkNPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMgPSBbJ2xpbmVhcicsICdiaW4tbGluZWFyJywgJ2xvZycsICdwb3cnLCAnc3FydCcsICd0aW1lJywgJ3V0YyddO1xudmFyIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19JTkRFWCA9IHV0aWxfMS50b1NldChleHBvcnRzLkNPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpO1xuZXhwb3J0cy5DT05USU5VT1VTX0RPTUFJTl9TQ0FMRVMgPSBleHBvcnRzLkNPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMuY29uY2F0KFsnc2VxdWVudGlhbCcgLyogVE9ETyBhZGQgJ3F1YW50aWxlJywgJ3F1YW50aXplJywgJ3RocmVzaG9sZCcqL10pO1xudmFyIENPTlRJTlVPVVNfRE9NQUlOX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuQ09OVElOVU9VU19ET01BSU5fU0NBTEVTKTtcbmV4cG9ydHMuRElTQ1JFVEVfRE9NQUlOX1NDQUxFUyA9IFsnb3JkaW5hbCcsICdiaW4tb3JkaW5hbCcsICdwb2ludCcsICdiYW5kJ107XG52YXIgRElTQ1JFVEVfRE9NQUlOX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuRElTQ1JFVEVfRE9NQUlOX1NDQUxFUyk7XG52YXIgQklOX1NDQUxFU19JTkRFWCA9IHV0aWxfMS50b1NldChbJ2Jpbi1saW5lYXInLCAnYmluLW9yZGluYWwnXSk7XG5leHBvcnRzLlRJTUVfU0NBTEVfVFlQRVMgPSBbJ3RpbWUnLCAndXRjJ107XG5mdW5jdGlvbiBoYXNEaXNjcmV0ZURvbWFpbih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgaW4gRElTQ1JFVEVfRE9NQUlOX0lOREVYO1xufVxuZXhwb3J0cy5oYXNEaXNjcmV0ZURvbWFpbiA9IGhhc0Rpc2NyZXRlRG9tYWluO1xuZnVuY3Rpb24gaXNCaW5TY2FsZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgaW4gQklOX1NDQUxFU19JTkRFWDtcbn1cbmV4cG9ydHMuaXNCaW5TY2FsZSA9IGlzQmluU2NhbGU7XG5mdW5jdGlvbiBoYXNDb250aW51b3VzRG9tYWluKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSBpbiBDT05USU5VT1VTX0RPTUFJTl9JTkRFWDtcbn1cbmV4cG9ydHMuaGFzQ29udGludW91c0RvbWFpbiA9IGhhc0NvbnRpbnVvdXNEb21haW47XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXNUb0NvbnRpbnVvdXModHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19JTkRFWDtcbn1cbmV4cG9ydHMuaXNDb250aW51b3VzVG9Db250aW51b3VzID0gaXNDb250aW51b3VzVG9Db250aW51b3VzO1xuZXhwb3J0cy5kZWZhdWx0U2NhbGVDb25maWcgPSB7XG4gICAgcm91bmQ6IHRydWUsXG4gICAgdGV4dFhSYW5nZVN0ZXA6IDkwLFxuICAgIHJhbmdlU3RlcDogMjEsXG4gICAgcG9pbnRQYWRkaW5nOiAwLjUsXG4gICAgYmFuZFBhZGRpbmdJbm5lcjogMC4xLFxuICAgIGZhY2V0U3BhY2luZzogMTYsXG4gICAgbWluRm9udFNpemU6IDgsXG4gICAgbWF4Rm9udFNpemU6IDQwLFxuICAgIG1pbk9wYWNpdHk6IDAuMyxcbiAgICBtYXhPcGFjaXR5OiAwLjgsXG4gICAgLy8gRklYTUU6IHJldmlzZSBpZiB0aGVzZSAqY2FuKiBiZWNvbWUgcmF0aW9zIG9mIHJhbmdlU3RlcFxuICAgIG1pblNpemU6IDksXG4gICAgbWluU3Ryb2tlV2lkdGg6IDEsXG4gICAgbWF4U3Ryb2tlV2lkdGg6IDQsXG4gICAgc2hhcGVzOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS11cCcsICd0cmlhbmdsZS1kb3duJ11cbn07XG5mdW5jdGlvbiBpc0V4dGVuZGVkU2NoZW1lKHNjaGVtZSkge1xuICAgIHJldHVybiBzY2hlbWUgJiYgISFzY2hlbWVbJ25hbWUnXTtcbn1cbmV4cG9ydHMuaXNFeHRlbmRlZFNjaGVtZSA9IGlzRXh0ZW5kZWRTY2hlbWU7XG5mdW5jdGlvbiBpc1NlbGVjdGlvbkRvbWFpbihkb21haW4pIHtcbiAgICByZXR1cm4gZG9tYWluICYmIGRvbWFpblsnc2VsZWN0aW9uJ107XG59XG5leHBvcnRzLmlzU2VsZWN0aW9uRG9tYWluID0gaXNTZWxlY3Rpb25Eb21haW47XG5leHBvcnRzLlNDQUxFX1BST1BFUlRJRVMgPSBbXG4gICAgJ3R5cGUnLCAnZG9tYWluJywgJ3JhbmdlJywgJ3JvdW5kJywgJ3JhbmdlU3RlcCcsICdzY2hlbWUnLCAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJywgJ2NsYW1wJywgJ25pY2UnLFxuICAgICdleHBvbmVudCcsICd6ZXJvJywgJ2ludGVycG9sYXRlJ1xuXTtcbmZ1bmN0aW9uIHNjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eShzY2FsZVR5cGUsIHByb3BOYW1lKSB7XG4gICAgc3dpdGNoIChwcm9wTmFtZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICBjYXNlICdzY2hlbWUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2ludGVycG9sYXRlJzpcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuY29udGFpbnMoWydsaW5lYXInLCAnYmluLWxpbmVhcicsICdwb3cnLCAnbG9nJywgJ3NxcnQnLCAndXRjJywgJ3RpbWUnXSwgc2NhbGVUeXBlKTtcbiAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGludW91c1RvQ29udGludW91cyhzY2FsZVR5cGUpIHx8IHNjYWxlVHlwZSA9PT0gJ2JhbmQnIHx8IHNjYWxlVHlwZSA9PT0gJ3BvaW50JztcbiAgICAgICAgY2FzZSAncmFuZ2VTdGVwJzpcbiAgICAgICAgY2FzZSAncGFkZGluZyc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdPdXRlcic6XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKFsncG9pbnQnLCAnYmFuZCddLCBzY2FsZVR5cGUpO1xuICAgICAgICBjYXNlICdwYWRkaW5nSW5uZXInOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlVHlwZSA9PT0gJ2JhbmQnO1xuICAgICAgICBjYXNlICdjbGFtcCc6XG4gICAgICAgICAgICByZXR1cm4gaXNDb250aW51b3VzVG9Db250aW51b3VzKHNjYWxlVHlwZSkgfHwgc2NhbGVUeXBlID09PSAnc2VxdWVudGlhbCc7XG4gICAgICAgIGNhc2UgJ25pY2UnOlxuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGludW91c1RvQ29udGludW91cyhzY2FsZVR5cGUpIHx8IHNjYWxlVHlwZSA9PT0gJ3NlcXVlbnRpYWwnIHx8IHNjYWxlVHlwZSA9PT0gJ3F1YW50aXplJztcbiAgICAgICAgY2FzZSAnZXhwb25lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlVHlwZSA9PT0gJ3BvdycgfHwgc2NhbGVUeXBlID09PSAnbG9nJztcbiAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHF1YW50aXplLCB0aHJlc2hvbGQ/XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVUeXBlID09PSAnYmluLW9yZGluYWwnIHx8ICghaGFzRGlzY3JldGVEb21haW4oc2NhbGVUeXBlKSAmJiAhdXRpbF8xLmNvbnRhaW5zKFsnbG9nJywgJ3RpbWUnLCAndXRjJywgJ2Jpbi1saW5lYXInXSwgc2NhbGVUeXBlKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzY2FsZSBwcm9wZXJ0eSBcIiArIHByb3BOYW1lICsgXCIuXCIpO1xufVxuZXhwb3J0cy5zY2FsZVR5cGVTdXBwb3J0UHJvcGVydHkgPSBzY2FsZVR5cGVTdXBwb3J0UHJvcGVydHk7XG4vKipcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBjaGFubmVsIHN1cHBvcnRzIHRoZSBpbnB1dCBzY2FsZSBwcm9wZXJ0eSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGNoYW5uZWxTY2FsZVByb3BlcnR5SW5jb21wYXRhYmlsaXR5KGNoYW5uZWwsIHByb3BOYW1lKSB7XG4gICAgc3dpdGNoIChwcm9wTmFtZSkge1xuICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAvLyBVc2VyIHNob3VsZCBub3QgY3VzdG9taXplIHJhbmdlIGZvciBwb3NpdGlvbiBhbmQgZmFjZXQgY2hhbm5lbCBkaXJlY3RseS5cbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAneCcgfHwgY2hhbm5lbCA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZy5tZXNzYWdlLkNBTk5PVF9VU0VfUkFOR0VfV0lUSF9QT1NJVElPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAncm93JyB8fCBjaGFubmVsID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2cubWVzc2FnZS5jYW5ub3RVc2VSYW5nZVByb3BlcnR5V2l0aEZhY2V0KCdyYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gR09PRCFcbiAgICAgICAgLy8gYmFuZCAvIHBvaW50XG4gICAgICAgIGNhc2UgJ3JhbmdlU3RlcCc6XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ3JvdycgfHwgY2hhbm5lbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nLm1lc3NhZ2UuY2Fubm90VXNlUmFuZ2VQcm9wZXJ0eVdpdGhGYWNldCgncmFuZ2VTdGVwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBHT09EIVxuICAgICAgICBjYXNlICdwYWRkaW5nJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0lubmVyJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ091dGVyJzpcbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAncm93JyB8fCBjaGFubmVsID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2UgZG8gbm90IHVzZSBkMyBzY2FsZSdzIHBhZGRpbmcgZm9yIHJvdy9jb2x1bW4gYmVjYXVzZSBwYWRkaW5nIHRoZXJlXG4gICAgICAgICAgICAgICAgICogaXMgYSByYXRpbyAoWzAsIDFdKSBhbmQgaXQgY2F1c2VzIHRoZSBwYWRkaW5nIHRvIGJlIGRlY2ltYWxzLlxuICAgICAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UgbWFudWFsbHkgY2FsY3VsYXRlIFwic3BhY2luZ1wiIGluIHRoZSBsYXlvdXQgYnkgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2cubWVzc2FnZS5DQU5OT1RfVVNFX1BBRERJTkdfV0lUSF9GQUNFVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIEdPT0QhXG4gICAgICAgIGNhc2UgJ2ludGVycG9sYXRlJzpcbiAgICAgICAgY2FzZSAnc2NoZW1lJzpcbiAgICAgICAgICAgIGlmIChjaGFubmVsICE9PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZy5tZXNzYWdlLmNhbm5vdFVzZVNjYWxlUHJvcGVydHlXaXRoTm9uQ29sb3IoY2hhbm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICBjYXNlICdjbGFtcCc6XG4gICAgICAgIGNhc2UgJ2V4cG9uZW50JzpcbiAgICAgICAgY2FzZSAnbmljZSc6XG4gICAgICAgIGNhc2UgJ3plcm8nOlxuICAgICAgICAgICAgLy8gVGhlc2UgY2hhbm5lbCBkbyBub3QgaGF2ZSBzdHJpY3QgcmVxdWlyZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIEdPT0QhXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpdCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY2FsZSBwcm9wZXJ0eSBcIiR7cHJvcE5hbWV9XCIuJyk7XG59XG5leHBvcnRzLmNoYW5uZWxTY2FsZVByb3BlcnR5SW5jb21wYXRhYmlsaXR5ID0gY2hhbm5lbFNjYWxlUHJvcGVydHlJbmNvbXBhdGFiaWxpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMk5oYkdVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YzJOaGJHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGRlFTd3lRa0ZCTmtJN1FVRkROMElzSzBKQlFYVkRPMEZCUlhaRExFbEJRV2xDTEZOQlFWTXNRMEZ6UW5wQ08wRkJkRUpFTEZkQlFXbENMRk5CUVZNN1NVRkRlRUlzTkVKQlFUUkNPMGxCUTJZc1owSkJRVTBzUjBGQllTeFJRVUZSTEVOQlFVTTdTVUZETlVJc2IwSkJRVlVzUjBGQmFVSXNXVUZCV1N4RFFVRkRPMGxCUTNoRExHRkJRVWNzUjBGQlZTeExRVUZMTEVOQlFVTTdTVUZEYmtJc1lVRkJSeXhIUVVGVkxFdEJRVXNzUTBGQlF6dEpRVU51UWl4alFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wbEJRMjVETEc5Q1FVRnZRanRKUVVOUUxHTkJRVWtzUjBGQlZ5eE5RVUZOTEVOQlFVTTdTVUZEZEVJc1lVRkJSeXhIUVVGWExFdEJRVXNzUTBGQlF6dEpRVU5xUXl4aFFVRmhPMGxCUTBFc2IwSkJRVlVzUjBGQmFVSXNXVUZCV1N4RFFVRkRPMGxCUlhKRUxHZERRVUZuUXp0SlFVTnVRaXhyUWtGQlVTeEhRVUZsTEZWQlFWVXNRMEZCUXp0SlFVTnNReXhyUWtGQlVTeEhRVUZsTEZWQlFWVXNRMEZCUXp0SlFVTnNReXh0UWtGQlV5eEhRVUZuUWl4WFFVRlhMRU5CUVVNN1NVRkZja01zYVVKQlFVOHNSMEZCWXl4VFFVRlRMRU5CUVVNN1NVRkRMMElzY1VKQlFWY3NSMEZCYTBJc1lVRkJZU3hEUVVGRE8wbEJRek5ETEdWQlFVc3NSMEZCV1N4UFFVRlBMRU5CUVVNN1NVRkRla0lzWTBGQlNTeEhRVUZYTEUxQlFVMHNRMEZCUXp0QlFVTnlReXhEUVVGRExFVkJkRUpuUWl4VFFVRlRMRWRCUVZRc2FVSkJRVk1zUzBGQlZDeHBRa0ZCVXl4UlFYTkNla0k3UVVGVFdTeFJRVUZCTEZkQlFWY3NSMEZCWjBJN1NVRkRkRU1zTkVKQlFUUkNPMGxCUXpWQ0xGRkJRVkVzUlVGQlJTeFpRVUZaTEVWQlFVVXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hOUVVGTk8wbEJRelZETEc5Q1FVRnZRanRKUVVOd1FpeE5RVUZOTEVWQlFVVXNTMEZCU3p0SlFVTmlMR0ZCUVdFN1NVRkRZaXhaUVVGWk8wbEJRMW9zVjBGQlZ6dEpRVU5ZTEZOQlFWTXNSVUZCUlN4aFFVRmhMRVZCUVVVc1QwRkJUeXhGUVVGRkxFMUJRVTA3UTBGRE1VTXNRMEZCUXp0QlFVVlhMRkZCUVVFc0swSkJRU3RDTEVkQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGbEJRVmtzUlVGQlJTeExRVUZMTEVWQlFVVXNTMEZCU3l4RlFVRkZMRTFCUVUwc1JVRkJSU3hOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdRVUZETVVnc1NVRkJUU3c0UWtGQk9FSXNSMEZCUnl4WlFVRkxMRU5CUVVNc2RVTkJRU3RDTEVOQlFVTXNRMEZCUXp0QlFVVnFSU3hSUVVGQkxIZENRVUYzUWl4SFFVRm5RaXgxUTBGQkswSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhaUVVGWkxFTkJRVU1zYVVSQlFXbEVMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRemxLTEVsQlFVMHNkVUpCUVhWQ0xFZEJRVWNzV1VGQlN5eERRVUZETEdkRFFVRjNRaXhEUVVGRExFTkJRVU03UVVGRmJrUXNVVUZCUVN4elFrRkJjMElzUjBGQlowSXNRMEZCUXl4VFFVRlRMRVZCUVVVc1lVRkJZU3hGUVVGRkxFOUJRVThzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0QlFVTXZSaXhKUVVGTkxIRkNRVUZ4UWl4SFFVRkhMRmxCUVVzc1EwRkJReXc0UWtGQmMwSXNRMEZCUXl4RFFVRkRPMEZCUlRWRUxFbEJRVTBzWjBKQlFXZENMRWRCUVVjc1dVRkJTeXhEUVVGRExFTkJRVU1zV1VGQldTeEZRVUZGTEdGQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkZha1FzVVVGQlFTeG5Ra0ZCWjBJc1IwRkJaMElzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1FVRkZOMFFzTWtKQlFXdERMRWxCUVdVN1NVRkRMME1zVFVGQlRTeERRVUZETEVsQlFVa3NTVUZCU1N4eFFrRkJjVUlzUTBGQlF6dEJRVU4yUXl4RFFVRkRPMEZCUmtRc09FTkJSVU03UVVGRlJDeHZRa0ZCTWtJc1NVRkJaVHRKUVVONFF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4SlFVRkpMR2RDUVVGblFpeERRVUZETzBGQlEyeERMRU5CUVVNN1FVRkdSQ3huUTBGRlF6dEJRVVZFTERaQ1FVRnZReXhKUVVGbE8wbEJSMnBFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRWxCUVVrc2RVSkJRWFZDTEVOQlFVTTdRVUZEZWtNc1EwRkJRenRCUVVwRUxHdEVRVWxETzBGQlJVUXNhME5CUVhsRExFbEJRV1U3U1VGRGRFUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1NVRkJTU3c0UWtGQk9FSXNRMEZCUXp0QlFVTm9SQ3hEUVVGRE8wRkJSa1FzTkVSQlJVTTdRVUUwUzFrc1VVRkJRU3hyUWtGQmEwSXNSMEZCUnp0SlFVTm9ReXhMUVVGTExFVkJRVVVzU1VGQlNUdEpRVU5ZTEdOQlFXTXNSVUZCUlN4RlFVRkZPMGxCUTJ4Q0xGTkJRVk1zUlVGQlJTeEZRVUZGTzBsQlEySXNXVUZCV1N4RlFVRkZMRWRCUVVjN1NVRkRha0lzWjBKQlFXZENMRVZCUVVVc1IwRkJSenRKUVVOeVFpeFpRVUZaTEVWQlFVVXNSVUZCUlR0SlFVVm9RaXhYUVVGWExFVkJRVVVzUTBGQlF6dEpRVU5rTEZkQlFWY3NSVUZCUlN4RlFVRkZPMGxCUldZc1ZVRkJWU3hGUVVGRkxFZEJRVWM3U1VGRFppeFZRVUZWTEVWQlFVVXNSMEZCUnp0SlFVVm1MREJFUVVFd1JEdEpRVU14UkN4UFFVRlBMRVZCUVVVc1EwRkJRenRKUVVWV0xHTkJRV01zUlVGQlJTeERRVUZETzBsQlEycENMR05CUVdNc1JVRkJSU3hEUVVGRE8wbEJSV3BDTEUxQlFVMHNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFVkJRVVVzVDBGQlR5eEZRVUZGTEZOQlFWTXNSVUZCUlN4aFFVRmhMRVZCUVVVc1pVRkJaU3hEUVVGRE8wTkJRMnBHTEVOQlFVTTdRVUZ6UWtZc01FSkJRV2xETEUxQlFTdENPMGxCUXpsRUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEJRVU53UXl4RFFVRkRPMEZCUmtRc05FTkJSVU03UVVGRlJDd3lRa0ZCYTBNc1RVRkJZenRKUVVNNVF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4SlFVRkpMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dEJRVU4yUXl4RFFVRkRPMEZCUmtRc09FTkJSVU03UVVGdlNGa3NVVUZCUVN4blFrRkJaMElzUjBGQmEwSTdTVUZETjBNc1RVRkJUU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFBRVUZQTEVWQlFVVXNUMEZCVHl4RlFVRkZMRmRCUVZjc1JVRkJSU3hSUVVGUkxFVkJRVVVzVTBGQlV5eEZRVUZGTEdOQlFXTXNSVUZCUlN4alFVRmpMRVZCUVVVc1QwRkJUeXhGUVVGRkxFMUJRVTA3U1VGRGNrZ3NWVUZCVlN4RlFVRkZMRTFCUVUwc1JVRkJSU3hoUVVGaE8wTkJRMnhETEVOQlFVTTdRVUZGUml4clEwRkJlVU1zVTBGQmIwSXNSVUZCUlN4UlFVRnhRanRKUVVOc1JpeE5RVUZOTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBDTEV0QlFVc3NUVUZCVFN4RFFVRkRPMUZCUTFvc1MwRkJTeXhSUVVGUkxFTkJRVU03VVVGRFpDeExRVUZMTEU5QlFVOHNRMEZCUXp0UlFVTmlMRXRCUVVzc1VVRkJVVHRaUVVOWUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4TFFVRkxMR0ZCUVdFN1dVRkRhRUlzVFVGQlRTeERRVUZETEdWQlFWRXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3haUVVGWkxFVkJRVVVzUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUlN4TlFVRk5MRVZCUVVVc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMUZCUXpWR0xFdEJRVXNzVDBGQlR6dFpRVU5XTEUxQlFVMHNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4VFFVRlRMRXRCUVVzc1RVRkJUU3hKUVVGSkxGTkJRVk1zUzBGQlN5eFBRVUZQTEVOQlFVTTdVVUZET1VZc1MwRkJTeXhYUVVGWExFTkJRVU03VVVGRGFrSXNTMEZCU3l4VFFVRlRMRU5CUVVNN1VVRkRaaXhMUVVGTExHTkJRV003V1VGRGFrSXNUVUZCVFN4RFFVRkRMR1ZCUVZFc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVOb1JDeExRVUZMTEdOQlFXTTdXVUZEYWtJc1RVRkJUU3hEUVVGRExGTkJRVk1zUzBGQlN5eE5RVUZOTEVOQlFVTTdVVUZET1VJc1MwRkJTeXhQUVVGUE8xbEJRMVlzVFVGQlRTeERRVUZETEhkQ1FVRjNRaXhEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEZOQlFWTXNTMEZCU3l4WlFVRlpMRU5CUVVNN1VVRkRNMFVzUzBGQlN5eE5RVUZOTzFsQlExUXNUVUZCVFN4RFFVRkRMSGRDUVVGM1FpeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRk5CUVZNc1MwRkJTeXhaUVVGWkxFbEJRVWtzVTBGQlowSXNTMEZCU3l4VlFVRlZMRU5CUVVNN1VVRkRPVWNzUzBGQlN5eFZRVUZWTzFsQlEySXNUVUZCVFN4RFFVRkRMRk5CUVZNc1MwRkJTeXhMUVVGTExFbEJRVWtzVTBGQlV5eExRVUZMTEV0QlFVc3NRMEZCUXp0UlFVTndSQ3hMUVVGTExFMUJRVTA3V1VGRFZDeDNRMEZCZDBNN1dVRkRlRU1zVFVGQlRTeERRVUZETEZOQlFWTXNTMEZCU3l4aFFVRmhMRWxCUVVrc1EwRkJReXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVVVzV1VGQldTeERRVUZETEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONFNTeERRVUZETzBsQlEwUXNhMFJCUVd0RU8wbEJRMnhFTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc05FSkJRVEJDTEZGQlFWRXNUVUZCUnl4RFFVRkRMRU5CUVVNN1FVRkRla1FzUTBGQlF6dEJRVGRDUkN3MFJFRTJRa003UVVGRlJEczdSMEZGUnp0QlFVTklMRFpEUVVGdlJDeFBRVUZuUWl4RlFVRkZMRkZCUVhGQ08wbEJRM3BHTEUxQlFVMHNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrSXNTMEZCU3l4UFFVRlBPMWxCUTFZc01rVkJRVEpGTzFsQlF6TkZMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUzBGQlN5eEhRVUZITEVsQlFVa3NUMEZCVHl4TFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzWkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETERoQ1FVRTRRaXhEUVVGRE8xbEJRM0JFTEVOQlFVTTdXVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzUzBGQlN5eEpRVUZKTEU5QlFVOHNTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU01UXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5d3JRa0ZCSzBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU01UkN4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEZGQlFWRTdVVUZETlVJc1pVRkJaVHRSUVVObUxFdEJRVXNzVjBGQlZ6dFpRVU5rTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhMUVVGTExFbEJRVWtzVDBGQlR5eExRVUZMTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRemxETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExDdENRVUVyUWl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xbEJRMnhGTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zVVVGQlVUdFJRVU0xUWl4TFFVRkxMRk5CUVZNc1EwRkJRenRSUVVObUxFdEJRVXNzWTBGQll5eERRVUZETzFGQlEzQkNMRXRCUVVzc1kwRkJZenRaUVVOcVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1MwRkJTeXhKUVVGSkxFOUJRVThzUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNNVF6czdPenR0UWtGSlJ6dG5Ra0ZEU0N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5dzJRa0ZCTmtJc1EwRkJRenRaUVVOdVJDeERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExGRkJRVkU3VVVGRE5VSXNTMEZCU3l4aFFVRmhMRU5CUVVNN1VVRkRia0lzUzBGQlN5eFJRVUZSTzFsQlExZ3NSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhMUVVGTExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoQ0xFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR3REUVVGclF5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUTJwRkxFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTI1Q0xFdEJRVXNzVFVGQlRTeERRVUZETzFGQlExb3NTMEZCU3l4UlFVRlJMRU5CUVVNN1VVRkRaQ3hMUVVGTExFOUJRVThzUTBGQlF6dFJRVU5pTEV0QlFVc3NUMEZCVHl4RFFVRkRPMUZCUTJJc1MwRkJTeXhWUVVGVkxFTkJRVU03VVVGRGFFSXNTMEZCU3l4TlFVRk5MRU5CUVVNN1VVRkRXaXhMUVVGTExFMUJRVTA3V1VGRFZDd3JRMEZCSzBNN1dVRkRMME1zVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRkZCUVZFN1NVRkRPVUlzUTBGQlF6dEpRVU5FTEhORVFVRnpSRHRKUVVOMFJDeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSFZEUVVGMVF5eERRVUZETEVOQlFVTTdRVUZETTBRc1EwRkJRenRCUVM5RFJDeHJSa0VyUTBNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICBzaW5nbGU6IHsgb246ICdjbGljaycsIGZpZWxkczogWydfaWQnXSwgcmVzb2x2ZTogJ2dsb2JhbCcgfSxcbiAgICBtdWx0aTogeyBvbjogJ2NsaWNrJywgZmllbGRzOiBbJ19pZCddLCB0b2dnbGU6ICdldmVudC5zaGlmdEtleScsIHJlc29sdmU6ICdnbG9iYWwnIH0sXG4gICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgb246ICdbbW91c2Vkb3duLCB3aW5kb3c6bW91c2V1cF0gPiB3aW5kb3c6bW91c2Vtb3ZlIScsXG4gICAgICAgIGVuY29kaW5nczogWyd4JywgJ3knXSxcbiAgICAgICAgdHJhbnNsYXRlOiAnW21vdXNlZG93biwgd2luZG93Om1vdXNldXBdID4gd2luZG93Om1vdXNlbW92ZSEnLFxuICAgICAgICB6b29tOiAnd2hlZWwnLFxuICAgICAgICByZXNvbHZlOiAnZ2xvYmFsJ1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMlZzWldOMGFXOXVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzTmxiR1ZqZEdsdmJpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVdsRFlTeFJRVUZCTEdGQlFXRXNSMEZCYlVJN1NVRkRNME1zVFVGQlRTeEZRVUZGTEVWQlFVTXNSVUZCUlN4RlFVRkZMRTlCUVU4c1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNSVUZCUlN4UFFVRlBMRVZCUVVVc1VVRkJVU3hGUVVGRE8wbEJRM3BFTEV0QlFVc3NSVUZCUlN4RlFVRkRMRVZCUVVVc1JVRkJSU3hQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGRkxHZENRVUZuUWl4RlFVRkZMRTlCUVU4c1JVRkJSU3hSUVVGUkxFVkJRVU03U1VGRGJFWXNVVUZCVVN4RlFVRkZPMUZCUTFJc1JVRkJSU3hGUVVGRkxHbEVRVUZwUkR0UlFVTnlSQ3hUUVVGVExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRPMUZCUTNKQ0xGTkJRVk1zUlVGQlJTeHBSRUZCYVVRN1VVRkROVVFzU1VGQlNTeEZRVUZGTEU5QlFVODdVVUZEWWl4UFFVRlBMRVZCUVVVc1VVRkJVVHRMUVVOc1FqdERRVU5HTEVOQlFVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc1NvcnRGaWVsZChzb3J0KSB7XG4gICAgcmV0dXJuICEhc29ydCAmJiAhIXNvcnRbJ2ZpZWxkJ10gJiYgISFzb3J0WydvcCddO1xufVxuZXhwb3J0cy5pc1NvcnRGaWVsZCA9IGlzU29ydEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzI5eWRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emIzSjBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQmFVSkJMSEZDUVVFMFFpeEpRVUV5UWp0SlFVTnlSQ3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03UVVGRGJrUXNRMEZCUXp0QlFVWkVMR3REUVVWREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG52YXIgY29tcG9zaXRlTWFyayA9IHJlcXVpcmUoXCIuL2NvbXBvc2l0ZW1hcmtcIik7XG52YXIgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xudmFyIHZsRW5jb2RpbmcgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4vc3RhY2tcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qIEN1c3RvbSB0eXBlIGd1YXJkcyAqL1xuZnVuY3Rpb24gaXNGYWNldFNwZWMoc3BlYykge1xuICAgIHJldHVybiBzcGVjWydmYWNldCddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzRmFjZXRTcGVjID0gaXNGYWNldFNwZWM7XG5mdW5jdGlvbiBpc1VuaXRTcGVjKHNwZWMpIHtcbiAgICByZXR1cm4gISFzcGVjWydtYXJrJ107XG59XG5leHBvcnRzLmlzVW5pdFNwZWMgPSBpc1VuaXRTcGVjO1xuZnVuY3Rpb24gaXNMYXllclNwZWMoc3BlYykge1xuICAgIHJldHVybiBzcGVjWydsYXllciddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTGF5ZXJTcGVjID0gaXNMYXllclNwZWM7XG5mdW5jdGlvbiBpc1JlcGVhdFNwZWMoc3BlYykge1xuICAgIHJldHVybiBzcGVjWydyZXBlYXQnXSAhPT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc1JlcGVhdFNwZWMgPSBpc1JlcGVhdFNwZWM7XG5mdW5jdGlvbiBpc0NvbmNhdFNwZWMoc3BlYykge1xuICAgIHJldHVybiBpc1ZDb25jYXRTcGVjKHNwZWMpIHx8IGlzSENvbmNhdFNwZWMoc3BlYyk7XG59XG5leHBvcnRzLmlzQ29uY2F0U3BlYyA9IGlzQ29uY2F0U3BlYztcbmZ1bmN0aW9uIGlzVkNvbmNhdFNwZWMoc3BlYykge1xuICAgIHJldHVybiBzcGVjWyd2Y29uY2F0J10gIT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNWQ29uY2F0U3BlYyA9IGlzVkNvbmNhdFNwZWM7XG5mdW5jdGlvbiBpc0hDb25jYXRTcGVjKHNwZWMpIHtcbiAgICByZXR1cm4gc3BlY1snaGNvbmNhdCddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzSENvbmNhdFNwZWMgPSBpc0hDb25jYXRTcGVjO1xuLyoqXG4gKiBEZWNvbXBvc2UgZXh0ZW5kZWQgdW5pdCBzcGVjcyBpbnRvIGNvbXBvc2l0aW9uIG9mIHB1cmUgdW5pdCBzcGVjcy5cbiAqL1xuLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIHRoaXMgdG8gYW5vdGhlciBmaWxlLiAgTWF5YmUgdmwuc3BlYy5ub3JtYWxpemUgb3Igdmwubm9ybWFsaXplXG5mdW5jdGlvbiBub3JtYWxpemUoc3BlYywgY29uZmlnKSB7XG4gICAgaWYgKGlzRmFjZXRTcGVjKHNwZWMpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVGYWNldChzcGVjLCBjb25maWcpO1xuICAgIH1cbiAgICBpZiAoaXNMYXllclNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUxheWVyKHNwZWMsIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChpc1JlcGVhdFNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlcGVhdChzcGVjLCBzcGVjLmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChpc1ZDb25jYXRTcGVjKHNwZWMpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVWQ29uY2F0KHNwZWMsIHNwZWMuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGlzSENvbmNhdFNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUhDb25jYXQoc3BlYywgc3BlYy5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoaXNVbml0U3BlYyhzcGVjKSkge1xuICAgICAgICB2YXIgaGFzUm93ID0gZW5jb2RpbmdfMS5jaGFubmVsSGFzRmllbGQoc3BlYy5lbmNvZGluZywgY2hhbm5lbF8xLlJPVyk7XG4gICAgICAgIHZhciBoYXNDb2x1bW4gPSBlbmNvZGluZ18xLmNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBjaGFubmVsXzEuQ09MVU1OKTtcbiAgICAgICAgaWYgKGhhc1JvdyB8fCBoYXNDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVGYWNldGVkVW5pdChzcGVjLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVOb25GYWNldFVuaXQoc3BlYywgY29uZmlnKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLklOVkFMSURfU1BFQyk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5vbkZhY2V0KHNwZWMsIGNvbmZpZykge1xuICAgIGlmIChpc0xheWVyU3BlYyhzcGVjKSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplTGF5ZXIoc3BlYywgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVwZWF0U3BlYyhzcGVjKSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0KHNwZWMsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVOb25GYWNldFVuaXQoc3BlYywgY29uZmlnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5vbkZhY2V0V2l0aFJlcGVhdChzcGVjLCBjb25maWcpIHtcbiAgICBpZiAoaXNMYXllclNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUxheWVyKHNwZWMsIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChpc1JlcGVhdFNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJlcGVhdChzcGVjLCBjb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplTm9uRmFjZXRVbml0KHNwZWMsIGNvbmZpZyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVGYWNldChzcGVjLCBjb25maWcpIHtcbiAgICB2YXIgc3Vic3BlYyA9IHNwZWMuc3BlYywgcmVzdCA9IHRzbGliXzEuX19yZXN0KHNwZWMsIFtcInNwZWNcIl0pO1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCByZXN0LCB7IHNwZWM6IG5vcm1hbGl6ZU5vbkZhY2V0KHN1YnNwZWMsIGNvbmZpZykgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVMYXllcihzcGVjLCBjb25maWcpIHtcbiAgICB2YXIgbGF5ZXIgPSBzcGVjLmxheWVyLCByZXN0ID0gdHNsaWJfMS5fX3Jlc3Qoc3BlYywgW1wibGF5ZXJcIl0pO1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCByZXN0LCB7IGxheWVyOiBsYXllci5tYXAoZnVuY3Rpb24gKHN1YnNwZWMpIHsgcmV0dXJuIGlzTGF5ZXJTcGVjKHN1YnNwZWMpID8gbm9ybWFsaXplTGF5ZXIoc3Vic3BlYywgY29uZmlnKSA6IG5vcm1hbGl6ZU5vbkZhY2V0VW5pdChzdWJzcGVjLCBjb25maWcpOyB9KSB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGVhdChzcGVjLCBjb25maWcpIHtcbiAgICB2YXIgc3Vic3BlYyA9IHNwZWMuc3BlYywgcmVzdCA9IHRzbGliXzEuX19yZXN0KHNwZWMsIFtcInNwZWNcIl0pO1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCByZXN0LCB7IHNwZWM6IG5vcm1hbGl6ZU5vbkZhY2V0V2l0aFJlcGVhdChzdWJzcGVjLCBjb25maWcpIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVkNvbmNhdChzcGVjLCBjb25maWcpIHtcbiAgICB2YXIgdmNvbmNhdCA9IHNwZWMudmNvbmNhdCwgcmVzdCA9IHRzbGliXzEuX19yZXN0KHNwZWMsIFtcInZjb25jYXRcIl0pO1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCByZXN0LCB7IHZjb25jYXQ6IHZjb25jYXQubWFwKGZ1bmN0aW9uIChzdWJzcGVjKSB7IHJldHVybiBub3JtYWxpemVOb25GYWNldChzdWJzcGVjLCBjb25maWcpOyB9KSB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhDb25jYXQoc3BlYywgY29uZmlnKSB7XG4gICAgdmFyIGhjb25jYXQgPSBzcGVjLmhjb25jYXQsIHJlc3QgPSB0c2xpYl8xLl9fcmVzdChzcGVjLCBbXCJoY29uY2F0XCJdKTtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVzdCwgeyBoY29uY2F0OiBoY29uY2F0Lm1hcChmdW5jdGlvbiAoc3Vic3BlYykgeyByZXR1cm4gbm9ybWFsaXplTm9uRmFjZXQoc3Vic3BlYywgY29uZmlnKTsgfSkgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVGYWNldGVkVW5pdChzcGVjLCBjb25maWcpIHtcbiAgICAvLyBOZXcgZW5jb2RpbmcgaW4gdGhlIGluc2lkZSBzcGVjIHNob3VsZCBub3QgY29udGFpbiByb3cgLyBjb2x1bW5cbiAgICAvLyBhcyByb3cvY29sdW1uIHNob3VsZCBiZSBtb3ZlZCB0byBmYWNldFxuICAgIHZhciBfYSA9IHNwZWMuZW5jb2RpbmcsIHJvdyA9IF9hLnJvdywgY29sdW1uID0gX2EuY29sdW1uLCBlbmNvZGluZyA9IHRzbGliXzEuX19yZXN0KF9hLCBbXCJyb3dcIiwgXCJjb2x1bW5cIl0pO1xuICAgIC8vIE1hcmsgYW5kIGVuY29kaW5nIHNob3VsZCBiZSBtb3ZlZCBpbnRvIHRoZSBpbm5lciBzcGVjXG4gICAgdmFyIG1hcmsgPSBzcGVjLm1hcmssIHNlbGVjdGlvbiA9IHNwZWMuc2VsZWN0aW9uLCBfID0gc3BlYy5lbmNvZGluZywgb3V0ZXJTcGVjID0gdHNsaWJfMS5fX3Jlc3Qoc3BlYywgW1wibWFya1wiLCBcInNlbGVjdGlvblwiLCBcImVuY29kaW5nXCJdKTtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgb3V0ZXJTcGVjLCB7IGZhY2V0OiB0c2xpYl8xLl9fYXNzaWduKHt9LCAocm93ID8geyByb3c6IHJvdyB9IDoge30pLCAoY29sdW1uID8geyBjb2x1bW46IGNvbHVtbiB9IDoge30pKSwgc3BlYzogbm9ybWFsaXplTm9uRmFjZXRVbml0KHRzbGliXzEuX19hc3NpZ24oeyBtYXJrOiBtYXJrLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nIH0sIChzZWxlY3Rpb24gPyB7IHNlbGVjdGlvbjogc2VsZWN0aW9uIH0gOiB7fSkpLCBjb25maWcpIH0pO1xufVxuZnVuY3Rpb24gaXNOb25GYWNldFVuaXRTcGVjV2l0aFByaW1pdGl2ZU1hcmsoc3BlYykge1xuICAgIHJldHVybiBtYXJrXzEuaXNQcmltaXRpdmVNYXJrKHNwZWMubWFyayk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVOb25GYWNldFVuaXQoc3BlYywgY29uZmlnKSB7XG4gICAgaWYgKGlzTm9uRmFjZXRVbml0U3BlY1dpdGhQcmltaXRpdmVNYXJrKHNwZWMpKSB7XG4gICAgICAgIC8vIFRPRE86IHRob3JvdWdobHkgdGVzdFxuICAgICAgICBpZiAoZW5jb2RpbmdfMS5pc1JhbmdlZChzcGVjLmVuY29kaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJhbmdlZFVuaXQoc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXJsYXlDb25maWcgPSBjb25maWcgJiYgY29uZmlnLm92ZXJsYXk7XG4gICAgICAgIHZhciBvdmVybGF5V2l0aExpbmUgPSBvdmVybGF5Q29uZmlnICYmIHNwZWMubWFyayA9PT0gbWFya18xLkFSRUEgJiZcbiAgICAgICAgICAgIHV0aWxfMS5jb250YWlucyhbJ2xpbmVwb2ludCcsICdsaW5lJ10sIG92ZXJsYXlDb25maWcuYXJlYSk7XG4gICAgICAgIHZhciBvdmVybGF5V2l0aFBvaW50ID0gb3ZlcmxheUNvbmZpZyAmJiAoKG92ZXJsYXlDb25maWcubGluZSAmJiBzcGVjLm1hcmsgPT09IG1hcmtfMS5MSU5FKSB8fFxuICAgICAgICAgICAgKG92ZXJsYXlDb25maWcuYXJlYSA9PT0gJ2xpbmVwb2ludCcgJiYgc3BlYy5tYXJrID09PSBtYXJrXzEuQVJFQSkpO1xuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdGhpcyB0byBiZWNvbWUgYW5vdGhlciBjYXNlIG9mIGNvbXBvc2l0ZU1hcmtcbiAgICAgICAgaWYgKG92ZXJsYXlXaXRoUG9pbnQgfHwgb3ZlcmxheVdpdGhMaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplT3ZlcmxheShzcGVjLCBvdmVybGF5V2l0aFBvaW50LCBvdmVybGF5V2l0aExpbmUsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwZWM7IC8vIE5vdGhpbmcgdG8gbm9ybWFsaXplXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlTWFyay5ub3JtYWxpemUoc3BlYywgY29uZmlnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVSYW5nZWRVbml0KHNwZWMpIHtcbiAgICB2YXIgaGFzWCA9IGVuY29kaW5nXzEuY2hhbm5lbEhhc0ZpZWxkKHNwZWMuZW5jb2RpbmcsIGNoYW5uZWxfMS5YKTtcbiAgICB2YXIgaGFzWSA9IGVuY29kaW5nXzEuY2hhbm5lbEhhc0ZpZWxkKHNwZWMuZW5jb2RpbmcsIGNoYW5uZWxfMS5ZKTtcbiAgICB2YXIgaGFzWDIgPSBlbmNvZGluZ18xLmNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBjaGFubmVsXzEuWDIpO1xuICAgIHZhciBoYXNZMiA9IGVuY29kaW5nXzEuY2hhbm5lbEhhc0ZpZWxkKHNwZWMuZW5jb2RpbmcsIGNoYW5uZWxfMS5ZMik7XG4gICAgaWYgKChoYXNYMiAmJiAhaGFzWCkgfHwgKGhhc1kyICYmICFoYXNZKSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFNwZWMgPSB1dGlsXzEuZHVwbGljYXRlKHNwZWMpO1xuICAgICAgICBpZiAoaGFzWDIgJiYgIWhhc1gpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTcGVjLmVuY29kaW5nLnggPSBub3JtYWxpemVkU3BlYy5lbmNvZGluZy54MjtcbiAgICAgICAgICAgIGRlbGV0ZSBub3JtYWxpemVkU3BlYy5lbmNvZGluZy54MjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzWTIgJiYgIWhhc1kpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTcGVjLmVuY29kaW5nLnkgPSBub3JtYWxpemVkU3BlYy5lbmNvZGluZy55MjtcbiAgICAgICAgICAgIGRlbGV0ZSBub3JtYWxpemVkU3BlYy5lbmNvZGluZy55MjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFNwZWM7XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuLy8gRklYTUUoIzE4MDQpOiByZS1kZXNpZ24gdGhpc1xuZnVuY3Rpb24gbm9ybWFsaXplT3ZlcmxheShzcGVjLCBvdmVybGF5V2l0aFBvaW50LCBvdmVybGF5V2l0aExpbmUsIGNvbmZpZykge1xuICAgIHZhciBtYXJrID0gc3BlYy5tYXJrLCBlbmNvZGluZyA9IHNwZWMuZW5jb2RpbmcsIG91dGVyU3BlYyA9IHRzbGliXzEuX19yZXN0KHNwZWMsIFtcIm1hcmtcIiwgXCJlbmNvZGluZ1wiXSk7XG4gICAgdmFyIGxheWVyID0gW3sgbWFyazogbWFyaywgZW5jb2Rpbmc6IGVuY29kaW5nIH1dO1xuICAgIC8vIE5lZWQgdG8gY29weSBzdGFjayBjb25maWcgdG8gb3ZlcmxheWVkIGxheWVyXG4gICAgdmFyIHN0YWNrUHJvcHMgPSBzdGFja18xLnN0YWNrKG1hcmssIGVuY29kaW5nLCBjb25maWcgPyBjb25maWcuc3RhY2sgOiB1bmRlZmluZWQpO1xuICAgIHZhciBvdmVybGF5RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICBpZiAoc3RhY2tQcm9wcykge1xuICAgICAgICB2YXIgc3RhY2tGaWVsZENoYW5uZWwgPSBzdGFja1Byb3BzLmZpZWxkQ2hhbm5lbCwgb2Zmc2V0ID0gc3RhY2tQcm9wcy5vZmZzZXQ7XG4gICAgICAgIG92ZXJsYXlFbmNvZGluZyA9IHRzbGliXzEuX19hc3NpZ24oe30sIGVuY29kaW5nLCAoX2EgPSB7fSwgX2Fbc3RhY2tGaWVsZENoYW5uZWxdID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZW5jb2Rpbmdbc3RhY2tGaWVsZENoYW5uZWxdLCAob2Zmc2V0ID8geyBzdGFjazogb2Zmc2V0IH0gOiB7fSkpLCBfYSkpO1xuICAgIH1cbiAgICBpZiAob3ZlcmxheVdpdGhMaW5lKSB7XG4gICAgICAgIGxheWVyLnB1c2goe1xuICAgICAgICAgICAgbWFyazoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICByb2xlOiAnbGluZU92ZXJsYXknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jb2Rpbmc6IG92ZXJsYXlFbmNvZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG92ZXJsYXlXaXRoUG9pbnQpIHtcbiAgICAgICAgbGF5ZXIucHVzaCh7XG4gICAgICAgICAgICBtYXJrOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICBmaWxsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcm9sZTogJ3BvaW50T3ZlcmxheSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNvZGluZzogb3ZlcmxheUVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgb3V0ZXJTcGVjLCB7IGxheWVyOiBsYXllciB9KTtcbiAgICB2YXIgX2E7XG59XG4vLyBUT0RPOiBhZGQgdmwuc3BlYy52YWxpZGF0ZSAmIG1vdmUgc3R1ZmYgZnJvbSB2bC52YWxpZGF0ZSB0byBoZXJlXG4vKiBBY2N1bXVsYXRlIG5vbi1kdXBsaWNhdGUgZmllbGREZWZzIGluIGEgZGljdGlvbmFyeSAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShkaWN0LCBmaWVsZERlZnMpIHtcbiAgICBmaWVsZERlZnMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGREZWYpIHtcbiAgICAgICAgLy8gQ29uc2lkZXIgb25seSBwdXJlIGZpZWxkRGVmIHByb3BlcnRpZXMgKGlnbm9yaW5nIHNjYWxlLCBheGlzLCBsZWdlbmQpXG4gICAgICAgIHZhciBwdXJlRmllbGREZWYgPSBbJ2ZpZWxkJywgJ3R5cGUnLCAndmFsdWUnLCAndGltZVVuaXQnLCAnYmluJywgJ2FnZ3JlZ2F0ZSddLnJlZHVjZShmdW5jdGlvbiAoZiwga2V5KSB7XG4gICAgICAgICAgICBpZiAoZmllbGREZWZba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZltrZXldID0gZmllbGREZWZba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBrZXkgPSB1dGlsXzEuaGFzaChwdXJlRmllbGREZWYpO1xuICAgICAgICBkaWN0W2tleV0gPSBkaWN0W2tleV0gfHwgZmllbGREZWY7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRpY3Q7XG59XG4vKiBSZWN1cnNpdmVseSBnZXQgZmllbGREZWZzIGZyb20gYSBzcGVjLCByZXR1cm5zIGEgZGljdGlvbmFyeSBvZiBmaWVsZERlZnMgKi9cbmZ1bmN0aW9uIGZpZWxkRGVmSW5kZXgoc3BlYywgZGljdCkge1xuICAgIGlmIChkaWN0ID09PSB2b2lkIDApIHsgZGljdCA9IHt9OyB9XG4gICAgLy8gVE9ETzogU3VwcG9ydCByZXBlYXQgYW5kIGNvbmNhdFxuICAgIGlmIChpc0xheWVyU3BlYyhzcGVjKSkge1xuICAgICAgICBzcGVjLmxheWVyLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAoaXNVbml0U3BlYyhsYXllcikpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlKGRpY3QsIHZsRW5jb2RpbmcuZmllbGREZWZzKGxheWVyLmVuY29kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZERlZkluZGV4KGxheWVyLCBkaWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRmFjZXRTcGVjKHNwZWMpKSB7XG4gICAgICAgIGFjY3VtdWxhdGUoZGljdCwgdmxFbmNvZGluZy5maWVsZERlZnMoc3BlYy5mYWNldCkpO1xuICAgICAgICBmaWVsZERlZkluZGV4KHNwZWMuc3BlYywgZGljdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVwZWF0U3BlYyhzcGVjKSkge1xuICAgICAgICBhY2N1bXVsYXRlKGRpY3QsIHZsRW5jb2RpbmcuZmllbGREZWZzKHNwZWMuc3BlYykpO1xuICAgICAgICBmaWVsZERlZkluZGV4KHNwZWMuc3BlYywgZGljdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29uY2F0U3BlYyhzcGVjKSkge1xuICAgICAgICB2YXIgY2hpbGRTcGVjID0gaXNWQ29uY2F0U3BlYyhzcGVjKSA/IHNwZWMudmNvbmNhdCA6IHNwZWMuaGNvbmNhdDtcbiAgICAgICAgY2hpbGRTcGVjLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoaXNVbml0U3BlYyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlKGRpY3QsIHZsRW5jb2RpbmcuZmllbGREZWZzKGNoaWxkLmVuY29kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZERlZkluZGV4KGNoaWxkLCBkaWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY2N1bXVsYXRlKGRpY3QsIHZsRW5jb2RpbmcuZmllbGREZWZzKHNwZWMuZW5jb2RpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpY3Q7XG59XG4vKiBSZXR1cm5zIGFsbCBub24tZHVwbGljYXRlIGZpZWxkRGVmcyBpbiBhIHNwZWMgaW4gYSBmbGF0IGFycmF5ICovXG5mdW5jdGlvbiBmaWVsZERlZnMoc3BlYykge1xuICAgIHJldHVybiB1dGlsXzEudmFscyhmaWVsZERlZkluZGV4KHNwZWMpKTtcbn1cbmV4cG9ydHMuZmllbGREZWZzID0gZmllbGREZWZzO1xuZnVuY3Rpb24gaXNTdGFja2VkKHNwZWMsIGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCBzcGVjLmNvbmZpZztcbiAgICBpZiAobWFya18xLmlzUHJpbWl0aXZlTWFyayhzcGVjLm1hcmspKSB7XG4gICAgICAgIHJldHVybiBzdGFja18xLnN0YWNrKHNwZWMubWFyaywgc3BlYy5lbmNvZGluZywgY29uZmlnID8gY29uZmlnLnN0YWNrIDogdW5kZWZpbmVkKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1N0YWNrZWQgPSBpc1N0YWNrZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM0JsWXk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl6Y0dWakxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVGQkxIRkRRVUZ2UkR0QlFVTndSQ3dyUTBGQmFVUTdRVUZKYWtRc2RVTkJRV3RHTzBGQlEyeEdMSFZEUVVGNVF6dEJRVWQ2UXl3eVFrRkJOa0k3UVVGRE4wSXNLMEpCUVd0Rk8wRkJTV3hGTEdsRFFVRTRRanRCUVVjNVFpd3JRa0ZCZFVRN1FVRnRTblpFTEhkQ1FVRjNRanRCUVVkNFFpeHhRa0ZCTkVJc1NVRkJORU03U1VGRGRFVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eFRRVUZUTEVOQlFVTTdRVUZEY2tNc1EwRkJRenRCUVVaRUxHdERRVVZETzBGQlJVUXNiMEpCUVRKQ0xFbEJRVFJETzBsQlEzSkZMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMEZCUTNoQ0xFTkJRVU03UVVGR1JDeG5RMEZGUXp0QlFVVkVMSEZDUVVFMFFpeEpRVUUwUXp0SlFVTjBSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRk5CUVZNc1EwRkJRenRCUVVOeVF5eERRVUZETzBGQlJrUXNhME5CUlVNN1FVRkZSQ3h6UWtGQk5rSXNTVUZCTkVNN1NVRkRka1VzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU03UVVGRGRFTXNRMEZCUXp0QlFVWkVMRzlEUVVWRE8wRkJSVVFzYzBKQlFUWkNMRWxCUVRSRE8wbEJRM1pGTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMEZCUTNCRUxFTkJRVU03UVVGR1JDeHZRMEZGUXp0QlFVVkVMSFZDUVVFNFFpeEpRVUUwUXp0SlFVTjRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRk5CUVZNc1EwRkJRenRCUVVOMlF5eERRVUZETzBGQlJrUXNjME5CUlVNN1FVRkZSQ3gxUWtGQk9FSXNTVUZCTkVNN1NVRkRlRVVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU03UVVGRGRrTXNRMEZCUXp0QlFVWkVMSE5EUVVWRE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N4MVJrRkJkVVk3UVVGRGRrWXNiVUpCUVRCQ0xFbEJRVEJDTEVWQlFVVXNUVUZCWXp0SlFVTnNSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlEzUkRMRU5CUVVNN1NVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlEzUkRMRU5CUVVNN1NVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1pDTEUxQlFVMHNRMEZCUXl4bFFVRmxMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTTFReXhEUVVGRE8wbEJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40UWl4TlFVRk5MRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU0zUXl4RFFVRkRPMGxCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFFpeE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVNM1F5eERRVUZETzBsQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlRaXhKUVVGTkxFMUJRVTBzUjBGQlJ5d3dRa0ZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzWVVGQlJ5eERRVUZETEVOQlFVTTdVVUZEYmtRc1NVRkJUU3hUUVVGVExFZEJRVWNzTUVKQlFXVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxHZENRVUZOTEVOQlFVTXNRMEZCUXp0UlFVVjZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFFpeE5RVUZOTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zU1VGQlNTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUXpWRExFTkJRVU03VVVGRFJDeE5RVUZOTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU1zU1VGQlNTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUXpkRExFTkJRVU03U1VGRFJDeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdRVUZETlVNc1EwRkJRenRCUVRGQ1JDdzRRa0V3UWtNN1FVRkZSQ3d5UWtGQk1rSXNTVUZCYjBjc1JVRkJSU3hOUVVGak8wbEJRemRKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVJc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRkRU1zUTBGQlF6dEpRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmxCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZGtJc1RVRkJUU3hEUVVGRExHVkJRV1VzUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRka01zUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1FVRkROME1zUTBGQlF6dEJRVWRFTEhGRFFVRnhReXhKUVVGdlJ5eEZRVUZGTEUxQlFXTTdTVUZEZGtvc1JVRkJSU3hEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFFpeE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zV1VGQldTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMlFpeE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU4yUXl4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEJRVU0zUXl4RFFVRkRPMEZCUjBRc2QwSkJRWGRDTEVsQlFYbERMRVZCUVVVc1RVRkJZenRKUVVONFJTeEpRVUZCTEcxQ1FVRmhMRVZCUVVVc2NVTkJRVThzUTBGQlV6dEpRVU4wUXl4TlFVRk5MSE5DUVVORUxFbEJRVWtzU1VGRFVDeEpRVUZKTEVWQlFVVXNhVUpCUVdsQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVTjRRenRCUVVOS0xFTkJRVU03UVVGRlJDeDNRa0ZCZDBJc1NVRkJlVU1zUlVGQlJTeE5RVUZqTzBsQlEzaEZMRWxCUVVFc2EwSkJRVmtzUlVGQlJTeHpRMEZCVHl4RFFVRlRPMGxCUTNKRExFMUJRVTBzYzBKQlEwUXNTVUZCU1N4SlFVTlFMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNUMEZCVHl4SlFVRkxMRTlCUVVFc1YwRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEdOQlFXTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1RVRkJUU3hEUVVGRExFZEJRVWNzY1VKQlFYRkNMRU5CUVVNc1QwRkJUeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUV2Uml4RFFVRXJSaXhEUVVGRExFbEJRemxJTzBGQlEwb3NRMEZCUXp0QlFVVkVMSGxDUVVGNVFpeEpRVUV3UXl4RlFVRkZMRTFCUVdNN1NVRkRNVVVzU1VGQlFTeHRRa0ZCWVN4RlFVRkZMSEZEUVVGUExFTkJRVk03U1VGRGRFTXNUVUZCVFN4elFrRkRSQ3hKUVVGSkxFbEJRMUFzU1VGQlNTeEZRVUZGTERKQ1FVRXlRaXhEUVVGRExFOUJRVThzUlVGQlJTeE5RVUZOTEVOQlFVTXNTVUZEYkVRN1FVRkRTaXhEUVVGRE8wRkJSVVFzTUVKQlFUQkNMRWxCUVRKRExFVkJRVVVzVFVGQll6dEpRVU0xUlN4SlFVRkJMSE5DUVVGblFpeEZRVUZGTEhkRFFVRlBMRU5CUVZNN1NVRkRla01zVFVGQlRTeHpRa0ZEUkN4SlFVRkpMRWxCUTFBc1QwRkJUeXhGUVVGRkxFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUXl4UFFVRlBMRWxCUVVzc1QwRkJRU3hwUWtGQmFVSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1RVRkJUU3hEUVVGRExFVkJRV3hETEVOQlFXdERMRU5CUVVNc1NVRkRja1U3UVVGRFNpeERRVUZETzBGQlJVUXNNRUpCUVRCQ0xFbEJRVEpETEVWQlFVVXNUVUZCWXp0SlFVTTFSU3hKUVVGQkxITkNRVUZuUWl4RlFVRkZMSGREUVVGUExFTkJRVk03U1VGRGVrTXNUVUZCVFN4elFrRkRSQ3hKUVVGSkxFbEJRMUFzVDBGQlR5eEZRVUZGTEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJReXhQUVVGUExFbEJRVXNzVDBGQlFTeHBRa0ZCYVVJc1EwRkJReXhQUVVGUExFVkJRVVVzVFVGQlRTeERRVUZETEVWQlFXeERMRU5CUVd0RExFTkJRVU1zU1VGRGNrVTdRVUZEU2l4RFFVRkRPMEZCUlVRc09FSkJRVGhDTEVsQlFUaENMRVZCUVVVc1RVRkJZenRKUVVNeFJTeHJSVUZCYTBVN1NVRkRiRVVzZVVOQlFYbERPMGxCUTNwRExFbEJRVTBzYTBKQlFYVkVMRVZCUVhSRUxGbEJRVkVzUlVGQlJTeHJRa0ZCWXl4RlFVRkZMR2RFUVVFMFFpeERRVUZETzBsQlJUbEVMSGRFUVVGM1JEdEpRVU5xUkN4SlFVRkJMR2RDUVVGVkxFVkJRVVVzTUVKQlFXOUNMRVZCUVVVc2FVSkJRVmNzUlVGQlJTeHRSVUZCV1N4RFFVRlRPMGxCUlRORkxFMUJRVTBzYzBKQlEwUXNVMEZCVXl4SlFVTmFMRXRCUVVzc2RVSkJRMEVzUTBGQlF5eEhRVUZITEVkQlFVY3NSVUZCUXl4SFFVRkhMRXRCUVVFc1JVRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVU5zUWl4RFFVRkRMRTFCUVUwc1IwRkJSeXhGUVVGRExFMUJRVTBzVVVGQlFTeEZRVUZETEVkQlFVVXNSVUZCUlN4RFFVRkRMRWRCUlRWQ0xFbEJRVWtzUlVGQlJTeHhRa0ZCY1VJc2IwSkJRM3BDTEVsQlFVa3NUVUZCUVR0WlFVTktMRkZCUVZFc1ZVRkJRU3hKUVVOTUxFTkJRVU1zVTBGQlV5eEhRVUZITEVWQlFVTXNVMEZCVXl4WFFVRkJMRVZCUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zUjBGRGFFTXNUVUZCVFN4RFFVRkRMRWxCUTFZN1FVRkRTaXhEUVVGRE8wRkJSVVFzTmtOQlFUWkRMRWxCUVhkRU8wbEJSV3BITEUxQlFVMHNRMEZCUXl4elFrRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0QlFVTjBReXhEUVVGRE8wRkJSVVFzSzBKQlFTdENMRWxCUVhkRUxFVkJRVVVzVFVGQll6dEpRVU55Unl4RlFVRkZMRU5CUVVNc1EwRkJReXh0UTBGQmJVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VTXNkMEpCUVhkQ08xRkJRM2hDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRzFDUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNMVFpeE5RVUZOTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEYmtNc1EwRkJRenRSUVVWRUxFbEJRVTBzWVVGQllTeEhRVUZITEUxQlFVMHNTVUZCU1N4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8xRkJReTlETEVsQlFVMHNaVUZCWlN4SFFVRkhMR0ZCUVdFc1NVRkJTeXhKUVVGSkxFTkJRVU1zU1VGQlNTeExRVUZMTEZkQlFVazdXVUZETVVRc1pVRkJVU3hEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RlFVRkZMR0ZCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU4wUkN4SlFVRk5MR2RDUVVGblFpeEhRVUZITEdGQlFXRXNTVUZCU1N4RFFVTjRReXhEUVVGRExHRkJRV0VzUTBGQlF5eEpRVUZKTEVsQlFVa3NTVUZCU1N4RFFVRkRMRWxCUVVrc1MwRkJTeXhYUVVGSkxFTkJRVU03V1VGRE1VTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hMUVVGTExGZEJRVmNzU1VGQlNTeEpRVUZKTEVOQlFVTXNTVUZCU1N4TFFVRkxMRmRCUVVrc1EwRkJReXhEUVVNelJDeERRVUZETzFGQlEwWXNjVVZCUVhGRk8xRkJRM0pGTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeEpRVUZKTEdWQlFXVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRlRU1zVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFbEJRVWtzUlVGQlJTeG5Ra0ZCWjBJc1JVRkJSU3hsUVVGbExFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdVVUZETTBVc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4MVFrRkJkVUk3U1VGRGRFTXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF5OURMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJSVVFzTmtKQlFUWkNMRWxCUVdNN1NVRkRla01zU1VGQlRTeEpRVUZKTEVkQlFVY3NNRUpCUVdVc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeEZRVUZGTEZkQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXk5RExFbEJRVTBzU1VGQlNTeEhRVUZITERCQ1FVRmxMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeFhRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXZReXhKUVVGTkxFdEJRVXNzUjBGQlJ5d3dRa0ZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzV1VGQlJTeERRVUZETEVOQlFVTTdTVUZEYWtRc1NVRkJUU3hMUVVGTExFZEJRVWNzTUVKQlFXVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxGbEJRVVVzUTBGQlF5eERRVUZETzBsQlEycEVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRla01zU1VGQlRTeGpRVUZqTEVkQlFVY3NaMEpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU4yUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1Q0xHTkJRV01zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4SFFVRkhMR05CUVdNc1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETzFsQlEzWkVMRTlCUVU4c1kwRkJZeXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTTdVVUZEY0VNc1EwRkJRenRSUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrSXNZMEZCWXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFZEJRVWNzWTBGQll5eERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRkZMRU5CUVVNN1dVRkRka1FzVDBGQlR5eGpRVUZqTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVOd1F5eERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJRenRKUVVONFFpeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOa0xFTkJRVU03UVVGSFJDd3JRa0ZCSzBJN1FVRkRMMElzTUVKQlFUQkNMRWxCUVdNc1JVRkJSU3huUWtGQmVVSXNSVUZCUlN4bFFVRjNRaXhGUVVGRkxFMUJRV003U1VGRGNFY3NTVUZCUVN4blFrRkJTU3hGUVVGRkxIZENRVUZSTEVWQlFVVXNjMFJCUVZrc1EwRkJVenRKUVVNMVF5eEpRVUZOTEV0QlFVc3NSMEZCUnl4RFFVRkRMRVZCUVVNc1NVRkJTU3hOUVVGQkxFVkJRVVVzVVVGQlVTeFZRVUZCTEVWQlFVTXNRMEZCUXl4RFFVRkRPMGxCUldwRExDdERRVUVyUXp0SlFVTXZReXhKUVVGTkxGVkJRVlVzUjBGQlJ5eGhRVUZMTEVOQlFVTXNTVUZCU1N4RlFVRkZMRkZCUVZFc1JVRkJSU3hOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETEV0QlFVc3NSMEZCUnl4VFFVRlRMRU5CUVVNc1EwRkJRenRKUVVVMVJTeEpRVUZKTEdWQlFXVXNSMEZCUnl4UlFVRlJMRU5CUVVNN1NVRkRMMElzUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOU0xFbEJRVUVzTWtOQlFTdENMRVZCUVVVc01FSkJRVTBzUTBGQlpUdFJRVU0zUkN4bFFVRmxMSGRDUVVOV0xGRkJRVkVzWlVGRFZpeHBRa0ZCYVVJc2VVSkJRMklzVVVGQlVTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFVkJRek5DTEVOQlFVTXNUVUZCVFN4SFFVRkhMRVZCUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUlVGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4UFFVVnlReXhEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNFSXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJRenRaUVVOVUxFbEJRVWtzUlVGQlJUdG5Ra0ZEU2l4SlFVRkpMRVZCUVVVc1RVRkJUVHRuUWtGRFdpeEpRVUZKTEVWQlFVVXNZVUZCWVR0aFFVTndRanRaUVVORUxGRkJRVkVzUlVGQlJTeGxRVUZsTzFOQlF6RkNMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY2tJc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF6dFpRVU5VTEVsQlFVa3NSVUZCUlR0blFrRkRTaXhKUVVGSkxFVkJRVVVzVDBGQlR6dG5Ra0ZEWWl4TlFVRk5MRVZCUVVVc1NVRkJTVHRuUWtGRFdpeEpRVUZKTEVWQlFVVXNZMEZCWXp0aFFVTnlRanRaUVVORUxGRkJRVkVzUlVGQlJTeGxRVUZsTzFOQlF6RkNMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJDeE5RVUZOTEhOQ1FVTkVMRk5CUVZNc1NVRkRXaXhMUVVGTExFOUJRVUVzU1VGRFREczdRVUZEU2l4RFFVRkRPMEZCUlVRc2JVVkJRVzFGTzBGQlJXNUZMSGRFUVVGM1JEdEJRVU40UkN4dlFrRkJiMElzU1VGQlV5eEZRVUZGTEZOQlFUUkNPMGxCUTNwRUxGTkJRVk1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCVXl4UlFVRlJPMUZCUTJwRExIZEZRVUYzUlR0UlFVTjRSU3hKUVVGTkxGbEJRVmtzUjBGQlJ5eERRVUZETEU5QlFVOHNSVUZCUlN4TlFVRk5MRVZCUVVVc1QwRkJUeXhGUVVGRkxGVkJRVlVzUlVGQlJTeExRVUZMTEVWQlFVVXNWMEZCVnl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEZRVUZGTEVkQlFVYzdXVUZETlVZc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyaERMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRla0lzUTBGQlF6dFpRVU5FTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRXQ3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEVUN4SlFVRk5MRWRCUVVjc1IwRkJSeXhYUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdVVUZETDBJc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hSUVVGUkxFTkJRVU03U1VGRGNFTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRTQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlEyUXNRMEZCUXp0QlFVVkVMRGhGUVVFNFJUdEJRVU01UlN4MVFrRkJkVUlzU1VGQk5FTXNSVUZCUlN4SlFVRmpPMGxCUVdRc2NVSkJRVUVzUlVGQlFTeFRRVUZqTzBsQlEycEdMR3REUVVGclF6dEpRVU5zUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVFc1MwRkJTenRaUVVOMFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjBRaXhWUVVGVkxFTkJRVU1zU1VGQlNTeEZRVUZGTEZWQlFWVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtRc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTk9MR0ZCUVdFc1EwRkJReXhMUVVGTExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdXVUZETjBJc1EwRkJRenRSUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFhRVUZYTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemRDTEZWQlFWVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1ZVRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVJDeGhRVUZoTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVU5xUXl4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VSXNWVUZCVlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhFTEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzBsQlEycERMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU01UWl4SlFVRk5MRk5CUVZNc1IwRkJSeXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEzQkZMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlFTeExRVUZMTzFsQlEzSkNMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM1JDTEZWQlFWVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1ZVRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONlJDeERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRMDRzWVVGQllTeERRVUZETEV0QlFVc3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVNM1FpeERRVUZETzFGQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4VlFVRlZMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVFUXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlJVUXNiVVZCUVcxRk8wRkJRMjVGTEcxQ1FVRXdRaXhKUVVFMFF6dEpRVU53UlN4TlFVRk5MRU5CUVVNc1YwRkJTU3hEUVVGRExHRkJRV0VzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTI1RExFTkJRVU03UVVGR1JDdzRRa0ZGUXp0QlFVVkVMRzFDUVVFd1FpeEpRVUYzUXl4RlFVRkZMRTFCUVdVN1NVRkRha1lzVFVGQlRTeEhRVUZITEUxQlFVMHNTVUZCU1N4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMSE5DUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlFpeE5RVUZOTEVOQlFVTXNZVUZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEZGQlFWRXNSVUZETjBJc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eExRVUZMTEVkQlFVY3NVMEZCVXl4RFFVTnNReXhMUVVGTExFbEJRVWtzUTBGQlF6dEpRVU51UWl4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU5tTEVOQlFVTTdRVUZTUkN3NFFrRlJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xudmFyIGFnZ3JlZ2F0ZV8xID0gcmVxdWlyZShcIi4vYWdncmVnYXRlXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG52YXIgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi9maWVsZGRlZlwiKTtcbnZhciBtYXJrXzEgPSByZXF1aXJlKFwiLi9tYXJrXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy5TVEFDS0FCTEVfTUFSS1MgPSBbbWFya18xLkJBUiwgbWFya18xLkFSRUEsIG1hcmtfMS5SVUxFLCBtYXJrXzEuUE9JTlQsIG1hcmtfMS5DSVJDTEUsIG1hcmtfMS5TUVVBUkUsIG1hcmtfMS5MSU5FLCBtYXJrXzEuVEVYVCwgbWFya18xLlRJQ0tdO1xuZXhwb3J0cy5TVEFDS19CWV9ERUZBVUxUX01BUktTID0gW21hcmtfMS5CQVIsIG1hcmtfMS5BUkVBXTtcbi8vIE5vdGU6IENvbXBhc3NRTCB1c2VzIHRoaXMgbWV0aG9kIGFuZCBvbmx5IHBhc3MgaW4gcmVxdWlyZWQgcHJvcGVydGllcyBvZiBlYWNoIGFyZ3VtZW50IG9iamVjdC5cbi8vIElmIHJlcXVpcmVkIHByb3BlcnRpZXMgY2hhbmdlLCBtYWtlIHN1cmUgdG8gdXBkYXRlIENvbXBhc3NRTC5cbmZ1bmN0aW9uIHN0YWNrKG0sIGVuY29kaW5nLCBzdGFja0NvbmZpZykge1xuICAgIHZhciBtYXJrID0gbWFya18xLmlzTWFya0RlZihtKSA/IG0udHlwZSA6IG07XG4gICAgLy8gU2hvdWxkIGhhdmUgc3RhY2thYmxlIG1hcmtcbiAgICBpZiAoIXV0aWxfMS5jb250YWlucyhleHBvcnRzLlNUQUNLQUJMRV9NQVJLUywgbWFyaykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNob3VsZCBiZSBhZ2dyZWdhdGUgcGxvdFxuICAgIGlmICghZW5jb2RpbmdfMS5pc0FnZ3JlZ2F0ZShlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNob3VsZCBoYXZlIGdyb3VwaW5nIGxldmVsIG9mIGRldGFpbFxuICAgIHZhciBzdGFja0J5ID0gY2hhbm5lbF8xLlNUQUNLX0dST1VQX0NIQU5ORUxTLnJlZHVjZShmdW5jdGlvbiAoc2MsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nXzEuY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxEZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgICh1dGlsXzEuaXNBcnJheShjaGFubmVsRGVmKSA/IGNoYW5uZWxEZWYgOiBbY2hhbm5lbERlZl0pLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkRGVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZihmaWVsZERlZikgJiYgIWZpZWxkRGVmLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzYy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZERlZjogZmllbGREZWZcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjO1xuICAgIH0sIFtdKTtcbiAgICBpZiAoc3RhY2tCeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEhhcyBvbmx5IG9uZSBhZ2dyZWdhdGUgYXhpc1xuICAgIHZhciBoYXNYRmllbGQgPSBmaWVsZGRlZl8xLmlzRmllbGREZWYoZW5jb2RpbmcueCk7XG4gICAgdmFyIGhhc1lGaWVsZCA9IGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy55KTtcbiAgICB2YXIgeElzQWdncmVnYXRlID0gZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLngpICYmICEhZW5jb2RpbmcueC5hZ2dyZWdhdGU7XG4gICAgdmFyIHlJc0FnZ3JlZ2F0ZSA9IGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy55KSAmJiAhIWVuY29kaW5nLnkuYWdncmVnYXRlO1xuICAgIGlmICh4SXNBZ2dyZWdhdGUgIT09IHlJc0FnZ3JlZ2F0ZSkge1xuICAgICAgICB2YXIgZmllbGRDaGFubmVsID0geElzQWdncmVnYXRlID8gY2hhbm5lbF8xLlggOiBjaGFubmVsXzEuWTtcbiAgICAgICAgdmFyIGZpZWxkRGVmID0gZW5jb2RpbmdbZmllbGRDaGFubmVsXTtcbiAgICAgICAgdmFyIGZpZWxkQ2hhbm5lbEFnZ3JlZ2F0ZSA9IGZpZWxkRGVmLmFnZ3JlZ2F0ZTtcbiAgICAgICAgdmFyIGZpZWxkQ2hhbm5lbFNjYWxlID0gZmllbGREZWYuc2NhbGU7XG4gICAgICAgIHZhciBzdGFja09mZnNldCA9IG51bGw7XG4gICAgICAgIGlmIChmaWVsZERlZi5zdGFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja09mZnNldCA9IGZpZWxkRGVmLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxfMS5jb250YWlucyhleHBvcnRzLlNUQUNLX0JZX0RFRkFVTFRfTUFSS1MsIG1hcmspKSB7XG4gICAgICAgICAgICAvLyBCYXIgYW5kIEFyZWEgd2l0aCBzdW0gb3BzIGFyZSBhdXRvbWF0aWNhbGx5IHN0YWNrZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgc3RhY2tPZmZzZXQgPSBzdGFja0NvbmZpZyA9PT0gdW5kZWZpbmVkID8gJ3plcm8nIDogc3RhY2tDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFja09mZnNldCA9IHN0YWNrQ29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhY2tPZmZzZXQgfHwgc3RhY2tPZmZzZXQgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc3RhY2tlZCwgY2hlY2sgaWYgaXQgcXVhbGlmaWVzIGZvciBzdGFja2luZyAoYW5kIGxvZyB3YXJuaW5nIGlmIG5vdCBxdWFsaWZpZWQuKVxuICAgICAgICBpZiAoZmllbGRDaGFubmVsU2NhbGUgJiYgZmllbGRDaGFubmVsU2NhbGUudHlwZSAmJiBmaWVsZENoYW5uZWxTY2FsZS50eXBlICE9PSBzY2FsZV8xLlNjYWxlVHlwZS5MSU5FQVIpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmNhbm5vdFN0YWNrTm9uTGluZWFyU2NhbGUoZmllbGRDaGFubmVsU2NhbGUudHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuY29kaW5nXzEuY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBmaWVsZENoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gY2hhbm5lbF8xLlgyIDogY2hhbm5lbF8xLlkyKSkge1xuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuY2Fubm90U3RhY2tSYW5nZWRNYXJrKGZpZWxkQ2hhbm5lbCkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoYWdncmVnYXRlXzEuU1VNX09QUywgZmllbGRDaGFubmVsQWdncmVnYXRlKSkge1xuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuY2Fubm90U3RhY2tOb25TdW1tYXRpdmVBZ2dyZWdhdGUoZmllbGRDaGFubmVsQWdncmVnYXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBieUNoYW5uZWw6IHhJc0FnZ3JlZ2F0ZSA/IChoYXNZRmllbGQgPyBjaGFubmVsXzEuWSA6IG51bGwpIDogKGhhc1hGaWVsZCA/IGNoYW5uZWxfMS5YIDogbnVsbCksXG4gICAgICAgICAgICBmaWVsZENoYW5uZWw6IGZpZWxkQ2hhbm5lbCxcbiAgICAgICAgICAgIHN0YWNrQnk6IHN0YWNrQnksXG4gICAgICAgICAgICBvZmZzZXQ6IHN0YWNrT2Zmc2V0XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5zdGFjayA9IHN0YWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzNSaFkyc3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmMzUmhZMnN1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3d5UWtGQk5rSTdRVUZGTjBJc2VVTkJRVzlETzBGQlEzQkRMSEZEUVVGelJUdEJRVU4wUlN4MVEwRkJhMFU3UVVGRGJFVXNkVU5CUVhsRk8wRkJRM3BGTEN0Q1FVRXdSenRCUVVNeFJ5eHBRMEZCYTBNN1FVRkRiRU1zSzBKQlFYbERPMEZCTmtJMVFpeFJRVUZCTEdWQlFXVXNSMEZCUnl4RFFVRkRMRlZCUVVjc1JVRkJSU3hYUVVGSkxFVkJRVVVzVjBGQlNTeEZRVUZGTEZsQlFVc3NSVUZCUlN4aFFVRk5MRVZCUVVVc1lVRkJUU3hGUVVGRkxGZEJRVWtzUlVGQlJTeFhRVUZKTEVWQlFVVXNWMEZCU1N4RFFVRkRMRU5CUVVNN1FVRkROMFVzVVVGQlFTeHpRa0ZCYzBJc1IwRkJSeXhEUVVGRExGVkJRVWNzUlVGQlJTeFhRVUZKTEVOQlFVTXNRMEZCUXp0QlFVVnNSQ3hwUjBGQmFVYzdRVUZEYWtjc1owVkJRV2RGTzBGQlJXaEZMR1ZCUVhOQ0xFTkJRV2xDTEVWQlFVVXNVVUZCZVVJc1JVRkJSU3hYUVVGM1FqdEpRVU14Uml4SlFVRk5MRWxCUVVrc1IwRkJSeXhuUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFZEJRVWNzUTBGQlF5eERRVUZETzBsQlEzWkRMRFpDUVVFMlFqdEpRVU0zUWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHVkJRVkVzUTBGQlF5eDFRa0ZCWlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55UXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZFTERKQ1FVRXlRanRKUVVNelFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSE5DUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpOQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlVRc2RVTkJRWFZETzBsQlEzWkRMRWxCUVUwc1QwRkJUeXhIUVVGSExEaENRVUZ2UWl4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGRExFVkJRVVVzUlVGQlJTeFBRVUZQTzFGQlEzUkVMRVZCUVVVc1EwRkJReXhEUVVGRExEQkNRVUZsTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4yUXl4SlFVRk5MRlZCUVZVc1IwRkJSeXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEY2tNc1EwRkJReXhqUVVGUExFTkJRVU1zVlVGQlZTeERRVUZETEVkQlFVY3NWVUZCVlN4SFFVRkhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCUXl4UlFVRlJPMmRDUVVOcVJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEyaEVMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU03ZDBKQlEwNHNUMEZCVHl4RlFVRkZMRTlCUVU4N2QwSkJRMmhDTEZGQlFWRXNSVUZCUlN4UlFVRlJPM0ZDUVVOdVFpeERRVUZETEVOQlFVTTdaMEpCUTB3c1EwRkJRenRaUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEwd3NRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03U1VGRFdpeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkZVQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVrSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRlJDdzRRa0ZCT0VJN1NVRkRPVUlzU1VGQlRTeFRRVUZUTEVkQlFVY3NjVUpCUVZVc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtNc1NVRkJUU3hUUVVGVExFZEJRVWNzY1VKQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVrTXNTVUZCVFN4WlFVRlpMRWRCUVVjc2NVSkJRVlVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRPMGxCUTNSRkxFbEJRVTBzV1VGQldTeEhRVUZITEhGQ1FVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF6dEpRVVYwUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFdEJRVXNzV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnNReXhKUVVGTkxGbEJRVmtzUjBGQlJ5eFpRVUZaTEVkQlFVY3NWMEZCUXl4SFFVRkhMRmRCUVVNc1EwRkJRenRSUVVNeFF5eEpRVUZOTEZGQlFWRXNSMEZCUnl4UlFVRlJMRU5CUVVNc1dVRkJXU3hEUVVFMlFpeERRVUZETzFGQlEzQkZMRWxCUVUwc2NVSkJRWEZDTEVkQlFVY3NVVUZCVVN4RFFVRkRMRk5CUVZNc1EwRkJRenRSUVVOcVJDeEpRVUZOTEdsQ1FVRnBRaXhIUVVGSExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZGZWtNc1NVRkJTU3hYUVVGWExFZEJRV2RDTEVsQlFVa3NRMEZCUXp0UlFVTndReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrTXNWMEZCVnl4SFFVRkhMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU03VVVGREwwSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZSTEVOQlFVTXNPRUpCUVhOQ0xFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RUxHbEZRVUZwUlR0WlFVTnFSU3hYUVVGWExFZEJRVWNzVjBGQlZ5eExRVUZMTEZOQlFWTXNSMEZCUnl4TlFVRk5MRWRCUVVjc1YwRkJWeXhEUVVGRE8xRkJRMnBGTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xGZEJRVmNzUjBGQlJ5eFhRVUZYTEVOQlFVTTdVVUZETlVJc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNWMEZCVnl4SlFVRkpMRmRCUVZjc1MwRkJTeXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRFpDeERRVUZETzFGQlJVUXNjVVpCUVhGR08xRkJRM0pHTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2xDUVVGcFFpeEpRVUZKTEdsQ1FVRnBRaXhEUVVGRExFbEJRVWtzU1VGQlNTeHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFdEJRVXNzYVVKQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJReTlHTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eDVRa0ZCZVVJc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNNRUpCUVdVc1EwRkJReXhSUVVGUkxFVkJRVVVzV1VGQldTeExRVUZMTEZkQlFVTXNSMEZCUnl4WlFVRkZMRWRCUVVjc1dVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkVMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpGRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eGxRVUZSTEVOQlFVTXNiVUpCUVU4c1JVRkJSU3h4UWtGQmNVSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNNVF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zWjBOQlFXZERMRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRE8xbEJRMHdzWTBGQll5eEZRVUZGTEZsQlFWa3NSMEZCUnl4RFFVRkRMRk5CUVZNc1IwRkJSeXhYUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4VFFVRlRMRWRCUVVjc1YwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF6dFpRVU01UlN4WlFVRlpMRVZCUVVVc1dVRkJXVHRaUVVNeFFpeFBRVUZQTEVWQlFVVXNUMEZCVHp0WlFVTm9RaXhOUVVGTkxFVkJRVVVzVjBGQlZ6dFRRVU53UWl4RFFVRkRPMGxCUTBvc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEWkN4RFFVRkRPMEZCYkVaRUxITkNRV3RHUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi9kYXRldGltZVwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUaW1lVW5pdDtcbihmdW5jdGlvbiAoVGltZVVuaXQpIHtcbiAgICBUaW1lVW5pdC5ZRUFSID0gJ3llYXInO1xuICAgIFRpbWVVbml0Lk1PTlRIID0gJ21vbnRoJztcbiAgICBUaW1lVW5pdC5EQVkgPSAnZGF5JztcbiAgICBUaW1lVW5pdC5EQVRFID0gJ2RhdGUnO1xuICAgIFRpbWVVbml0LkhPVVJTID0gJ2hvdXJzJztcbiAgICBUaW1lVW5pdC5NSU5VVEVTID0gJ21pbnV0ZXMnO1xuICAgIFRpbWVVbml0LlNFQ09ORFMgPSAnc2Vjb25kcyc7XG4gICAgVGltZVVuaXQuTUlMTElTRUNPTkRTID0gJ21pbGxpc2Vjb25kcyc7XG4gICAgVGltZVVuaXQuWUVBUk1PTlRIID0gJ3llYXJtb250aCc7XG4gICAgVGltZVVuaXQuWUVBUk1PTlRIREFURSA9ICd5ZWFybW9udGhkYXRlJztcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFSE9VUlMgPSAneWVhcm1vbnRoZGF0ZWhvdXJzJztcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFSE9VUlNNSU5VVEVTID0gJ3llYXJtb250aGRhdGVob3Vyc21pbnV0ZXMnO1xuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSU01JTlVURVNTRUNPTkRTID0gJ3llYXJtb250aGRhdGVob3Vyc21pbnV0ZXNzZWNvbmRzJztcbiAgICAvLyBNT05USERBVEUgYWx3YXlzIGluY2x1ZGUgMjkgRmVicnVhcnkgc2luY2Ugd2UgdXNlIHllYXIgMHRoICh3aGljaCBpcyBhIGxlYXAgeWVhcik7XG4gICAgVGltZVVuaXQuTU9OVEhEQVRFID0gJ21vbnRoZGF0ZSc7XG4gICAgVGltZVVuaXQuSE9VUlNNSU5VVEVTID0gJ2hvdXJzbWludXRlcyc7XG4gICAgVGltZVVuaXQuSE9VUlNNSU5VVEVTU0VDT05EUyA9ICdob3Vyc21pbnV0ZXNzZWNvbmRzJztcbiAgICBUaW1lVW5pdC5NSU5VVEVTU0VDT05EUyA9ICdtaW51dGVzc2Vjb25kcyc7XG4gICAgVGltZVVuaXQuU0VDT05EU01JTExJU0VDT05EUyA9ICdzZWNvbmRzbWlsbGlzZWNvbmRzJztcbiAgICBUaW1lVW5pdC5RVUFSVEVSID0gJ3F1YXJ0ZXInO1xuICAgIFRpbWVVbml0LllFQVJRVUFSVEVSID0gJ3llYXJxdWFydGVyJztcbiAgICBUaW1lVW5pdC5RVUFSVEVSTU9OVEggPSAncXVhcnRlcm1vbnRoJztcbiAgICBUaW1lVW5pdC5ZRUFSUVVBUlRFUk1PTlRIID0gJ3llYXJxdWFydGVybW9udGgnO1xufSkoVGltZVVuaXQgPSBleHBvcnRzLlRpbWVVbml0IHx8IChleHBvcnRzLlRpbWVVbml0ID0ge30pKTtcbi8qKiBUaW1lIFVuaXQgdGhhdCBvbmx5IGNvcnJlc3BvbmRzIHRvIG9ubHkgb25lIHBhcnQgb2YgRGF0ZSBvYmplY3RzLiAqL1xuZXhwb3J0cy5TSU5HTEVfVElNRVVOSVRTID0gW1xuICAgIFRpbWVVbml0LllFQVIsXG4gICAgVGltZVVuaXQuUVVBUlRFUixcbiAgICBUaW1lVW5pdC5NT05USCxcbiAgICBUaW1lVW5pdC5EQVksXG4gICAgVGltZVVuaXQuREFURSxcbiAgICBUaW1lVW5pdC5IT1VSUyxcbiAgICBUaW1lVW5pdC5NSU5VVEVTLFxuICAgIFRpbWVVbml0LlNFQ09ORFMsXG4gICAgVGltZVVuaXQuTUlMTElTRUNPTkRTLFxuXTtcbnZhciBTSU5HTEVfVElNRVVOSVRfSU5ERVggPSBleHBvcnRzLlNJTkdMRV9USU1FVU5JVFMucmVkdWNlKGZ1bmN0aW9uIChkLCB0aW1lVW5pdCkge1xuICAgIGRbdGltZVVuaXRdID0gdHJ1ZTtcbiAgICByZXR1cm4gZDtcbn0sIHt9KTtcbmZ1bmN0aW9uIGlzU2luZ2xlVGltZVVuaXQodGltZVVuaXQpIHtcbiAgICByZXR1cm4gISFTSU5HTEVfVElNRVVOSVRfSU5ERVhbdGltZVVuaXRdO1xufVxuZXhwb3J0cy5pc1NpbmdsZVRpbWVVbml0ID0gaXNTaW5nbGVUaW1lVW5pdDtcbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIG9ubHkgaGF2ZSB0aGUgbWVhc3VyZW1lbnRzIHJlbGV2YW50IHRvIHRoZSBzcGVjaWZpZWQgdW5pdFxuICogaS5lLiAoJ3llYXJtb250aCcsICcyMDAwLTEyLTA0IDA3OjU4OjE0JykgLT4gJzIwMDAtMTItMDEgMDA6MDA6MDAnXG4gKiBOb3RlOiB0aGUgYmFzZSBkYXRlIGlzIEphbiAwMSAxOTAwIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnQodW5pdCwgZGF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZSgwLCAwLCAxLCAwLCAwLCAwLCAwKTsgLy8gc3RhcnQgd2l0aCB1bmlmb3JtIGRhdGVcbiAgICBleHBvcnRzLlNJTkdMRV9USU1FVU5JVFMuZm9yRWFjaChmdW5jdGlvbiAoc2luZ2xlVW5pdCkge1xuICAgICAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh1bml0LCBzaW5nbGVVbml0KSkge1xuICAgICAgICAgICAgc3dpdGNoIChzaW5nbGVVbml0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5EQVk6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgdG8gVGltZVVuaXRzIGNvbnRhaW5pbmcgXFwnZGF5XFwnJyk7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5ZRUFSOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5RVUFSVEVSOlxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZSBxdWFydGVyIGJ5IHNldHRpbmcgbW9udGggdG8gYmUgdGhlIGZpcnN0IG9mIHRoZSBxdWFydGVyIGkuZS4gbWF5ICg0KSAtPiBhcHJpbCAoMylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldE1vbnRoKChNYXRoLmZsb29yKGRhdGUuZ2V0TW9udGgoKSAvIDMpKSAqIDMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0Lk1PTlRIOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5EQVRFOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0RGF0ZShkYXRlLmdldERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGltZVVuaXQuSE9VUlM6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0Lk1JTlVURVM6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5TRUNPTkRTOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0U2Vjb25kcyhkYXRlLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGltZVVuaXQuTUlMTElTRUNPTkRTOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbnZlcnQgPSBjb252ZXJ0O1xuZXhwb3J0cy5NVUxUSV9USU1FVU5JVFMgPSBbXG4gICAgVGltZVVuaXQuWUVBUlFVQVJURVIsXG4gICAgVGltZVVuaXQuWUVBUlFVQVJURVJNT05USCxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEgsXG4gICAgVGltZVVuaXQuWUVBUk1PTlRIREFURSxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFSE9VUlMsXG4gICAgVGltZVVuaXQuWUVBUk1PTlRIREFURUhPVVJTTUlOVVRFUyxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFSE9VUlNNSU5VVEVTU0VDT05EUyxcbiAgICBUaW1lVW5pdC5RVUFSVEVSTU9OVEgsXG4gICAgVGltZVVuaXQuSE9VUlNNSU5VVEVTLFxuICAgIFRpbWVVbml0LkhPVVJTTUlOVVRFU1NFQ09ORFMsXG4gICAgVGltZVVuaXQuTUlOVVRFU1NFQ09ORFMsXG4gICAgVGltZVVuaXQuU0VDT05EU01JTExJU0VDT05EUyxcbl07XG52YXIgTVVMVElfVElNRVVOSVRfSU5ERVggPSBleHBvcnRzLk1VTFRJX1RJTUVVTklUUy5yZWR1Y2UoZnVuY3Rpb24gKGQsIHRpbWVVbml0KSB7XG4gICAgZFt0aW1lVW5pdF0gPSB0cnVlO1xuICAgIHJldHVybiBkO1xufSwge30pO1xuZnVuY3Rpb24gaXNNdWx0aVRpbWVVbml0KHRpbWVVbml0KSB7XG4gICAgcmV0dXJuICEhTVVMVElfVElNRVVOSVRfSU5ERVhbdGltZVVuaXRdO1xufVxuZXhwb3J0cy5pc011bHRpVGltZVVuaXQgPSBpc011bHRpVGltZVVuaXQ7XG5leHBvcnRzLlRJTUVVTklUUyA9IFtcbiAgICBUaW1lVW5pdC5ZRUFSLFxuICAgIFRpbWVVbml0LlFVQVJURVIsXG4gICAgVGltZVVuaXQuTU9OVEgsXG4gICAgVGltZVVuaXQuREFZLFxuICAgIFRpbWVVbml0LkRBVEUsXG4gICAgVGltZVVuaXQuSE9VUlMsXG4gICAgVGltZVVuaXQuTUlOVVRFUyxcbiAgICBUaW1lVW5pdC5TRUNPTkRTLFxuICAgIFRpbWVVbml0Lk1JTExJU0VDT05EUyxcbiAgICBUaW1lVW5pdC5ZRUFSUVVBUlRFUixcbiAgICBUaW1lVW5pdC5ZRUFSUVVBUlRFUk1PTlRILFxuICAgIFRpbWVVbml0LllFQVJNT05USCxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFLFxuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSUyxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFSE9VUlNNSU5VVEVTLFxuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSU01JTlVURVNTRUNPTkRTLFxuICAgIFRpbWVVbml0LlFVQVJURVJNT05USCxcbiAgICBUaW1lVW5pdC5IT1VSU01JTlVURVMsXG4gICAgVGltZVVuaXQuSE9VUlNNSU5VVEVTU0VDT05EUyxcbiAgICBUaW1lVW5pdC5NSU5VVEVTU0VDT05EUyxcbiAgICBUaW1lVW5pdC5TRUNPTkRTTUlMTElTRUNPTkRTXG5dO1xuLyoqIFJldHVybnMgdHJ1ZSBpZiBmdWxsVGltZVVuaXQgY29udGFpbnMgdGhlIHRpbWVVbml0LCBmYWxzZSBvdGhlcndpc2UuICovXG5mdW5jdGlvbiBjb250YWluc1RpbWVVbml0KGZ1bGxUaW1lVW5pdCwgdGltZVVuaXQpIHtcbiAgICB2YXIgaW5kZXggPSBmdWxsVGltZVVuaXQuaW5kZXhPZih0aW1lVW5pdCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgJiZcbiAgICAgICAgKHRpbWVVbml0ICE9PSBUaW1lVW5pdC5TRUNPTkRTIHx8XG4gICAgICAgICAgICBpbmRleCA9PT0gMCB8fFxuICAgICAgICAgICAgZnVsbFRpbWVVbml0LmNoYXJBdChpbmRleCAtIDEpICE9PSAnaScgLy8gZXhjbHVkZSBtaWxsaXNlY29uZHNcbiAgICAgICAgKTtcbn1cbmV4cG9ydHMuY29udGFpbnNUaW1lVW5pdCA9IGNvbnRhaW5zVGltZVVuaXQ7XG4vKipcbiAqIFJldHVybnMgVmVnYSBleHByZXNzc2lvbiBmb3IgYSBnaXZlbiB0aW1lVW5pdCBhbmQgZmllbGRSZWZcbiAqL1xuZnVuY3Rpb24gZmllbGRFeHByKGZ1bGxUaW1lVW5pdCwgZmllbGQpIHtcbiAgICB2YXIgZmllbGRSZWYgPSBcImRhdHVtW1wiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKGZpZWxkKSArIFwiXVwiO1xuICAgIGZ1bmN0aW9uIGZ1bmModGltZVVuaXQpIHtcbiAgICAgICAgaWYgKHRpbWVVbml0ID09PSBUaW1lVW5pdC5RVUFSVEVSKSB7XG4gICAgICAgICAgICAvLyBxdWFydGVyIHN0YXJ0aW5nIGF0IDAgKDAsMyw2LDkpLlxuICAgICAgICAgICAgcmV0dXJuIFwiKHF1YXJ0ZXIoXCIgKyBmaWVsZFJlZiArIFwiKS0xKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVVbml0ICsgXCIoXCIgKyBmaWVsZFJlZiArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkID0gZXhwb3J0cy5TSU5HTEVfVElNRVVOSVRTLnJlZHVjZShmdW5jdGlvbiAoX2QsIHR1KSB7XG4gICAgICAgIGlmIChjb250YWluc1RpbWVVbml0KGZ1bGxUaW1lVW5pdCwgdHUpKSB7XG4gICAgICAgICAgICBfZFt0dV0gPSBmdW5jKHR1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2Q7XG4gICAgfSwge30pO1xuICAgIGlmIChkLmRheSAmJiB1dGlsXzEua2V5cyhkKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmRheVJlcGxhY2VkV2l0aERhdGUoZnVsbFRpbWVVbml0KSk7XG4gICAgICAgIGRlbGV0ZSBkLmRheTtcbiAgICAgICAgZC5kYXRlID0gZnVuYyhUaW1lVW5pdC5EQVRFKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGV0aW1lXzEuZGF0ZVRpbWVFeHByKGQpO1xufVxuZXhwb3J0cy5maWVsZEV4cHIgPSBmaWVsZEV4cHI7XG4vKiogcmV0dXJucyB0aGUgc21hbGxlc3QgbmljZSB1bml0IGZvciBzY2FsZS5uaWNlICovXG5mdW5jdGlvbiBzbWFsbGVzdFVuaXQodGltZVVuaXQpIHtcbiAgICBpZiAoIXRpbWVVbml0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5TRUNPTkRTKSkge1xuICAgICAgICByZXR1cm4gJ3NlY29uZCc7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5NSU5VVEVTKSkge1xuICAgICAgICByZXR1cm4gJ21pbnV0ZSc7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5IT1VSUykpIHtcbiAgICAgICAgcmV0dXJuICdob3VyJztcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LkRBWSkgfHxcbiAgICAgICAgY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuREFURSkpIHtcbiAgICAgICAgcmV0dXJuICdkYXknO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuTU9OVEgpKSB7XG4gICAgICAgIHJldHVybiAnbW9udGgnO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuWUVBUikpIHtcbiAgICAgICAgcmV0dXJuICd5ZWFyJztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuc21hbGxlc3RVbml0ID0gc21hbGxlc3RVbml0O1xuLyoqIHJldHVybnMgdGhlIHNpZ25hbCBleHByZXNzaW9uIHVzZWQgZm9yIGF4aXMgbGFiZWxzIGZvciBhIHRpbWUgdW5pdCAqL1xuZnVuY3Rpb24gZm9ybWF0RXhwcmVzc2lvbih0aW1lVW5pdCwgZmllbGQsIHNob3J0VGltZUxhYmVscykge1xuICAgIGlmICghdGltZVVuaXQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIGRhdGVDb21wb25lbnRzID0gW107XG4gICAgdmFyIGV4cHJlc3Npb24gPSAnJztcbiAgICB2YXIgaGFzWWVhciA9IGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LllFQVIpO1xuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5RVUFSVEVSKSkge1xuICAgICAgICAvLyBzcGVjaWFsIGV4cHJlc3Npb24gZm9yIHF1YXJ0ZXIgYXMgcHJlZml4XG4gICAgICAgIGV4cHJlc3Npb24gPSBcIidRJyArIHF1YXJ0ZXIoXCIgKyBmaWVsZCArIFwiKVwiO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuTU9OVEgpKSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdXNlIHNob3J0IG1vbnRoIG5hbWVcbiAgICAgICAgZGF0ZUNvbXBvbmVudHMucHVzaChzaG9ydFRpbWVMYWJlbHMgIT09IGZhbHNlID8gJyViJyA6ICclQicpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuREFZKSkge1xuICAgICAgICBkYXRlQ29tcG9uZW50cy5wdXNoKHNob3J0VGltZUxhYmVscyA/ICclYScgOiAnJUEnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuREFURSkpIHtcbiAgICAgICAgZGF0ZUNvbXBvbmVudHMucHVzaCgnJWQnICsgKGhhc1llYXIgPyAnLCcgOiAnJykpOyAvLyBhZGQgY29tbWEgaWYgdGhlcmUgaXMgeWVhclxuICAgIH1cbiAgICBpZiAoaGFzWWVhcikge1xuICAgICAgICBkYXRlQ29tcG9uZW50cy5wdXNoKHNob3J0VGltZUxhYmVscyA/ICcleScgOiAnJVknKTtcbiAgICB9XG4gICAgdmFyIHRpbWVDb21wb25lbnRzID0gW107XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LkhPVVJTKSkge1xuICAgICAgICB0aW1lQ29tcG9uZW50cy5wdXNoKCclSCcpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuTUlOVVRFUykpIHtcbiAgICAgICAgdGltZUNvbXBvbmVudHMucHVzaCgnJU0nKTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LlNFQ09ORFMpKSB7XG4gICAgICAgIHRpbWVDb21wb25lbnRzLnB1c2goJyVTJyk7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5NSUxMSVNFQ09ORFMpKSB7XG4gICAgICAgIHRpbWVDb21wb25lbnRzLnB1c2goJyVMJyk7XG4gICAgfVxuICAgIHZhciBkYXRlVGltZUNvbXBvbmVudHMgPSBbXTtcbiAgICBpZiAoZGF0ZUNvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkYXRlVGltZUNvbXBvbmVudHMucHVzaChkYXRlQ29tcG9uZW50cy5qb2luKCcgJykpO1xuICAgIH1cbiAgICBpZiAodGltZUNvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkYXRlVGltZUNvbXBvbmVudHMucHVzaCh0aW1lQ29tcG9uZW50cy5qb2luKCc6JykpO1xuICAgIH1cbiAgICBpZiAoZGF0ZVRpbWVDb21wb25lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIEFkZCBzcGFjZSBiZXR3ZWVuIHF1YXJ0ZXIgYW5kIG1haW4gdGltZSBmb3JtYXRcbiAgICAgICAgICAgIGV4cHJlc3Npb24gKz0gXCIgKyAnICcgKyBcIjtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uICs9IFwidGltZUZvcm1hdChcIiArIGZpZWxkICsgXCIsICdcIiArIGRhdGVUaW1lQ29tcG9uZW50cy5qb2luKCcgJykgKyBcIicpXCI7XG4gICAgfVxuICAgIC8vIElmIGV4cHJlc3Npb24gaXMgc3RpbGwgYW4gZW1wdHkgc3RyaW5nLCByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQuXG4gICAgcmV0dXJuIGV4cHJlc3Npb24gfHwgdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5mb3JtYXRFeHByZXNzaW9uID0gZm9ybWF0RXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGlzRGlzY3JldGVCeURlZmF1bHQodGltZVVuaXQpIHtcbiAgICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgICAgIC8vIFRoZXNlIHRpbWUgdW5pdCB1c2UgZGlzY3JldGUgc2NhbGUgYnkgZGVmYXVsdFxuICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0Rpc2NyZXRlQnlEZWZhdWx0ID0gaXNEaXNjcmV0ZUJ5RGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHbHRaWFZ1YVhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12ZEdsdFpYVnVhWFF1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3gxUTBGQmMwUTdRVUZEZEVRc01rSkJRVFpDTzBGQlF6ZENMQ3RDUVVFclF6dEJRVVV2UXl4SlFVRnBRaXhSUVVGUkxFTkJlVUo0UWp0QlFYcENSQ3hYUVVGcFFpeFJRVUZSTzBsQlExWXNZVUZCU1N4SFFVRlhMRTFCUVUwc1EwRkJRenRKUVVOMFFpeGpRVUZMTEVkQlFWa3NUMEZCVHl4RFFVRkRPMGxCUTNwQ0xGbEJRVWNzUjBGQlZTeExRVUZMTEVOQlFVTTdTVUZEYmtJc1lVRkJTU3hIUVVGWExFMUJRVTBzUTBGQlF6dEpRVU4wUWl4alFVRkxMRWRCUVZrc1QwRkJUeXhEUVVGRE8wbEJRM3BDTEdkQ1FVRlBMRWRCUVdNc1UwRkJVeXhEUVVGRE8wbEJReTlDTEdkQ1FVRlBMRWRCUVdNc1UwRkJVeXhEUVVGRE8wbEJReTlDTEhGQ1FVRlpMRWRCUVcxQ0xHTkJRV01zUTBGQlF6dEpRVU01UXl4clFrRkJVeXhIUVVGblFpeFhRVUZYTEVOQlFVTTdTVUZEY2tNc2MwSkJRV0VzUjBGQmIwSXNaVUZCWlN4RFFVRkRPMGxCUTJwRUxESkNRVUZyUWl4SFFVRjVRaXh2UWtGQmIwSXNRMEZCUXp0SlFVTm9SU3hyUTBGQmVVSXNSMEZCWjBNc01rSkJRVEpDTEVOQlFVTTdTVUZEY2tZc2VVTkJRV2RETEVkQlFYVkRMR3REUVVGclF5eERRVUZETzBsQlJYWklMSEZHUVVGeFJqdEpRVU40UlN4clFrRkJVeXhIUVVGblFpeFhRVUZYTEVOQlFVTTdTVUZEY2tNc2NVSkJRVmtzUjBGQmJVSXNZMEZCWXl4RFFVRkRPMGxCUXpsRExEUkNRVUZ0UWl4SFFVRXdRaXh4UWtGQmNVSXNRMEZCUXp0SlFVTnVSU3gxUWtGQll5eEhRVUZ4UWl4blFrRkJaMElzUTBGQlF6dEpRVU53UkN3MFFrRkJiVUlzUjBGQk1FSXNjVUpCUVhGQ0xFTkJRVU03U1VGRGJrVXNaMEpCUVU4c1IwRkJZeXhUUVVGVExFTkJRVU03U1VGREwwSXNiMEpCUVZjc1IwRkJhMElzWVVGQllTeERRVUZETzBsQlF6TkRMSEZDUVVGWkxFZEJRVzFDTEdOQlFXTXNRMEZCUXp0SlFVTTVReXg1UWtGQlowSXNSMEZCZFVJc2EwSkJRV3RDTEVOQlFVTTdRVUZEZWtVc1EwRkJReXhGUVhwQ1owSXNVVUZCVVN4SFFVRlNMR2RDUVVGUkxFdEJRVklzWjBKQlFWRXNVVUY1UW5oQ08wRkJVMFFzZDBWQlFYZEZPMEZCUXpORUxGRkJRVUVzWjBKQlFXZENMRWRCUVVjN1NVRkRPVUlzVVVGQlVTeERRVUZETEVsQlFVazdTVUZEWWl4UlFVRlJMRU5CUVVNc1QwRkJUenRKUVVOb1FpeFJRVUZSTEVOQlFVTXNTMEZCU3p0SlFVTmtMRkZCUVZFc1EwRkJReXhIUVVGSE8wbEJRMW9zVVVGQlVTeERRVUZETEVsQlFVazdTVUZEWWl4UlFVRlJMRU5CUVVNc1MwRkJTenRKUVVOa0xGRkJRVkVzUTBGQlF5eFBRVUZQTzBsQlEyaENMRkZCUVZFc1EwRkJReXhQUVVGUE8wbEJRMmhDTEZGQlFWRXNRMEZCUXl4WlFVRlpPME5CUTNSQ0xFTkJRVU03UVVGRlJpeEpRVUZOTEhGQ1FVRnhRaXhIUVVGclFpeDNRa0ZCWjBJc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eERRVUZETEVWQlFVVXNVVUZCVVR0SlFVTXZSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMGxCUTI1Q0xFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZEV0N4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03UVVGRlVDd3dRa0ZCYVVNc1VVRkJhMEk3U1VGRGFrUXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRCUVVNelF5eERRVUZETzBGQlJrUXNORU5CUlVNN1FVRkZSRHM3T3p0SFFVbEhPMEZCUTBnc2FVSkJRWGRDTEVsQlFXTXNSVUZCUlN4SlFVRlZPMGxCUTJoRUxFbEJRVTBzVFVGQlRTeEhRVUZUTEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNNRUpCUVRCQ08wbEJRemxGTEhkQ1FVRm5RaXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZUTEZWQlFWVTdVVUZETVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOdVFpeExRVUZMTEZGQlFWRXNRMEZCUXl4SFFVRkhPMjlDUVVObUxFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNaMFJCUVdkRUxFTkJRVU1zUTBGQlF6dG5Ra0ZEY0VVc1MwRkJTeXhSUVVGUkxFTkJRVU1zU1VGQlNUdHZRa0ZEYUVJc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNc1EwRkJRenR2UWtGRGRrTXNTMEZCU3l4RFFVRkRPMmRDUVVOU0xFdEJRVXNzVVVGQlVTeERRVUZETEU5QlFVODdiMEpCUTI1Q0xEWkdRVUUyUmp0dlFrRkROMFlzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNaRUxFdEJRVXNzUTBGQlF6dG5Ra0ZEVWl4TFFVRkxMRkZCUVZFc1EwRkJReXhMUVVGTE8yOUNRVU5xUWl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRPMjlDUVVOcVF5eExRVUZMTEVOQlFVTTdaMEpCUTFJc1MwRkJTeXhSUVVGUkxFTkJRVU1zU1VGQlNUdHZRa0ZEYUVJc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNc1EwRkJRenR2UWtGREwwSXNTMEZCU3l4RFFVRkRPMmRDUVVOU0xFdEJRVXNzVVVGQlVTeERRVUZETEV0QlFVczdiMEpCUTJwQ0xFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU03YjBKQlEycERMRXRCUVVzc1EwRkJRenRuUWtGRFVpeExRVUZMTEZGQlFWRXNRMEZCUXl4UFFVRlBPMjlDUVVOdVFpeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF5eERRVUZETzI5Q1FVTnlReXhMUVVGTExFTkJRVU03WjBKQlExSXNTMEZCU3l4UlFVRlJMRU5CUVVNc1QwRkJUenR2UWtGRGJrSXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTXNRMEZCUXp0dlFrRkRja01zUzBGQlN5eERRVUZETzJkQ1FVTlNMRXRCUVVzc1VVRkJVU3hEUVVGRExGbEJRVms3YjBKQlEzaENMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEdWQlFXVXNSVUZCUlN4RFFVRkRMRU5CUVVNN2IwSkJReTlETEV0QlFVc3NRMEZCUXp0WlFVTldMRU5CUVVNN1VVRkRTQ3hEUVVGRE8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZGU0N4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRE8wRkJRMmhDTEVOQlFVTTdRVUZ5UTBRc01FSkJjVU5ETzBGQlJWa3NVVUZCUVN4bFFVRmxMRWRCUVVjN1NVRkROMElzVVVGQlVTeERRVUZETEZkQlFWYzdTVUZEY0VJc1VVRkJVU3hEUVVGRExHZENRVUZuUWp0SlFVTjZRaXhSUVVGUkxFTkJRVU1zVTBGQlV6dEpRVU5zUWl4UlFVRlJMRU5CUVVNc1lVRkJZVHRKUVVOMFFpeFJRVUZSTEVOQlFVTXNhMEpCUVd0Q08wbEJRek5DTEZGQlFWRXNRMEZCUXl4NVFrRkJlVUk3U1VGRGJFTXNVVUZCVVN4RFFVRkRMR2REUVVGblF6dEpRVU42UXl4UlFVRlJMRU5CUVVNc1dVRkJXVHRKUVVOeVFpeFJRVUZSTEVOQlFVTXNXVUZCV1R0SlFVTnlRaXhSUVVGUkxFTkJRVU1zYlVKQlFXMUNPMGxCUXpWQ0xGRkJRVkVzUTBGQlF5eGpRVUZqTzBsQlEzWkNMRkZCUVZFc1EwRkJReXh0UWtGQmJVSTdRMEZETjBJc1EwRkJRenRCUVVWR0xFbEJRVTBzYjBKQlFXOUNMRWRCUVd0Q0xIVkNRVUZsTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJReXhGUVVGRkxGRkJRVkU3U1VGRE4wVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF6dEpRVU51UWl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMWdzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMEZCUlZBc2VVSkJRV2RETEZGQlFXdENPMGxCUTJoRUxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdRVUZETVVNc1EwRkJRenRCUVVaRUxEQkRRVVZETzBGQlJWa3NVVUZCUVN4VFFVRlRMRWRCUVVjN1NVRkRka0lzVVVGQlVTeERRVUZETEVsQlFVazdTVUZEWWl4UlFVRlJMRU5CUVVNc1QwRkJUenRKUVVOb1FpeFJRVUZSTEVOQlFVTXNTMEZCU3p0SlFVTmtMRkZCUVZFc1EwRkJReXhIUVVGSE8wbEJRMW9zVVVGQlVTeERRVUZETEVsQlFVazdTVUZEWWl4UlFVRlJMRU5CUVVNc1MwRkJTenRKUVVOa0xGRkJRVkVzUTBGQlF5eFBRVUZQTzBsQlEyaENMRkZCUVZFc1EwRkJReXhQUVVGUE8wbEJRMmhDTEZGQlFWRXNRMEZCUXl4WlFVRlpPMGxCUTNKQ0xGRkJRVkVzUTBGQlF5eFhRVUZYTzBsQlEzQkNMRkZCUVZFc1EwRkJReXhuUWtGQlowSTdTVUZEZWtJc1VVRkJVU3hEUVVGRExGTkJRVk03U1VGRGJFSXNVVUZCVVN4RFFVRkRMR0ZCUVdFN1NVRkRkRUlzVVVGQlVTeERRVUZETEd0Q1FVRnJRanRKUVVNelFpeFJRVUZSTEVOQlFVTXNlVUpCUVhsQ08wbEJRMnhETEZGQlFWRXNRMEZCUXl4blEwRkJaME03U1VGRGVrTXNVVUZCVVN4RFFVRkRMRmxCUVZrN1NVRkRja0lzVVVGQlVTeERRVUZETEZsQlFWazdTVUZEY2tJc1VVRkJVU3hEUVVGRExHMUNRVUZ0UWp0SlFVTTFRaXhSUVVGUkxFTkJRVU1zWTBGQll6dEpRVU4yUWl4UlFVRlJMRU5CUVVNc2JVSkJRVzFDTzBOQlF6ZENMRU5CUVVNN1FVRkZSaXd5UlVGQk1rVTdRVUZETTBVc01FSkJRV2xETEZsQlFYTkNMRVZCUVVVc1VVRkJhMEk3U1VGRGVrVXNTVUZCVFN4TFFVRkxMRWRCUVVjc1dVRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTTNReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTm1MRU5CUTBVc1VVRkJVU3hMUVVGTExGRkJRVkVzUTBGQlF5eFBRVUZQTzFsQlF6ZENMRXRCUVVzc1MwRkJTeXhEUVVGRE8xbEJRMWdzV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRWRCUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUjBGQlJ5eERRVUZETEhWQ1FVRjFRanRUUVVNM1JDeERRVUZETzBGQlEwNHNRMEZCUXp0QlFWSkVMRFJEUVZGRE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N4dFFrRkJNRUlzV1VGQmMwSXNSVUZCUlN4TFFVRmhPMGxCUXpkRUxFbEJRVTBzVVVGQlVTeEhRVUZKTEZkQlFWTXNhMEpCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlJ5eERRVUZETzBsQlJXcEVMR05CUVdNc1VVRkJhMEk3VVVGRE9VSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hMUVVGTExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExHMURRVUZ0UXp0WlFVTnVReXhOUVVGTkxFTkJRVU1zWTBGQldTeFJRVUZSTEZOQlFVMHNRMEZCUXp0UlFVTndReXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4TlFVRk5MRU5CUVVrc1VVRkJVU3hUUVVGSkxGRkJRVkVzVFVGQlJ5eERRVUZETzFGQlEzQkRMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJSVVFzU1VGQlRTeERRVUZETEVkQlFVY3NkMEpCUVdkQ0xFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFVTXNSVUZCWjBJc1JVRkJSU3hGUVVGWk8xRkJReTlFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeERRVUZETEZsQlFWa3NSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0UlFVTndRaXhEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXp0SlFVTmFMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVVZRTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzVjBGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaERMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNoRUxFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXp0UlFVTmlMRU5CUVVNc1EwRkJReXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNdlFpeERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRMSFZDUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdRVUZEZWtJc1EwRkJRenRCUVRGQ1JDdzRRa0V3UWtNN1FVRkZSQ3h2UkVGQmIwUTdRVUZEY0VRc2MwSkJRVFpDTEZGQlFXdENPMGxCUXpkRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOa0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZEYmtJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBFTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeERRVUZETEZGQlFWRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycEVMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZEYUVJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRPMUZCUTNoRExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpsRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdTVUZEWml4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMME1zVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTnFRaXhEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVVVGQlVTeEZRVUZGTEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVOb1FpeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRCUVVOdVFpeERRVUZETzBGQk9VSkVMRzlEUVRoQ1F6dEJRVVZFTEhsRlFVRjVSVHRCUVVONlJTd3dRa0ZCYVVNc1VVRkJhMElzUlVGQlJTeExRVUZoTEVWQlFVVXNaVUZCZDBJN1NVRkRNVVlzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMlFzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVVFzU1VGQlRTeGpRVUZqTEVkQlFXRXNSVUZCUlN4RFFVRkRPMGxCUTNCRExFbEJRVWtzVlVGQlZTeEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTndRaXhKUVVGTkxFOUJRVThzUjBGQlJ5eG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUlRGRUxFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhFTERKRFFVRXlRenRSUVVNeFF5eFZRVUZWTEVkQlFVY3NiVUpCUVdsQ0xFdEJRVXNzVFVGQlJ5eERRVUZETzBsQlEzcERMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlF5eHJRMEZCYTBNN1VVRkRiRU1zWTBGQll5eERRVUZETEVsQlFVa3NRMEZCUXl4bFFVRmxMRXRCUVVzc1MwRkJTeXhIUVVGSExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTXZSQ3hEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVVVGQlVTeEZRVUZGTEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE4wTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhsUVVGbExFZEJRVWNzU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTNKRUxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY2tRc1kwRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVkQlFVY3NRMEZCUXl4UFFVRlBMRWRCUVVjc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl3MlFrRkJOa0k3U1VGRGFrWXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEV2l4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExHVkJRV1VzUjBGQlJ5eEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRja1FzUTBGQlF6dEpRVVZFTEVsQlFVMHNZMEZCWXl4SFFVRmhMRVZCUVVVc1EwRkJRenRKUVVWd1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlF6VkNMRU5CUVVNN1NVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOcVJDeGpRVUZqTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRelZDTEVOQlFVTTdTVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnFSQ3hqUVVGakxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXpWQ0xFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUkN4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlF6VkNMRU5CUVVNN1NVRkZSQ3hKUVVGTkxHdENRVUZyUWl4SFFVRmhMRVZCUVVVc1EwRkJRenRKUVVONFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4alFVRmpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VJc2EwSkJRV3RDTEVOQlFVTXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTndSQ3hEUVVGRE8wbEJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNZMEZCWXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6bENMR3RDUVVGclFpeERRVUZETEVsQlFVa3NRMEZCUXl4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEY0VRc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJ4RExFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRaaXhwUkVGQmFVUTdXVUZEYWtRc1ZVRkJWU3hKUVVGSkxGZEJRVmNzUTBGQlF6dFJRVU0xUWl4RFFVRkRPMUZCUTBRc1ZVRkJWU3hKUVVGSkxHZENRVUZqTEV0QlFVc3NWMEZCVFN4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVVrc1EwRkJRenRKUVVNeFJTeERRVUZETzBsQlJVUXNiMFZCUVc5Rk8wbEJRM0JGTEUxQlFVMHNRMEZCUXl4VlFVRlZMRWxCUVVrc1UwRkJVeXhEUVVGRE8wRkJRMnBETEVOQlFVTTdRVUU1UkVRc05FTkJPRVJETzBGQlJVUXNOa0pCUVc5RExGRkJRV3RDTzBsQlEzQkVMRTFCUVUwc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtJc1owUkJRV2RFTzFGQlEyaEVMRXRCUVVzc1QwRkJUeXhEUVVGRE8xRkJRMklzUzBGQlN5eExRVUZMTEVOQlFVTTdVVUZEV0N4TFFVRkxMRTlCUVU4c1EwRkJRenRSUVVOaUxFdEJRVXNzVTBGQlV6dFpRVU5hTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1FVRkRaaXhEUVVGRE8wRkJWa1FzYTBSQlZVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVE9QX0xFVkVMX1BST1BFUlRJRVMgPSBbXG4gICAgJ2JhY2tncm91bmQnLCAncGFkZGluZydcbl07XG5mdW5jdGlvbiBleHRyYWN0VG9wTGV2ZWxQcm9wZXJ0aWVzKHQpIHtcbiAgICByZXR1cm4gVE9QX0xFVkVMX1BST1BFUlRJRVMucmVkdWNlKGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICAgIGlmICh0ICYmIHRbcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb1twXSA9IHRbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5leHRyYWN0VG9wTGV2ZWxQcm9wZXJ0aWVzID0gZXh0cmFjdFRvcExldmVsUHJvcGVydGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHOXdiR1YyWld4d2NtOXdjeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OTBiM0JzWlhabGJIQnliM0J6TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJkVUpCTEVsQlFVMHNiMEpCUVc5Q0xFZEJRV2xETzBsQlEzcEVMRmxCUVZrc1JVRkJSU3hUUVVGVE8wTkJRM2hDTEVOQlFVTTdRVUZGUml4dFEwRkJkMFVzUTBGQlNUdEpRVU14UlN4TlFVRk5MRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRGRFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEWkN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5ZTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRCUVVOVUxFTkJRVU03UVVGUVJDdzRSRUZQUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNGaWx0ZXIodCkge1xuICAgIHJldHVybiB0WydmaWx0ZXInXSAhPT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc0ZpbHRlciA9IGlzRmlsdGVyO1xuZnVuY3Rpb24gaXNDYWxjdWxhdGUodCkge1xuICAgIHJldHVybiB0WydjYWxjdWxhdGUnXSAhPT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc0NhbGN1bGF0ZSA9IGlzQ2FsY3VsYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKaGJuTm1iM0p0TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMM1J5WVc1elptOXliUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFWTkJMR3RDUVVGNVFpeERRVUZaTzBsQlEyNURMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NVMEZCVXl4RFFVRkRPMEZCUTI1RExFTkJRVU03UVVGR1JDdzBRa0ZGUXp0QlFXTkVMSEZDUVVFMFFpeERRVUZaTzBsQlEzUkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEV0QlFVc3NVMEZCVXl4RFFVRkRPMEZCUTNSRExFTkJRVU03UVVGR1JDeHJRMEZGUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuLyoqIENvbnN0YW50cyBhbmQgdXRpbGl0aWVzIGZvciBkYXRhIHR5cGUgKi9cbi8qKiBEYXRhIHR5cGUgYmFzZWQgb24gbGV2ZWwgb2YgbWVhc3VyZW1lbnQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgVHlwZS5RVUFOVElUQVRJVkUgPSAncXVhbnRpdGF0aXZlJztcbiAgICBUeXBlLk9SRElOQUwgPSAnb3JkaW5hbCc7XG4gICAgVHlwZS5URU1QT1JBTCA9ICd0ZW1wb3JhbCc7XG4gICAgVHlwZS5OT01JTkFMID0gJ25vbWluYWwnO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbmV4cG9ydHMuUVVBTlRJVEFUSVZFID0gVHlwZS5RVUFOVElUQVRJVkU7XG5leHBvcnRzLk9SRElOQUwgPSBUeXBlLk9SRElOQUw7XG5leHBvcnRzLlRFTVBPUkFMID0gVHlwZS5URU1QT1JBTDtcbmV4cG9ydHMuTk9NSU5BTCA9IFR5cGUuTk9NSU5BTDtcbi8qKlxuICogR2V0IGZ1bGwsIGxvd2VyY2FzZSB0eXBlIG5hbWUgZm9yIGEgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSAgdHlwZVxuICogQHJldHVybiBGdWxsIHR5cGUgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RnVsbE5hbWUodHlwZSkge1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuUVVBTlRJVEFUSVZFOlxuICAgICAgICAgICAgICAgIHJldHVybiAncXVhbnRpdGF0aXZlJztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRFTVBPUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiAndGVtcG9yYWwnO1xuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuT1JESU5BTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29yZGluYWwnO1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuTk9NSU5BTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbWluYWwnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGdldCBpbnZhbGlkIGlucHV0LCByZXR1cm4gdW5kZWZpbmVkIHR5cGUuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ2V0RnVsbE5hbWUgPSBnZXRGdWxsTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRIbHdaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OTBlWEJsTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3cwUTBGQk5FTTdRVUZETlVNc09FTkJRVGhET3p0QlFVVTVReXhKUVVGcFFpeEpRVUZKTEVOQlMzQkNPMEZCVEVRc1YwRkJhVUlzU1VGQlNUdEpRVU5PTEdsQ1FVRlpMRWRCUVcxQ0xHTkJRV01zUTBGQlF6dEpRVU01UXl4WlFVRlBMRWRCUVdNc1UwRkJVeXhEUVVGRE8wbEJReTlDTEdGQlFWRXNSMEZCWlN4VlFVRlZMRU5CUVVNN1NVRkRiRU1zV1VGQlR5eEhRVUZqTEZOQlFWTXNRMEZCUXp0QlFVTTVReXhEUVVGRExFVkJUR2RDTEVsQlFVa3NSMEZCU2l4WlFVRkpMRXRCUVVvc1dVRkJTU3hSUVV0d1FqdEJRVWRaTEZGQlFVRXNXVUZCV1N4SFFVRkhMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU03UVVGRGFrTXNVVUZCUVN4UFFVRlBMRWRCUVVjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dEJRVU4yUWl4UlFVRkJMRkZCUVZFc1IwRkJSeXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETzBGQlEzcENMRkZCUVVFc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTTdRVUZGY0VNN096czdSMEZKUnp0QlFVTklMSEZDUVVFMFFpeEpRVUZwUWp0SlFVTXpReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTFRc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXp0UlFVTXhRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJJc1MwRkJTeXhIUVVGSExFTkJRVU03V1VGRFZDeExRVUZMTEc5Q1FVRlpPMmRDUVVObUxFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTTdXVUZEZUVJc1MwRkJTeXhIUVVGSExFTkJRVU03V1VGRFZDeExRVUZMTEdkQ1FVRlJPMmRDUVVOWUxFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdXVUZEY0VJc1MwRkJTeXhIUVVGSExFTkJRVU03V1VGRFZDeExRVUZMTEdWQlFVODdaMEpCUTFZc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dFpRVU51UWl4TFFVRkxMRWRCUVVjc1EwRkJRenRaUVVOVUxFdEJRVXNzWlVGQlR6dG5Ra0ZEVml4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRE8xRkJRM0pDTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc2EwUkJRV3RFTzBsQlEyeEVMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03UVVGRGJrSXNRMEZCUXp0QlFYQkNSQ3hyUTBGdlFrTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKTtcbnZhciB2ZWdhX3V0aWxfMSA9IHJlcXVpcmUoXCJ2ZWdhLXV0aWxcIik7XG5leHBvcnRzLmV4dGVuZCA9IHZlZ2FfdXRpbF8xLmV4dGVuZDtcbmV4cG9ydHMuaXNBcnJheSA9IHZlZ2FfdXRpbF8xLmlzQXJyYXk7XG5leHBvcnRzLmlzT2JqZWN0ID0gdmVnYV91dGlsXzEuaXNPYmplY3Q7XG5leHBvcnRzLmlzTnVtYmVyID0gdmVnYV91dGlsXzEuaXNOdW1iZXI7XG5leHBvcnRzLmlzU3RyaW5nID0gdmVnYV91dGlsXzEuaXNTdHJpbmc7XG5leHBvcnRzLnRydW5jYXRlID0gdmVnYV91dGlsXzEudHJ1bmNhdGU7XG5leHBvcnRzLnRvU2V0ID0gdmVnYV91dGlsXzEudG9TZXQ7XG5leHBvcnRzLnN0cmluZ1ZhbHVlID0gdmVnYV91dGlsXzEuc3RyaW5nVmFsdWU7XG52YXIgdmVnYV91dGlsXzIgPSByZXF1aXJlKFwidmVnYS11dGlsXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIG9iamVjdCBwcm9wZXJ0aWVzLlxuICpcbiAqIEV4YW1wbGU6ICAoZnJvbSBsb2Rhc2gpXG4gKlxuICogdmFyIG9iamVjdCA9IHsnYSc6IDEsICdiJzogJzInLCAnYyc6IDN9O1xuICogcGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8g4oaSIHsnYSc6IDEsICdjJzogM31cbiAqXG4gKi9cbmZ1bmN0aW9uIHBpY2sob2JqLCBwcm9wcykge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG59XG5leHBvcnRzLnBpY2sgPSBwaWNrO1xuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgXy5waWNrOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgb3duXG4gKiBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygb2JqZWN0IHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBvbWl0KG9iaiwgcHJvcHMpIHtcbiAgICB2YXIgY29weSA9IGR1cGxpY2F0ZShvYmopO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgZGVsZXRlIGNvcHlbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG59XG5leHBvcnRzLm9taXQgPSBvbWl0O1xuZnVuY3Rpb24gaGFzaChhKSB7XG4gICAgaWYgKHZlZ2FfdXRpbF8yLmlzU3RyaW5nKGEpIHx8IHZlZ2FfdXRpbF8yLmlzTnVtYmVyKGEpIHx8IGlzQm9vbGVhbihhKSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5KGEpO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBpdGVtKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgPiAtMTtcbn1cbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcbi8qKiBSZXR1cm5zIHRoZSBhcnJheSB3aXRob3V0IHRoZSBlbGVtZW50cyBpbiBpdGVtICovXG5mdW5jdGlvbiB3aXRob3V0KGFycmF5LCBleGNsdWRlZEl0ZW1zKSB7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gIWNvbnRhaW5zKGV4Y2x1ZGVkSXRlbXMsIGl0ZW0pOyB9KTtcbn1cbmV4cG9ydHMud2l0aG91dCA9IHdpdGhvdXQ7XG5mdW5jdGlvbiB1bmlvbihhcnJheSwgb3RoZXIpIHtcbiAgICByZXR1cm4gYXJyYXkuY29uY2F0KHdpdGhvdXQob3RoZXIsIGFycmF5KSk7XG59XG5leHBvcnRzLnVuaW9uID0gdW5pb247XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbnkgaXRlbSByZXR1cm5zIHRydWUuXG4gKi9cbmZ1bmN0aW9uIHNvbWUoYXJyLCBmKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXJyLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmIChmKGFycltrXSwgaywgaSsrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zb21lID0gc29tZTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFsbCBpdGVtcyByZXR1cm4gdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXZlcnkoYXJyLCBmKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXJyLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmICghZihhcnJba10sIGssIGkrKykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXlzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgYXJyYXlzKTtcbn1cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG4vKipcbiAqIHJlY3Vyc2l2ZWx5IG1lcmdlcyBzcmMgaW50byBkZXN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVlcChkZXN0KSB7XG4gICAgdmFyIHNyYyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNyY1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCBzcmNfMSA9IHNyYzsgX2EgPCBzcmNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHMgPSBzcmNfMVtfYV07XG4gICAgICAgIGRlc3QgPSBkZWVwTWVyZ2VfKGRlc3QsIHMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbmV4cG9ydHMubWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xuLy8gcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbmZ1bmN0aW9uIGRlZXBNZXJnZV8oZGVzdCwgc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgZm9yICh2YXIgcCBpbiBzcmMpIHtcbiAgICAgICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcmNbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzcmNbcF0gIT09ICdvYmplY3QnIHx8IHZlZ2FfdXRpbF8yLmlzQXJyYXkoc3JjW3BdKSB8fCBzcmNbcF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlc3RbcF0gPSBzcmNbcF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlc3RbcF0gIT09ICdvYmplY3QnIHx8IGRlc3RbcF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlc3RbcF0gPSBtZXJnZURlZXAoc3JjW3BdLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge30sIHNyY1twXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXJnZURlZXAoZGVzdFtwXSwgc3JjW3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbmZ1bmN0aW9uIHVuaXF1ZSh2YWx1ZXMsIGYpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB1ID0ge307XG4gICAgdmFyIHY7XG4gICAgZm9yICh2YXIgX2kgPSAwLCB2YWx1ZXNfMSA9IHZhbHVlczsgX2kgPCB2YWx1ZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHZhbCA9IHZhbHVlc18xW19pXTtcbiAgICAgICAgdiA9IGYodmFsKTtcbiAgICAgICAgaWYgKHYgaW4gdSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdVt2XSA9IDE7XG4gICAgICAgIHJlc3VsdHMucHVzaCh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmV4cG9ydHMudW5pcXVlID0gdW5pcXVlO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBkaWN0aW9uYXJpZXMgZGlzYWdyZWUuIEFwcGxpZXMgb25seSB0byBkZWZpbmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZmVyKGRpY3QsIG90aGVyKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpY3QpIHtcbiAgICAgICAgaWYgKGRpY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgaWYgKG90aGVyW2tleV0gJiYgZGljdFtrZXldICYmIG90aGVyW2tleV0gIT09IGRpY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuZGlmZmVyID0gZGlmZmVyO1xuZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoa2V5IGluIGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaGFzSW50ZXJzZWN0aW9uID0gaGFzSW50ZXJzZWN0aW9uO1xuZnVuY3Rpb24gZGlmZmVyQXJyYXkoYXJyYXksIG90aGVyKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhcnJheS5zb3J0KCk7XG4gICAgb3RoZXIuc29ydCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG90aGVyW2ldICE9PSBhcnJheVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5kaWZmZXJBcnJheSA9IGRpZmZlckFycmF5O1xuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXM7XG5mdW5jdGlvbiB2YWxzKHgpIHtcbiAgICB2YXIgX3ZhbHMgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIHgpIHtcbiAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIF92YWxzLnB1c2goeFtrXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF92YWxzO1xufVxuZXhwb3J0cy52YWxzID0gdmFscztcbmZ1bmN0aW9uIGR1cGxpY2F0ZShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbmV4cG9ydHMuZHVwbGljYXRlID0gZHVwbGljYXRlO1xuZnVuY3Rpb24gaXNCb29sZWFuKGIpIHtcbiAgICByZXR1cm4gYiA9PT0gdHJ1ZSB8fCBiID09PSBmYWxzZTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gYSB2YWxpZCB2YXJpYWJsZSBuYW1lXG4gKi9cbmZ1bmN0aW9uIHZhck5hbWUocykge1xuICAgIC8vIFJlcGxhY2Ugbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIChhbnl0aGluZyBiZXNpZGVzIGEtekEtWjAtOV8pIHdpdGggX1xuICAgIHZhciBhbHBoYW51bWVyaWNTID0gcy5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbiAgICAvLyBBZGQgXyBpZiB0aGUgc3RyaW5nIGhhcyBsZWFkaW5nIG51bWJlcnMuXG4gICAgcmV0dXJuIChzLm1hdGNoKC9eXFxkKy8pID8gJ18nIDogJycpICsgYWxwaGFudW1lcmljUztcbn1cbmV4cG9ydHMudmFyTmFtZSA9IHZhck5hbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkWFJwYkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTkxZEdsc0xuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFc2FVUkJRVzFFTzBGQlEyNUVMSFZEUVVGelJ6dEJRVUU1Uml3MlFrRkJRU3hOUVVGTkxFTkJRVUU3UVVGQlJTdzRRa0ZCUVN4UFFVRlBMRU5CUVVFN1FVRkJSU3dyUWtGQlFTeFJRVUZSTEVOQlFVRTdRVUZCUlN3clFrRkJRU3hSUVVGUkxFTkJRVUU3UVVGQlJTd3JRa0ZCUVN4UlFVRlJMRU5CUVVFN1FVRkJSU3dyUWtGQlFTeFJRVUZSTEVOQlFVRTdRVUZCUlN3MFFrRkJRU3hMUVVGTExFTkJRVUU3UVVGQlJTeHJRMEZCUVN4WFFVRlhMRU5CUVVFN1FVRkRia1lzZFVOQlFYTkVPMEZCUlhSRU96czdPenM3T3pzN1IwRlRSenRCUVVOSUxHTkJRWEZDTEVkQlFWRXNSVUZCUlN4TFFVRmxPMGxCUXpWRExFbEJRVTBzU1VGQlNTeEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTm9RaXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVTXNTVUZCU1R0UlFVTnFRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0zUWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTNwQ0xFTkJRVU03U1VGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTklMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlVrUXNiMEpCVVVNN1FVRkZSRHM3TzBkQlIwYzdRVUZEU0N4alFVRnhRaXhIUVVGUkxFVkJRVVVzUzBGQlpUdEpRVU0xUXl4SlFVRk5MRWxCUVVrc1IwRkJSeXhUUVVGVExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZETlVJc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZETEVsQlFVazdVVUZEYWtJc1QwRkJUeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEY0VJc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFNDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVU1RUxHOUNRVTFETzBGQlJVUXNZMEZCY1VJc1EwRkJUVHRKUVVONlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4dlFrRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEc5Q1FVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMjVDTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlEzUkNMRU5CUVVNN1FVRk1SQ3h2UWtGTFF6dEJRVVZFTEd0Q1FVRTBRaXhMUVVGVkxFVkJRVVVzU1VGQlR6dEpRVU0zUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOc1F5eERRVUZETzBGQlJrUXNORUpCUlVNN1FVRkZSQ3h4UkVGQmNVUTdRVUZEY2tRc2FVSkJRVEpDTEV0QlFWVXNSVUZCUlN4aFFVRnJRanRKUVVOMlJDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGQkxFbEJRVWtzU1VGQlNTeFBRVUZCTEVOQlFVTXNVVUZCVVN4RFFVRkRMR0ZCUVdFc1JVRkJSU3hKUVVGSkxFTkJRVU1zUlVGQk9VSXNRMEZCT0VJc1EwRkJReXhEUVVGRE8wRkJRemxFTEVOQlFVTTdRVUZHUkN3d1FrRkZRenRCUVVWRUxHVkJRWGxDTEV0QlFWVXNSVUZCUlN4TFFVRlZPMGxCUXpkRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTTNReXhEUVVGRE8wRkJSa1FzYzBKQlJVTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxHTkJRWGRDTEVkQlFWRXNSVUZCUlN4RFFVRnpRenRKUVVOMFJTeEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkRWaXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGRExFZEJRVWNzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJRenRSUVVOc1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4wUWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRVkpFTEc5Q1FWRkRPMEZCUlVRN08wZEJSVWM3UVVGRFJpeGxRVUY1UWl4SFFVRlJMRVZCUVVVc1EwRkJjME03U1VGRGVFVXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8wbEJRMVlzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU03VVVGRGJFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlEyWXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlEyUXNRMEZCUXp0QlFWSkJMSE5DUVZGQk8wRkJSVVFzYVVKQlFYZENMRTFCUVdFN1NVRkRia01zVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVVzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0QlFVTnlReXhEUVVGRE8wRkJSa1FzTUVKQlJVTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxHMUNRVUV3UWl4SlFVRlRPMGxCUVVVc1lVRkJZVHRUUVVGaUxGVkJRV0VzUlVGQllpeHhRa0ZCWVN4RlFVRmlMRWxCUVdFN1VVRkJZaXcwUWtGQllUczdTVUZEYUVRc1IwRkJSeXhEUVVGRExFTkJRVmtzVlVGQlJ5eEZRVUZJTEZkQlFVY3NSVUZCU0N4cFFrRkJSeXhGUVVGSUxFbEJRVWM3VVVGQlpDeEpRVUZOTEVOQlFVTXNXVUZCUVR0UlFVTldMRWxCUVVrc1IwRkJSeXhWUVVGVkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMHRCUXpWQ08wbEJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRk1SQ3c0UWtGTFF6dEJRVVZFTEcxRFFVRnRRenRCUVVOdVF5eHZRa0ZCYjBJc1NVRkJVeXhGUVVGRkxFZEJRVkU3U1VGRGNrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhIUVVGSExFdEJRVXNzVVVGQlVTeEpRVUZKTEVkQlFVY3NTMEZCU3l4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRelZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJSVVFzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCVFN4RFFVRkRMRWxCUVVrc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU53UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eGpRVUZqTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRek5DTEZGQlFWRXNRMEZCUXp0UlFVTllMRU5CUVVNN1VVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UWl4UlFVRlJMRU5CUVVNN1VVRkRXQ3hEUVVGRE8xRkJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzVVVGQlVTeEpRVUZKTEcxQ1FVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVFpeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRkZCUVZFc1NVRkJTU3hKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNelJDeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4WFFVRlhMRXRCUVVzc1MwRkJTeXhIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFVXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTTNRaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJSVVFzWjBKQlFUQkNMRTFCUVZjc1JVRkJSU3hEUVVGelFqdEpRVU16UkN4SlFVRk5MRTlCUVU4c1IwRkJWU3hGUVVGRkxFTkJRVU03U1VGRE1VSXNTVUZCVFN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRE8wbEJRMklzU1VGQlNTeERRVUZUTEVOQlFVTTdTVUZEWkN4SFFVRkhMRU5CUVVNc1EwRkJZeXhWUVVGTkxFVkJRVTRzYVVKQlFVMHNSVUZCVGl4dlFrRkJUU3hGUVVGT0xFbEJRVTA3VVVGQmJrSXNTVUZCVFN4SFFVRkhMR1ZCUVVFN1VVRkRXaXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTFnc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRXQ3hSUVVGUkxFTkJRVU03VVVGRFdDeERRVUZETzFGQlEwUXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU5VTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03UzBGRGJrSTdTVUZEUkN4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8wRkJRMnBDTEVOQlFVTTdRVUZpUkN4M1FrRmhRenRCUVZGRU96dEhRVVZITzBGQlEwZ3NaMEpCUVRCQ0xFbEJRV0VzUlVGQlJTeExRVUZqTzBsQlEzSkVMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVTBzUjBGQlJ5eEpRVUZKTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRka0lzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBJc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRlRVFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTmtMRU5CUVVNN1VVRkRTQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1FVRkRaaXhEUVVGRE8wRkJWRVFzZDBKQlUwTTdRVUZGUkN4NVFrRkJaME1zUTBGQldTeEZRVUZGTEVOQlFWazdTVUZEZUVRc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOd1FpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5pTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1FVRkRaaXhEUVVGRE8wRkJVRVFzTUVOQlQwTTdRVUZGUkN4eFFrRkJLMElzUzBGQlZTeEZRVUZGTEV0QlFWVTdTVUZEYmtRc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNTMEZCU3l4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5zUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZFTEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRKUVVOaUxFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXp0SlFVVmlMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRPMUZCUTNSRExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpGQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdRVUZEWml4RFFVRkRPMEZCWmtRc2EwTkJaVU03UVVGRldTeFJRVUZCTEVsQlFVa3NSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wRkJSV2hETEdOQlFYZENMRU5CUVhGQ08wbEJRek5ETEVsQlFVMHNTMEZCU3l4SFFVRlJMRVZCUVVVc1EwRkJRenRKUVVOMFFpeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyeENMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eGpRVUZqTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hDTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYmtJc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMEZCUTJZc1EwRkJRenRCUVZKRUxHOUNRVkZETzBGQlJVUXNiVUpCUVRaQ0xFZEJRVTA3U1VGRGFrTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRM3BETEVOQlFVTTdRVUZHUkN3NFFrRkZRenRCUVVWRUxHMUNRVUV3UWl4RFFVRk5PMGxCUXpsQ0xFMUJRVTBzUTBGQlF5eERRVUZETEV0QlFVc3NTVUZCU1N4SlFVRkpMRU5CUVVNc1MwRkJTeXhMUVVGTExFTkJRVU03UVVGRGJrTXNRMEZCUXp0QlFVWkVMRGhDUVVWRE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N4cFFrRkJkMElzUTBGQlV6dEpRVU12UWl3eVJVRkJNa1U3U1VGRE0wVXNTVUZCVFN4aFFVRmhMRWRCUVVjc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eExRVUZMTEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkZOVU1zTWtOQlFUSkRPMGxCUXpORExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVWQlFVVXNRMEZCUXl4SFFVRkhMR0ZCUVdFc1EwRkJRenRCUVVOMFJDeERRVUZETzBGQlRrUXNNRUpCVFVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXJrXzEgPSByZXF1aXJlKFwiLi9tYXJrXCIpO1xuLy8gVE9ETzogbW92ZSB0byB2bC5zcGVjLnZhbGlkYXRvcj9cbnZhciBtYXJrXzIgPSByZXF1aXJlKFwiLi9tYXJrXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKipcbiAqIFJlcXVpcmVkIEVuY29kaW5nIENoYW5uZWxzIGZvciBlYWNoIG1hcmsgdHlwZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5ERUZBVUxUX1JFUVVJUkVEX0NIQU5ORUxfTUFQID0ge1xuICAgIHRleHQ6IFsndGV4dCddLFxuICAgIGxpbmU6IFsneCcsICd5J10sXG4gICAgYXJlYTogWyd4JywgJ3knXVxufTtcbi8qKlxuICogU3VwcG9ydGVkIEVuY29kaW5nIENoYW5uZWwgZm9yIGVhY2ggbWFyayB0eXBlXG4gKi9cbmV4cG9ydHMuREVGQVVMVF9TVVBQT1JURURfQ0hBTk5FTF9UWVBFID0ge1xuICAgIGJhcjogdXRpbF8xLnRvU2V0KFsncm93JywgJ2NvbHVtbicsICd4JywgJ3knLCAnc2l6ZScsICdjb2xvcicsICdkZXRhaWwnXSksXG4gICAgbGluZTogdXRpbF8xLnRvU2V0KFsncm93JywgJ2NvbHVtbicsICd4JywgJ3knLCAnY29sb3InLCAnZGV0YWlsJ10pLFxuICAgIGFyZWE6IHV0aWxfMS50b1NldChbJ3JvdycsICdjb2x1bW4nLCAneCcsICd5JywgJ2NvbG9yJywgJ2RldGFpbCddKSxcbiAgICB0aWNrOiB1dGlsXzEudG9TZXQoWydyb3cnLCAnY29sdW1uJywgJ3gnLCAneScsICdjb2xvcicsICdkZXRhaWwnXSksXG4gICAgY2lyY2xlOiB1dGlsXzEudG9TZXQoWydyb3cnLCAnY29sdW1uJywgJ3gnLCAneScsICdjb2xvcicsICdzaXplJywgJ2RldGFpbCddKSxcbiAgICBzcXVhcmU6IHV0aWxfMS50b1NldChbJ3JvdycsICdjb2x1bW4nLCAneCcsICd5JywgJ2NvbG9yJywgJ3NpemUnLCAnZGV0YWlsJ10pLFxuICAgIHBvaW50OiB1dGlsXzEudG9TZXQoWydyb3cnLCAnY29sdW1uJywgJ3gnLCAneScsICdjb2xvcicsICdzaXplJywgJ2RldGFpbCcsICdzaGFwZSddKSxcbiAgICB0ZXh0OiB1dGlsXzEudG9TZXQoWydyb3cnLCAnY29sdW1uJywgJ3NpemUnLCAnY29sb3InLCAndGV4dCddKSAvLyBUT0RPKCM3MjQpIHJldmlzZVxufTtcbi8vIFRPRE86IGNvbnNpZGVyIGlmIHdlIHNob3VsZCBhZGQgdmFsaWRhdGUgbWV0aG9kIGFuZFxuLy8gcmVxdWlyZXMgWlNjaGVtYSBpbiB0aGUgbWFpbiB2ZWdhLWxpdGUgcmVwb1xuLyoqXG4gKiBGdXJ0aGVyIGNoZWNrIGlmIGVuY29kaW5nIG1hcHBpbmcgb2YgYSBzcGVjIGlzIGludmFsaWQgYW5kXG4gKiByZXR1cm4gZXJyb3IgaWYgaXQgaXMgaW52YWxpZC5cbiAqXG4gKiBUaGlzIGNoZWNrcyBpZlxuICogKDEpIGFsbCB0aGUgcmVxdWlyZWQgZW5jb2RpbmcgY2hhbm5lbHMgZm9yIHRoZSBtYXJrIHR5cGUgYXJlIHNwZWNpZmllZFxuICogKDIpIGFsbCB0aGUgc3BlY2lmaWVkIGVuY29kaW5nIGNoYW5uZWxzIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIG1hcmsgdHlwZVxuICogQHBhcmFtICB7W3R5cGVdfSBzcGVjIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1JlcXVpcmVkQ2hhbm5lbE1hcCAgPSBEZWZhdWx0UmVxdWlyZWRDaGFubmVsTWFwfSAgcmVxdWlyZWRDaGFubmVsTWFwXG4gKiBAcGFyYW0gIHtTdXBwb3J0ZWRDaGFubmVsTWFwID0gRGVmYXVsdFN1cHBvcnRlZENoYW5uZWxNYXB9IHN1cHBvcnRlZENoYW5uZWxNYXBcbiAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJuIG9uZSByZWFzb24gd2h5IHRoZSBlbmNvZGluZyBpcyBpbnZhbGlkLFxuICogICAgICAgICAgICAgICAgICBvciBudWxsIGlmIHRoZSBlbmNvZGluZyBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW5jb2RpbmdNYXBwaW5nRXJyb3Ioc3BlYywgcmVxdWlyZWRDaGFubmVsTWFwLCBzdXBwb3J0ZWRDaGFubmVsTWFwKSB7XG4gICAgaWYgKHJlcXVpcmVkQ2hhbm5lbE1hcCA9PT0gdm9pZCAwKSB7IHJlcXVpcmVkQ2hhbm5lbE1hcCA9IGV4cG9ydHMuREVGQVVMVF9SRVFVSVJFRF9DSEFOTkVMX01BUDsgfVxuICAgIGlmIChzdXBwb3J0ZWRDaGFubmVsTWFwID09PSB2b2lkIDApIHsgc3VwcG9ydGVkQ2hhbm5lbE1hcCA9IGV4cG9ydHMuREVGQVVMVF9TVVBQT1JURURfQ0hBTk5FTF9UWVBFOyB9XG4gICAgdmFyIG1hcmsgPSBtYXJrXzEuaXNNYXJrRGVmKHNwZWMubWFyaykgPyBzcGVjLm1hcmsudHlwZSA6IHNwZWMubWFyaztcbiAgICB2YXIgZW5jb2RpbmcgPSBzcGVjLmVuY29kaW5nO1xuICAgIHZhciByZXF1aXJlZENoYW5uZWxzID0gcmVxdWlyZWRDaGFubmVsTWFwW21hcmtdO1xuICAgIHZhciBzdXBwb3J0ZWRDaGFubmVscyA9IHN1cHBvcnRlZENoYW5uZWxNYXBbbWFya107XG4gICAgZm9yICh2YXIgaSBpbiByZXF1aXJlZENoYW5uZWxzKSB7XG4gICAgICAgIGlmICghKHJlcXVpcmVkQ2hhbm5lbHNbaV0gaW4gZW5jb2RpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01pc3NpbmcgZW5jb2RpbmcgY2hhbm5lbCBcXFwiJyArIHJlcXVpcmVkQ2hhbm5lbHNbaV0gK1xuICAgICAgICAgICAgICAgICdcXFwiIGZvciBtYXJrIFxcXCInICsgbWFyayArICdcXFwiJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBjaGFubmVsIGluIGVuY29kaW5nKSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ2hhbm5lbHNbY2hhbm5lbF0pIHtcbiAgICAgICAgICAgIHJldHVybiAnRW5jb2RpbmcgY2hhbm5lbCBcXFwiJyArIGNoYW5uZWwgK1xuICAgICAgICAgICAgICAgICdcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgbWFyayB0eXBlIFxcXCInICsgbWFyayArICdcXFwiJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWFyayA9PT0gbWFya18yLkJBUiAmJiAhZW5jb2RpbmcueCAmJiAhZW5jb2RpbmcueSkge1xuICAgICAgICByZXR1cm4gJ01pc3NpbmcgYm90aCB4IGFuZCB5IGZvciBiYXInO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0RW5jb2RpbmdNYXBwaW5nRXJyb3IgPSBnZXRFbmNvZGluZ01hcHBpbmdFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRtRnNhV1JoZEdVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12ZG1Gc2FXUmhkR1V1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3dyUWtGQmFVTTdRVUZIYWtNc2JVTkJRVzFETzBGQlJXNURMQ3RDUVVFeVFqdEJRVU16UWl3clFrRkJOa0k3UVVGTk4wSTdPenRIUVVkSE8wRkJRMVVzVVVGQlFTdzBRa0ZCTkVJc1IwRkJkVUk3U1VGRE9VUXNTVUZCU1N4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRMlFzU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJRenRKUVVOb1FpeEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRE8wTkJRMnBDTEVOQlFVTTdRVUZSUmpzN1IwRkZSenRCUVVOVkxGRkJRVUVzT0VKQlFUaENMRWRCUVhkQ08wbEJRMnBGTEVkQlFVY3NSVUZCUlN4WlFVRkxMRU5CUVVNc1EwRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1RVRkJUU3hGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTnNSU3hKUVVGSkxFVkJRVVVzV1VGQlN5eERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEU5QlFVOHNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVNelJDeEpRVUZKTEVWQlFVVXNXVUZCU3l4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU16UkN4SlFVRkpMRVZCUVVVc1dVRkJTeXhEUVVGRExFTkJRVU1zUzBGQlN5eEZRVUZGTEZGQlFWRXNSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3hOUVVGTkxFVkJRVVVzV1VGQlN5eERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEU5QlFVOHNSVUZCUlN4TlFVRk5MRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03U1VGRGNrVXNUVUZCVFN4RlFVRkZMRmxCUVVzc1EwRkJReXhEUVVGRExFdEJRVXNzUlVGQlJTeFJRVUZSTEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUTNKRkxFdEJRVXNzUlVGQlJTeFpRVUZMTEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1VVRkJVU3hGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNUMEZCVHl4RlFVRkZMRTFCUVUwc1JVRkJSU3hSUVVGUkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdTVUZETjBVc1NVRkJTU3hGUVVGRkxGbEJRVXNzUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCUlN4UlFVRlJMRVZCUVVVc1RVRkJUU3hGUVVGRkxFOUJRVThzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRzlDUVVGdlFqdERRVU0zUlN4RFFVRkRPMEZCUlVZc2MwUkJRWE5FTzBGQlEzUkVMRGhEUVVFNFF6dEJRVVU1UXpzN096czdPenM3T3pzN08wZEJXVWM3UVVGRFNDeHBRMEZCZDBNc1NVRkJPRUlzUlVGRGNFVXNhMEpCUVhGRkxFVkJRM0pGTEcxQ1FVRjVSVHRKUVVSNlJTeHRRMEZCUVN4RlFVRkJMSEZDUVVGNVF5eHZRMEZCTkVJN1NVRkRja1VzYjBOQlFVRXNSVUZCUVN4elFrRkJNa01zYzBOQlFUaENPMGxCUlhwRkxFbEJRVTBzU1VGQlNTeEhRVUZITEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZETDBRc1NVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXp0SlFVTXZRaXhKUVVGTkxHZENRVUZuUWl4SFFVRkhMR3RDUVVGclFpeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTJ4RUxFbEJRVTBzYVVKQlFXbENMRWRCUVVjc2JVSkJRVzFDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkZjRVFzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCVFN4RFFVRkRMRWxCUVVrc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrTXNUVUZCVFN4RFFVRkRMRFpDUVVFMlFpeEhRVUZITEdkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVRc1owSkJRV2RDTEVkQlFVY3NTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVOdVF5eERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVkVMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVTBzVDBGQlR5eEpRVUZKTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMMElzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRU1zVFVGQlRTeERRVUZETEhGQ1FVRnhRaXhIUVVGSExFOUJRVTg3WjBKQlEzQkRMSEZEUVVGeFF5eEhRVUZITEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkRlRVFzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzVlVGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RExFMUJRVTBzUTBGQlF5dzRRa0ZCT0VJc1EwRkJRenRKUVVONFF5eERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOa0xFTkJRVU03UVVFMVFrUXNNRVJCTkVKREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gaXNEYXRhUmVmVW5pb25lZERvbWFpbihkb21haW4pIHtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuICdmaWVsZHMnIGluIGRvbWFpbiAmJiAhKCdkYXRhJyBpbiBkb21haW4pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzRGF0YVJlZlVuaW9uZWREb21haW4gPSBpc0RhdGFSZWZVbmlvbmVkRG9tYWluO1xuZnVuY3Rpb24gaXNGaWVsZFJlZlVuaW9uRG9tYWluKGRvbWFpbikge1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gJ2ZpZWxkcycgaW4gZG9tYWluICYmICdkYXRhJyBpbiBkb21haW47XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNGaWVsZFJlZlVuaW9uRG9tYWluID0gaXNGaWVsZFJlZlVuaW9uRG9tYWluO1xuZnVuY3Rpb24gaXNEYXRhUmVmRG9tYWluKGRvbWFpbikge1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gJ2ZpZWxkJyBpbiBkb21haW4gJiYgJ2RhdGEnIGluIGRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0RhdGFSZWZEb21haW4gPSBpc0RhdGFSZWZEb21haW47XG5mdW5jdGlvbiBpc1NpZ25hbFJlZkRvbWFpbihkb21haW4pIHtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuICdzaWduYWwnIGluIGRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1NpZ25hbFJlZkRvbWFpbiA9IGlzU2lnbmFsUmVmRG9tYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZG1WbllTNXpZMmhsYldFdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12ZG1WbllTNXpZMmhsYldFdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZIUVN3clFrRkJLMEk3UVVGclNDOUNMR2REUVVGMVF5eE5RVUZuUWp0SlFVTnlSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNUVUZCVFN4RFFVRkRMRkZCUVZFc1NVRkJTU3hOUVVGTkxFbEJRVWtzUTBGQlF5eERRVUZETEUxQlFVMHNTVUZCU1N4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVOdVJDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRCUVVObUxFTkJRVU03UVVGTVJDeDNSRUZMUXp0QlFVVkVMQ3RDUVVGelF5eE5RVUZuUWp0SlFVTndSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNUVUZCVFN4RFFVRkRMRkZCUVZFc1NVRkJTU3hOUVVGTkxFbEJRVWtzVFVGQlRTeEpRVUZKTEUxQlFVMHNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0QlFVTm1MRU5CUVVNN1FVRk1SQ3h6UkVGTFF6dEJRVVZFTEhsQ1FVRm5ReXhOUVVGblFqdEpRVU01UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHTkJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRjRUlzVFVGQlRTeERRVUZETEU5QlFVOHNTVUZCU1N4TlFVRk5MRWxCUVVrc1RVRkJUU3hKUVVGSkxFMUJRVTBzUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU5tTEVOQlFVTTdRVUZNUkN3d1EwRkxRenRCUVVWRUxESkNRVUZyUXl4TlFVRm5RanRKUVVOb1JDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMR05CUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY2tJc1RVRkJUU3hEUVVGRExGRkJRVkVzU1VGQlNTeE5RVUZOTEVOQlFVTTdTVUZETlVJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdRVUZEWml4RFFVRkRPMEZCVEVRc09FTkJTME1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5heGlzID0gcmVxdWlyZShcIi4vYXhpc1wiKTtcbmV4cG9ydHMuYWdncmVnYXRlID0gcmVxdWlyZShcIi4vYWdncmVnYXRlXCIpO1xuZXhwb3J0cy5iaW4gPSByZXF1aXJlKFwiLi9iaW5cIik7XG5leHBvcnRzLmNoYW5uZWwgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuZXhwb3J0cy5jb21wb3NpdGVNYXJrID0gcmVxdWlyZShcIi4vY29tcG9zaXRlbWFya1wiKTtcbnZhciBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvbXBpbGVcIik7XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXzEuY29tcGlsZTtcbmV4cG9ydHMuY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuZXhwb3J0cy5kYXRhID0gcmVxdWlyZShcIi4vZGF0YVwiKTtcbmV4cG9ydHMuZGF0ZXRpbWUgPSByZXF1aXJlKFwiLi9kYXRldGltZVwiKTtcbmV4cG9ydHMuZW5jb2RpbmcgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbmV4cG9ydHMuZmFjZXQgPSByZXF1aXJlKFwiLi9mYWNldFwiKTtcbmV4cG9ydHMuZmllbGREZWYgPSByZXF1aXJlKFwiLi9maWVsZGRlZlwiKTtcbmV4cG9ydHMubGVnZW5kID0gcmVxdWlyZShcIi4vbGVnZW5kXCIpO1xuZXhwb3J0cy5tYXJrID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbmV4cG9ydHMuc2NhbGUgPSByZXF1aXJlKFwiLi9zY2FsZVwiKTtcbmV4cG9ydHMuc29ydCA9IHJlcXVpcmUoXCIuL3NvcnRcIik7XG5leHBvcnRzLnNwZWMgPSByZXF1aXJlKFwiLi9zcGVjXCIpO1xuZXhwb3J0cy5zdGFjayA9IHJlcXVpcmUoXCIuL3N0YWNrXCIpO1xuZXhwb3J0cy50aW1lVW5pdCA9IHJlcXVpcmUoXCIuL3RpbWV1bml0XCIpO1xuZXhwb3J0cy50cmFuc2Zvcm0gPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1cIik7XG5leHBvcnRzLnR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuZXhwb3J0cy51dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMudmFsaWRhdGUgPSByZXF1aXJlKFwiLi92YWxpZGF0ZVwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkbXd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZkbXd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3hwUTBGQmRVTTdRVUZEZGtNc01rTkJRV2xFTzBGQlEycEVMQ3RDUVVGeFF6dEJRVU55UXl4MVEwRkJOa003UVVGRE4wTXNiVVJCUVhsRU8wRkJRM3BFTERaRFFVRXlRenRCUVVGdVF5dzBRa0ZCUVN4UFFVRlBMRU5CUVVFN1FVRkRaaXh4UTBGQk1rTTdRVUZETTBNc2FVTkJRWFZETzBGQlEzWkRMSGxEUVVFclF6dEJRVU12UXl4NVEwRkJLME03UVVGREwwTXNiVU5CUVhsRE8wRkJRM3BETEhsRFFVRXJRenRCUVVNdlF5eHhRMEZCTWtNN1FVRkRNME1zYVVOQlFYVkRPMEZCUTNaRExHMURRVUY1UXp0QlFVTjZReXhwUTBGQmRVTTdRVUZEZGtNc2FVTkJRWFZETzBGQlEzWkRMRzFEUVVGNVF6dEJRVU42UXl4NVEwRkJLME03UVVGREwwTXNNa05CUVdsRU8wRkJRMnBFTEdsRFFVRjFRenRCUVVOMlF5eHBRMEZCZFVNN1FVRkRka01zZVVOQlFTdERPMEZCUld4RExGRkJRVUVzVDBGQlR5eEhRVUZYTEU5QlFVOHNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXlKOSIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC52ZWdhID0gZ2xvYmFsLnZlZ2EgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBhY2Nlc3NvciA9IGZ1bmN0aW9uKGZuLCBmaWVsZHMsIG5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICBmbi5maWVsZHMgPSBmaWVsZHMgfHwgW10sXG4gICAgZm4uZm5hbWUgPSBuYW1lLFxuICAgIGZuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFjY2Vzc29yTmFtZShmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IG51bGwgOiBmbi5mbmFtZTtcbn1cblxuZnVuY3Rpb24gYWNjZXNzb3JGaWVsZHMoZm4pIHtcbiAgcmV0dXJuIGZuID09IG51bGwgPyBudWxsIDogZm4uZmllbGRzO1xufVxuXG52YXIgZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHRocm93IEVycm9yKG1lc3NhZ2UpO1xufVxuXG52YXIgc3BsaXRBY2Nlc3NQYXRoID0gZnVuY3Rpb24ocCkge1xuICB2YXIgcGF0aCA9IFtdLFxuICAgICAgcSA9IG51bGwsXG4gICAgICBiID0gMCxcbiAgICAgIG4gPSBwLmxlbmd0aCxcbiAgICAgIHMgPSAnJyxcbiAgICAgIGksIGosIGM7XG5cbiAgcCA9IHAgKyAnJztcblxuICBmdW5jdGlvbiBwdXNoKCkge1xuICAgIHBhdGgucHVzaChzICsgcC5zdWJzdHJpbmcoaSwgaikpO1xuICAgIHMgPSAnJztcbiAgICBpID0gaiArIDE7XG4gIH1cblxuICBmb3IgKGk9aj0wOyBqPG47ICsraikge1xuICAgIGMgPSBwW2pdO1xuICAgIGlmIChjID09PSAnXFxcXCcpIHMgKz0gcC5zdWJzdHJpbmcoaSwgaiksIGkgPSArK2o7XG4gICAgZWxzZSBpZiAoYyA9PT0gcSkgcHVzaCgpLCBxID0gbnVsbCwgYiA9IC0xO1xuICAgIGVsc2UgaWYgKHEpIGNvbnRpbnVlO1xuICAgIGVsc2UgaWYgKGkgPT09IGIgJiYgYyA9PT0gJ1wiJykgaSA9IGogKyAxLCBxID0gYztcbiAgICBlbHNlIGlmIChpID09PSBiICYmIGMgPT09IFwiJ1wiKSBpID0gaiArIDEsIHEgPSBjO1xuICAgIGVsc2UgaWYgKGMgPT09ICcuJyAmJiAhYikgKGogPiBpKSA/IHB1c2goKSA6IChpID0gaiArIDEpO1xuICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgaWYgKGogPiBpKSBwdXNoKCk7XG4gICAgICBiID0gaSA9IGogKyAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgIGlmICghYikgZXJyb3IoJ0FjY2VzcyBwYXRoIG1pc3Npbmcgb3BlbiBicmFja2V0OiAnICsgcCk7XG4gICAgICBpZiAoYiA+IDApIHB1c2goKTtcbiAgICAgIGIgPSAwO1xuICAgICAgaSA9IGogKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChiKSBlcnJvcignQWNjZXNzIHBhdGggbWlzc2luZyBjbG9zaW5nIGJyYWNrZXQ6ICcgKyBwKTtcbiAgaWYgKHEpIGVycm9yKCdBY2Nlc3MgcGF0aCBtaXNzaW5nIGNsb3NpbmcgcXVvdGU6ICcgKyBwKTtcbiAgaWYgKGogPiBpKSArK2osIHB1c2goKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gXyA9PT0gT2JqZWN0KF8pO1xufVxuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uICQoeCkge1xuICByZXR1cm4gaXNBcnJheSh4KSA/ICdbJyArIHgubWFwKCQpICsgJ10nXG4gICAgOiBpc09iamVjdCh4KSB8fCBpc1N0cmluZyh4KSA/XG4gICAgICAvLyBPdXRwdXQgdmFsaWQgSlNPTiBhbmQgSlMgc291cmNlIHN0cmluZ3MuXG4gICAgICAvLyBTZWUgaHR0cDovL3RpbWVsZXNzcmVwby5jb20vanNvbi1pc250LWEtamF2YXNjcmlwdC1zdWJzZXRcbiAgICAgIEpTT04uc3RyaW5naWZ5KHgpLnJlcGxhY2UoJ1xcdTIwMjgnLCdcXFxcdTIwMjgnKS5yZXBsYWNlKCdcXHUyMDI5JywgJ1xcXFx1MjAyOScpXG4gICAgOiB4O1xufVxuXG52YXIgZmllbGQgPSBmdW5jdGlvbihmaWVsZCwgbmFtZSkge1xuICB2YXIgcGF0aCA9IHNwbGl0QWNjZXNzUGF0aChmaWVsZCksXG4gICAgICBjb2RlID0gJ3JldHVybiBfWycgKyBwYXRoLm1hcCgkKS5qb2luKCddWycpICsgJ107JztcblxuICByZXR1cm4gYWNjZXNzb3IoXG4gICAgRnVuY3Rpb24oJ18nLCBjb2RlKSxcbiAgICBbKGZpZWxkID0gcGF0aC5sZW5ndGg9PT0xID8gcGF0aFswXSA6IGZpZWxkKV0sXG4gICAgbmFtZSB8fCBmaWVsZFxuICApO1xufVxuXG52YXIgZW1wdHkgPSBbXTtcblxudmFyIGlkID0gZmllbGQoJ2lkJyk7XG5cbnZhciBpZGVudGl0eSA9IGFjY2Vzc29yKGZ1bmN0aW9uKF8pIHsgcmV0dXJuIF87IH0sIGVtcHR5LCAnaWRlbnRpdHknKTtcblxudmFyIHplcm8gPSBhY2Nlc3NvcihmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sIGVtcHR5LCAnemVybycpO1xuXG52YXIgb25lID0gYWNjZXNzb3IoZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9LCBlbXB0eSwgJ29uZScpO1xuXG52YXIgdHJ1dGh5ID0gYWNjZXNzb3IoZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LCBlbXB0eSwgJ3RydWUnKTtcblxudmFyIGZhbHN5ID0gYWNjZXNzb3IoZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSwgZW1wdHksICdmYWxzZScpO1xuXG5mdW5jdGlvbiBsb2cobWV0aG9kLCBsZXZlbCwgaW5wdXQpIHtcbiAgdmFyIGFyZ3MgPSBbbGV2ZWxdLmNvbmNhdChbXS5zbGljZS5jYWxsKGlucHV0KSk7XG4gIGNvbnNvbGVbbWV0aG9kXS5hcHBseShjb25zb2xlLCBhcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbnZhciBOb25lICA9IDA7XG52YXIgV2FybiAgPSAxO1xudmFyIEluZm8gID0gMjtcbnZhciBEZWJ1ZyA9IDM7XG5cbnZhciBsb2dnZXIgPSBmdW5jdGlvbihfKSB7XG4gIHZhciBsZXZlbCA9IF8gfHwgTm9uZTtcbiAgcmV0dXJuIHtcbiAgICBsZXZlbDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGV2ZWwgPSArXywgdGhpcykgOiBsZXZlbDtcbiAgICB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxldmVsID49IFdhcm4pIGxvZygnd2FybicsICdXQVJOJywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gSW5mbykgbG9nKCdsb2cnLCAnSU5GTycsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlYnVnOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsZXZlbCA+PSBEZWJ1ZykgbG9nKCdsb2cnLCAnREVCVUcnLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG59XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIF8gIT0gbnVsbCA/IChpc0FycmF5KF8pID8gXyA6IFtfXSkgOiBbXTtcbn1cblxudmFyIGNvbXBhcmUgPSBmdW5jdGlvbihmaWVsZHMsIG9yZGVycykge1xuICB2YXIgaWR4ID0gW10sXG4gICAgICBjbXAgPSAoZmllbGRzID0gYXJyYXkoZmllbGRzKSkubWFwKGZ1bmN0aW9uKGYsIGkpIHtcbiAgICAgICAgcmV0dXJuIGYgPT0gbnVsbCA/IG51bGxcbiAgICAgICAgICA6IChpZHgucHVzaChpKSwgc3BsaXRBY2Nlc3NQYXRoKGYpLm1hcCgkKS5qb2luKCddWycpKTtcbiAgICAgIH0pLFxuICAgICAgbiA9IGlkeC5sZW5ndGggLSAxLFxuICAgICAgb3JkID0gYXJyYXkob3JkZXJzKSxcbiAgICAgIGNvZGUgPSAndmFyIHUsdjtyZXR1cm4gJyxcbiAgICAgIGksIGosIGYsIHUsIHYsIGQsIGx0LCBndDtcblxuICBpZiAobiA8IDApIHJldHVybiBudWxsO1xuXG4gIGZvciAoaj0wOyBqPD1uOyArK2opIHtcbiAgICBpID0gaWR4W2pdO1xuICAgIGYgPSBjbXBbaV07XG4gICAgdSA9ICcodT1hWycrZisnXSknO1xuICAgIHYgPSAnKHY9YlsnK2YrJ10pJztcbiAgICBkID0gJygodj12IGluc3RhbmNlb2YgRGF0ZT8rdjp2KSwodT11IGluc3RhbmNlb2YgRGF0ZT8rdTp1KSknO1xuICAgIGx0ID0gb3JkW2ldICE9PSAnZGVzY2VuZGluZycgPyAoZ3Q9MSwgLTEpIDogKGd0PS0xLCAxKTtcbiAgICBjb2RlICs9ICcoJyArIHUrJzwnK3YrJ3x8dT09bnVsbCkmJnYhPW51bGw/JyArIGx0XG4gICAgICArICc6KHU+dnx8dj09bnVsbCkmJnUhPW51bGw/JyArIGd0XG4gICAgICArICc6JytkKychPT11JiZ2PT09dj8nICsgbHRcbiAgICAgICsgJzp2IT09diYmdT09PXU/JyArIGd0XG4gICAgICArIChpIDwgbiA/ICc6JyA6ICc6MCcpO1xuICB9XG5cbiAgcmV0dXJuIGFjY2Vzc29yKFxuICAgIEZ1bmN0aW9uKCdhJywgJ2InLCBjb2RlICsgJzsnKSxcbiAgICBmaWVsZHMuZmlsdGVyKGZ1bmN0aW9uKF8pIHsgcmV0dXJuIF8gIT0gbnVsbDsgfSlcbiAgKTtcbn1cblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gaXNGdW5jdGlvbihfKSA/IF8gOiBmdW5jdGlvbigpIHsgcmV0dXJuIF87IH07XG59XG5cbnZhciBleHRlbmQgPSBmdW5jdGlvbihfKSB7XG4gIGZvciAodmFyIHgsIGssIGk9MSwgbGVuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoayBpbiB4KSB7IF9ba10gPSB4W2tdOyB9XG4gIH1cbiAgcmV0dXJuIF87XG59XG5cbnZhciBleHRlbnRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgYSwgYiwgYywgdSwgdjtcblxuICBpZiAoZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYyA9IGI7IGJyZWFrOyB9XG4gICAgdSA9IHYgPSBpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCkge1xuICAgICAgaWYgKGEgPiBiKSBhID0gYiwgdSA9IGk7XG4gICAgICBpZiAoYyA8IGIpIGMgPSBiLCB2ID0gaTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGMgPSBiOyBicmVhazsgfVxuICAgIHUgPSB2ID0gaTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoYSA+IGIpIGEgPSBiLCB1ID0gaTtcbiAgICAgIGlmIChjIDwgYikgYyA9IGIsIHYgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbdSwgdl07XG59XG5cbnZhciBOVUxMID0ge307XG5cbnZhciBmYXN0bWFwID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG9iaiA9IHt9LFxuICAgICAgbWFwLFxuICAgICAgdGVzdDtcblxuICBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldICE9PSBOVUxMO1xuICB9XG5cbiAgbWFwID0ge1xuICAgIHNpemU6IDAsXG4gICAgZW1wdHk6IDAsXG4gICAgb2JqZWN0OiBvYmosXG4gICAgaGFzOiBoYXMsXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoYXMoa2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWhhcyhrZXkpKSB7XG4gICAgICAgICsrbWFwLnNpemU7XG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gTlVMTCkgLS1tYXAuZW1wdHk7XG4gICAgICB9XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGhhcyhrZXkpKSB7XG4gICAgICAgIC0tbWFwLnNpemU7XG4gICAgICAgICsrbWFwLmVtcHR5O1xuICAgICAgICBvYmpba2V5XSA9IE5VTEw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIG1hcC5zaXplID0gbWFwLmVtcHR5ID0gMDtcbiAgICAgIG1hcC5vYmplY3QgPSBvYmogPSB7fTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRlc3QgPSBfLCBtYXApIDogdGVzdDtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXh0ID0ge30sXG4gICAgICAgICAgc2l6ZSA9IDAsXG4gICAgICAgICAga2V5LCB2YWx1ZTtcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodmFsdWUgIT09IE5VTEwgJiYgKCF0ZXN0IHx8ICF0ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgICBuZXh0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICArK3NpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICAgIG1hcC5lbXB0eSA9IDA7XG4gICAgICBtYXAub2JqZWN0ID0gKG9iaiA9IG5leHQpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoaW5wdXQpIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIG1hcC5zZXQoa2V5LCBpbnB1dFtrZXldKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkge1xuICB2YXIgcHJvdG8gPSAoY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIHJldHVybiBwcm90bztcbn1cblxudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIHR5cGVvZiBfID09PSAnYm9vbGVhbic7XG59XG5cbnZhciBpc0RhdGUgPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXykgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdudW1iZXInO1xufVxuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG52YXIga2V5ID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyA/IGFycmF5KGZpZWxkcykgOiBmaWVsZHM7XG4gIHZhciBmbiA9ICEoZmllbGRzICYmIGZpZWxkcy5sZW5ndGgpXG4gICAgPyBmdW5jdGlvbigpIHsgcmV0dXJuICcnOyB9XG4gICAgOiBGdW5jdGlvbignXycsICdyZXR1cm4gXFwnXFwnKycgK1xuICAgICAgICBmaWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gJ19bJyArIHNwbGl0QWNjZXNzUGF0aChmKS5tYXAoJCkuam9pbignXVsnKSArICddJztcbiAgICAgICAgfSkuam9pbignK1xcJ3xcXCcrJykgKyAnOycpO1xuICByZXR1cm4gYWNjZXNzb3IoZm4sIGZpZWxkcywgJ2tleScpO1xufVxuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbihjb21wYXJlLCBhcnJheTAsIGFycmF5MSwgb3V0cHV0KSB7XG4gIHZhciBuMCA9IGFycmF5MC5sZW5ndGgsXG4gICAgICBuMSA9IGFycmF5MS5sZW5ndGg7XG5cbiAgaWYgKCFuMSkgcmV0dXJuIGFycmF5MDtcbiAgaWYgKCFuMCkgcmV0dXJuIGFycmF5MTtcblxuICB2YXIgbWVyZ2VkID0gb3V0cHV0IHx8IG5ldyBhcnJheTAuY29uc3RydWN0b3IobjAgKyBuMSksXG4gICAgICBpMCA9IDAsIGkxID0gMCwgaSA9IDA7XG5cbiAgZm9yICg7IGkwPG4wICYmIGkxPG4xOyArK2kpIHtcbiAgICBtZXJnZWRbaV0gPSBjb21wYXJlKGFycmF5MFtpMF0sIGFycmF5MVtpMV0pID4gMFxuICAgICAgID8gYXJyYXkxW2kxKytdXG4gICAgICAgOiBhcnJheTBbaTArK107XG4gIH1cblxuICBmb3IgKDsgaTA8bjA7ICsraTAsICsraSkge1xuICAgIG1lcmdlZFtpXSA9IGFycmF5MFtpMF07XG4gIH1cblxuICBmb3IgKDsgaTE8bjE7ICsraTEsICsraSkge1xuICAgIG1lcmdlZFtpXSA9IGFycmF5MVtpMV07XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG52YXIgcmVwZWF0ID0gZnVuY3Rpb24oc3RyLCByZXBzKSB7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLXJlcHMgPj0gMCkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG52YXIgcGFkID0gZnVuY3Rpb24oc3RyLCBsZW5ndGgsIHBhZGNoYXIsIGFsaWduKSB7XG4gIHZhciBjID0gcGFkY2hhciB8fCAnICcsXG4gICAgICBzID0gc3RyICsgJycsXG4gICAgICBuID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG5cbiAgcmV0dXJuIG4gPD0gMCA/IHNcbiAgICA6IGFsaWduID09PSAnbGVmdCcgPyByZXBlYXQoYywgbikgKyBzXG4gICAgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyByZXBlYXQoYywgfn4obi8yKSkgKyBzICsgcmVwZWF0KGMsIE1hdGguY2VpbChuLzIpKVxuICAgIDogcyArIHJlcGVhdChjLCBuKTtcbn1cblxudmFyIHBlZWsgPSBmdW5jdGlvbihhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG59XG5cbnZhciB0b0Jvb2xlYW4gPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBfID09IG51bGwgfHwgXyA9PT0gJycgPyBudWxsIDogIV8gfHwgXyA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogISFfO1xufVxuXG52YXIgdG9EYXRlID0gZnVuY3Rpb24oXywgcGFyc2VyKSB7XG4gIHJldHVybiBfID09IG51bGwgfHwgXyA9PT0gJycgPyBudWxsIDogKHBhcnNlciA/IHBhcnNlcihfKSA6IERhdGUucGFyc2UoXykpO1xufVxuXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBfID09IG51bGwgfHwgXyA9PT0gJycgPyBudWxsIDogK187XG59XG5cbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIF8gPT0gbnVsbCB8fCBfID09PSAnJyA/IG51bGwgOiBfICsgJyc7XG59XG5cbnZhciB0b1NldCA9IGZ1bmN0aW9uKF8pIHtcbiAgZm9yICh2YXIgcz17fSwgaT0wLCBuPV8ubGVuZ3RoOyBpPG47ICsraSkgc1tfW2ldXSA9IDE7XG4gIHJldHVybiBzO1xufVxuXG52YXIgdHJ1bmNhdGUgPSBmdW5jdGlvbihzdHIsIGxlbmd0aCwgYWxpZ24sIGVsbGlwc2lzKSB7XG4gIHZhciBlID0gZWxsaXBzaXMgIT0gbnVsbCA/IGVsbGlwc2lzIDogJ1xcdTIwMjYnLFxuICAgICAgcyA9IHN0ciArICcnLFxuICAgICAgbiA9IHMubGVuZ3RoLFxuICAgICAgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGUubGVuZ3RoKTtcblxuICByZXR1cm4gbiA8PSBsZW5ndGggPyBzXG4gICAgOiBhbGlnbiA9PT0gJ2xlZnQnID8gZSArIHMuc2xpY2UobiAtIGwpXG4gICAgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyBzLnNsaWNlKDAsIE1hdGguY2VpbChsLzIpKSArIGUgKyBzLnNsaWNlKG4gLSB+fihsLzIpKVxuICAgIDogcy5zbGljZSgwLCBsKSArIGU7XG59XG5cbnZhciB2aXNpdEFycmF5ID0gZnVuY3Rpb24oYXJyYXksIGZpbHRlciwgdmlzaXRvcikge1xuICBpZiAoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIHQ7XG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgICAgIGlmICh0ID0gZmlsdGVyKGFycmF5W2ldKSkgdmlzaXRvcih0LCBpLCBhcnJheSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5LmZvckVhY2godmlzaXRvcik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuYWNjZXNzb3IgPSBhY2Nlc3NvcjtcbmV4cG9ydHMuYWNjZXNzb3JOYW1lID0gYWNjZXNzb3JOYW1lO1xuZXhwb3J0cy5hY2Nlc3NvckZpZWxkcyA9IGFjY2Vzc29yRmllbGRzO1xuZXhwb3J0cy5pZCA9IGlkO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy56ZXJvID0gemVybztcbmV4cG9ydHMub25lID0gb25lO1xuZXhwb3J0cy50cnV0aHkgPSB0cnV0aHk7XG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG5leHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcbmV4cG9ydHMuTm9uZSA9IE5vbmU7XG5leHBvcnRzLldhcm4gPSBXYXJuO1xuZXhwb3J0cy5JbmZvID0gSW5mbztcbmV4cG9ydHMuRGVidWcgPSBEZWJ1ZztcbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5leHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZXh0ZW50SW5kZXggPSBleHRlbnRJbmRleDtcbmV4cG9ydHMuZmFzdG1hcCA9IGZhc3RtYXA7XG5leHBvcnRzLmZpZWxkID0gZmllbGQ7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmtleSA9IGtleTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMucGFkID0gcGFkO1xuZXhwb3J0cy5wZWVrID0gcGVlaztcbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xuZXhwb3J0cy5zcGxpdEFjY2Vzc1BhdGggPSBzcGxpdEFjY2Vzc1BhdGg7XG5leHBvcnRzLnN0cmluZ1ZhbHVlID0gJDtcbmV4cG9ydHMudG9Cb29sZWFuID0gdG9Cb29sZWFuO1xuZXhwb3J0cy50b0RhdGUgPSB0b0RhdGU7XG5leHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG5leHBvcnRzLnRvU2V0ID0gdG9TZXQ7XG5leHBvcnRzLnRydW5jYXRlID0gdHJ1bmNhdGU7XG5leHBvcnRzLnZpc2l0QXJyYXkgPSB2aXNpdEFycmF5O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiaW1wb3J0IHtNYXAsIG1hcCBhcyBkM21hcH0gZnJvbSAnZDMtY29sbGVjdGlvbic7XG5pbXBvcnQge2Zvcm1hdCBhcyBkM051bWJlckZvcm1hdH0gZnJvbSAnZDMtZm9ybWF0JztcbmltcG9ydCB7RW50ZXJFbGVtZW50LCBzZWxlY3QsIFNlbGVjdGlvbn0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7dGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVNb250aCwgdGltZVNlY29uZCwgdGltZVdlZWssIHRpbWVZZWFyfSBmcm9tICdkMy10aW1lJztcbmltcG9ydCB7dGltZUZvcm1hdH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xuaW1wb3J0IHtGaWVsZERlZn0gZnJvbSAndmVnYS1saXRlL2J1aWxkL3NyYy9maWVsZGRlZic7XG5pbXBvcnQge1RvcExldmVsRXh0ZW5kZWRTcGVjfSBmcm9tICd2ZWdhLWxpdGUvYnVpbGQvc3JjL3NwZWMnO1xuaW1wb3J0IHtURU1QT1JBTH0gZnJvbSAndmVnYS1saXRlL2J1aWxkL3NyYy90eXBlJztcbmltcG9ydCAqIGFzIHZsIGZyb20gJ3ZlZ2EtbGl0ZS9idWlsZC9zcmMvdmwnO1xuaW1wb3J0IHtGaWVsZE9wdGlvbiwgT3B0aW9ufSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHtTdXBwbGVtZW50ZWRGaWVsZE9wdGlvbn0gZnJvbSAnLi9zdXBwbGVtZW50ZWRGaWVsZE9wdGlvbic7XG5cbi8vIGJ5IGRlZmF1bHQsIGRlbGF5IHNob3dpbmcgdG9vbHRpcCBmb3IgMTAwIG1zXG5jb25zdCBERUxBWSA9IDEwMDtcbmxldCB0b29sdGlwUHJvbWlzZTogbnVtYmVyID0gdW5kZWZpbmVkO1xubGV0IHRvb2x0aXBBY3RpdmUgPSBmYWxzZTtcblxuZXhwb3J0IHR5cGUgVmdWaWV3ID0gYW55O1xudHlwZSBTY2VuZUdyYXBoID0ge1xuICBkYXR1bToge1xuICAgIF9mYWNldElEOiBudW1iZXIsXG4gICAgX2lkOiBudW1iZXJcbiAgfSxcbiAgbWFyazoge1xuICAgIG1hcmt0eXBlOiBzdHJpbmcsXG4gICAgaXRlbXM6IG9iamVjdCxcbiAgICBuYW1lOiBzdHJpbmdcbiAgfVxufTtcbnR5cGUgVG9vbFRpcERhdGEgPSB7dGl0bGU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IG51bWJlciB9O1xuXG4vKipcbiogRXhwb3J0IEFQSSBmb3IgVmVnYSB2aXN1YWxpemF0aW9uczogdmcudG9vbHRpcCh2Z1ZpZXcsIG9wdGlvbnMpXG4qIG9wdGlvbnMgY2FuIHNwZWNpZnkgd2hldGhlciB0byBzaG93IGFsbCBmaWVsZHMgb3IgdG8gc2hvdyBvbmx5IGN1c3RvbSBmaWVsZHNcbiogSXQgY2FuIGFsc28gcHJvdmlkZSBjdXN0b20gdGl0bGUgYW5kIGZvcm1hdCBmb3IgZmllbGRzXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHZlZ2EodmdWaWV3OiBWZ1ZpZXcsIG9wdGlvbnM6IE9wdGlvbiA9IHtzaG93QWxsRmllbGRzOiB0cnVlfSkge1xuICAvLyBUT0RPOiBjaGFuZ2UgaXRlbSB0eXBlIHRvIHZlZ2Egc2NlbmVncmFwaFxuXG4gIC8vIGluaXRpYWxpemUgdG9vbHRpcCB3aXRoIGl0ZW0gZGF0YSBhbmQgb3B0aW9ucyBvbiBtb3VzZSBvdmVyXG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXIudG9vbHRpcEluaXQnLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkpIHtcbiAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIHByb21pc2UgYmVjYXVzZSBtb3VzZSBjYW4gb25seSBwb2ludCBhdCBvbmUgdGhpbmcgYXQgYSB0aW1lXG4gICAgICBjYW5jZWxQcm9taXNlKCk7XG5cbiAgICAgIHRvb2x0aXBQcm9taXNlID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbml0KGV2ZW50LCBpdGVtLCBvcHRpb25zKTtcbiAgICAgIH0sIG9wdGlvbnMuZGVsYXkgfHwgREVMQVkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gdXBkYXRlIHRvb2x0aXAgcG9zaXRpb24gb24gbW91c2UgbW92ZVxuICAvLyAoaW1wb3J0YW50IGZvciBsYXJnZSBtYXJrcyBlLmcuIGJhcnMpXG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUudG9vbHRpcFVwZGF0ZScsIGZ1bmN0aW9uIChldmVudDogTW91c2VFdmVudCwgaXRlbTogU2NlbmVHcmFwaCkge1xuICAgIGlmIChzaG91bGRTaG93VG9vbHRpcChpdGVtKSAmJiB0b29sdGlwQWN0aXZlKSB7XG4gICAgICB1cGRhdGUoZXZlbnQsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY2xlYXIgdG9vbHRpcCBvbiBtb3VzZSBvdXRcbiAgdmdWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0LnRvb2x0aXBSZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkpIHtcbiAgICAgIGNhbmNlbFByb21pc2UoKTtcblxuICAgICAgaWYgKHRvb2x0aXBBY3RpdmUpIHtcbiAgICAgICAgY2xlYXIoZXZlbnQsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyLnRvb2x0aXBJbml0Jyk7XG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlLnRvb2x0aXBVcGRhdGUnKTtcbiAgICAgIHZnVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dC50b29sdGlwUmVtb3ZlJyk7XG5cbiAgICAgIGNhbmNlbFByb21pc2UoKTsgLy8gY2xlYXIgdG9vbHRpcCBwcm9taXNlXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4qIEV4cG9ydCBBUEkgZm9yIFZlZ2EtTGl0ZSB2aXN1YWxpemF0aW9uczogdmwudG9vbHRpcCh2Z1ZpZXcsIHZsU3BlYywgb3B0aW9ucylcbiogb3B0aW9ucyBjYW4gc3BlY2lmeSB3aGV0aGVyIHRvIHNob3cgYWxsIGZpZWxkcyBvciB0byBzaG93IG9ubHkgY3VzdG9tIGZpZWxkc1xuKiBJdCBjYW4gYWxzbyBwcm92aWRlIGN1c3RvbSB0aXRsZSBhbmQgZm9ybWF0IGZvciBmaWVsZHNcbiogb3B0aW9ucyBjYW4gYmUgc3VwcGxlbWVudGVkIGJ5IHZsU3BlY1xuKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWdhTGl0ZSh2Z1ZpZXc6IFZnVmlldywgdmxTcGVjOiBUb3BMZXZlbEV4dGVuZGVkU3BlYywgb3B0aW9uczogT3B0aW9uID0ge30pIHtcblxuICBvcHRpb25zID0gc3VwcGxlbWVudE9wdGlvbnMob3B0aW9ucywgdmxTcGVjKTtcblxuICAvLyBUT0RPOiB1cGRhdGUgdGhpcyB0byB1c2UgbmV3IHZlZ2EtdmlldyBhcGkgKGFkZEV2ZW50TGlzdGVuZXIpXG4gIC8vIGluaXRpYWxpemUgdG9vbHRpcCB3aXRoIGl0ZW0gZGF0YSBhbmQgb3B0aW9ucyBvbiBtb3VzZSBvdmVyXG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXIudG9vbHRpcEluaXQnLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkpIHtcbiAgICAgIC8vIGNsZWFyIGV4aXN0aW5nIHByb21pc2UgYmVjYXVzZSBtb3VzZSBjYW4gb25seSBwb2ludCBhdCBvbmUgdGhpbmcgYXQgYSB0aW1lXG4gICAgICBjYW5jZWxQcm9taXNlKCk7XG5cbiAgICAgIC8vIG1ha2UgYSBuZXcgcHJvbWlzZSB3aXRoIHRpbWUgZGVsYXkgZm9yIHRvb2x0aXBcbiAgICAgIHRvb2x0aXBQcm9taXNlID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbml0KGV2ZW50LCBpdGVtLCBvcHRpb25zKTtcbiAgICAgIH0sIG9wdGlvbnMuZGVsYXkgfHwgREVMQVkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gdXBkYXRlIHRvb2x0aXAgcG9zaXRpb24gb24gbW91c2UgbW92ZVxuICAvLyAoaW1wb3J0YW50IGZvciBsYXJnZSBtYXJrcyBlLmcuIGJhcnMpXG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUudG9vbHRpcFVwZGF0ZScsIGZ1bmN0aW9uIChldmVudDogTW91c2VFdmVudCwgaXRlbTogU2NlbmVHcmFwaCkge1xuICAgIGlmIChzaG91bGRTaG93VG9vbHRpcChpdGVtKSAmJiB0b29sdGlwQWN0aXZlKSB7XG4gICAgICB1cGRhdGUoZXZlbnQsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY2xlYXIgdG9vbHRpcCBvbiBtb3VzZSBvdXRcbiAgdmdWaWV3LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0LnRvb2x0aXBSZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkpIHtcbiAgICAgIGNhbmNlbFByb21pc2UoKTtcblxuICAgICAgaWYgKHRvb2x0aXBBY3RpdmUpIHtcbiAgICAgICAgY2xlYXIoZXZlbnQsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyLnRvb2x0aXBJbml0Jyk7XG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlLnRvb2x0aXBVcGRhdGUnKTtcbiAgICAgIHZnVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dC50b29sdGlwUmVtb3ZlJyk7XG5cbiAgICAgIGNhbmNlbFByb21pc2UoKTsgLy8gY2xlYXIgdG9vbHRpcCBwcm9taXNlXG4gICAgfVxuICB9O1xufTtcblxuLyogQ2FuY2VsIHRvb2x0aXAgcHJvbWlzZSAqL1xuZnVuY3Rpb24gY2FuY2VsUHJvbWlzZSgpIHtcbiAgLyogV2UgZG9uJ3QgY2hlY2sgaWYgdG9vbHRpcFByb21pc2UgaXMgdmFsaWQgYmVjYXVzZSBwYXNzaW5nXG4gICBhbiBpbnZhbGlkIElEIHRvIGNsZWFyVGltZW91dCBkb2VzIG5vdCBoYXZlIGFueSBlZmZlY3RcbiAgIChhbmQgZG9lc24ndCB0aHJvdyBhbiBleGNlcHRpb24pLiAqL1xuICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRvb2x0aXBQcm9taXNlKTtcbiAgdG9vbHRpcFByb21pc2UgPSB1bmRlZmluZWQ7XG59XG5cbi8qIG1hcHBpbmcgZnJvbSBmaWVsZERlZi50eXBlIHRvIGZvcm1hdFR5cGUgKi9cbmNvbnN0IGZvcm1hdFR5cGVNYXA6IHtbdHlwZTogc3RyaW5nXTogJ251bWJlcicgfCAndGltZSd9ID0ge1xuICAncXVhbnRpdGF0aXZlJzogJ251bWJlcicsXG4gICd0ZW1wb3JhbCc6ICd0aW1lJyxcbiAgJ29yZGluYWwnOiB1bmRlZmluZWQsXG4gICdub21pbmFsJzogdW5kZWZpbmVkXG59O1xuXG4vKipcbiogKFZlZ2EtTGl0ZSBvbmx5KSBTdXBwbGVtZW50IG9wdGlvbnMgd2l0aCB2bFNwZWNcbipcbiogQHBhcmFtIG9wdGlvbnMgLSB1c2VyLXByb3ZpZGVkIG9wdGlvbnNcbiogQHBhcmFtIHZsU3BlYyAtIHZlZ2EtbGl0ZSBzcGVjXG4qIEByZXR1cm4gdGhlIHZsU3BlYy1zdXBwbGVtZW50ZWQgb3B0aW9ucyBvYmplY3RcbipcbiogaWYgb3B0aW9ucy5zaG93QWxsRmllbGRzIGlzIHRydWUgb3IgdW5kZWZpbmVkLCB2bFNwZWMgd2lsbCBzdXBwbGVtZW50XG4qIG9wdGlvbnMuZmllbGRzIHdpdGggYWxsIGZpZWxkcyBpbiB0aGUgc3BlY1xuKiBpZiBvcHRpb25zLnNob3dBbGxGaWVsZHMgaXMgZmFsc2UsIHZsU3BlYyB3aWxsIG9ubHkgc3VwcGxlbWVudCBleGlzdGluZyBmaWVsZHNcbiogaW4gb3B0aW9ucy5maWVsZHNcbiovXG5mdW5jdGlvbiBzdXBwbGVtZW50T3B0aW9ucyhvcHRpb25zOiBPcHRpb24sIHZsU3BlYzogVG9wTGV2ZWxFeHRlbmRlZFNwZWMpIHtcbiAgLy8gZmllbGRzIHRvIGJlIHN1cHBsZW1lbnRlZCBieSB2bFNwZWNcbiAgY29uc3Qgc3VwcGxlbWVudGVkRmllbGRzOiBGaWVsZE9wdGlvbltdID0gW107XG5cbiAgLy8gaWYgc2hvd0FsbEZpZWxkcyBpcyB0cnVlIG9yIHVuZGVmaW5lZCwgc3VwcGxlbWVudCBhbGwgZmllbGRzIGluIHZsU3BlY1xuICBpZiAob3B0aW9ucy5zaG93QWxsRmllbGRzICE9PSBmYWxzZSkge1xuICAgIHZsLnNwZWMuZmllbGREZWZzKHZsU3BlYykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGREZWY6IEZpZWxkRGVmPHN0cmluZz4pIHtcbiAgICAgIC8vIGdldCBhIGZpZWxkT3B0aW9uIGluIG9wdGlvbnMgdGhhdCBtYXRjaGVzIHRoZSBmaWVsZERlZlxuICAgICAgY29uc3QgZmllbGRPcHRpb24gPSBnZXRGaWVsZE9wdGlvbihvcHRpb25zLmZpZWxkcywgZmllbGREZWYpO1xuXG4gICAgICAvLyBzdXBwbGVtZW50IHRoZSBmaWVsZE9wdGlvbiB3aXRoIGZpZWxkRGVmIGFuZCBjb25maWdcbiAgICAgIGNvbnN0IHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uID0gc3VwcGxlbWVudEZpZWxkT3B0aW9uKGZpZWxkT3B0aW9uLCBmaWVsZERlZiwgdmxTcGVjKTtcblxuICAgICAgc3VwcGxlbWVudGVkRmllbGRzLnB1c2goc3VwcGxlbWVudGVkRmllbGRPcHRpb24pO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBpZiBzaG93QWxsRmllbGRzIGlzIGZhbHNlLCBvbmx5IHN1cHBsZW1lbnQgZXhpc3RpbmcgZmllbGRzIGluIG9wdGlvbnMuZmllbGRzXG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE9wdGlvbjogRmllbGRPcHRpb24pIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBmaWVsZERlZiBpbiB2bFNwZWMgdGhhdCBtYXRjaGVzIHRoZSBmaWVsZE9wdGlvblxuICAgICAgICBjb25zdCBmaWVsZERlZiA9IGdldEZpZWxkRGVmKHZsLnNwZWMuZmllbGREZWZzKHZsU3BlYykgYXMgRmllbGREZWY8c3RyaW5nPltdLCBmaWVsZE9wdGlvbik7XG5cbiAgICAgICAgLy8gc3VwcGxlbWVudCB0aGUgZmllbGRPcHRpb24gd2l0aCBmaWVsZERlZiBhbmQgY29uZmlnXG4gICAgICAgIGNvbnN0IHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uID0gc3VwcGxlbWVudEZpZWxkT3B0aW9uKGZpZWxkT3B0aW9uLCBmaWVsZERlZiwgdmxTcGVjKTtcblxuICAgICAgICBzdXBwbGVtZW50ZWRGaWVsZHMucHVzaChzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLmZpZWxkcyA9IHN1cHBsZW1lbnRlZEZpZWxkcztcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4qIEZpbmQgYSBmaWVsZE9wdGlvbiBpbiBmaWVsZE9wdGlvbnMgdGhhdCBtYXRjaGVzIGEgZmllbGREZWZcbipcbiogQHBhcmFtIHtPYmplY3RbXX0gZmllbGRPcHRpb25zcyAtIGEgbGlzdCBvZiBmaWVsZCBvcHRpb25zIChpLmUuIG9wdGlvbnMuZmllbGRzW10pXG4qIEBwYXJhbSB7T2JqZWN0fSBmaWVsZERlZiAtIGZyb20gdmxTcGVjXG4qIEByZXR1cm4gdGhlIG1hdGNoaW5nIGZpZWxkT3B0aW9uLCBvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4qXG4qIElmIHRoZSBmaWVsZERlZiBpcyBhZ2dyZWdhdGVkLCBmaW5kIGEgZmllbGRPcHRpb24gdGhhdCBtYXRjaGVzIHRoZSBmaWVsZCBuYW1lIGFuZFxuKiB0aGUgYWdncmVnYXRpb24gb2YgdGhlIGZpZWxkRGVmLlxuKiBJZiB0aGUgZmllbGREZWYgaXMgbm90IGFnZ3JlZ2F0ZWQsIGZpbmQgYSBmaWVsZE9wdGlvbiB0aGF0IG1hdGNoZXMgdGhlIGZpZWxkIG5hbWUuXG4qL1xuZnVuY3Rpb24gZ2V0RmllbGRPcHRpb24oZmllbGRPcHRpb25zOiBGaWVsZE9wdGlvbltdLCBmaWVsZERlZjogRmllbGREZWY8c3RyaW5nPikge1xuICBpZiAoIWZpZWxkRGVmIHx8ICFmaWVsZE9wdGlvbnMgfHwgZmllbGRPcHRpb25zLmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGlmIGFnZ3JlZ2F0ZSwgbWF0Y2ggZmllbGQgbmFtZSBhbmQgYWdncmVnYXRlIG9wZXJhdGlvblxuICBpZiAoZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgLy8gdHJ5IGZpbmQgdGhlIHBlcmZlY3QgbWF0Y2g6IGZpZWxkIG5hbWUgZXF1YWxzLCBhZ2dyZWdhdGUgb3BlcmF0aW9uIGVxdWFsc1xuICAgIGZvciAobGV0IGl0ZW0gb2YgZmllbGRPcHRpb25zKSB7XG4gICAgICBpZiAoaXRlbS5maWVsZCA9PT0gZmllbGREZWYuZmllbGQgJiYgaXRlbS5hZ2dyZWdhdGUgPT09IGZpZWxkRGVmLmFnZ3JlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cnkgZmluZCB0aGUgc2Vjb25kLWJlc3QgbWF0Y2g6IGZpZWxkIG5hbWUgZXF1YWxzLCBmaWVsZC5hZ2dyZWdhdGUgaXMgbm90IHNwZWNpZmllZFxuICAgIGZvciAobGV0IGl0ZW0gb2YgZmllbGRPcHRpb25zKSB7XG4gICAgICBpZiAoaXRlbS5maWVsZCA9PT0gZmllbGREZWYuZmllbGQgJiYgIWl0ZW0uYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHsgLy8gaWYgbm90IGFnZ3JlZ2F0ZSwganVzdCBtYXRjaCBmaWVsZCBuYW1lXG4gICAgZm9yIChsZXQgaXRlbSBvZiBmaWVsZE9wdGlvbnMpIHtcbiAgICAgIGlmIChpdGVtLmZpZWxkID09PSBmaWVsZERlZi5maWVsZCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdW5kZWZpbmVkIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4qIEZpbmQgYSBmaWVsZERlZiB0aGF0IG1hdGNoZXMgYSBmaWVsZE9wdGlvblxuKlxuKiBAcGFyYW0ge09iamVjdH0gZmllbGRPcHRpb24gLSBhIGZpZWxkIG9wdGlvbiAoYSBtZW1iZXIgaW4gb3B0aW9ucy5maWVsZHNbXSlcbiogQHJldHVybiB0aGUgbWF0Y2hpbmcgZmllbGREZWYsIG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaCB3YXMgZm91bmRcbipcbiogQSBtYXRjaGluZyBmaWVsZERlZiBzaG91bGQgaGF2ZSB0aGUgc2FtZSBmaWVsZCBuYW1lIGFzIGZpZWxkT3B0aW9uLlxuKiBJZiB0aGUgbWF0Y2hpbmcgZmllbGREZWYgaXMgYWdncmVnYXRlZCwgdGhlIGFnZ3JlZ2F0aW9uIHNob3VsZCBub3QgY29udHJhZGljdFxuKiB3aXRoIHRoYXQgb2YgdGhlIGZpZWxkT3B0aW9uLlxuKi9cbmZ1bmN0aW9uIGdldEZpZWxkRGVmKGZpZWxkRGVmczogRmllbGREZWY8c3RyaW5nPltdLCBmaWVsZE9wdGlvbjogRmllbGRPcHRpb24pOiBGaWVsZERlZjxzdHJpbmc+IHtcbiAgaWYgKCFmaWVsZE9wdGlvbiB8fCAhZmllbGRPcHRpb24uZmllbGQgfHwgIWZpZWxkRGVmcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBmaWVsZCBuYW1lIHNob3VsZCBtYXRjaCwgYWdncmVnYXRpb24gc2hvdWxkIG5vdCBkaXNhZ3JlZVxuICBmb3IgKGxldCBpdGVtIG9mIGZpZWxkRGVmcykge1xuICAgIGlmIChpdGVtLmZpZWxkID09PSBmaWVsZE9wdGlvbi5maWVsZCkge1xuICAgICAgaWYgKGl0ZW0uYWdncmVnYXRlKSB7XG4gICAgICAgIGlmIChpdGVtLmFnZ3JlZ2F0ZSA9PT0gZmllbGRPcHRpb24uYWdncmVnYXRlIHx8ICFmaWVsZE9wdGlvbi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuIHVuZGVmaW5lZCBpZiBubyBtYXRjaCB3YXMgZm91bmRcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4qIFN1cHBsZW1lbnQgYSBmaWVsZE9wdGlvbiAoZnJvbSBvcHRpb25zLmZpZWxkc1tdKSB3aXRoIGEgZmllbGREZWYsIGNvbmZpZ1xuKiAod2hpY2ggcHJvdmlkZXMgdGltZUZvcm1hdCwgbnVtYmVyRm9ybWF0LCBjb3VudFRpdGxlKVxuKiBFaXRoZXIgZmllbGRPcHRpb24gb3IgZmllbGREZWYgY2FuIGJlIHVuZGVmaW5lZCwgYnV0IHRoZXkgY2Fubm90IGJvdGggYmUgdW5kZWZpbmVkLlxuKiBjb25maWcgKGFuZCBpdHMgbWVtYmVycyB0aW1lRm9ybWF0LCBudW1iZXJGb3JtYXQgYW5kIGNvdW50VGl0bGUpIGNhbiBiZSB1bmRlZmluZWQuXG4qIEByZXR1cm4gdGhlIHN1cHBsZW1lbnRlZCBmaWVsZE9wdGlvbiwgb3IgdW5kZWZpbmVkIG9uIGVycm9yXG4qL1xuZnVuY3Rpb24gc3VwcGxlbWVudEZpZWxkT3B0aW9uKGZpZWxkT3B0aW9uOiBGaWVsZE9wdGlvbiwgZmllbGREZWY6IEZpZWxkRGVmPHN0cmluZz4sIHZsU3BlYzogVG9wTGV2ZWxFeHRlbmRlZFNwZWMpIHtcbiAgLy8gbWFueSBzcGVjcyBkb24ndCBoYXZlIGNvbmZpZ1xuICBjb25zdCBjb25maWcgPSB2bC51dGlsLmV4dGVuZCh7fSwgdmxTcGVjLmNvbmZpZyk7XG5cbiAgLy8gYXQgbGVhc3Qgb25lIG9mIGZpZWxkT3B0aW9uIGFuZCBmaWVsZERlZiBzaG91bGQgZXhpc3RcbiAgaWYgKCFmaWVsZE9wdGlvbiAmJiAhZmllbGREZWYpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVG9vbHRpcF0gQ2Fubm90IHN1cHBsZW1lbnQgYSBmaWVsZCB3aGVuIGZpZWxkIGFuZCBmaWVsZERlZiBhcmUgYm90aCBlbXB0eS4nKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gaWYgZWl0aGVyIG9uZSBvZiBmaWVsZE9wdGlvbiBhbmQgZmllbGREZWYgaXMgdW5kZWZpbmVkLCBtYWtlIGl0IGFuIGVtcHR5IG9iamVjdFxuICBpZiAoIWZpZWxkT3B0aW9uICYmIGZpZWxkRGVmKSB7XG4gICAgZmllbGRPcHRpb24gPSB7fTtcbiAgfVxuICBpZiAoZmllbGRPcHRpb24gJiYgIWZpZWxkRGVmKSB7XG4gICAgZmllbGREZWYgPSB7fTtcbiAgfVxuXG4gIC8vIHRoZSBzdXBwbGVtZW50ZWQgZmllbGQgb3B0aW9uXG4gIGNvbnN0IHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uOiBTdXBwbGVtZW50ZWRGaWVsZE9wdGlvbiA9IHt9O1xuXG4gIC8vIHN1cHBsZW1lbnQgYSB1c2VyLXByb3ZpZGVkIGZpZWxkIG5hbWUgd2l0aCB1bmRlcnNjb3JlIHByZWZpeGVzIGFuZCBzdWZmaXhlcyB0b1xuICAvLyBtYXRjaCB0aGUgZmllbGQgbmFtZXMgaW4gaXRlbS5kYXR1bVxuICAvLyBmb3IgYWdncmVnYXRpb24sIHRoaXMgd2lsbCBhZGQgcHJlZml4IFwibWVhbl9cIiBldGMuXG4gIC8vIGZvciB0aW1lVW5pdCwgdGhpcyB3aWxsIGFkZCBwcmVmaXggXCJ5ZWFybW9udGhfXCIgZXRjLlxuICAvLyBmb3IgYmluLCB0aGlzIHdpbGwgYWRkIHByZWZpeCBcImJpbl9cIiBhbmQgc3VmZml4IFwiX3N0YXJ0XCIuIExhdGVyIHdlIHdpbGwgcmVwbGFjZSBcIl9zdGFydFwiIHdpdGggXCJfcmFuZ2VcIi5cbiAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZmllbGQgPSBmaWVsZERlZi5maWVsZCA/XG4gICAgdmwuZmllbGREZWYuZmllbGQoZmllbGREZWYpIDogZmllbGRPcHRpb24uZmllbGQ7XG5cbiAgLy8gSWYgYSBmaWVsZERlZiBpcyBhIChUSU1FVU5JVClULCB3ZSBjaGVjayBpZiB0aGUgb3JpZ2luYWwgVCBpcyBwcmVzZW50IGluIHRoZSB2bFNwZWMuXG4gIC8vIElmIG9ubHkgKFRJTUVVTklUKVQgaXMgcHJlc2VudCBpbiB2bFNwZWMsIHdlIHNldCBgcmVtb3ZlT3JpZ2luYWxUZW1wb3JhbEZpZWxkYCB0byBULFxuICAvLyB3aGljaCB3aWxsIGNhdXNlIGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZVRpbWVGaWVsZHMoKSB0byByZW1vdmUgVCBhbmQgb25seSBrZWVwIChUSU1FVU5JVClUXG4gIC8vIGluIGl0ZW0gZGF0YS5cbiAgLy8gSWYgYm90aCAoVElNRVVOSVQpVCBhbmQgVCBhcmUgaW4gdmxTcGVjLCB3ZSBzZXQgYHJlbW92ZU9yaWdpbmFsVGVtcG9yYWxGaWVsZGAgdG8gdW5kZWZpbmVkLFxuICAvLyB3aGljaCB3aWxsIGxlYXZlIGJvdGggVCBhbmQgKFRJTUVVTklUKVQgaW4gaXRlbSBkYXRhLlxuICAvLyBOb3RlOiB1c2VyIHNob3VsZCBuZXZlciBoYXZlIHRvIHByb3ZpZGUgdGhpcyBib29sZWFuIGluIG9wdGlvbnNcbiAgaWYgKGZpZWxkRGVmLnR5cGUgPT09IFRFTVBPUkFMICYmIGZpZWxkRGVmLnRpbWVVbml0KSB7XG4gICAgLy8gaW4gbW9zdCBjYXNlcywgaWYgaXQncyBhIChUSU1FVU5JVClULCB3ZSByZW1vdmUgb3JpZ2luYWwgVFxuICAgIGNvbnN0IG9yaWdpbmFsVGVtcG9yYWxGaWVsZCA9IGZpZWxkRGVmLmZpZWxkO1xuICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLnJlbW92ZU9yaWdpbmFsVGVtcG9yYWxGaWVsZCA9IG9yaWdpbmFsVGVtcG9yYWxGaWVsZDtcblxuICAgIC8vIGhhbmRsZSBjb3JuZXIgY2FzZTogaWYgVCBpcyBwcmVzZW50IGluIHZsU3BlYywgdGhlbiB3ZSBrZWVwIGJvdGggVCBhbmQgKFRJTUVVTklUKVRcbiAgICBjb25zdCBmaWVsZERlZnMgPSB2bC5zcGVjLmZpZWxkRGVmcyh2bFNwZWMpO1xuICAgIGZvciAobGV0IGl0ZW1zIG9mIGZpZWxkRGVmcykge1xuICAgICAgaWYgKGl0ZW1zLmZpZWxkID09PSBvcmlnaW5hbFRlbXBvcmFsRmllbGQgJiYgIWl0ZW1zLnRpbWVVbml0KSB7XG4gICAgICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLnJlbW92ZU9yaWdpbmFsVGVtcG9yYWxGaWVsZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gc3VwcGxlbWVudCB0aXRsZVxuICBpZiAoIWNvbmZpZy5jb3VudFRpdGxlKSB7XG4gICAgY29uZmlnLmNvdW50VGl0bGUgPSB2bC5jb25maWcuZGVmYXVsdENvbmZpZy5jb3VudFRpdGxlOyAvLyB1c2UgdmwgZGVmYXVsdCBjb3VudFRpdGxlXG4gIH1cbiAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24udGl0bGUgPSBmaWVsZE9wdGlvbi50aXRsZSA/XG4gICAgZmllbGRPcHRpb24udGl0bGUgOiB2bC5maWVsZERlZi50aXRsZShmaWVsZERlZiwgY29uZmlnKTtcblxuICAvLyBzdXBwbGVtZW50IGZvcm1hdFR5cGVcbiAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZm9ybWF0VHlwZSA9IGZpZWxkT3B0aW9uLmZvcm1hdFR5cGUgP1xuICAgIGZpZWxkT3B0aW9uLmZvcm1hdFR5cGUgOiBmb3JtYXRUeXBlTWFwW2ZpZWxkRGVmLnR5cGVdO1xuXG4gIC8vIHN1cHBsZW1lbnQgZm9ybWF0XG4gIGlmIChmaWVsZE9wdGlvbi5mb3JtYXQpIHtcbiAgICBzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbi5mb3JtYXQgPSBmaWVsZE9wdGlvbi5mb3JtYXQ7XG4gIH0gZWxzZSB7IC8vIHdoZW4gdXNlciBkb2Vzbid0IHByb3ZpZGUgZm9ybWF0LCBzdXBwbGVtZW50IGZvcm1hdCB1c2luZyB0aW1lVW5pdCwgdGltZUZvcm1hdCwgYW5kIG51bWJlckZvcm1hdFxuICAgIHN3aXRjaCAoc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZm9ybWF0VHlwZSkge1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZvcm1hdCA9IGZpZWxkRGVmLnRpbWVVbml0ID9cbiAgICAgICAgICAvLyBUT0RPKHplbmluZyk6IHVzZSB0ZW1wbGF0ZSBmb3IgYWxsIHRpbWUgZmllbGRzLCB0byBiZSBjb25zaXN0ZW50IHdpdGggVmVnYS1MaXRlXG4gICAgICAgICAgdmwudGltZVVuaXQuZm9ybWF0RXhwcmVzc2lvbihmaWVsZERlZi50aW1lVW5pdCwgJycsIGZhbHNlKS5zcGxpdChcIidcIilbMV1cbiAgICAgICAgICA6IGNvbmZpZy50aW1lRm9ybWF0IHx8IHZsLmNvbmZpZy5kZWZhdWx0Q29uZmlnLnRpbWVGb3JtYXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZm9ybWF0ID0gY29uZmlnLm51bWJlckZvcm1hdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICAvLyBzdXBwbGVtZW50IGJpbiBmcm9tIGZpZWxkRGVmLCB1c2VyIHNob3VsZCBuZXZlciBoYXZlIHRvIHByb3ZpZGUgYmluIGluIG9wdGlvbnNcbiAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZpZWxkID0gc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZmllbGQucmVwbGFjZSgnX3N0YXJ0JywgJ19yYW5nZScpOyAvLyByZXBsYWNlIHN1ZmZpeFxuICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmJpbiA9IHRydWU7XG4gICAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZm9ybWF0VHlwZSA9ICdzdHJpbmcnOyAvLyB3ZSBzaG93IGJpbiByYW5nZSBhcyBzdHJpbmcgKGUuZy4gXCI1LTEwXCIpXG4gIH1cblxuICByZXR1cm4gc3VwcGxlbWVudGVkRmllbGRPcHRpb247XG59XG5cblxuLyogSW5pdGlhbGl6ZSB0b29sdGlwIHdpdGggZGF0YSAqL1xuZnVuY3Rpb24gaW5pdChldmVudDogTW91c2VFdmVudCwgaXRlbTogU2NlbmVHcmFwaCwgb3B0aW9uczogT3B0aW9uKSB7XG4gIC8vIGdldCB0b29sdGlwIEhUTUwgcGxhY2Vob2xkZXJcbiAgY29uc3QgdG9vbHRpcFBsYWNlaG9sZGVyID0gZ2V0VG9vbHRpcFBsYWNlaG9sZGVyKCk7XG5cbiAgLy8gcHJlcGFyZSBkYXRhIGZvciB0b29sdGlwXG4gIGNvbnN0IHRvb2x0aXBEYXRhID0gZ2V0VG9vbHRpcERhdGEoaXRlbSwgb3B0aW9ucyk7XG4gIGlmICghdG9vbHRpcERhdGEgfHwgdG9vbHRpcERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIGJpbmQgZGF0YSB0byB0b29sdGlwIEhUTUwgcGxhY2Vob2xkZXJcbiAgYmluZERhdGEodG9vbHRpcFBsYWNlaG9sZGVyLCB0b29sdGlwRGF0YSk7XG5cbiAgdXBkYXRlUG9zaXRpb24oZXZlbnQsIG9wdGlvbnMpO1xuICB1cGRhdGVDb2xvclRoZW1lKG9wdGlvbnMpO1xuICBzZWxlY3QoJyN2aXMtdG9vbHRpcCcpLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgdG9vbHRpcEFjdGl2ZSA9IHRydWU7XG5cbiAgLy8gaW52b2tlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2tcbiAgaWYgKG9wdGlvbnMub25BcHBlYXIpIHtcbiAgICBvcHRpb25zLm9uQXBwZWFyKGV2ZW50LCBpdGVtKTtcbiAgfVxufVxuXG4vKiBVcGRhdGUgdG9vbHRpcCBwb3NpdGlvbiBvbiBtb3VzZW1vdmUgKi9cbmZ1bmN0aW9uIHVwZGF0ZShldmVudDogTW91c2VFdmVudCwgaXRlbTogU2NlbmVHcmFwaCwgb3B0aW9uczogT3B0aW9uKSB7XG4gIHVwZGF0ZVBvc2l0aW9uKGV2ZW50LCBvcHRpb25zKTtcblxuICAvLyBpbnZva2UgdXNlci1wcm92aWRlZCBjYWxsYmFja1xuICBpZiAob3B0aW9ucy5vbk1vdmUpIHtcbiAgICBvcHRpb25zLm9uTW92ZShldmVudCwgaXRlbSk7XG4gIH1cbn1cblxuLyogQ2xlYXIgdG9vbHRpcCAqL1xuZnVuY3Rpb24gY2xlYXIoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgsIG9wdGlvbnM6IE9wdGlvbikge1xuICAvLyB2aXNpYmlsaXR5IGhpZGRlbiBpbnN0ZWFkIG9mIGRpc3BsYXkgbm9uZVxuICAvLyBiZWNhdXNlIHdlIG5lZWQgY29tcHV0ZWQgdG9vbHRpcCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGJlc3QgcG9zaXRpb24gaXRcbiAgc2VsZWN0KCcjdmlzLXRvb2x0aXAnKS5zdHlsZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcblxuICB0b29sdGlwQWN0aXZlID0gZmFsc2U7XG4gIGNsZWFyRGF0YSgpO1xuICBjbGVhckNvbG9yVGhlbWUoKTtcbiAgY2xlYXJQb3NpdGlvbigpO1xuXG4gIC8vIGludm9rZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrXG4gIGlmIChvcHRpb25zLm9uRGlzYXBwZWFyKSB7XG4gICAgb3B0aW9ucy5vbkRpc2FwcGVhcihldmVudCwgaXRlbSk7XG4gIH1cbn1cblxuXG4vKiBEZWNpZGUgaWYgYSBzY2VuZWdyYXBoIGl0ZW0gZGVzZXJ2ZXMgdG9vbHRpcCAqL1xuZnVuY3Rpb24gc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbTogU2NlbmVHcmFwaCkge1xuICAvLyBubyBkYXRhLCBubyBzaG93XG4gIGlmICghaXRlbSB8fCAhaXRlbS5kYXR1bSkgIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gKHNtYWxsIG11bHRpcGxlcykgYXZvaWQgc2hvd2luZyB0b29sdGlwIGZvciBhIGZhY2V0J3MgYmFja2dyb3VuZFxuICBpZiAoaXRlbS5kYXR1bS5fZmFjZXRJRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBhdm9pZCBzaG93aW5nIHRvb2x0aXAgZm9yIGF4aXMgdGl0bGUgYW5kIGxhYmVsc1xuICBpZiAoIWl0ZW0uZGF0dW0uX2lkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiogUHJlcGFyZSBkYXRhIGZvciB0aGUgdG9vbHRpcFxuKiBAcmV0dXJuIEFuIGFycmF5IG9mIHRvb2x0aXAgZGF0YSBbeyB0aXRsZTogLi4uLCB2YWx1ZTogLi4ufV1cbiovXG4vLyBUT0RPOiBhZGQgbWFya3R5cGVcbmZ1bmN0aW9uIGdldFRvb2x0aXBEYXRhKGl0ZW06IFNjZW5lR3JhcGgsIG9wdGlvbnM6IE9wdGlvbikge1xuICAvLyBpZ25vcmUgdGhlIGRhdGEgZm9yIGdyb3VwIHR5cGUgdGhhdCByZXByZXNlbnRzIHdoaXRlIHNwYWNlXG4gIGlmIChpdGVtLm1hcmsubWFya3R5cGUgPT09ICdncm91cCcgJiYgaXRlbS5tYXJrLm5hbWUgPT09ICduZXN0ZWRfbWFpbl9ncm91cCcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gdGhpcyBhcnJheSB3aWxsIGJlIGJpbmQgdG8gdGhlIHRvb2x0aXAgZWxlbWVudFxuICBsZXQgdG9vbHRpcERhdGE6IFRvb2xUaXBEYXRhW107XG4gIGNvbnN0IGl0ZW1EYXRhOiBNYXA8YW55PiA9IGQzbWFwKGl0ZW0uZGF0dW0pO1xuXG4gIGNvbnN0IHJlbW92ZUtleXMgPSBbXG4gICAgJ19pZCcsICdfcHJldicsICd3aWR0aCcsICdoZWlnaHQnLFxuICAgICdjb3VudF9zdGFydCcsICdjb3VudF9lbmQnLFxuICAgICdsYXlvdXRfc3RhcnQnLCAnbGF5b3V0X21pZCcsICdsYXlvdXRfZW5kJywgJ2xheW91dF9wYXRoJywgJ2xheW91dF94JywgJ2xheW91dF95J1xuICBdO1xuICByZW1vdmVGaWVsZHMoaXRlbURhdGEsIHJlbW92ZUtleXMpO1xuXG4gIC8vIHJlbW92ZSBkdXBsaWNhdGUgdGltZSBmaWVsZHMgKGlmIGFueSlcbiAgcmVtb3ZlRHVwbGljYXRlVGltZUZpZWxkcyhpdGVtRGF0YSwgb3B0aW9ucy5maWVsZHMpO1xuXG4gIC8vIGNvbWJpbmUgbXVsdGlwbGUgcm93cyBvZiBhIGJpbm5lZCBmaWVsZCBpbnRvIGEgc2luZ2xlIHJvd1xuICBjb21iaW5lQmluRmllbGRzKGl0ZW1EYXRhLCBvcHRpb25zLmZpZWxkcyk7XG5cbiAgLy8gVE9ETyh6ZW5pbmcpOiB1c2UgVmVnYS1MaXRlIGxheWVyaW5nIHRvIHN1cHBvcnQgdG9vbHRpcCBvbiBsaW5lIGFuZCBhcmVhIGNoYXJ0cyAoIzEpXG4gIGRyb3BGaWVsZHNGb3JMaW5lQXJlYShpdGVtLm1hcmsubWFya3R5cGUsIGl0ZW1EYXRhKTtcblxuICBpZiAob3B0aW9ucy5zaG93QWxsRmllbGRzID09PSB0cnVlKSB7XG4gICAgdG9vbHRpcERhdGEgPSBwcmVwYXJlQWxsRmllbGRzRGF0YShpdGVtRGF0YSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdG9vbHRpcERhdGEgPSBwcmVwYXJlQ3VzdG9tRmllbGRzRGF0YShpdGVtRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdG9vbHRpcERhdGE7XG59XG5cbi8qKlxuKiBQcmVwYXJlIGN1c3RvbSBmaWVsZHMgZGF0YSBmb3IgdG9vbHRpcC4gVGhpcyBmdW5jdGlvbiBmb3JtYXRzXG4qIGZpZWxkIHRpdGxlcyBhbmQgdmFsdWVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdHRlZCBmaWVsZHMuXG4qXG4qIEBwYXJhbSB7dGltZS5tYXB9IGl0ZW1EYXRhIC0gYSBtYXAgb2YgaXRlbS5kYXR1bVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHVzZXItcHJvdmlkZWQgb3B0aW9uc1xuKiBAcmV0dXJuIEFuIGFycmF5IG9mIGZvcm1hdHRlZCBmaWVsZHMgc3BlY2lmaWVkIGJ5IG9wdGlvbnMgW3sgdGl0bGU6IC4uLiwgdmFsdWU6IC4uLn1dXG4qL1xuZnVuY3Rpb24gcHJlcGFyZUN1c3RvbUZpZWxkc0RhdGEoaXRlbURhdGE6IE1hcDxhbnk+LCBvcHRpb25zOiBPcHRpb24pIHtcbiAgY29uc3QgdG9vbHRpcERhdGE6IFRvb2xUaXBEYXRhW10gPSBbXTtcblxuICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE9wdGlvbikge1xuICAgIC8vIHByZXBhcmUgZmllbGQgdGl0bGVcbiAgICBjb25zdCB0aXRsZSA9IGZpZWxkT3B0aW9uLnRpdGxlID8gZmllbGRPcHRpb24udGl0bGUgOiBmaWVsZE9wdGlvbi5maWVsZDtcblxuICAgIC8vIGdldCAocmF3KSBmaWVsZCB2YWx1ZVxuICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoaXRlbURhdGEsIGZpZWxkT3B0aW9uLmZpZWxkKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgdmFsdWVcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGN1c3RvbUZvcm1hdCh2YWx1ZSwgZmllbGRPcHRpb24uZm9ybWF0VHlwZSwgZmllbGRPcHRpb24uZm9ybWF0KSB8fCBhdXRvRm9ybWF0KHZhbHVlKTtcblxuICAgIC8vIGFkZCBmb3JtYXR0ZWQgZGF0YSB0byB0b29sdGlwRGF0YVxuICAgIHRvb2x0aXBEYXRhLnB1c2goe3RpdGxlOiB0aXRsZSwgdmFsdWU6IGZvcm1hdHRlZFZhbHVlfSk7XG5cbiAgfSk7XG5cbiAgcmV0dXJuIHRvb2x0aXBEYXRhO1xufVxuXG4vKipcbiogR2V0IGEgZmllbGQgdmFsdWUgZnJvbSBhIGRhdGEgbWFwLlxuKiBAcGFyYW0ge3RpbWUubWFwfSBpdGVtRGF0YSAtIGEgbWFwIG9mIGl0ZW0uZGF0dW1cbiogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIC0gdGhlIG5hbWUgb2YgdGhlIGZpZWxkLiBJdCBjYW4gY29udGFpbiBcIi5cIiB0byBzcGVjaWZ5XG4qIHRoYXQgdGhlIGZpZWxkIGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBpdGVtLmRhdHVtXG4qIEByZXR1cm4gdGhlIGZpZWxkIHZhbHVlIG9uIHN1Y2Nlc3MsIHVuZGVmaW5lZCBvdGhlcndpc2VcbiovXG4vLyBUT0RPKHplbmluZyk6IE11dGUgXCJDYW5ub3QgZmluZCBmaWVsZFwiIHdhcm5pbmdzIGZvciBjb21wb3NpdGUgdmlzIChpc3N1ZSAjMzkpXG5mdW5jdGlvbiBnZXRWYWx1ZShpdGVtRGF0YTogTWFwPGFueT4sIGZpZWxkOiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBEYXRlO1xuXG4gIGNvbnN0IGFjY2Vzc29yczogc3RyaW5nW10gPSBmaWVsZC5zcGxpdCgnLicpO1xuXG4gIC8vIGdldCB0aGUgZmlyc3QgYWNjZXNzb3IgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBhcnJheVxuICBjb25zdCBmaXJzdEFjY2Vzc29yOiBzdHJpbmcgPSBhY2Nlc3NvcnNbMF07XG4gIGFjY2Vzc29ycy5zaGlmdCgpO1xuICBpZiAoaXRlbURhdGEuaGFzKGZpcnN0QWNjZXNzb3IpKSB7XG4gICAgdmFsdWUgPSBpdGVtRGF0YS5nZXQoZmlyc3RBY2Nlc3Nvcik7XG5cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIGFjY2Vzc29ycywgdXNlIHRoZW0gdG8gZ2V0IHRoZSB2YWx1ZVxuICAgIGFjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAodmFsdWVbYV0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVthXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdbVG9vbHRpcF0gQ2Fubm90IGZpbmQgZmllbGQgJyArIGZpZWxkICsgJyBpbiBkYXRhLicpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cblxuLyoqXG4qIFByZXBhcmUgZGF0YSBmb3IgYWxsIGZpZWxkcyBpbiBpdGVtRGF0YSBmb3IgdG9vbHRpcC4gVGhpcyBmdW5jdGlvblxuKiBmb3JtYXRzIGZpZWxkIHRpdGxlcyBhbmQgdmFsdWVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdHRlZCBmaWVsZHMuXG4qXG4qIEBwYXJhbSB7dGltZS5tYXB9IGl0ZW1EYXRhIC0gYSBtYXAgb2YgaXRlbS5kYXR1bVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHVzZXItcHJvdmlkZWQgb3B0aW9uc1xuKiBAcmV0dXJuIEFsbCBmaWVsZHMgaW4gaXRlbURhdGEsIGZvcm1hdHRlZCwgaW4gdGhlIGZvcm0gb2YgYW4gYXJyYXk6IFt7IHRpdGxlOiAuLi4sIHZhbHVlOiAuLi59XVxuKlxuKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZXhwZWN0cyBpdGVtRGF0YSB0byBiZSBzaW1wbGUge2ZpZWxkOnZhbHVlfSBwYWlycy5cbiogSXQgd2lsbCBub3QgdHJ5IHRvIHBhcnNlIHZhbHVlIGlmIGl0IGlzIGFuIG9iamVjdC4gSWYgdmFsdWUgaXMgYW4gb2JqZWN0LCBwbGVhc2VcbiogdXNlIHByZXBhcmVDdXN0b21GaWVsZHNEYXRhKCkgaW5zdGVhZC5cbiovXG5mdW5jdGlvbiBwcmVwYXJlQWxsRmllbGRzRGF0YShpdGVtRGF0YTogTWFwPGFueT4sIG9wdGlvbnM6IE9wdGlvbikge1xuICBjb25zdCB0b29sdGlwRGF0YTogVG9vbFRpcERhdGFbXSA9IFtdO1xuXG4gIC8vIGhlcmUsIGZpZWxkT3B0aW9ucyBzdGlsbCBwcm92aWRlcyBmb3JtYXRcbiAgY29uc3QgZmllbGRPcHRpb25zID0gZDNtYXAob3B0aW9ucy5maWVsZHMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkOyB9KTtcblxuICBpdGVtRGF0YS5lYWNoKGZ1bmN0aW9uICh2YWx1ZTogc3RyaW5nLCBmaWVsZDogc3RyaW5nKSB7XG4gICAgLy8gcHJlcGFyZSB0aXRsZVxuICAgIGxldCB0aXRsZTtcbiAgICBpZiAoZmllbGRPcHRpb25zLmhhcyhmaWVsZCkgJiYgZmllbGRPcHRpb25zLmdldChmaWVsZCkudGl0bGUpIHtcbiAgICAgIHRpdGxlID0gZmllbGRPcHRpb25zLmdldChmaWVsZCkudGl0bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gZmllbGQ7XG4gICAgfVxuXG4gICAgbGV0IGZvcm1hdFR5cGU7XG4gICAgbGV0IGZvcm1hdDtcbiAgICAvLyBmb3JtYXQgdmFsdWVcbiAgICBpZiAoZmllbGRPcHRpb25zLmhhcyhmaWVsZCkpIHtcbiAgICAgIGZvcm1hdFR5cGUgPSBmaWVsZE9wdGlvbnMuZ2V0KGZpZWxkKS5mb3JtYXRUeXBlO1xuICAgICAgZm9ybWF0ID0gZmllbGRPcHRpb25zLmdldChmaWVsZCkuZm9ybWF0O1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGN1c3RvbUZvcm1hdCh2YWx1ZSwgZm9ybWF0VHlwZSwgZm9ybWF0KSB8fCBhdXRvRm9ybWF0KHZhbHVlKTtcblxuICAgIC8vIGFkZCBmb3JtYXR0ZWQgZGF0YSB0byB0b29sdGlwRGF0YVxuICAgIHRvb2x0aXBEYXRhLnB1c2goe3RpdGxlOiB0aXRsZSwgdmFsdWU6IGZvcm1hdHRlZFZhbHVlfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0b29sdGlwRGF0YTtcbn1cblxuLyoqXG4qIFJlbW92ZSBtdWx0aXBsZSBmaWVsZHMgZnJvbSBhIHRvb2x0aXAgZGF0YSBtYXAsIHVzaW5nIHJlbW92ZUtleXNcbipcbiogQ2VydGFpbiBtZXRhIGRhdGEgZmllbGRzIChlLmcuIFwiX2lkXCIsIFwiX3ByZXZcIikgc2hvdWxkIGJlIGhpZGRlbiBpbiB0aGUgdG9vbHRpcFxuKiBieSBkZWZhdWx0LiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGVzZSBmaWVsZHMgZnJvbSB0b29sdGlwIGRhdGEuXG4qIEBwYXJhbSB7dGltZS5tYXB9IGRhdGFNYXAgLSB0aGUgZGF0YSBtYXAgdGhhdCBjb250YWlucyB0b29sdGlwIGRhdGEuXG4qIEBwYXJhbSB7c3RyaW5nW119IHJlbW92ZUtleXMgLSB0aGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkYXRhTWFwLlxuKi9cbmZ1bmN0aW9uIHJlbW92ZUZpZWxkcyhkYXRhTWFwOiBNYXA8YW55PiwgcmVtb3ZlS2V5czogc3RyaW5nW10pIHtcbiAgcmVtb3ZlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkYXRhTWFwLnJlbW92ZShrZXkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBXaGVuIGEgdGVtcG9yYWwgZmllbGQgaGFzIHRpbWVVbml0LCBpdGVtRGF0YSB3aWxsIGdpdmUgdXMgZHVwbGljYXRlZCBmaWVsZHNcbiAqIChlLmcuLCBZZWFyIGFuZCBZRUFSKFllYXIpKS4gSW4gdG9vbHRpcCB3YW50IHRvIGRpc3BsYXkgdGhlIGZpZWxkIFdJVEggdGhlXG4gKiB0aW1lVW5pdCBhbmQgcmVtb3ZlIHRoZSBmaWVsZCB0aGF0IGRvZXNuJ3QgaGF2ZSB0aW1lVW5pdC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlVGltZUZpZWxkcyhpdGVtRGF0YTogTWFwPGFueT4sIG9wdEZpZWxkczogU3VwcGxlbWVudGVkRmllbGRPcHRpb25bXSkge1xuICBpZiAoIW9wdEZpZWxkcykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRGaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAob3B0RmllbGQpIHtcbiAgICBpZiAob3B0RmllbGQucmVtb3ZlT3JpZ2luYWxUZW1wb3JhbEZpZWxkKSB7XG4gICAgICByZW1vdmVGaWVsZHMoaXRlbURhdGEsIFtvcHRGaWVsZC5yZW1vdmVPcmlnaW5hbFRlbXBvcmFsRmllbGRdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiogQ29tYmluZSBtdWx0aXBsZSBiaW5uZWQgZmllbGRzIGluIGl0ZW1EYXRhIGludG8gb25lIGZpZWxkLiBUaGUgdmFsdWUgb2YgdGhlIGZpZWxkXG4qIGlzIGEgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSBiaW4gcmFuZ2UuXG4qXG4qIEBwYXJhbSB7dGltZS5tYXB9IGl0ZW1EYXRhIC0gYSBtYXAgb2YgaXRlbS5kYXR1bVxuKiBAcGFyYW0ge09iamVjdFtdfSBmaWVsZE9wdGlvbnMgLSBhIGxpc3Qgb2YgZmllbGQgb3B0aW9ucyAoaS5lLiBvcHRpb25zLmZpZWxkc1tdKVxuKiBAcmV0dXJuIGl0ZW1EYXRhIHdpdGggY29tYmluZWQgYmluIGZpZWxkc1xuKi9cbmZ1bmN0aW9uIGNvbWJpbmVCaW5GaWVsZHMoaXRlbURhdGE6IE1hcDxhbnk+LCBmaWVsZE9wdGlvbnM6IEZpZWxkT3B0aW9uW10pIHtcbiAgaWYgKCFmaWVsZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZmllbGRPcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkT3B0aW9uKSB7XG4gICAgaWYgKGZpZWxkT3B0aW9uLmJpbiA9PT0gdHJ1ZSkge1xuICAgICAgLy8gZ2V0IGJpbm5lZCBmaWVsZCBuYW1lc1xuICAgICAgY29uc3QgYmluRmllbGRSYW5nZSA9IGZpZWxkT3B0aW9uLmZpZWxkO1xuICAgICAgY29uc3QgYmluRmllbGRTdGFydCA9IGJpbkZpZWxkUmFuZ2UuY29uY2F0KCdfc3RhcnQnKTtcbiAgICAgIGNvbnN0IGJpbkZpZWxkTWlkID0gYmluRmllbGRSYW5nZS5jb25jYXQoJ19taWQnKTtcbiAgICAgIGNvbnN0IGJpbkZpZWxkRW5kID0gYmluRmllbGRSYW5nZS5jb25jYXQoJ19lbmQnKTtcblxuICAgICAgLy8gdXNlIHN0YXJ0IHZhbHVlIGFuZCBlbmQgdmFsdWUgdG8gY29tcHV0ZSByYW5nZVxuICAgICAgLy8gc2F2ZSB0aGUgY29tcHV0ZWQgcmFuZ2UgaW4gYmluRmllbGRTdGFydFxuICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9IGl0ZW1EYXRhLmdldChiaW5GaWVsZFN0YXJ0KTtcbiAgICAgIGNvbnN0IGVuZFZhbHVlID0gaXRlbURhdGEuZ2V0KGJpbkZpZWxkRW5kKTtcbiAgICAgIGlmICgoc3RhcnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSAmJiAoZW5kVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBzdGFydFZhbHVlICsgJy0nICsgZW5kVmFsdWU7XG4gICAgICAgIGl0ZW1EYXRhLnNldChiaW5GaWVsZFJhbmdlLCByYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBiaW5GaWVsZE1pZCwgYmluRmllbGRFbmQsIGFuZCBiaW5GaWVsZFJhbmdlIGZyb20gaXRlbURhdGFcbiAgICAgIGNvbnN0IGJpblJlbW92ZUtleXMgPSBbXTtcbiAgICAgIGJpblJlbW92ZUtleXMucHVzaChiaW5GaWVsZFN0YXJ0LCBiaW5GaWVsZE1pZCwgYmluRmllbGRFbmQpO1xuICAgICAgcmVtb3ZlRmllbGRzKGl0ZW1EYXRhLCBiaW5SZW1vdmVLZXlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpdGVtRGF0YTtcbn1cblxuLyoqXG4qIERyb3AgZmllbGRzIGZvciBsaW5lIGFuZCBhcmVhIG1hcmtzLlxuKlxuKiBMaW5lcyBhbmQgYXJlYXMgYXJlIGRlZmluZWQgYnkgYSBzZXJpZXMgb2YgZGF0dW0uIFdlIG92ZXJsYXkgcG9pbnQgbWFya3Ncbiogb24gdG9wIG9mIGxpbmVzIGFuZCBhcmVhcyB0byBhbGxvdyB0b29sdGlwIHRvIHNob3cgYWxsIGRhdGEgaW4gdGhlIHNlcmllcy5cbiogRm9yIHRoZSBsaW5lIG1hcmtzIGFuZCBhcmVhIG1hcmtzIHVuZGVybmVhdGgsIHdlIG9ubHkgc2hvdyBub21pbmFsIGZpZWxkc1xuKiBpbiB0b29sdGlwLiBUaGlzIGlzIGJlY2F1c2UgbGluZSAvIGFyZWEgbWFya3Mgb25seSBnaXZlIHVzIHRoZSBsYXN0IGRhdHVtXG4qIGluIHRoZWlyIHNlcmllcy4gSXQgb25seSBtYWtlIHNlbnNlIHRvIHNob3cgdGhlIG5vbWluYWwgZmllbGRzIChlLmcuLCBzeW1ib2xcbiogPSBBUFBMLCBBTVpOLCBHT09HLCBJQk0sIE1TRlQpIGJlY2F1c2UgdGhlc2UgZmllbGRzIGRvbid0IHRlbmQgdG8gY2hhbmdlIGFsb25nXG4qIHRoZSBsaW5lIC8gYXJlYSBib3JkZXIuXG4qL1xuZnVuY3Rpb24gZHJvcEZpZWxkc0ZvckxpbmVBcmVhKG1hcmt0eXBlOiBzdHJpbmcsIGl0ZW1EYXRhOiBNYXA8YW55Pikge1xuICBpZiAobWFya3R5cGUgPT09ICdsaW5lJyB8fCBtYXJrdHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgY29uc3QgcXVhbktleXM6IHN0cmluZ1tdID0gW107XG4gICAgaXRlbURhdGEuZWFjaChmdW5jdGlvbiAodmFsdWUsIGZpZWxkKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICBxdWFuS2V5cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZUZpZWxkcyhpdGVtRGF0YSwgcXVhbktleXMpO1xuICB9XG59XG5cbi8qKlxuKiBGb3JtYXQgdmFsdWUgdXNpbmcgZm9ybWF0VHlwZSBhbmQgZm9ybWF0XG4qIEBwYXJhbSB2YWx1ZSAtIGEgZmllbGQgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4qIEBwYXJhbSBmb3JtYXRUeXBlIC0gdGhlIGZvcmFtdFR5cGUgY2FuIGJlOiBcInRpbWVcIiwgXCJudW1iZXJcIiwgb3IgXCJzdHJpbmdcIlxuKiBAcGFyYW0gZm9ybWF0IC0gYSB0aW1lIHRpbWUgZm9ybWF0IHNwZWNpZmllciwgb3IgYSB0aW1lIG51bWJlciBmb3JtYXQgc3BlY2lmaWVyLCBvciB1bmRlZmluZWRcbiogQHJldHVybiB0aGUgZm9ybWF0dGVkIHZhbHVlLCBvciB1bmRlZmluZWQgaWYgdmFsdWUgb3IgZm9ybWF0VHlwZSBpcyBtaXNzaW5nXG4qL1xuZnVuY3Rpb24gY3VzdG9tRm9ybWF0KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBEYXRlLCBmb3JtYXRUeXBlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWZvcm1hdFR5cGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3dpdGNoIChmb3JtYXRUeXBlKSB7XG4gICAgY2FzZSAndGltZSc6XG4gICAgICByZXR1cm4gZm9ybWF0ID8gdGltZUZvcm1hdChmb3JtYXQpKHZhbHVlIGFzIERhdGUpIDogYXV0b1RpbWVGb3JtYXQodmFsdWUgYXMgRGF0ZSk7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBmb3JtYXQgPyBkM051bWJlckZvcm1hdChmb3JtYXQpKHZhbHVlIGFzIG51bWJlcikgOiBhdXRvTnVtYmVyRm9ybWF0KHZhbHVlIGFzIG51bWJlcik7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlIGFzIHN0cmluZztcbiAgfVxufVxuXG4vKipcbiogQXV0b21hdGljYWxseSBmb3JtYXQgYSB0aW1lLCBudW1iZXIgb3Igc3RyaW5nIHZhbHVlXG4qIEByZXR1cm4gdGhlIGZvcm1hdHRlZCB0aW1lLCBudW1iZXIgb3Igc3RyaW5nIHZhbHVlXG4qL1xuZnVuY3Rpb24gYXV0b0Zvcm1hdCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGF1dG9OdW1iZXJGb3JtYXQodmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhdXRvVGltZUZvcm1hdCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBmb3JtYXQgYSBudW1iZXIgYmFzZWQgb24gaXRzIGRlY2ltYWwuXG4gKiBAcGFyYW0gdmFsdWUgbnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHJldHVybiBJZiBpdCdzIGEgZGVjaW1hbCBudW1iZXIsIHJldHVybiBhIGZpeGVkIHR3byBwb2ludHMgcHJlY2lzaW9uLlxuICogSWYgaXQncyBhIHdob2xlIG51bWJlciwgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSB3aXRob3V0IGFueSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGF1dG9OdW1iZXJGb3JtYXQodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gdmFsdWUgJSAxID09PSAwID8gZDNOdW1iZXJGb3JtYXQoJywnKSh2YWx1ZSkgOiBkM051bWJlckZvcm1hdCgnLC4yZicpKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGZvcm1hdCBhIHRpbWUgYmFzZWQgb24gaXRzIGRhdGUuXG4gKiBAcGFyYW0gZGF0ZSBvYmplY3QgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJuIGEgZm9ybWF0dGVkIHRpbWUgc3RyaW5nIGRlcGVuZGluZyBvbiB0aGUgdGltZS4gRm9yIGV4YW1wbGUsXG4gKiB0aGUgc3RhcnQgb2YgRmVicnVhcnkgaXMgZm9ybWF0dGVkIGFzIFwiRmVicnVhcnlcIiwgd2hpbGUgRmVicnVhcnkgc2Vjb25kIGlzIGZvcm1hdHRlZCBhcyBcIkZlYiAyXCIuXG4gKi9cbmZ1bmN0aW9uIGF1dG9UaW1lRm9ybWF0KGRhdGU6IERhdGUpIHtcbiAgY29uc3QgZm9ybWF0TWlsbGlzZWNvbmQgPSB0aW1lRm9ybWF0KCcuJUwnKSxcbiAgICBmb3JtYXRTZWNvbmQgPSB0aW1lRm9ybWF0KCc6JVMnKSxcbiAgICBmb3JtYXRNaW51dGUgPSB0aW1lRm9ybWF0KCclSTolTScpLFxuICAgIGZvcm1hdEhvdXIgPSB0aW1lRm9ybWF0KCclSSAlcCcpLFxuICAgIGZvcm1hdERheSA9IHRpbWVGb3JtYXQoJyVhICVkJyksXG4gICAgZm9ybWF0V2VlayA9IHRpbWVGb3JtYXQoJyViICVkJyksXG4gICAgZm9ybWF0TW9udGggPSB0aW1lRm9ybWF0KCclQicpLFxuICAgIGZvcm1hdFllYXIgPSB0aW1lRm9ybWF0KCclWScpO1xuXG4gIHJldHVybiAodGltZVNlY29uZChkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgOiB0aW1lTWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgOiB0aW1lSG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgIDogdGltZURheShkYXRlKSA8IGRhdGUgPyBmb3JtYXRIb3VyXG4gICAgICA6IHRpbWVNb250aChkYXRlKSA8IGRhdGUgPyAodGltZVdlZWsoZGF0ZSkgPCBkYXRlID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgIDogdGltZVllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG59XG5cbi8qKlxuKiBHZXQgdGhlIHRvb2x0aXAgSFRNTCBwbGFjZWhvbGRlciBieSBpZCBzZWxlY3RvciBcIiN2aXMtdG9vbHRpcFwiXG4qIElmIG5vbmUgZXhpc3RzLCBjcmVhdGUgYSBwbGFjZWhvbGRlci5cbiogQHJldHVybnMgdGhlIEhUTUwgcGxhY2Vob2xkZXIgZm9yIHRvb2x0aXBcbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwUGxhY2Vob2xkZXIoKSB7XG4gIGxldCB0b29sdGlwUGxhY2Vob2xkZXI7XG5cbiAgaWYgKHNlbGVjdCgnI3Zpcy10b29sdGlwJykuZW1wdHkoKSkge1xuICAgIHRvb2x0aXBQbGFjZWhvbGRlciA9IHNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcbiAgICAgIC5hdHRyKCdpZCcsICd2aXMtdG9vbHRpcCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAndmctdG9vbHRpcCcpO1xuICB9IGVsc2Uge1xuICAgIHRvb2x0aXBQbGFjZWhvbGRlciA9IHNlbGVjdCgnI3Zpcy10b29sdGlwJyk7XG4gIH1cblxuICByZXR1cm4gdG9vbHRpcFBsYWNlaG9sZGVyO1xufVxuXG4vKipcbiogQmluZCB0b29sdGlwRGF0YSB0byB0aGUgdG9vbHRpcCBwbGFjZWhvbGRlclxuKi9cbmZ1bmN0aW9uIGJpbmREYXRhKHRvb2x0aXBQbGFjZWhvbGRlcjogU2VsZWN0aW9uPEVsZW1lbnQgfCBFbnRlckVsZW1lbnQgfCBEb2N1bWVudCB8IFdpbmRvdywge30sIEhUTUxFbGVtZW50LCBhbnk+LCB0b29sdGlwRGF0YTogVG9vbFRpcERhdGFbXSkge1xuICB0b29sdGlwUGxhY2Vob2xkZXIuc2VsZWN0QWxsKCd0YWJsZScpLnJlbW92ZSgpO1xuICBjb25zdCB0b29sdGlwUm93cyA9IHRvb2x0aXBQbGFjZWhvbGRlci5hcHBlbmQoJ3RhYmxlJykuc2VsZWN0QWxsKCcudG9vbHRpcC1yb3cnKVxuICAgIC5kYXRhKHRvb2x0aXBEYXRhKTtcblxuICB0b29sdGlwUm93cy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgY29uc3Qgcm93ID0gdG9vbHRpcFJvd3MuZW50ZXIoKS5hcHBlbmQoJ3RyJylcbiAgICAuYXR0cignY2xhc3MnLCAndG9vbHRpcC1yb3cnKTtcbiAgcm93LmFwcGVuZCgndGQnKS5hdHRyKCdjbGFzcycsICdrZXknKS50ZXh0KGZ1bmN0aW9uIChkOiBUb29sVGlwRGF0YSkgeyByZXR1cm4gZC50aXRsZSArICc6JzsgfSk7XG4gIHJvdy5hcHBlbmQoJ3RkJykuYXR0cignY2xhc3MnLCAndmFsdWUnKS50ZXh0KGZ1bmN0aW9uIChkOiBUb29sVGlwRGF0YSkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG59XG5cbi8qKlxuKiBDbGVhciB0b29sdGlwIGRhdGFcbiovXG5mdW5jdGlvbiBjbGVhckRhdGEoKSB7XG4gIHNlbGVjdCgnI3Zpcy10b29sdGlwJykuc2VsZWN0QWxsKCcudG9vbHRpcC1yb3cnKS5kYXRhKFtdKVxuICAgIC5leGl0KCkucmVtb3ZlKCk7XG59XG5cbi8qKlxuKiBVcGRhdGUgdG9vbHRpcCBwb3NpdGlvblxuKiBEZWZhdWx0IHBvc2l0aW9uIGlzIDEwcHggcmlnaHQgb2YgYW5kIDEwcHggYmVsb3cgdGhlIGN1cnNvci4gVGhpcyBjYW4gYmVcbiogb3ZlcndyaXR0ZW4gYnkgb3B0aW9ucy5vZmZzZXRcbiovXG5mdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihldmVudDogTW91c2VFdmVudCwgb3B0aW9uczogT3B0aW9uKSB7XG4gIC8vIGRldGVybWluZSB4IGFuZCB5IG9mZnNldHMsIGRlZmF1bHRzIGFyZSAxMHB4XG4gIGxldCBvZmZzZXRYID0gMTA7XG4gIGxldCBvZmZzZXRZID0gMTA7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub2Zmc2V0ICYmIChvcHRpb25zLm9mZnNldC54ICE9PSB1bmRlZmluZWQpICYmIChvcHRpb25zLm9mZnNldC54ICE9PSBudWxsKSkge1xuICAgIG9mZnNldFggPSBvcHRpb25zLm9mZnNldC54O1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub2Zmc2V0ICYmIChvcHRpb25zLm9mZnNldC55ICE9PSB1bmRlZmluZWQpICYmIChvcHRpb25zLm9mZnNldC55ICE9PSBudWxsKSkge1xuICAgIG9mZnNldFkgPSBvcHRpb25zLm9mZnNldC55O1xuICB9XG5cbiAgLy8gVE9ETzogdXNlIHRoZSBjb3JyZWN0IHRpbWUgdHlwZVxuICBzZWxlY3QoJyN2aXMtdG9vbHRpcCcpXG4gICAgLnN0eWxlKCd0b3AnLCBmdW5jdGlvbiAodGhpczogSFRNTEVsZW1lbnQpIHtcbiAgICAgIC8vIGJ5IGRlZmF1bHQ6IHB1dCB0b29sdGlwIDEwcHggYmVsb3cgY3Vyc29yXG4gICAgICAvLyBpZiB0b29sdGlwIGlzIGNsb3NlIHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdywgcHV0IHRvb2x0aXAgMTBweCBhYm92ZSBjdXJzb3JcbiAgICAgIGNvbnN0IHRvb2x0aXBIZWlnaHQgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgIGlmIChldmVudC5jbGllbnRZICsgdG9vbHRpcEhlaWdodCArIG9mZnNldFkgPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgKGV2ZW50LmNsaWVudFkgKyBvZmZzZXRZKSArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJycgKyAoZXZlbnQuY2xpZW50WSAtIHRvb2x0aXBIZWlnaHQgLSBvZmZzZXRZKSArICdweCc7XG4gICAgICB9XG4gICAgfSlcbiAgICAuc3R5bGUoJ2xlZnQnLCBmdW5jdGlvbiAodGhpczogSFRNTEVsZW1lbnQpIHtcbiAgICAgIC8vIGJ5IGRlZmF1bHQ6IHB1dCB0b29sdGlwIDEwcHggdG8gdGhlIHJpZ2h0IG9mIGN1cnNvclxuICAgICAgLy8gaWYgdG9vbHRpcCBpcyBjbG9zZSB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgd2luZG93LCBwdXQgdG9vbHRpcCAxMCBweCB0byB0aGUgbGVmdCBvZiBjdXJzb3JcbiAgICAgIGNvbnN0IHRvb2x0aXBXaWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICBpZiAoZXZlbnQuY2xpZW50WCArIHRvb2x0aXBXaWR0aCArIG9mZnNldFggPCB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICByZXR1cm4gJycgKyAoZXZlbnQuY2xpZW50WCArIG9mZnNldFgpICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJyArIChldmVudC5jbGllbnRYIC0gdG9vbHRpcFdpZHRoIC0gb2Zmc2V0WCkgKyAncHgnO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG4vKiBDbGVhciB0b29sdGlwIHBvc2l0aW9uICovXG5mdW5jdGlvbiBjbGVhclBvc2l0aW9uKCkge1xuICBzZWxlY3QoJyN2aXMtdG9vbHRpcCcpXG4gICAgLnN0eWxlKCd0b3AnLCAnLTk5OTlweCcpXG4gICAgLnN0eWxlKCdsZWZ0JywgJy05OTk5cHgnKTtcbn1cblxuLyoqXG4qIFVwZGF0ZSB0b29sdGlwIGNvbG9yIHRoZW1lIGFjY29yZGluZyB0byBvcHRpb25zLmNvbG9yVGhlbWVcbipcbiogSWYgY29sb3JUaGVtZSA9PT0gXCJkYXJrXCIsIGFwcGx5IGRhcmsgdGhlbWUgdG8gdG9vbHRpcC5cbiogT3RoZXJ3aXNlIGFwcGx5IGxpZ2h0IGNvbG9yIHRoZW1lLlxuKi9cbmZ1bmN0aW9uIHVwZGF0ZUNvbG9yVGhlbWUob3B0aW9uczogT3B0aW9uKSB7XG4gIGNsZWFyQ29sb3JUaGVtZSgpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29sb3JUaGVtZSA9PT0gJ2RhcmsnKSB7XG4gICAgc2VsZWN0KCcjdmlzLXRvb2x0aXAnKS5jbGFzc2VkKCdkYXJrLXRoZW1lJywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0KCcjdmlzLXRvb2x0aXAnKS5jbGFzc2VkKCdsaWdodC10aGVtZScsIHRydWUpO1xuICB9XG59XG5cbi8qIENsZWFyIGNvbG9yIHRoZW1lcyAqL1xuZnVuY3Rpb24gY2xlYXJDb2xvclRoZW1lKCkge1xuICBzZWxlY3QoJyN2aXMtdG9vbHRpcCcpLmNsYXNzZWQoJ2RhcmstdGhlbWUgbGlnaHQtdGhlbWUnLCBmYWxzZSk7XG59XG4iXX0=
